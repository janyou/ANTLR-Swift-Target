// Generated from ./grammars-v4/cobol85/Cobol85.g4 by ANTLR 4.5.1
import Antlr4

open class Cobol85Parser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = Cobol85Parser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(Cobol85Parser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()
	internal static let _sharedContextCache: PredictionContextCache = PredictionContextCache()
	public static let ABORT=1, ACCEPT=2, ACCESS=3, ADD=4, ADDRESS=5, ADVANCING=6, 
                   AFTER=7, ALIGNED=8, ALL=9, ALPHABET=10, ALPHABETIC=11, 
                   ALPHABETIC_LOWER=12, ALPHABETIC_UPPER=13, ALPHANUMERIC=14, 
                   ALPHANUMERIC_EDITED=15, ALSO=16, ALTER=17, ALTERNATE=18, 
                   AND=19, ANY=20, APOST=21, ARE=22, AREA=23, AREAS=24, 
                   ARITH=25, AS=26, ASCENDING=27, ASCII=28, ASSIGN=29, ASSOCIATED_DATA=30, 
                   ASSOCIATED_DATA_LENGTH=31, AT=32, ATTRIBUTE=33, AUTHOR=34, 
                   AUTO=35, AUTO_SKIP=36, BACKGROUND_COLOR=37, BACKGROUND_COLOUR=38, 
                   BASIS=39, BEEP=40, BEFORE=41, BEGINNING=42, BELL=43, 
                   BINARY=44, BIT=45, BLANK=46, BLINK=47, BLOCK=48, BOUNDS=49, 
                   BOTTOM=50, BY=51, BYFUNCTION=52, BYTITLE=53, CALL=54, 
                   CANCEL=55, CAPABLE=56, CBL=57, CCSVERSION=58, CD=59, 
                   CF=60, CH=61, CHANGED=62, CHANNEL=63, CHARACTER=64, CHARACTERS=65, 
                   CLASS=66, CLASS_ID=67, CLOCK_UNITS=68, CLOSE=69, CLOSE_DISPOSITION=70, 
                   COBOL=71, CODE=72, CODEPAGE=73, CODE_SET=74, COLLATING=75, 
                   COL=76, COLUMN=77, COM_REG=78, COMMA=79, COMMITMENT=80, 
                   COMMON=81, COMMUNICATION=82, COMP=83, COMP_1=84, COMP_2=85, 
                   COMP_3=86, COMP_4=87, COMP_5=88, COMPUTATIONAL=89, COMPUTATIONAL_1=90, 
                   COMPUTATIONAL_2=91, COMPUTATIONAL_3=92, COMPUTATIONAL_4=93, 
                   COMPUTATIONAL_5=94, COMPUTE=95, CONFIGURATION=96, CONTAINS=97, 
                   CONTENT=98, CONTINUE=99, CONTROL=100, CONTROL_POINT=101, 
                   CONTROLS=102, CONVENTION=103, CONVERTING=104, COPY=105, 
                   CORR=106, CORRESPONDING=107, COUNT=108, CRUNCH=109, CURRENCY=110, 
                   CURSOR=111, DATA=112, DATA_BASE=113, DATE=114, DATE_COMPILED=115, 
                   DATE_WRITTEN=116, DAY=117, DAY_OF_WEEK=118, DBCS=119, 
                   DE=120, DEBUG_CONTENTS=121, DEBUG_ITEM=122, DEBUG_LINE=123, 
                   DEBUG_NAME=124, DEBUG_SUB_1=125, DEBUG_SUB_2=126, DEBUG_SUB_3=127, 
                   DEBUGGING=128, DECIMAL_POINT=129, DECLARATIVES=130, DEFAULT=131, 
                   DEFAULT_DISPLAY=132, DEFINITION=133, DELETE=134, DELIMITED=135, 
                   DELIMITER=136, DEPENDING=137, DESCENDING=138, DESTINATION=139, 
                   DETAIL=140, DFHRESP=141, DFHVALUE=142, DISABLE=143, DISK=144, 
                   DISPLAY=145, DISPLAY_1=146, DIVIDE=147, DIVISION=148, 
                   DONTCARE=149, DOUBLE=150, DOWN=151, DUPLICATES=152, DYNAMIC=153, 
                   EBCDIC=154, EGCS=155, EGI=156, EJECT=157, ELSE=158, EMI=159, 
                   EMPTY_CHECK=160, ENABLE=161, END=162, END_ADD=163, END_CALL=164, 
                   END_COMPUTE=165, END_DELETE=166, END_DIVIDE=167, END_EVALUATE=168, 
                   END_IF=169, END_MULTIPLY=170, END_OF_PAGE=171, END_PERFORM=172, 
                   END_READ=173, END_RECEIVE=174, END_RETURN=175, END_REWRITE=176, 
                   END_SEARCH=177, END_START=178, END_STRING=179, END_SUBTRACT=180, 
                   END_UNSTRING=181, END_WRITE=182, ENDING=183, ENTER=184, 
                   ENTRY=185, ENTRY_PROCEDURE=186, ENVIRONMENT=187, EOP=188, 
                   EQUAL=189, ERASE=190, ERROR=191, EOL=192, EOS=193, ESCAPE=194, 
                   ESI=195, EVALUATE=196, EVENT=197, EVERY=198, EXCEPTION=199, 
                   EXCLUSIVE=200, EXHIBIT=201, EXIT=202, EXPORT=203, EXTEND=204, 
                   EXTENDED=205, EXTERNAL=206, FALSE=207, FD=208, FILE=209, 
                   FILE_CONTROL=210, FILLER=211, FINAL=212, FIRST=213, FOOTING=214, 
                   FOR=215, FOREGROUND_COLOR=216, FOREGROUND_COLOUR=217, 
                   FROM=218, FULL=219, FUNCTION=220, FUNCTIONNAME=221, FUNCTION_POINTER=222, 
                   GENERATE=223, GOBACK=224, GIVING=225, GLOBAL=226, GO=227, 
                   GREATER=228, GRID=229, GROUP=230, HEADING=231, HIGHLIGHT=232, 
                   HIGH_VALUE=233, HIGH_VALUES=234, I_O=235, I_O_CONTROL=236, 
                   ID=237, IDENTIFICATION=238, IF=239, IMPLICIT=240, IMPORT=241, 
                   IN=242, INDEX=243, INDEXED=244, INDICATE=245, INITIAL=246, 
                   INITIALIZE=247, INITIATE=248, INPUT=249, INPUT_OUTPUT=250, 
                   INSPECT=251, INSTALLATION=252, INTEGER=253, INTO=254, 
                   INVALID=255, INVOKE=256, IS=257, JUST=258, JUSTIFIED=259, 
                   KANJI=260, KEPT=261, KEY=262, LABEL=263, LANGUAGE=264, 
                   LAST=265, LB=266, LD=267, LEADING=268, LEFT=269, LEFTLINE=270, 
                   LENGTH=271, LENGTH_CHECK=272, LESS=273, LIB=274, LIBACCESS=275, 
                   LIBPARAMETER=276, LIBRARY=277, LIMIT=278, LIMITS=279, 
                   LINAGE=280, LINAGE_COUNTER=281, LINE=282, LINES=283, 
                   LINE_COUNTER=284, LINKAGE=285, LIST=286, LOCAL=287, LOCAL_STORAGE=288, 
                   LOCK=289, LONG_DATE=290, LONG_TIME=291, LOWER=292, LOWLIGHT=293, 
                   LOW_VALUE=294, LOW_VALUES=295, MEMORY=296, MERGE=297, 
                   MESSAGE=298, MMDDYYYY=299, MODE=300, MODULES=301, MORE_LABELS=302, 
                   MOVE=303, MULTIPLE=304, MULTIPLY=305, NAMED=306, NATIONAL=307, 
                   NATIVE=308, NEGATIVE=309, NETWORK=310, NEXT=311, NO=312, 
                   NO_ECHO=313, NOSEQ=314, NOSTDTRUNC=315, NOT=316, NULL=317, 
                   NULLS=318, NUMBER=319, NUMERIC=320, NUMERIC_DATE=321, 
                   NUMERIC_EDITED=322, NUMERIC_TIME=323, OBJECT_COMPUTER=324, 
                   OCCURS=325, ODT=326, OF=327, OFF=328, OMITTED=329, ON=330, 
                   OPEN=331, OPTIMIZE=332, OPTIONAL=333, OR=334, ORDER=335, 
                   ORDERLY=336, ORGANIZATION=337, OTHER=338, OUTPUT=339, 
                   OVERFLOW=340, OVERLINE=341, OWN=342, PACKED_DECIMAL=343, 
                   PADDING=344, PAGE=345, PAGE_COUNTER=346, PASSWORD=347, 
                   PERFORM=348, PF=349, PH=350, PIC=351, PICTURE=352, PLUS=353, 
                   POINTER=354, POSITION=355, POSITIVE=356, PORT=357, PRINTER=358, 
                   PRINTING=359, PRIVATE=360, PROCEDURE=361, PROCEDURE_POINTER=362, 
                   PROCEDURES=363, PROCEED=364, PROCESS=365, PROGRAM=366, 
                   PROGRAM_ID=367, PROGRAM_LIBRARY=368, PROMPT=369, PURGE=370, 
                   QUEUE=371, QUOTE=372, QUOTES=373, RANDOM=374, READER=375, 
                   REMOTE=376, RD=377, REAL=378, READ=379, RECEIVE=380, 
                   RECEIVED=381, RECORD=382, RECORDING=383, RECORDS=384, 
                   REDEFINES=385, REEL=386, REF=387, REFERENCE=388, REFERENCES=389, 
                   RELATIVE=390, RELEASE=391, REMAINDER=392, REMARKS=393, 
                   REMOVAL=394, REMOVE=395, RENAMES=396, REPLACE=397, REPLACING=398, 
                   REPORT=399, REPORTING=400, REPORTS=401, REQUIRED=402, 
                   RERUN=403, RESERVE=404, REVERSE_VIDEO=405, RESET=406, 
                   RETURN=407, RETURN_CODE=408, REVERSED=409, REWIND=410, 
                   REWRITE=411, RF=412, RH=413, RIGHT=414, ROUNDED=415, 
                   RUN=416, SAME=417, SAVE=418, SCREEN=419, SD=420, SEARCH=421, 
                   SECTION=422, SECURE=423, SECURITY=424, SEGMENT=425, SEGMENT_LIMIT=426, 
                   SELECT=427, SEND=428, SENTENCE=429, SEPARATE=430, SEQUENCE=431, 
                   SEQUENTIAL=432, SET=433, SHARED=434, SHAREDBYALL=435, 
                   SHAREDBYRUNUNIT=436, SHARING=437, SHIFT_IN=438, SHIFT_OUT=439, 
                   SHORT_DATE=440, SIGN=441, SIZE=442, SORT=443, SORT_CONTROL=444, 
                   SORT_CORE_SIZE=445, SORT_FILE_SIZE=446, SORT_MERGE=447, 
                   SORT_MESSAGE=448, SORT_MODE_SIZE=449, SORT_RETURN=450, 
                   SOURCE=451, SOURCE_COMPUTER=452, SP=453, SPACE=454, SPACES=455, 
                   SPECIAL_NAMES=456, STANDARD=457, STANDARD_1=458, STANDARD_2=459, 
                   START=460, STATUS=461, STOP=462, STRING=463, SUB_QUEUE_1=464, 
                   SUB_QUEUE_2=465, SUB_QUEUE_3=466, SUBTRACT=467, SUM=468, 
                   SUPPRESS=469, SYMBOL=470, SYMBOLIC=471, SYNC=472, SYNCHRONIZED=473, 
                   TABLE=474, TALLY=475, TALLYING=476, TASK=477, TAPE=478, 
                   TERMINAL=479, TERMINATE=480, TEST=481, TEXT=482, THAN=483, 
                   THEN=484, THREAD=485, THREAD_LOCAL=486, THROUGH=487, 
                   THRU=488, TIME=489, TIMER=490, TIMES=491, TITLE=492, 
                   TO=493, TODAYS_DATE=494, TODAYS_NAME=495, TOP=496, TRAILING=497, 
                   TRUE=498, TRUNCATED=499, TYPE=500, TYPEDEF=501, UNDERLINE=502, 
                   UNIT=503, UNSTRING=504, UNTIL=505, UP=506, UPON=507, 
                   USAGE=508, USE=509, USING=510, VALUE=511, VALUES=512, 
                   VARYING=513, VIRTUAL=514, WAIT=515, WHEN=516, WHEN_COMPILED=517, 
                   WITH=518, WORDS=519, WORKING_STORAGE=520, WRITE=521, 
                   XOPTS=522, YEAR=523, YYYYMMDD=524, YYYYDDD=525, ZERO=526, 
                   ZERO_FILL=527, ZEROS=528, ZEROES=529, AMPCHAR=530, ASTERISKCHAR=531, 
                   DOUBLEASTERISKCHAR=532, COLONCHAR=533, COMMACHAR=534, 
                   COMMENTENTRYTAG=535, COMMENTTAG=536, DOLLARCHAR=537, 
                   DOUBLEQUOTE=538, DOT_FS=539, DOT=540, EQUALCHAR=541, 
                   EXECCICSTAG=542, EXECSQLTAG=543, EXECSQLIMSTAG=544, LESSTHANCHAR=545, 
                   LESSTHANOREQUAL=546, LPARENCHAR=547, MINUSCHAR=548, MORETHANCHAR=549, 
                   MORETHANOREQUAL=550, PLUSCHAR=551, SINGLEQUOTE=552, RPARENCHAR=553, 
                   SLASHCHAR=554, NONNUMERICLITERAL=555, LEVEL_NUMBER_66=556, 
                   LEVEL_NUMBER_77=557, LEVEL_NUMBER_88=558, INTEGERLITERAL=559, 
                   NUMERICLITERAL=560, IDENTIFIER=561, NEWLINE=562, EXECCICSLINE=563, 
                   EXECSQLIMSLINE=564, EXECSQLLINE=565, COMMENTENTRYLINE=566, 
                   COMMENTLINE=567, WS=568, SEPARATOR=569
	public static let RULE_startRule = 0, RULE_compilationUnit = 1, RULE_programUnit = 2, 
                   RULE_endProgramStatement = 3, RULE_compilerOptions = 4, 
                   RULE_compilerOption = 5, RULE_compilerSubOption = 6, 
                   RULE_identificationDivision = 7, RULE_identificationDivisionBody = 8, 
                   RULE_programIdParagraph = 9, RULE_authorParagraph = 10, 
                   RULE_installationParagraph = 11, RULE_dateWrittenParagraph = 12, 
                   RULE_dateCompiledParagraph = 13, RULE_securityParagraph = 14, 
                   RULE_remarksParagraph = 15, RULE_environmentDivision = 16, 
                   RULE_environmentDivisionBody = 17, RULE_configurationSection = 18, 
                   RULE_configurationSectionParagraph = 19, RULE_sourceComputerParagraph = 20, 
                   RULE_objectComputerParagraph = 21, RULE_objectComputerClause = 22, 
                   RULE_memorySizeClause = 23, RULE_diskSizeClause = 24, 
                   RULE_collatingSequenceClause = 25, RULE_collatingSequenceClauseAlphanumeric = 26, 
                   RULE_collatingSequenceClauseNational = 27, RULE_segmentLimitClause = 28, 
                   RULE_characterSetClause = 29, RULE_specialNamesParagraph = 30, 
                   RULE_specialNameClause = 31, RULE_alphabetClause = 32, 
                   RULE_alphabetClauseFormat1 = 33, RULE_alphabetLiterals = 34, 
                   RULE_alphabetThrough = 35, RULE_alphabetAlso = 36, RULE_alphabetClauseFormat2 = 37, 
                   RULE_channelClause = 38, RULE_classClause = 39, RULE_classClauseThrough = 40, 
                   RULE_classClauseFrom = 41, RULE_classClauseTo = 42, RULE_currencySignClause = 43, 
                   RULE_decimalPointClause = 44, RULE_defaultComputationalSignClause = 45, 
                   RULE_defaultDisplaySignClause = 46, RULE_environmentSwitchNameClause = 47, 
                   RULE_environmentSwitchNameSpecialNamesStatusPhrase = 48, 
                   RULE_odtClause = 49, RULE_reserveNetworkClause = 50, 
                   RULE_symbolicCharactersClause = 51, RULE_symbolicCharacters = 52, 
                   RULE_inputOutputSection = 53, RULE_inputOutputSectionParagraph = 54, 
                   RULE_fileControlParagraph = 55, RULE_fileControlEntry = 56, 
                   RULE_selectClause = 57, RULE_fileControlClause = 58, 
                   RULE_assignClause = 59, RULE_reserveClause = 60, RULE_organizationClause = 61, 
                   RULE_paddingCharacterClause = 62, RULE_recordDelimiterClause = 63, 
                   RULE_accessModeClause = 64, RULE_recordKeyClause = 65, 
                   RULE_alternateRecordKeyClause = 66, RULE_passwordClause = 67, 
                   RULE_fileStatusClause = 68, RULE_relativeKeyClause = 69, 
                   RULE_ioControlParagraph = 70, RULE_ioControlClause = 71, 
                   RULE_rerunClause = 72, RULE_rerunEveryRecords = 73, RULE_rerunEveryOf = 74, 
                   RULE_rerunEveryClock = 75, RULE_sameClause = 76, RULE_multipleFileClause = 77, 
                   RULE_multipleFilePosition = 78, RULE_commitmentControlClause = 79, 
                   RULE_dataDivision = 80, RULE_dataDivisionBody = 81, RULE_fileSection = 82, 
                   RULE_fileDescriptionEntry = 83, RULE_fileDescriptionEntryClause = 84, 
                   RULE_externalClause = 85, RULE_globalClause = 86, RULE_blockContainsClause = 87, 
                   RULE_blockContainsTo = 88, RULE_recordContainsClause = 89, 
                   RULE_recordContainsClauseFormat1 = 90, RULE_recordContainsClauseFormat2 = 91, 
                   RULE_recordContainsClauseFormat3 = 92, RULE_recordContainsTo = 93, 
                   RULE_labelRecordsClause = 94, RULE_valueOfClause = 95, 
                   RULE_valuePair = 96, RULE_dataRecordsClause = 97, RULE_linageClause = 98, 
                   RULE_linageAt = 99, RULE_linageFootingAt = 100, RULE_linageLinesAtTop = 101, 
                   RULE_linageLinesAtBottom = 102, RULE_recordingModeClause = 103, 
                   RULE_modeStatement = 104, RULE_codeSetClause = 105, RULE_reportClause = 106, 
                   RULE_dataBaseSection = 107, RULE_dataBaseSectionEntry = 108, 
                   RULE_workingStorageSection = 109, RULE_linkageSection = 110, 
                   RULE_communicationSection = 111, RULE_communicationDescriptionEntry = 112, 
                   RULE_communicationDescriptionEntryFormat1 = 113, RULE_communicationDescriptionEntryFormat2 = 114, 
                   RULE_communicationDescriptionEntryFormat3 = 115, RULE_destinationCountClause = 116, 
                   RULE_destinationTableClause = 117, RULE_endKeyClause = 118, 
                   RULE_errorKeyClause = 119, RULE_messageCountClause = 120, 
                   RULE_messageDateClause = 121, RULE_messageTimeClause = 122, 
                   RULE_statusKeyClause = 123, RULE_symbolicDestinationClause = 124, 
                   RULE_symbolicQueueClause = 125, RULE_symbolicSourceClause = 126, 
                   RULE_symbolicTerminalClause = 127, RULE_symbolicSubQueueClause = 128, 
                   RULE_textLengthClause = 129, RULE_localStorageSection = 130, 
                   RULE_screenSection = 131, RULE_screenDescriptionEntry = 132, 
                   RULE_screenDescriptionBlankClause = 133, RULE_screenDescriptionBellClause = 134, 
                   RULE_screenDescriptionBlinkClause = 135, RULE_screenDescriptionEraseClause = 136, 
                   RULE_screenDescriptionLightClause = 137, RULE_screenDescriptionGridClause = 138, 
                   RULE_screenDescriptionReverseVideoClause = 139, RULE_screenDescriptionUnderlineClause = 140, 
                   RULE_screenDescriptionSizeClause = 141, RULE_screenDescriptionLineClause = 142, 
                   RULE_screenDescriptionColumnClause = 143, RULE_screenDescriptionForegroundColorClause = 144, 
                   RULE_screenDescriptionBackgroundColorClause = 145, RULE_screenDescriptionControlClause = 146, 
                   RULE_screenDescriptionValueClause = 147, RULE_screenDescriptionPictureClause = 148, 
                   RULE_screenDescriptionFromClause = 149, RULE_screenDescriptionToClause = 150, 
                   RULE_screenDescriptionUsingClause = 151, RULE_screenDescriptionUsageClause = 152, 
                   RULE_screenDescriptionBlankWhenZeroClause = 153, RULE_screenDescriptionJustifiedClause = 154, 
                   RULE_screenDescriptionSignClause = 155, RULE_screenDescriptionAutoClause = 156, 
                   RULE_screenDescriptionSecureClause = 157, RULE_screenDescriptionRequiredClause = 158, 
                   RULE_screenDescriptionPromptClause = 159, RULE_screenDescriptionPromptOccursClause = 160, 
                   RULE_screenDescriptionFullClause = 161, RULE_screenDescriptionZeroFillClause = 162, 
                   RULE_reportSection = 163, RULE_reportDescription = 164, 
                   RULE_reportDescriptionEntry = 165, RULE_reportDescriptionGlobalClause = 166, 
                   RULE_reportDescriptionPageLimitClause = 167, RULE_reportDescriptionHeadingClause = 168, 
                   RULE_reportDescriptionFirstDetailClause = 169, RULE_reportDescriptionLastDetailClause = 170, 
                   RULE_reportDescriptionFootingClause = 171, RULE_reportGroupDescriptionEntry = 172, 
                   RULE_reportGroupDescriptionEntryFormat1 = 173, RULE_reportGroupDescriptionEntryFormat2 = 174, 
                   RULE_reportGroupDescriptionEntryFormat3 = 175, RULE_reportGroupBlankWhenZeroClause = 176, 
                   RULE_reportGroupColumnNumberClause = 177, RULE_reportGroupIndicateClause = 178, 
                   RULE_reportGroupJustifiedClause = 179, RULE_reportGroupLineNumberClause = 180, 
                   RULE_reportGroupLineNumberNextPage = 181, RULE_reportGroupLineNumberPlus = 182, 
                   RULE_reportGroupNextGroupClause = 183, RULE_reportGroupNextGroupPlus = 184, 
                   RULE_reportGroupNextGroupNextPage = 185, RULE_reportGroupPictureClause = 186, 
                   RULE_reportGroupResetClause = 187, RULE_reportGroupSignClause = 188, 
                   RULE_reportGroupSourceClause = 189, RULE_reportGroupSumClause = 190, 
                   RULE_reportGroupTypeClause = 191, RULE_reportGroupTypeReportHeading = 192, 
                   RULE_reportGroupTypePageHeading = 193, RULE_reportGroupTypeControlHeading = 194, 
                   RULE_reportGroupTypeDetail = 195, RULE_reportGroupTypeControlFooting = 196, 
                   RULE_reportGroupUsageClause = 197, RULE_reportGroupTypePageFooting = 198, 
                   RULE_reportGroupTypeReportFooting = 199, RULE_reportGroupValueClause = 200, 
                   RULE_programLibrarySection = 201, RULE_libraryDescriptionEntry = 202, 
                   RULE_libraryDescriptionEntryFormat1 = 203, RULE_libraryDescriptionEntryFormat2 = 204, 
                   RULE_libraryAttributeClauseFormat1 = 205, RULE_libraryAttributeClauseFormat2 = 206, 
                   RULE_libraryAttributeFunction = 207, RULE_libraryAttributeParameter = 208, 
                   RULE_libraryAttributeTitle = 209, RULE_libraryEntryProcedureClauseFormat1 = 210, 
                   RULE_libraryEntryProcedureClauseFormat2 = 211, RULE_libraryEntryProcedureForClause = 212, 
                   RULE_libraryEntryProcedureGivingClause = 213, RULE_libraryEntryProcedureUsingClause = 214, 
                   RULE_libraryEntryProcedureUsingName = 215, RULE_libraryEntryProcedureWithClause = 216, 
                   RULE_libraryEntryProcedureWithName = 217, RULE_libraryIsCommonClause = 218, 
                   RULE_libraryIsGlobalClause = 219, RULE_dataDescriptionEntry = 220, 
                   RULE_dataDescriptionEntryFormat1 = 221, RULE_dataDescriptionEntryFormat2 = 222, 
                   RULE_dataDescriptionEntryFormat3 = 223, RULE_dataDescriptionEntryExecSql = 224, 
                   RULE_dataAlignedClause = 225, RULE_dataBlankWhenZeroClause = 226, 
                   RULE_dataCommonOwnLocalClause = 227, RULE_dataExternalClause = 228, 
                   RULE_dataGlobalClause = 229, RULE_dataIntegerStringClause = 230, 
                   RULE_dataJustifiedClause = 231, RULE_dataOccursClause = 232, 
                   RULE_dataOccursTo = 233, RULE_dataOccursSort = 234, RULE_dataPictureClause = 235, 
                   RULE_pictureString = 236, RULE_pictureChars = 237, RULE_pictureCharsKeyword = 238, 
                   RULE_pictureCardinality = 239, RULE_dataReceivedByClause = 240, 
                   RULE_dataRecordAreaClause = 241, RULE_dataRedefinesClause = 242, 
                   RULE_dataRenamesClause = 243, RULE_dataSignClause = 244, 
                   RULE_dataSynchronizedClause = 245, RULE_dataThreadLocalClause = 246, 
                   RULE_dataTypeClause = 247, RULE_dataTypeDefClause = 248, 
                   RULE_dataUsageClause = 249, RULE_dataUsingClause = 250, 
                   RULE_dataValueClause = 251, RULE_dataValueInterval = 252, 
                   RULE_dataValueIntervalFrom = 253, RULE_dataValueIntervalTo = 254, 
                   RULE_dataWithLowerBoundsClause = 255, RULE_procedureDivision = 256, 
                   RULE_procedureDivisionUsingClause = 257, RULE_procedureDivisionGivingClause = 258, 
                   RULE_procedureDeclaratives = 259, RULE_procedureDeclarative = 260, 
                   RULE_procedureSectionHeader = 261, RULE_procedureDivisionBody = 262, 
                   RULE_procedureSection = 263, RULE_paragraphs = 264, RULE_paragraph = 265, 
                   RULE_sentence = 266, RULE_statement = 267, RULE_acceptStatement = 268, 
                   RULE_acceptFromDateStatement = 269, RULE_acceptFromMnemonicStatement = 270, 
                   RULE_acceptFromEscapeKeyStatement = 271, RULE_acceptMessageCountStatement = 272, 
                   RULE_addStatement = 273, RULE_addToStatement = 274, RULE_addToGivingStatement = 275, 
                   RULE_addCorrespondingStatement = 276, RULE_addFrom = 277, 
                   RULE_addTo = 278, RULE_addGiving = 279, RULE_alteredGoTo = 280, 
                   RULE_alterStatement = 281, RULE_alterProceedTo = 282, 
                   RULE_callStatement = 283, RULE_callByReferenceStatement = 284, 
                   RULE_callByReference = 285, RULE_callByValueStatement = 286, 
                   RULE_callByValue = 287, RULE_callByContentStatement = 288, 
                   RULE_callByContent = 289, RULE_callGivingPhrase = 290, 
                   RULE_cancelStatement = 291, RULE_cancelCall = 292, RULE_closeStatement = 293, 
                   RULE_closeFile = 294, RULE_closeReelUnitStatement = 295, 
                   RULE_closeRelativeStatement = 296, RULE_closePortFileIOStatement = 297, 
                   RULE_closePortFileIOUsing = 298, RULE_closePortFileIOUsingCloseDisposition = 299, 
                   RULE_closePortFileIOUsingAssociatedData = 300, RULE_closePortFileIOUsingAssociatedDataLength = 301, 
                   RULE_computeStatement = 302, RULE_computeStore = 303, 
                   RULE_continueStatement = 304, RULE_deleteStatement = 305, 
                   RULE_disableStatement = 306, RULE_displayStatement = 307, 
                   RULE_displayOperand = 308, RULE_displayAt = 309, RULE_displayUpon = 310, 
                   RULE_displayWith = 311, RULE_divideStatement = 312, RULE_divideIntoStatement = 313, 
                   RULE_divideIntoGivingStatement = 314, RULE_divideIntoByGivingStatement = 315, 
                   RULE_divideGivingPhrase = 316, RULE_divideGiving = 317, 
                   RULE_divideRemainder = 318, RULE_enableStatement = 319, 
                   RULE_entryStatement = 320, RULE_evaluateStatement = 321, 
                   RULE_evaluateSelect = 322, RULE_evaluateAlsoSelect = 323, 
                   RULE_evaluateWhenPhrase = 324, RULE_evaluateWhen = 325, 
                   RULE_evaluateCondition = 326, RULE_evaluateThrough = 327, 
                   RULE_evaluateAlsoCondition = 328, RULE_evaluateWhenOther = 329, 
                   RULE_evaluateValue = 330, RULE_execCicsStatement = 331, 
                   RULE_execSqlStatement = 332, RULE_execSqlImsStatement = 333, 
                   RULE_exhibitStatement = 334, RULE_exhibitOperand = 335, 
                   RULE_exitStatement = 336, RULE_generateStatement = 337, 
                   RULE_gobackStatement = 338, RULE_goToStatement = 339, 
                   RULE_goToStatementSimple = 340, RULE_goToDependingOnStatement = 341, 
                   RULE_ifStatement = 342, RULE_ifThen = 343, RULE_ifElse = 344, 
                   RULE_initializeStatement = 345, RULE_initializeReplacingPhrase = 346, 
                   RULE_initializeReplacingBy = 347, RULE_initiateStatement = 348, 
                   RULE_inspectStatement = 349, RULE_inspectTallyingPhrase = 350, 
                   RULE_inspectReplacingPhrase = 351, RULE_inspectTallyingReplacingPhrase = 352, 
                   RULE_inspectConvertingPhrase = 353, RULE_inspectFor = 354, 
                   RULE_inspectCharacters = 355, RULE_inspectReplacingCharacters = 356, 
                   RULE_inspectAllLeadings = 357, RULE_inspectReplacingAllLeadings = 358, 
                   RULE_inspectAllLeading = 359, RULE_inspectReplacingAllLeading = 360, 
                   RULE_inspectBy = 361, RULE_inspectTo = 362, RULE_inspectBeforeAfter = 363, 
                   RULE_mergeStatement = 364, RULE_mergeOnKeyClause = 365, 
                   RULE_mergeCollatingSequencePhrase = 366, RULE_mergeCollatingAlphanumeric = 367, 
                   RULE_mergeCollatingNational = 368, RULE_mergeUsing = 369, 
                   RULE_mergeOutputProcedurePhrase = 370, RULE_mergeOutputThrough = 371, 
                   RULE_mergeGivingPhrase = 372, RULE_mergeGiving = 373, 
                   RULE_moveStatement = 374, RULE_moveToStatement = 375, 
                   RULE_moveToSendingArea = 376, RULE_moveCorrespondingToStatement = 377, 
                   RULE_multiplyStatement = 378, RULE_multiplyRegular = 379, 
                   RULE_multiplyRegularOperand = 380, RULE_multiplyGiving = 381, 
                   RULE_multiplyGivingOperand = 382, RULE_multiplyGivingResult = 383, 
                   RULE_openStatement = 384, RULE_openInputStatement = 385, 
                   RULE_openInput = 386, RULE_openOutputStatement = 387, 
                   RULE_openOutput = 388, RULE_openIOStatement = 389, RULE_openExtendStatement = 390, 
                   RULE_performStatement = 391, RULE_performInlineStatement = 392, 
                   RULE_performProcedureStatement = 393, RULE_performType = 394, 
                   RULE_performTimes = 395, RULE_performUntil = 396, RULE_performVarying = 397, 
                   RULE_performVaryingClause = 398, RULE_performTestClause = 399, 
                   RULE_purgeStatement = 400, RULE_readStatement = 401, 
                   RULE_readInto = 402, RULE_readWith = 403, RULE_readKey = 404, 
                   RULE_receiveStatement = 405, RULE_receiveFromStatement = 406, 
                   RULE_receiveFrom = 407, RULE_receiveIntoStatement = 408, 
                   RULE_receiveNoData = 409, RULE_receiveWithData = 410, 
                   RULE_receiveBefore = 411, RULE_receiveWith = 412, RULE_receiveThread = 413, 
                   RULE_receiveSize = 414, RULE_receiveStatus = 415, RULE_releaseStatement = 416, 
                   RULE_returnStatement = 417, RULE_returnInto = 418, RULE_rewriteStatement = 419, 
                   RULE_rewriteFrom = 420, RULE_searchStatement = 421, RULE_searchVarying = 422, 
                   RULE_searchWhen = 423, RULE_sendStatement = 424, RULE_sendStatementSync = 425, 
                   RULE_sendStatementAsync = 426, RULE_sendFromPhrase = 427, 
                   RULE_sendWithPhrase = 428, RULE_sendReplacingPhrase = 429, 
                   RULE_sendAdvancingPhrase = 430, RULE_sendAdvancingPage = 431, 
                   RULE_sendAdvancingLines = 432, RULE_sendAdvancingMnemonic = 433, 
                   RULE_setStatement = 434, RULE_setToStatement = 435, RULE_setUpDownByStatement = 436, 
                   RULE_setTo = 437, RULE_setToValue = 438, RULE_setByValue = 439, 
                   RULE_sortStatement = 440, RULE_sortOnKeyClause = 441, 
                   RULE_sortDuplicatesPhrase = 442, RULE_sortCollatingSequencePhrase = 443, 
                   RULE_sortCollatingAlphanumeric = 444, RULE_sortCollatingNational = 445, 
                   RULE_sortInputProcedurePhrase = 446, RULE_sortInputThrough = 447, 
                   RULE_sortUsing = 448, RULE_sortOutputProcedurePhrase = 449, 
                   RULE_sortOutputThrough = 450, RULE_sortGivingPhrase = 451, 
                   RULE_sortGiving = 452, RULE_startStatement = 453, RULE_startKey = 454, 
                   RULE_stopStatement = 455, RULE_stringStatement = 456, 
                   RULE_stringSendingPhrase = 457, RULE_stringSending = 458, 
                   RULE_stringDelimitedByPhrase = 459, RULE_stringForPhrase = 460, 
                   RULE_stringIntoPhrase = 461, RULE_stringWithPointerPhrase = 462, 
                   RULE_subtractStatement = 463, RULE_subtractFromStatement = 464, 
                   RULE_subtractFromGivingStatement = 465, RULE_subtractCorrespondingStatement = 466, 
                   RULE_subtractSubtrahend = 467, RULE_subtractMinuend = 468, 
                   RULE_subtractMinuendGiving = 469, RULE_subtractGiving = 470, 
                   RULE_subtractMinuendCorresponding = 471, RULE_terminateStatement = 472, 
                   RULE_unstringStatement = 473, RULE_unstringSendingPhrase = 474, 
                   RULE_unstringDelimitedByPhrase = 475, RULE_unstringOrAllPhrase = 476, 
                   RULE_unstringIntoPhrase = 477, RULE_unstringInto = 478, 
                   RULE_unstringDelimiterIn = 479, RULE_unstringCountIn = 480, 
                   RULE_unstringWithPointerPhrase = 481, RULE_unstringTallyingPhrase = 482, 
                   RULE_useStatement = 483, RULE_useAfterClause = 484, RULE_useAfterOn = 485, 
                   RULE_useDebugClause = 486, RULE_useDebugOn = 487, RULE_writeStatement = 488, 
                   RULE_writeFromPhrase = 489, RULE_writeAdvancingPhrase = 490, 
                   RULE_writeAdvancingPage = 491, RULE_writeAdvancingLines = 492, 
                   RULE_writeAdvancingMnemonic = 493, RULE_writeAtEndOfPagePhrase = 494, 
                   RULE_writeNotAtEndOfPagePhrase = 495, RULE_atEndPhrase = 496, 
                   RULE_notAtEndPhrase = 497, RULE_invalidKeyPhrase = 498, 
                   RULE_notInvalidKeyPhrase = 499, RULE_onOverflowPhrase = 500, 
                   RULE_notOnOverflowPhrase = 501, RULE_onSizeErrorPhrase = 502, 
                   RULE_notOnSizeErrorPhrase = 503, RULE_onExceptionClause = 504, 
                   RULE_notOnExceptionClause = 505, RULE_arithmeticExpression = 506, 
                   RULE_plusMinus = 507, RULE_multDivs = 508, RULE_multDiv = 509, 
                   RULE_powers = 510, RULE_power = 511, RULE_basis = 512, 
                   RULE_condition = 513, RULE_andOrCondition = 514, RULE_combinableCondition = 515, 
                   RULE_simpleCondition = 516, RULE_classCondition = 517, 
                   RULE_conditionNameReference = 518, RULE_conditionNameSubscriptReference = 519, 
                   RULE_relationCondition = 520, RULE_relationSignCondition = 521, 
                   RULE_relationArithmeticComparison = 522, RULE_relationCombinedComparison = 523, 
                   RULE_relationCombinedCondition = 524, RULE_relationalOperator = 525, 
                   RULE_abbreviation = 526, RULE_identifier = 527, RULE_tableCall = 528, 
                   RULE_functionCall = 529, RULE_referenceModifier = 530, 
                   RULE_characterPosition = 531, RULE_length = 532, RULE_subscript = 533, 
                   RULE_argument = 534, RULE_qualifiedDataName = 535, RULE_qualifiedDataNameFormat1 = 536, 
                   RULE_qualifiedDataNameFormat2 = 537, RULE_qualifiedDataNameFormat3 = 538, 
                   RULE_qualifiedDataNameFormat4 = 539, RULE_qualifiedInData = 540, 
                   RULE_inData = 541, RULE_inFile = 542, RULE_inMnemonic = 543, 
                   RULE_inSection = 544, RULE_inLibrary = 545, RULE_inTable = 546, 
                   RULE_alphabetName = 547, RULE_assignmentName = 548, RULE_basisName = 549, 
                   RULE_cdName = 550, RULE_className = 551, RULE_computerName = 552, 
                   RULE_conditionName = 553, RULE_dataName = 554, RULE_dataDescName = 555, 
                   RULE_environmentName = 556, RULE_fileName = 557, RULE_functionName = 558, 
                   RULE_indexName = 559, RULE_languageName = 560, RULE_libraryName = 561, 
                   RULE_localName = 562, RULE_mnemonicName = 563, RULE_paragraphName = 564, 
                   RULE_procedureName = 565, RULE_programName = 566, RULE_recordName = 567, 
                   RULE_reportName = 568, RULE_routineName = 569, RULE_screenName = 570, 
                   RULE_sectionName = 571, RULE_systemName = 572, RULE_symbolicCharacter = 573, 
                   RULE_textName = 574, RULE_cobolWord = 575, RULE_literal = 576, 
                   RULE_booleanLiteral = 577, RULE_numericLiteral = 578, 
                   RULE_integerLiteral = 579, RULE_cicsDfhRespLiteral = 580, 
                   RULE_cicsDfhValueLiteral = 581, RULE_figurativeConstant = 582, 
                   RULE_specialRegister = 583, RULE_commentEntry = 584
	public static let ruleNames: [String] = [
		"startRule", "compilationUnit", "programUnit", "endProgramStatement", 
		"compilerOptions", "compilerOption", "compilerSubOption", "identificationDivision", 
		"identificationDivisionBody", "programIdParagraph", "authorParagraph", 
		"installationParagraph", "dateWrittenParagraph", "dateCompiledParagraph", 
		"securityParagraph", "remarksParagraph", "environmentDivision", "environmentDivisionBody", 
		"configurationSection", "configurationSectionParagraph", "sourceComputerParagraph", 
		"objectComputerParagraph", "objectComputerClause", "memorySizeClause", 
		"diskSizeClause", "collatingSequenceClause", "collatingSequenceClauseAlphanumeric", 
		"collatingSequenceClauseNational", "segmentLimitClause", "characterSetClause", 
		"specialNamesParagraph", "specialNameClause", "alphabetClause", "alphabetClauseFormat1", 
		"alphabetLiterals", "alphabetThrough", "alphabetAlso", "alphabetClauseFormat2", 
		"channelClause", "classClause", "classClauseThrough", "classClauseFrom", 
		"classClauseTo", "currencySignClause", "decimalPointClause", "defaultComputationalSignClause", 
		"defaultDisplaySignClause", "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase", 
		"odtClause", "reserveNetworkClause", "symbolicCharactersClause", "symbolicCharacters", 
		"inputOutputSection", "inputOutputSectionParagraph", "fileControlParagraph", 
		"fileControlEntry", "selectClause", "fileControlClause", "assignClause", 
		"reserveClause", "organizationClause", "paddingCharacterClause", "recordDelimiterClause", 
		"accessModeClause", "recordKeyClause", "alternateRecordKeyClause", "passwordClause", 
		"fileStatusClause", "relativeKeyClause", "ioControlParagraph", "ioControlClause", 
		"rerunClause", "rerunEveryRecords", "rerunEveryOf", "rerunEveryClock", 
		"sameClause", "multipleFileClause", "multipleFilePosition", "commitmentControlClause", 
		"dataDivision", "dataDivisionBody", "fileSection", "fileDescriptionEntry", 
		"fileDescriptionEntryClause", "externalClause", "globalClause", "blockContainsClause", 
		"blockContainsTo", "recordContainsClause", "recordContainsClauseFormat1", 
		"recordContainsClauseFormat2", "recordContainsClauseFormat3", "recordContainsTo", 
		"labelRecordsClause", "valueOfClause", "valuePair", "dataRecordsClause", 
		"linageClause", "linageAt", "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom", 
		"recordingModeClause", "modeStatement", "codeSetClause", "reportClause", 
		"dataBaseSection", "dataBaseSectionEntry", "workingStorageSection", "linkageSection", 
		"communicationSection", "communicationDescriptionEntry", "communicationDescriptionEntryFormat1", 
		"communicationDescriptionEntryFormat2", "communicationDescriptionEntryFormat3", 
		"destinationCountClause", "destinationTableClause", "endKeyClause", "errorKeyClause", 
		"messageCountClause", "messageDateClause", "messageTimeClause", "statusKeyClause", 
		"symbolicDestinationClause", "symbolicQueueClause", "symbolicSourceClause", 
		"symbolicTerminalClause", "symbolicSubQueueClause", "textLengthClause", 
		"localStorageSection", "screenSection", "screenDescriptionEntry", "screenDescriptionBlankClause", 
		"screenDescriptionBellClause", "screenDescriptionBlinkClause", "screenDescriptionEraseClause", 
		"screenDescriptionLightClause", "screenDescriptionGridClause", "screenDescriptionReverseVideoClause", 
		"screenDescriptionUnderlineClause", "screenDescriptionSizeClause", "screenDescriptionLineClause", 
		"screenDescriptionColumnClause", "screenDescriptionForegroundColorClause", 
		"screenDescriptionBackgroundColorClause", "screenDescriptionControlClause", 
		"screenDescriptionValueClause", "screenDescriptionPictureClause", "screenDescriptionFromClause", 
		"screenDescriptionToClause", "screenDescriptionUsingClause", "screenDescriptionUsageClause", 
		"screenDescriptionBlankWhenZeroClause", "screenDescriptionJustifiedClause", 
		"screenDescriptionSignClause", "screenDescriptionAutoClause", "screenDescriptionSecureClause", 
		"screenDescriptionRequiredClause", "screenDescriptionPromptClause", "screenDescriptionPromptOccursClause", 
		"screenDescriptionFullClause", "screenDescriptionZeroFillClause", "reportSection", 
		"reportDescription", "reportDescriptionEntry", "reportDescriptionGlobalClause", 
		"reportDescriptionPageLimitClause", "reportDescriptionHeadingClause", 
		"reportDescriptionFirstDetailClause", "reportDescriptionLastDetailClause", 
		"reportDescriptionFootingClause", "reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1", 
		"reportGroupDescriptionEntryFormat2", "reportGroupDescriptionEntryFormat3", 
		"reportGroupBlankWhenZeroClause", "reportGroupColumnNumberClause", "reportGroupIndicateClause", 
		"reportGroupJustifiedClause", "reportGroupLineNumberClause", "reportGroupLineNumberNextPage", 
		"reportGroupLineNumberPlus", "reportGroupNextGroupClause", "reportGroupNextGroupPlus", 
		"reportGroupNextGroupNextPage", "reportGroupPictureClause", "reportGroupResetClause", 
		"reportGroupSignClause", "reportGroupSourceClause", "reportGroupSumClause", 
		"reportGroupTypeClause", "reportGroupTypeReportHeading", "reportGroupTypePageHeading", 
		"reportGroupTypeControlHeading", "reportGroupTypeDetail", "reportGroupTypeControlFooting", 
		"reportGroupUsageClause", "reportGroupTypePageFooting", "reportGroupTypeReportFooting", 
		"reportGroupValueClause", "programLibrarySection", "libraryDescriptionEntry", 
		"libraryDescriptionEntryFormat1", "libraryDescriptionEntryFormat2", "libraryAttributeClauseFormat1", 
		"libraryAttributeClauseFormat2", "libraryAttributeFunction", "libraryAttributeParameter", 
		"libraryAttributeTitle", "libraryEntryProcedureClauseFormat1", "libraryEntryProcedureClauseFormat2", 
		"libraryEntryProcedureForClause", "libraryEntryProcedureGivingClause", 
		"libraryEntryProcedureUsingClause", "libraryEntryProcedureUsingName", 
		"libraryEntryProcedureWithClause", "libraryEntryProcedureWithName", "libraryIsCommonClause", 
		"libraryIsGlobalClause", "dataDescriptionEntry", "dataDescriptionEntryFormat1", 
		"dataDescriptionEntryFormat2", "dataDescriptionEntryFormat3", "dataDescriptionEntryExecSql", 
		"dataAlignedClause", "dataBlankWhenZeroClause", "dataCommonOwnLocalClause", 
		"dataExternalClause", "dataGlobalClause", "dataIntegerStringClause", "dataJustifiedClause", 
		"dataOccursClause", "dataOccursTo", "dataOccursSort", "dataPictureClause", 
		"pictureString", "pictureChars", "pictureCharsKeyword", "pictureCardinality", 
		"dataReceivedByClause", "dataRecordAreaClause", "dataRedefinesClause", 
		"dataRenamesClause", "dataSignClause", "dataSynchronizedClause", "dataThreadLocalClause", 
		"dataTypeClause", "dataTypeDefClause", "dataUsageClause", "dataUsingClause", 
		"dataValueClause", "dataValueInterval", "dataValueIntervalFrom", "dataValueIntervalTo", 
		"dataWithLowerBoundsClause", "procedureDivision", "procedureDivisionUsingClause", 
		"procedureDivisionGivingClause", "procedureDeclaratives", "procedureDeclarative", 
		"procedureSectionHeader", "procedureDivisionBody", "procedureSection", 
		"paragraphs", "paragraph", "sentence", "statement", "acceptStatement", 
		"acceptFromDateStatement", "acceptFromMnemonicStatement", "acceptFromEscapeKeyStatement", 
		"acceptMessageCountStatement", "addStatement", "addToStatement", "addToGivingStatement", 
		"addCorrespondingStatement", "addFrom", "addTo", "addGiving", "alteredGoTo", 
		"alterStatement", "alterProceedTo", "callStatement", "callByReferenceStatement", 
		"callByReference", "callByValueStatement", "callByValue", "callByContentStatement", 
		"callByContent", "callGivingPhrase", "cancelStatement", "cancelCall", 
		"closeStatement", "closeFile", "closeReelUnitStatement", "closeRelativeStatement", 
		"closePortFileIOStatement", "closePortFileIOUsing", "closePortFileIOUsingCloseDisposition", 
		"closePortFileIOUsingAssociatedData", "closePortFileIOUsingAssociatedDataLength", 
		"computeStatement", "computeStore", "continueStatement", "deleteStatement", 
		"disableStatement", "displayStatement", "displayOperand", "displayAt", 
		"displayUpon", "displayWith", "divideStatement", "divideIntoStatement", 
		"divideIntoGivingStatement", "divideIntoByGivingStatement", "divideGivingPhrase", 
		"divideGiving", "divideRemainder", "enableStatement", "entryStatement", 
		"evaluateStatement", "evaluateSelect", "evaluateAlsoSelect", "evaluateWhenPhrase", 
		"evaluateWhen", "evaluateCondition", "evaluateThrough", "evaluateAlsoCondition", 
		"evaluateWhenOther", "evaluateValue", "execCicsStatement", "execSqlStatement", 
		"execSqlImsStatement", "exhibitStatement", "exhibitOperand", "exitStatement", 
		"generateStatement", "gobackStatement", "goToStatement", "goToStatementSimple", 
		"goToDependingOnStatement", "ifStatement", "ifThen", "ifElse", "initializeStatement", 
		"initializeReplacingPhrase", "initializeReplacingBy", "initiateStatement", 
		"inspectStatement", "inspectTallyingPhrase", "inspectReplacingPhrase", 
		"inspectTallyingReplacingPhrase", "inspectConvertingPhrase", "inspectFor", 
		"inspectCharacters", "inspectReplacingCharacters", "inspectAllLeadings", 
		"inspectReplacingAllLeadings", "inspectAllLeading", "inspectReplacingAllLeading", 
		"inspectBy", "inspectTo", "inspectBeforeAfter", "mergeStatement", "mergeOnKeyClause", 
		"mergeCollatingSequencePhrase", "mergeCollatingAlphanumeric", "mergeCollatingNational", 
		"mergeUsing", "mergeOutputProcedurePhrase", "mergeOutputThrough", "mergeGivingPhrase", 
		"mergeGiving", "moveStatement", "moveToStatement", "moveToSendingArea", 
		"moveCorrespondingToStatement", "multiplyStatement", "multiplyRegular", 
		"multiplyRegularOperand", "multiplyGiving", "multiplyGivingOperand", "multiplyGivingResult", 
		"openStatement", "openInputStatement", "openInput", "openOutputStatement", 
		"openOutput", "openIOStatement", "openExtendStatement", "performStatement", 
		"performInlineStatement", "performProcedureStatement", "performType", 
		"performTimes", "performUntil", "performVarying", "performVaryingClause", 
		"performTestClause", "purgeStatement", "readStatement", "readInto", "readWith", 
		"readKey", "receiveStatement", "receiveFromStatement", "receiveFrom", 
		"receiveIntoStatement", "receiveNoData", "receiveWithData", "receiveBefore", 
		"receiveWith", "receiveThread", "receiveSize", "receiveStatus", "releaseStatement", 
		"returnStatement", "returnInto", "rewriteStatement", "rewriteFrom", "searchStatement", 
		"searchVarying", "searchWhen", "sendStatement", "sendStatementSync", "sendStatementAsync", 
		"sendFromPhrase", "sendWithPhrase", "sendReplacingPhrase", "sendAdvancingPhrase", 
		"sendAdvancingPage", "sendAdvancingLines", "sendAdvancingMnemonic", "setStatement", 
		"setToStatement", "setUpDownByStatement", "setTo", "setToValue", "setByValue", 
		"sortStatement", "sortOnKeyClause", "sortDuplicatesPhrase", "sortCollatingSequencePhrase", 
		"sortCollatingAlphanumeric", "sortCollatingNational", "sortInputProcedurePhrase", 
		"sortInputThrough", "sortUsing", "sortOutputProcedurePhrase", "sortOutputThrough", 
		"sortGivingPhrase", "sortGiving", "startStatement", "startKey", "stopStatement", 
		"stringStatement", "stringSendingPhrase", "stringSending", "stringDelimitedByPhrase", 
		"stringForPhrase", "stringIntoPhrase", "stringWithPointerPhrase", "subtractStatement", 
		"subtractFromStatement", "subtractFromGivingStatement", "subtractCorrespondingStatement", 
		"subtractSubtrahend", "subtractMinuend", "subtractMinuendGiving", "subtractGiving", 
		"subtractMinuendCorresponding", "terminateStatement", "unstringStatement", 
		"unstringSendingPhrase", "unstringDelimitedByPhrase", "unstringOrAllPhrase", 
		"unstringIntoPhrase", "unstringInto", "unstringDelimiterIn", "unstringCountIn", 
		"unstringWithPointerPhrase", "unstringTallyingPhrase", "useStatement", 
		"useAfterClause", "useAfterOn", "useDebugClause", "useDebugOn", "writeStatement", 
		"writeFromPhrase", "writeAdvancingPhrase", "writeAdvancingPage", "writeAdvancingLines", 
		"writeAdvancingMnemonic", "writeAtEndOfPagePhrase", "writeNotAtEndOfPagePhrase", 
		"atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase", "notInvalidKeyPhrase", 
		"onOverflowPhrase", "notOnOverflowPhrase", "onSizeErrorPhrase", "notOnSizeErrorPhrase", 
		"onExceptionClause", "notOnExceptionClause", "arithmeticExpression", "plusMinus", 
		"multDivs", "multDiv", "powers", "power", "basis", "condition", "andOrCondition", 
		"combinableCondition", "simpleCondition", "classCondition", "conditionNameReference", 
		"conditionNameSubscriptReference", "relationCondition", "relationSignCondition", 
		"relationArithmeticComparison", "relationCombinedComparison", "relationCombinedCondition", 
		"relationalOperator", "abbreviation", "identifier", "tableCall", "functionCall", 
		"referenceModifier", "characterPosition", "length", "subscript", "argument", 
		"qualifiedDataName", "qualifiedDataNameFormat1", "qualifiedDataNameFormat2", 
		"qualifiedDataNameFormat3", "qualifiedDataNameFormat4", "qualifiedInData", 
		"inData", "inFile", "inMnemonic", "inSection", "inLibrary", "inTable", 
		"alphabetName", "assignmentName", "basisName", "cdName", "className", 
		"computerName", "conditionName", "dataName", "dataDescName", "environmentName", 
		"fileName", "functionName", "indexName", "languageName", "libraryName", 
		"localName", "mnemonicName", "paragraphName", "procedureName", "programName", 
		"recordName", "reportName", "routineName", "screenName", "sectionName", 
		"systemName", "symbolicCharacter", "textName", "cobolWord", "literal", 
		"booleanLiteral", "numericLiteral", "integerLiteral", "cicsDfhRespLiteral", 
		"cicsDfhValueLiteral", "figurativeConstant", "specialRegister", "commentEntry"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, "'&'", "'*'", 
		"'**'", "':'", "','", "'>*CE'", "'>*'", "'$'", "'\"'", nil, "'.'", "'='", 
		"'>*EXECCICS'", "'>*EXECSQL'", "'>*EXECSQLIMS'", "'<'", "'<='", "'('", 
		"'-'", "'>'", "'>='", "'+'", "'''", "')'", "'/'", nil, "'66'", "'77'", 
		"'88'", nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, "', '"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, "ABORT", "ACCEPT", "ACCESS", "ADD", "ADDRESS", "ADVANCING", "AFTER", 
		"ALIGNED", "ALL", "ALPHABET", "ALPHABETIC", "ALPHABETIC_LOWER", "ALPHABETIC_UPPER", 
		"ALPHANUMERIC", "ALPHANUMERIC_EDITED", "ALSO", "ALTER", "ALTERNATE", "AND", 
		"ANY", "APOST", "ARE", "AREA", "AREAS", "ARITH", "AS", "ASCENDING", "ASCII", 
		"ASSIGN", "ASSOCIATED_DATA", "ASSOCIATED_DATA_LENGTH", "AT", "ATTRIBUTE", 
		"AUTHOR", "AUTO", "AUTO_SKIP", "BACKGROUND_COLOR", "BACKGROUND_COLOUR", 
		"BASIS", "BEEP", "BEFORE", "BEGINNING", "BELL", "BINARY", "BIT", "BLANK", 
		"BLINK", "BLOCK", "BOUNDS", "BOTTOM", "BY", "BYFUNCTION", "BYTITLE", "CALL", 
		"CANCEL", "CAPABLE", "CBL", "CCSVERSION", "CD", "CF", "CH", "CHANGED", 
		"CHANNEL", "CHARACTER", "CHARACTERS", "CLASS", "CLASS_ID", "CLOCK_UNITS", 
		"CLOSE", "CLOSE_DISPOSITION", "COBOL", "CODE", "CODEPAGE", "CODE_SET", 
		"COLLATING", "COL", "COLUMN", "COM_REG", "COMMA", "COMMITMENT", "COMMON", 
		"COMMUNICATION", "COMP", "COMP_1", "COMP_2", "COMP_3", "COMP_4", "COMP_5", 
		"COMPUTATIONAL", "COMPUTATIONAL_1", "COMPUTATIONAL_2", "COMPUTATIONAL_3", 
		"COMPUTATIONAL_4", "COMPUTATIONAL_5", "COMPUTE", "CONFIGURATION", "CONTAINS", 
		"CONTENT", "CONTINUE", "CONTROL", "CONTROL_POINT", "CONTROLS", "CONVENTION", 
		"CONVERTING", "COPY", "CORR", "CORRESPONDING", "COUNT", "CRUNCH", "CURRENCY", 
		"CURSOR", "DATA", "DATA_BASE", "DATE", "DATE_COMPILED", "DATE_WRITTEN", 
		"DAY", "DAY_OF_WEEK", "DBCS", "DE", "DEBUG_CONTENTS", "DEBUG_ITEM", "DEBUG_LINE", 
		"DEBUG_NAME", "DEBUG_SUB_1", "DEBUG_SUB_2", "DEBUG_SUB_3", "DEBUGGING", 
		"DECIMAL_POINT", "DECLARATIVES", "DEFAULT", "DEFAULT_DISPLAY", "DEFINITION", 
		"DELETE", "DELIMITED", "DELIMITER", "DEPENDING", "DESCENDING", "DESTINATION", 
		"DETAIL", "DFHRESP", "DFHVALUE", "DISABLE", "DISK", "DISPLAY", "DISPLAY_1", 
		"DIVIDE", "DIVISION", "DONTCARE", "DOUBLE", "DOWN", "DUPLICATES", "DYNAMIC", 
		"EBCDIC", "EGCS", "EGI", "EJECT", "ELSE", "EMI", "EMPTY_CHECK", "ENABLE", 
		"END", "END_ADD", "END_CALL", "END_COMPUTE", "END_DELETE", "END_DIVIDE", 
		"END_EVALUATE", "END_IF", "END_MULTIPLY", "END_OF_PAGE", "END_PERFORM", 
		"END_READ", "END_RECEIVE", "END_RETURN", "END_REWRITE", "END_SEARCH", 
		"END_START", "END_STRING", "END_SUBTRACT", "END_UNSTRING", "END_WRITE", 
		"ENDING", "ENTER", "ENTRY", "ENTRY_PROCEDURE", "ENVIRONMENT", "EOP", "EQUAL", 
		"ERASE", "ERROR", "EOL", "EOS", "ESCAPE", "ESI", "EVALUATE", "EVENT", 
		"EVERY", "EXCEPTION", "EXCLUSIVE", "EXHIBIT", "EXIT", "EXPORT", "EXTEND", 
		"EXTENDED", "EXTERNAL", "FALSE", "FD", "FILE", "FILE_CONTROL", "FILLER", 
		"FINAL", "FIRST", "FOOTING", "FOR", "FOREGROUND_COLOR", "FOREGROUND_COLOUR", 
		"FROM", "FULL", "FUNCTION", "FUNCTIONNAME", "FUNCTION_POINTER", "GENERATE", 
		"GOBACK", "GIVING", "GLOBAL", "GO", "GREATER", "GRID", "GROUP", "HEADING", 
		"HIGHLIGHT", "HIGH_VALUE", "HIGH_VALUES", "I_O", "I_O_CONTROL", "ID", 
		"IDENTIFICATION", "IF", "IMPLICIT", "IMPORT", "IN", "INDEX", "INDEXED", 
		"INDICATE", "INITIAL", "INITIALIZE", "INITIATE", "INPUT", "INPUT_OUTPUT", 
		"INSPECT", "INSTALLATION", "INTEGER", "INTO", "INVALID", "INVOKE", "IS", 
		"JUST", "JUSTIFIED", "KANJI", "KEPT", "KEY", "LABEL", "LANGUAGE", "LAST", 
		"LB", "LD", "LEADING", "LEFT", "LEFTLINE", "LENGTH", "LENGTH_CHECK", "LESS", 
		"LIB", "LIBACCESS", "LIBPARAMETER", "LIBRARY", "LIMIT", "LIMITS", "LINAGE", 
		"LINAGE_COUNTER", "LINE", "LINES", "LINE_COUNTER", "LINKAGE", "LIST", 
		"LOCAL", "LOCAL_STORAGE", "LOCK", "LONG_DATE", "LONG_TIME", "LOWER", "LOWLIGHT", 
		"LOW_VALUE", "LOW_VALUES", "MEMORY", "MERGE", "MESSAGE", "MMDDYYYY", "MODE", 
		"MODULES", "MORE_LABELS", "MOVE", "MULTIPLE", "MULTIPLY", "NAMED", "NATIONAL", 
		"NATIVE", "NEGATIVE", "NETWORK", "NEXT", "NO", "NO_ECHO", "NOSEQ", "NOSTDTRUNC", 
		"NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NUMERIC_DATE", "NUMERIC_EDITED", 
		"NUMERIC_TIME", "OBJECT_COMPUTER", "OCCURS", "ODT", "OF", "OFF", "OMITTED", 
		"ON", "OPEN", "OPTIMIZE", "OPTIONAL", "OR", "ORDER", "ORDERLY", "ORGANIZATION", 
		"OTHER", "OUTPUT", "OVERFLOW", "OVERLINE", "OWN", "PACKED_DECIMAL", "PADDING", 
		"PAGE", "PAGE_COUNTER", "PASSWORD", "PERFORM", "PF", "PH", "PIC", "PICTURE", 
		"PLUS", "POINTER", "POSITION", "POSITIVE", "PORT", "PRINTER", "PRINTING", 
		"PRIVATE", "PROCEDURE", "PROCEDURE_POINTER", "PROCEDURES", "PROCEED", 
		"PROCESS", "PROGRAM", "PROGRAM_ID", "PROGRAM_LIBRARY", "PROMPT", "PURGE", 
		"QUEUE", "QUOTE", "QUOTES", "RANDOM", "READER", "REMOTE", "RD", "REAL", 
		"READ", "RECEIVE", "RECEIVED", "RECORD", "RECORDING", "RECORDS", "REDEFINES", 
		"REEL", "REF", "REFERENCE", "REFERENCES", "RELATIVE", "RELEASE", "REMAINDER", 
		"REMARKS", "REMOVAL", "REMOVE", "RENAMES", "REPLACE", "REPLACING", "REPORT", 
		"REPORTING", "REPORTS", "REQUIRED", "RERUN", "RESERVE", "REVERSE_VIDEO", 
		"RESET", "RETURN", "RETURN_CODE", "REVERSED", "REWIND", "REWRITE", "RF", 
		"RH", "RIGHT", "ROUNDED", "RUN", "SAME", "SAVE", "SCREEN", "SD", "SEARCH", 
		"SECTION", "SECURE", "SECURITY", "SEGMENT", "SEGMENT_LIMIT", "SELECT", 
		"SEND", "SENTENCE", "SEPARATE", "SEQUENCE", "SEQUENTIAL", "SET", "SHARED", 
		"SHAREDBYALL", "SHAREDBYRUNUNIT", "SHARING", "SHIFT_IN", "SHIFT_OUT", 
		"SHORT_DATE", "SIGN", "SIZE", "SORT", "SORT_CONTROL", "SORT_CORE_SIZE", 
		"SORT_FILE_SIZE", "SORT_MERGE", "SORT_MESSAGE", "SORT_MODE_SIZE", "SORT_RETURN", 
		"SOURCE", "SOURCE_COMPUTER", "SP", "SPACE", "SPACES", "SPECIAL_NAMES", 
		"STANDARD", "STANDARD_1", "STANDARD_2", "START", "STATUS", "STOP", "STRING", 
		"SUB_QUEUE_1", "SUB_QUEUE_2", "SUB_QUEUE_3", "SUBTRACT", "SUM", "SUPPRESS", 
		"SYMBOL", "SYMBOLIC", "SYNC", "SYNCHRONIZED", "TABLE", "TALLY", "TALLYING", 
		"TASK", "TAPE", "TERMINAL", "TERMINATE", "TEST", "TEXT", "THAN", "THEN", 
		"THREAD", "THREAD_LOCAL", "THROUGH", "THRU", "TIME", "TIMER", "TIMES", 
		"TITLE", "TO", "TODAYS_DATE", "TODAYS_NAME", "TOP", "TRAILING", "TRUE", 
		"TRUNCATED", "TYPE", "TYPEDEF", "UNDERLINE", "UNIT", "UNSTRING", "UNTIL", 
		"UP", "UPON", "USAGE", "USE", "USING", "VALUE", "VALUES", "VARYING", "VIRTUAL", 
		"WAIT", "WHEN", "WHEN_COMPILED", "WITH", "WORDS", "WORKING_STORAGE", "WRITE", 
		"XOPTS", "YEAR", "YYYYMMDD", "YYYYDDD", "ZERO", "ZERO_FILL", "ZEROS", 
		"ZEROES", "AMPCHAR", "ASTERISKCHAR", "DOUBLEASTERISKCHAR", "COLONCHAR", 
		"COMMACHAR", "COMMENTENTRYTAG", "COMMENTTAG", "DOLLARCHAR", "DOUBLEQUOTE", 
		"DOT_FS", "DOT", "EQUALCHAR", "EXECCICSTAG", "EXECSQLTAG", "EXECSQLIMSTAG", 
		"LESSTHANCHAR", "LESSTHANOREQUAL", "LPARENCHAR", "MINUSCHAR", "MORETHANCHAR", 
		"MORETHANOREQUAL", "PLUSCHAR", "SINGLEQUOTE", "RPARENCHAR", "SLASHCHAR", 
		"NONNUMERICLITERAL", "LEVEL_NUMBER_66", "LEVEL_NUMBER_77", "LEVEL_NUMBER_88", 
		"INTEGERLITERAL", "NUMERICLITERAL", "IDENTIFIER", "NEWLINE", "EXECCICSLINE", 
		"EXECSQLIMSLINE", "EXECSQLLINE", "COMMENTENTRYLINE", "COMMENTLINE", "WS", 
		"SEPARATOR"
	]
	public static let VOCABULARY: Vocabulary = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	//@Deprecated
	public let tokenNames: [String?]? = {
	    let length = _SYMBOLIC_NAMES.count
	    var tokenNames = [String?](repeating: nil, count: length)
		for i in 0..<length {
			var name = VOCABULARY.getLiteralName(i)
			if name == nil {
				name = VOCABULARY.getSymbolicName(i)
			}
			if name == nil {
				name = "<INVALID>"
			}
			tokenNames[i] = name
		}
		return tokenNames
	}()

	override
	open func getTokenNames() -> [String?]? {
		return tokenNames
	}

	override
	open func getGrammarFileName() -> String { return "Cobol85.g4" }

	override
	open func getRuleNames() -> [String] { return Cobol85Parser.ruleNames }

	override
	open func getSerializedATN() -> String { return Cobol85Parser._serializedATN }

	override
	open func getATN() -> ATN { return Cobol85Parser._ATN }

	open override func getVocabulary() -> Vocabulary {
	    return Cobol85Parser.VOCABULARY
	}

	public override init(_ input:TokenStream)throws {
	    RuntimeMetaData.checkVersion("4.5.3", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,Cobol85Parser._ATN,Cobol85Parser._decisionToDFA, Cobol85Parser._sharedContextCache)
	}
	open class StartRuleContext:ParserRuleContext {
		open func compilationUnit() -> CompilationUnitContext? {
			return getRuleContext(CompilationUnitContext.self,0)
		}
		open func EOF() -> TerminalNode? { return getToken(Cobol85Parser.EOF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_startRule }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStartRule(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStartRule(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStartRule(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStartRule(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func startRule() throws -> StartRuleContext {
		var _localctx: StartRuleContext = StartRuleContext(_ctx, getState())
		try enterRule(_localctx, 0, Cobol85Parser.RULE_startRule)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1170)
		 	try compilationUnit()
		 	setState(1171)
		 	try match(Cobol85Parser.EOF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CompilationUnitContext:ParserRuleContext {
		open func programUnit() -> Array<ProgramUnitContext> {
			return getRuleContexts(ProgramUnitContext.self)
		}
		open func programUnit(_ i: Int) -> ProgramUnitContext? {
			return getRuleContext(ProgramUnitContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_compilationUnit }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCompilationUnit(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCompilationUnit(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCompilationUnit(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCompilationUnit(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilationUnit() throws -> CompilationUnitContext {
		var _localctx: CompilationUnitContext = CompilationUnitContext(_ctx, getState())
		try enterRule(_localctx, 2, Cobol85Parser.RULE_compilationUnit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1174) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1173)
		 		try programUnit()


		 		setState(1176); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ID || _la == Cobol85Parser.IDENTIFICATION
		 	          testSet = testSet || _la == Cobol85Parser.PROCESS
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProgramUnitContext:ParserRuleContext {
		open func identificationDivision() -> IdentificationDivisionContext? {
			return getRuleContext(IdentificationDivisionContext.self,0)
		}
		open func compilerOptions() -> CompilerOptionsContext? {
			return getRuleContext(CompilerOptionsContext.self,0)
		}
		open func environmentDivision() -> EnvironmentDivisionContext? {
			return getRuleContext(EnvironmentDivisionContext.self,0)
		}
		open func dataDivision() -> DataDivisionContext? {
			return getRuleContext(DataDivisionContext.self,0)
		}
		open func procedureDivision() -> ProcedureDivisionContext? {
			return getRuleContext(ProcedureDivisionContext.self,0)
		}
		open func programUnit() -> Array<ProgramUnitContext> {
			return getRuleContexts(ProgramUnitContext.self)
		}
		open func programUnit(_ i: Int) -> ProgramUnitContext? {
			return getRuleContext(ProgramUnitContext.self,i)
		}
		open func endProgramStatement() -> EndProgramStatementContext? {
			return getRuleContext(EndProgramStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_programUnit }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProgramUnit(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProgramUnit(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProgramUnit(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProgramUnit(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func programUnit() throws -> ProgramUnitContext {
		var _localctx: ProgramUnitContext = ProgramUnitContext(_ctx, getState())
		try enterRule(_localctx, 4, Cobol85Parser.RULE_programUnit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1179)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROCESS
		 	      return testSet
		 	 }()) {
		 		setState(1178)
		 		try compilerOptions()

		 	}

		 	setState(1181)
		 	try identificationDivision()
		 	setState(1183)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ENVIRONMENT
		 	      return testSet
		 	 }()) {
		 		setState(1182)
		 		try environmentDivision()

		 	}

		 	setState(1186)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DATA
		 	      return testSet
		 	 }()) {
		 		setState(1185)
		 		try dataDivision()

		 	}

		 	setState(1189)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROCEDURE
		 	      return testSet
		 	 }()) {
		 		setState(1188)
		 		try procedureDivision()

		 	}

		 	setState(1194)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,5,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1191)
		 			try programUnit()

		 	 
		 		}
		 		setState(1196)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,5,_ctx)
		 	}
		 	setState(1198)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,6,_ctx)) {
		 	case 1:
		 		setState(1197)
		 		try endProgramStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EndProgramStatementContext:ParserRuleContext {
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open func PROGRAM() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM, 0) }
		open func programName() -> ProgramNameContext? {
			return getRuleContext(ProgramNameContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_endProgramStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEndProgramStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEndProgramStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEndProgramStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEndProgramStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func endProgramStatement() throws -> EndProgramStatementContext {
		var _localctx: EndProgramStatementContext = EndProgramStatementContext(_ctx, getState())
		try enterRule(_localctx, 6, Cobol85Parser.RULE_endProgramStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1200)
		 	try match(Cobol85Parser.END)
		 	setState(1201)
		 	try match(Cobol85Parser.PROGRAM)
		 	setState(1202)
		 	try programName()
		 	setState(1203)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CompilerOptionsContext:ParserRuleContext {
		open func PROCESS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.PROCESS) }
		open func PROCESS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.PROCESS, i)
		}
		open func compilerOption() -> Array<CompilerOptionContext> {
			return getRuleContexts(CompilerOptionContext.self)
		}
		open func compilerOption(_ i: Int) -> CompilerOptionContext? {
			return getRuleContext(CompilerOptionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_compilerOptions }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCompilerOptions(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCompilerOptions(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCompilerOptions(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCompilerOptions(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilerOptions() throws -> CompilerOptionsContext {
		var _localctx: CompilerOptionsContext = CompilerOptionsContext(_ctx, getState())
		try enterRule(_localctx, 8, Cobol85Parser.RULE_compilerOptions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1211) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1205)
		 		try match(Cobol85Parser.PROCESS)
		 		setState(1207) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(1206)
		 			try compilerOption()


		 			setState(1209); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.APOST || _la == Cobol85Parser.ARITH
		 		          testSet = testSet || _la == Cobol85Parser.CODEPAGE || _la == Cobol85Parser.DBCS
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LIB,Cobol85Parser.NOSEQ,Cobol85Parser.NOSTDTRUNC,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 274)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.XOPTS
		 		      return testSet
		 		 }())


		 		setState(1213); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROCESS
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CompilerOptionContext:ParserRuleContext {
		open func APOST() -> TerminalNode? { return getToken(Cobol85Parser.APOST, 0) }
		open func ARITH() -> TerminalNode? { return getToken(Cobol85Parser.ARITH, 0) }
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func EXTEND() -> TerminalNode? { return getToken(Cobol85Parser.EXTEND, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func CODEPAGE() -> TerminalNode? { return getToken(Cobol85Parser.CODEPAGE, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func DBCS() -> TerminalNode? { return getToken(Cobol85Parser.DBCS, 0) }
		open func LIB() -> TerminalNode? { return getToken(Cobol85Parser.LIB, 0) }
		open func NOSEQ() -> TerminalNode? { return getToken(Cobol85Parser.NOSEQ, 0) }
		open func NOSTDTRUNC() -> TerminalNode? { return getToken(Cobol85Parser.NOSTDTRUNC, 0) }
		open func OPTIMIZE() -> TerminalNode? { return getToken(Cobol85Parser.OPTIMIZE, 0) }
		open func FULL() -> TerminalNode? { return getToken(Cobol85Parser.FULL, 0) }
		open func XOPTS() -> TerminalNode? { return getToken(Cobol85Parser.XOPTS, 0) }
		open func compilerSubOption() -> Array<CompilerSubOptionContext> {
			return getRuleContexts(CompilerSubOptionContext.self)
		}
		open func compilerSubOption(_ i: Int) -> CompilerSubOptionContext? {
			return getRuleContext(CompilerSubOptionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_compilerOption }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCompilerOption(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCompilerOption(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCompilerOption(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCompilerOption(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilerOption() throws -> CompilerOptionContext {
		var _localctx: CompilerOptionContext = CompilerOptionContext(_ctx, getState())
		try enterRule(_localctx, 10, Cobol85Parser.RULE_compilerOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1242)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.APOST:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1215)
		 		try match(Cobol85Parser.APOST)

		 		break

		 	case Cobol85Parser.ARITH:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1216)
		 		try match(Cobol85Parser.ARITH)
		 		setState(1217)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(1218)
		 		try match(Cobol85Parser.EXTEND)
		 		setState(1219)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break

		 	case Cobol85Parser.CODEPAGE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1220)
		 		try match(Cobol85Parser.CODEPAGE)
		 		setState(1221)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(1222)
		 		try literal()
		 		setState(1223)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break

		 	case Cobol85Parser.DBCS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1225)
		 		try match(Cobol85Parser.DBCS)

		 		break

		 	case Cobol85Parser.LIB:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1226)
		 		try match(Cobol85Parser.LIB)

		 		break

		 	case Cobol85Parser.NOSEQ:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1227)
		 		try match(Cobol85Parser.NOSEQ)

		 		break

		 	case Cobol85Parser.NOSTDTRUNC:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1228)
		 		try match(Cobol85Parser.NOSTDTRUNC)

		 		break

		 	case Cobol85Parser.OPTIMIZE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1229)
		 		try match(Cobol85Parser.OPTIMIZE)
		 		setState(1230)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(1231)
		 		try match(Cobol85Parser.FULL)
		 		setState(1232)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break

		 	case Cobol85Parser.XOPTS:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1233)
		 		try match(Cobol85Parser.XOPTS)
		 		setState(1234)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(1236) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(1235)
		 			try compilerSubOption()


		 			setState(1238); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.APOST
		 		          testSet = testSet || _la == Cobol85Parser.SP
		 		      return testSet
		 		 }())
		 		setState(1240)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CompilerSubOptionContext:ParserRuleContext {
		open func SP() -> TerminalNode? { return getToken(Cobol85Parser.SP, 0) }
		open func APOST() -> TerminalNode? { return getToken(Cobol85Parser.APOST, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_compilerSubOption }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCompilerSubOption(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCompilerSubOption(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCompilerSubOption(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCompilerSubOption(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilerSubOption() throws -> CompilerSubOptionContext {
		var _localctx: CompilerSubOptionContext = CompilerSubOptionContext(_ctx, getState())
		try enterRule(_localctx, 12, Cobol85Parser.RULE_compilerSubOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1244)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.APOST
		 	          testSet = testSet || _la == Cobol85Parser.SP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdentificationDivisionContext:ParserRuleContext {
		open func DIVISION() -> TerminalNode? { return getToken(Cobol85Parser.DIVISION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func programIdParagraph() -> ProgramIdParagraphContext? {
			return getRuleContext(ProgramIdParagraphContext.self,0)
		}
		open func IDENTIFICATION() -> TerminalNode? { return getToken(Cobol85Parser.IDENTIFICATION, 0) }
		open func ID() -> TerminalNode? { return getToken(Cobol85Parser.ID, 0) }
		open func identificationDivisionBody() -> Array<IdentificationDivisionBodyContext> {
			return getRuleContexts(IdentificationDivisionBodyContext.self)
		}
		open func identificationDivisionBody(_ i: Int) -> IdentificationDivisionBodyContext? {
			return getRuleContext(IdentificationDivisionBodyContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_identificationDivision }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIdentificationDivision(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIdentificationDivision(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIdentificationDivision(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIdentificationDivision(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func identificationDivision() throws -> IdentificationDivisionContext {
		var _localctx: IdentificationDivisionContext = IdentificationDivisionContext(_ctx, getState())
		try enterRule(_localctx, 14, Cobol85Parser.RULE_identificationDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1246)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ID || _la == Cobol85Parser.IDENTIFICATION
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1247)
		 	try match(Cobol85Parser.DIVISION)
		 	setState(1248)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1249)
		 	try programIdParagraph()
		 	setState(1253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.AUTHOR
		 	          testSet = testSet || _la == Cobol85Parser.DATE_COMPILED || _la == Cobol85Parser.DATE_WRITTEN
		 	          testSet = testSet || _la == Cobol85Parser.INSTALLATION
		 	          testSet = testSet || _la == Cobol85Parser.REMARKS || _la == Cobol85Parser.SECURITY
		 	      return testSet
		 	 }()) {
		 		setState(1250)
		 		try identificationDivisionBody()


		 		setState(1255)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdentificationDivisionBodyContext:ParserRuleContext {
		open func authorParagraph() -> AuthorParagraphContext? {
			return getRuleContext(AuthorParagraphContext.self,0)
		}
		open func installationParagraph() -> InstallationParagraphContext? {
			return getRuleContext(InstallationParagraphContext.self,0)
		}
		open func dateWrittenParagraph() -> DateWrittenParagraphContext? {
			return getRuleContext(DateWrittenParagraphContext.self,0)
		}
		open func dateCompiledParagraph() -> DateCompiledParagraphContext? {
			return getRuleContext(DateCompiledParagraphContext.self,0)
		}
		open func securityParagraph() -> SecurityParagraphContext? {
			return getRuleContext(SecurityParagraphContext.self,0)
		}
		open func remarksParagraph() -> RemarksParagraphContext? {
			return getRuleContext(RemarksParagraphContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_identificationDivisionBody }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIdentificationDivisionBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIdentificationDivisionBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIdentificationDivisionBody(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIdentificationDivisionBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func identificationDivisionBody() throws -> IdentificationDivisionBodyContext {
		var _localctx: IdentificationDivisionBodyContext = IdentificationDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 16, Cobol85Parser.RULE_identificationDivisionBody)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1262)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.AUTHOR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1256)
		 		try authorParagraph()

		 		break

		 	case Cobol85Parser.INSTALLATION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1257)
		 		try installationParagraph()

		 		break

		 	case Cobol85Parser.DATE_WRITTEN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1258)
		 		try dateWrittenParagraph()

		 		break

		 	case Cobol85Parser.DATE_COMPILED:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1259)
		 		try dateCompiledParagraph()

		 		break

		 	case Cobol85Parser.SECURITY:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1260)
		 		try securityParagraph()

		 		break

		 	case Cobol85Parser.REMARKS:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1261)
		 		try remarksParagraph()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProgramIdParagraphContext:ParserRuleContext {
		open func PROGRAM_ID() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM_ID, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func programName() -> ProgramNameContext? {
			return getRuleContext(ProgramNameContext.self,0)
		}
		open func COMMON() -> TerminalNode? { return getToken(Cobol85Parser.COMMON, 0) }
		open func INITIAL() -> TerminalNode? { return getToken(Cobol85Parser.INITIAL, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(Cobol85Parser.LIBRARY, 0) }
		open func DEFINITION() -> TerminalNode? { return getToken(Cobol85Parser.DEFINITION, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func PROGRAM() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_programIdParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProgramIdParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProgramIdParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProgramIdParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProgramIdParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func programIdParagraph() throws -> ProgramIdParagraphContext {
		var _localctx: ProgramIdParagraphContext = ProgramIdParagraphContext(_ctx, getState())
		try enterRule(_localctx, 18, Cobol85Parser.RULE_programIdParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1264)
		 	try match(Cobol85Parser.PROGRAM_ID)
		 	setState(1265)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1266)
		 	try programName()
		 	setState(1274)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COMMON || _la == Cobol85Parser.DEFINITION
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.INITIAL,Cobol85Parser.IS,Cobol85Parser.LIBRARY]
		 	              return  Utils.testBitLeftShiftArray(testArray, 246)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(1268)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1267)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(1270)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.COMMON || _la == Cobol85Parser.DEFINITION
		 		          testSet = testSet || _la == Cobol85Parser.INITIAL || _la == Cobol85Parser.LIBRARY
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(1272)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.PROGRAM
		 		      return testSet
		 		 }()) {
		 			setState(1271)
		 			try match(Cobol85Parser.PROGRAM)

		 		}


		 	}

		 	setState(1276)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AuthorParagraphContext:ParserRuleContext {
		open func AUTHOR() -> TerminalNode? { return getToken(Cobol85Parser.AUTHOR, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_authorParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAuthorParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAuthorParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAuthorParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAuthorParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func authorParagraph() throws -> AuthorParagraphContext {
		var _localctx: AuthorParagraphContext = AuthorParagraphContext(_ctx, getState())
		try enterRule(_localctx, 20, Cobol85Parser.RULE_authorParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1278)
		 	try match(Cobol85Parser.AUTHOR)
		 	setState(1279)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1280)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InstallationParagraphContext:ParserRuleContext {
		open func INSTALLATION() -> TerminalNode? { return getToken(Cobol85Parser.INSTALLATION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_installationParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInstallationParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInstallationParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInstallationParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInstallationParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func installationParagraph() throws -> InstallationParagraphContext {
		var _localctx: InstallationParagraphContext = InstallationParagraphContext(_ctx, getState())
		try enterRule(_localctx, 22, Cobol85Parser.RULE_installationParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1283)
		 	try match(Cobol85Parser.INSTALLATION)
		 	setState(1284)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1286)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1285)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DateWrittenParagraphContext:ParserRuleContext {
		open func DATE_WRITTEN() -> TerminalNode? { return getToken(Cobol85Parser.DATE_WRITTEN, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dateWrittenParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDateWrittenParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDateWrittenParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDateWrittenParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDateWrittenParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dateWrittenParagraph() throws -> DateWrittenParagraphContext {
		var _localctx: DateWrittenParagraphContext = DateWrittenParagraphContext(_ctx, getState())
		try enterRule(_localctx, 24, Cobol85Parser.RULE_dateWrittenParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1288)
		 	try match(Cobol85Parser.DATE_WRITTEN)
		 	setState(1289)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1291)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1290)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DateCompiledParagraphContext:ParserRuleContext {
		open func DATE_COMPILED() -> TerminalNode? { return getToken(Cobol85Parser.DATE_COMPILED, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dateCompiledParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDateCompiledParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDateCompiledParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDateCompiledParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDateCompiledParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dateCompiledParagraph() throws -> DateCompiledParagraphContext {
		var _localctx: DateCompiledParagraphContext = DateCompiledParagraphContext(_ctx, getState())
		try enterRule(_localctx, 26, Cobol85Parser.RULE_dateCompiledParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1293)
		 	try match(Cobol85Parser.DATE_COMPILED)
		 	setState(1294)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1296)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1295)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SecurityParagraphContext:ParserRuleContext {
		open func SECURITY() -> TerminalNode? { return getToken(Cobol85Parser.SECURITY, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_securityParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSecurityParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSecurityParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSecurityParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSecurityParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func securityParagraph() throws -> SecurityParagraphContext {
		var _localctx: SecurityParagraphContext = SecurityParagraphContext(_ctx, getState())
		try enterRule(_localctx, 28, Cobol85Parser.RULE_securityParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1298)
		 	try match(Cobol85Parser.SECURITY)
		 	setState(1299)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1301)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1300)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RemarksParagraphContext:ParserRuleContext {
		open func REMARKS() -> TerminalNode? { return getToken(Cobol85Parser.REMARKS, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func commentEntry() -> CommentEntryContext? {
			return getRuleContext(CommentEntryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_remarksParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRemarksParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRemarksParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRemarksParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRemarksParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func remarksParagraph() throws -> RemarksParagraphContext {
		var _localctx: RemarksParagraphContext = RemarksParagraphContext(_ctx, getState())
		try enterRule(_localctx, 30, Cobol85Parser.RULE_remarksParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1303)
		 	try match(Cobol85Parser.REMARKS)
		 	setState(1304)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1306)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }()) {
		 		setState(1305)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnvironmentDivisionContext:ParserRuleContext {
		open func ENVIRONMENT() -> TerminalNode? { return getToken(Cobol85Parser.ENVIRONMENT, 0) }
		open func DIVISION() -> TerminalNode? { return getToken(Cobol85Parser.DIVISION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func environmentDivisionBody() -> Array<EnvironmentDivisionBodyContext> {
			return getRuleContexts(EnvironmentDivisionBodyContext.self)
		}
		open func environmentDivisionBody(_ i: Int) -> EnvironmentDivisionBodyContext? {
			return getRuleContext(EnvironmentDivisionBodyContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_environmentDivision }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnvironmentDivision(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnvironmentDivision(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnvironmentDivision(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnvironmentDivision(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func environmentDivision() throws -> EnvironmentDivisionContext {
		var _localctx: EnvironmentDivisionContext = EnvironmentDivisionContext(_ctx, getState())
		try enterRule(_localctx, 32, Cobol85Parser.RULE_environmentDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1308)
		 	try match(Cobol85Parser.ENVIRONMENT)
		 	setState(1309)
		 	try match(Cobol85Parser.DIVISION)
		 	setState(1310)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1314)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CONFIGURATION
		 	          testSet = testSet || _la == Cobol85Parser.INPUT_OUTPUT
		 	          testSet = testSet || _la == Cobol85Parser.SPECIAL_NAMES
		 	      return testSet
		 	 }()) {
		 		setState(1311)
		 		try environmentDivisionBody()


		 		setState(1316)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnvironmentDivisionBodyContext:ParserRuleContext {
		open func configurationSection() -> ConfigurationSectionContext? {
			return getRuleContext(ConfigurationSectionContext.self,0)
		}
		open func specialNamesParagraph() -> SpecialNamesParagraphContext? {
			return getRuleContext(SpecialNamesParagraphContext.self,0)
		}
		open func inputOutputSection() -> InputOutputSectionContext? {
			return getRuleContext(InputOutputSectionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_environmentDivisionBody }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnvironmentDivisionBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnvironmentDivisionBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnvironmentDivisionBody(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnvironmentDivisionBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func environmentDivisionBody() throws -> EnvironmentDivisionBodyContext {
		var _localctx: EnvironmentDivisionBodyContext = EnvironmentDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 34, Cobol85Parser.RULE_environmentDivisionBody)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1320)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.CONFIGURATION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1317)
		 		try configurationSection()

		 		break

		 	case Cobol85Parser.SPECIAL_NAMES:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1318)
		 		try specialNamesParagraph()

		 		break

		 	case Cobol85Parser.INPUT_OUTPUT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1319)
		 		try inputOutputSection()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConfigurationSectionContext:ParserRuleContext {
		open func CONFIGURATION() -> TerminalNode? { return getToken(Cobol85Parser.CONFIGURATION, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func configurationSectionParagraph() -> Array<ConfigurationSectionParagraphContext> {
			return getRuleContexts(ConfigurationSectionParagraphContext.self)
		}
		open func configurationSectionParagraph(_ i: Int) -> ConfigurationSectionParagraphContext? {
			return getRuleContext(ConfigurationSectionParagraphContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_configurationSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterConfigurationSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitConfigurationSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitConfigurationSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitConfigurationSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func configurationSection() throws -> ConfigurationSectionContext {
		var _localctx: ConfigurationSectionContext = ConfigurationSectionContext(_ctx, getState())
		try enterRule(_localctx, 36, Cobol85Parser.RULE_configurationSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1322)
		 	try match(Cobol85Parser.CONFIGURATION)
		 	setState(1323)
		 	try match(Cobol85Parser.SECTION)
		 	setState(1324)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1328)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.OBJECT_COMPUTER
		 	          testSet = testSet || _la == Cobol85Parser.SOURCE_COMPUTER
		 	      return testSet
		 	 }()) {
		 		setState(1325)
		 		try configurationSectionParagraph()


		 		setState(1330)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConfigurationSectionParagraphContext:ParserRuleContext {
		open func sourceComputerParagraph() -> SourceComputerParagraphContext? {
			return getRuleContext(SourceComputerParagraphContext.self,0)
		}
		open func objectComputerParagraph() -> ObjectComputerParagraphContext? {
			return getRuleContext(ObjectComputerParagraphContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_configurationSectionParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterConfigurationSectionParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitConfigurationSectionParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitConfigurationSectionParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitConfigurationSectionParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func configurationSectionParagraph() throws -> ConfigurationSectionParagraphContext {
		var _localctx: ConfigurationSectionParagraphContext = ConfigurationSectionParagraphContext(_ctx, getState())
		try enterRule(_localctx, 38, Cobol85Parser.RULE_configurationSectionParagraph)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1333)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.SOURCE_COMPUTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1331)
		 		try sourceComputerParagraph()

		 		break

		 	case Cobol85Parser.OBJECT_COMPUTER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1332)
		 		try objectComputerParagraph()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SourceComputerParagraphContext:ParserRuleContext {
		open func SOURCE_COMPUTER() -> TerminalNode? { return getToken(Cobol85Parser.SOURCE_COMPUTER, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func computerName() -> ComputerNameContext? {
			return getRuleContext(ComputerNameContext.self,0)
		}
		open func DEBUGGING() -> TerminalNode? { return getToken(Cobol85Parser.DEBUGGING, 0) }
		open func MODE() -> TerminalNode? { return getToken(Cobol85Parser.MODE, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sourceComputerParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSourceComputerParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSourceComputerParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSourceComputerParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSourceComputerParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sourceComputerParagraph() throws -> SourceComputerParagraphContext {
		var _localctx: SourceComputerParagraphContext = SourceComputerParagraphContext(_ctx, getState())
		try enterRule(_localctx, 40, Cobol85Parser.RULE_sourceComputerParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1335)
		 	try match(Cobol85Parser.SOURCE_COMPUTER)
		 	setState(1336)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1337)
		 	try computerName()
		 	setState(1343)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DEBUGGING
		 	          testSet = testSet || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(1339)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(1338)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(1341)
		 		try match(Cobol85Parser.DEBUGGING)
		 		setState(1342)
		 		try match(Cobol85Parser.MODE)

		 	}

		 	setState(1345)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ObjectComputerParagraphContext:ParserRuleContext {
		open func OBJECT_COMPUTER() -> TerminalNode? { return getToken(Cobol85Parser.OBJECT_COMPUTER, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func computerName() -> ComputerNameContext? {
			return getRuleContext(ComputerNameContext.self,0)
		}
		open func objectComputerClause() -> Array<ObjectComputerClauseContext> {
			return getRuleContexts(ObjectComputerClauseContext.self)
		}
		open func objectComputerClause(_ i: Int) -> ObjectComputerClauseContext? {
			return getRuleContext(ObjectComputerClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_objectComputerParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterObjectComputerParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitObjectComputerParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitObjectComputerParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitObjectComputerParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func objectComputerParagraph() throws -> ObjectComputerParagraphContext {
		var _localctx: ObjectComputerParagraphContext = ObjectComputerParagraphContext(_ctx, getState())
		try enterRule(_localctx, 42, Cobol85Parser.RULE_objectComputerParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1347)
		 	try match(Cobol85Parser.OBJECT_COMPUTER)
		 	setState(1348)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1349)
		 	try computerName()
		 	setState(1353)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CHARACTER || _la == Cobol85Parser.COLLATING
		 	          testSet = testSet || _la == Cobol85Parser.DISK
		 	          testSet = testSet || _la == Cobol85Parser.MEMORY
		 	          testSet = testSet || _la == Cobol85Parser.PROGRAM || _la == Cobol85Parser.SEGMENT_LIMIT
		 	          testSet = testSet || _la == Cobol85Parser.SEQUENCE
		 	      return testSet
		 	 }()) {
		 		setState(1350)
		 		try objectComputerClause()


		 		setState(1355)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1356)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ObjectComputerClauseContext:ParserRuleContext {
		open func memorySizeClause() -> MemorySizeClauseContext? {
			return getRuleContext(MemorySizeClauseContext.self,0)
		}
		open func diskSizeClause() -> DiskSizeClauseContext? {
			return getRuleContext(DiskSizeClauseContext.self,0)
		}
		open func collatingSequenceClause() -> CollatingSequenceClauseContext? {
			return getRuleContext(CollatingSequenceClauseContext.self,0)
		}
		open func segmentLimitClause() -> SegmentLimitClauseContext? {
			return getRuleContext(SegmentLimitClauseContext.self,0)
		}
		open func characterSetClause() -> CharacterSetClauseContext? {
			return getRuleContext(CharacterSetClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_objectComputerClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterObjectComputerClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitObjectComputerClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitObjectComputerClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitObjectComputerClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func objectComputerClause() throws -> ObjectComputerClauseContext {
		var _localctx: ObjectComputerClauseContext = ObjectComputerClauseContext(_ctx, getState())
		try enterRule(_localctx, 44, Cobol85Parser.RULE_objectComputerClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1363)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.MEMORY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1358)
		 		try memorySizeClause()

		 		break

		 	case Cobol85Parser.DISK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1359)
		 		try diskSizeClause()

		 		break
		 	case Cobol85Parser.COLLATING:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.SEQUENCE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1360)
		 		try collatingSequenceClause()

		 		break

		 	case Cobol85Parser.SEGMENT_LIMIT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1361)
		 		try segmentLimitClause()

		 		break

		 	case Cobol85Parser.CHARACTER:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1362)
		 		try characterSetClause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MemorySizeClauseContext:ParserRuleContext {
		open func MEMORY() -> TerminalNode? { return getToken(Cobol85Parser.MEMORY, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func WORDS() -> TerminalNode? { return getToken(Cobol85Parser.WORDS, 0) }
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open func MODULES() -> TerminalNode? { return getToken(Cobol85Parser.MODULES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_memorySizeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMemorySizeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMemorySizeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMemorySizeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMemorySizeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func memorySizeClause() throws -> MemorySizeClauseContext {
		var _localctx: MemorySizeClauseContext = MemorySizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 46, Cobol85Parser.RULE_memorySizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1365)
		 	try match(Cobol85Parser.MEMORY)
		 	setState(1367)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIZE
		 	      return testSet
		 	 }()) {
		 		setState(1366)
		 		try match(Cobol85Parser.SIZE)

		 	}

		 	setState(1371)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(1369)
		 		try integerLiteral()

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(1370)
		 		try cobolWord()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1374)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 	          testSet = testSet || _la == Cobol85Parser.MODULES
		 	          testSet = testSet || _la == Cobol85Parser.WORDS
		 	      return testSet
		 	 }()) {
		 		setState(1373)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 		          testSet = testSet || _la == Cobol85Parser.MODULES
		 		          testSet = testSet || _la == Cobol85Parser.WORDS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DiskSizeClauseContext:ParserRuleContext {
		open func DISK() -> TerminalNode? { return getToken(Cobol85Parser.DISK, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func WORDS() -> TerminalNode? { return getToken(Cobol85Parser.WORDS, 0) }
		open func MODULES() -> TerminalNode? { return getToken(Cobol85Parser.MODULES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_diskSizeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDiskSizeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDiskSizeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDiskSizeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDiskSizeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func diskSizeClause() throws -> DiskSizeClauseContext {
		var _localctx: DiskSizeClauseContext = DiskSizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 48, Cobol85Parser.RULE_diskSizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1376)
		 	try match(Cobol85Parser.DISK)
		 	setState(1378)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIZE
		 	      return testSet
		 	 }()) {
		 		setState(1377)
		 		try match(Cobol85Parser.SIZE)

		 	}

		 	setState(1381)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1380)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1385)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(1383)
		 		try integerLiteral()

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(1384)
		 		try cobolWord()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1388)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.MODULES
		 	          testSet = testSet || _la == Cobol85Parser.WORDS
		 	      return testSet
		 	 }()) {
		 		setState(1387)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.MODULES
		 		          testSet = testSet || _la == Cobol85Parser.WORDS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CollatingSequenceClauseContext:ParserRuleContext {
		open func SEQUENCE() -> TerminalNode? { return getToken(Cobol85Parser.SEQUENCE, 0) }
		open func PROGRAM() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM, 0) }
		open func COLLATING() -> TerminalNode? { return getToken(Cobol85Parser.COLLATING, 0) }
		open func collatingSequenceClauseAlphanumeric() -> CollatingSequenceClauseAlphanumericContext? {
			return getRuleContext(CollatingSequenceClauseAlphanumericContext.self,0)
		}
		open func collatingSequenceClauseNational() -> CollatingSequenceClauseNationalContext? {
			return getRuleContext(CollatingSequenceClauseNationalContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetName() -> Array<AlphabetNameContext> {
			return getRuleContexts(AlphabetNameContext.self)
		}
		open func alphabetName(_ i: Int) -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_collatingSequenceClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCollatingSequenceClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCollatingSequenceClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCollatingSequenceClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCollatingSequenceClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collatingSequenceClause() throws -> CollatingSequenceClauseContext {
		var _localctx: CollatingSequenceClauseContext = CollatingSequenceClauseContext(_ctx, getState())
		try enterRule(_localctx, 50, Cobol85Parser.RULE_collatingSequenceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1391)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROGRAM
		 	      return testSet
		 	 }()) {
		 		setState(1390)
		 		try match(Cobol85Parser.PROGRAM)

		 	}

		 	setState(1394)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COLLATING
		 	      return testSet
		 	 }()) {
		 		setState(1393)
		 		try match(Cobol85Parser.COLLATING)

		 	}

		 	setState(1396)
		 	try match(Cobol85Parser.SEQUENCE)

		 	setState(1398)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1397)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1401); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1400)
		 			try alphabetName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1403); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,40,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	setState(1406)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,41,_ctx)) {
		 	case 1:
		 		setState(1405)
		 		try collatingSequenceClauseAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(1409)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FOR
		 	          testSet = testSet || _la == Cobol85Parser.NATIONAL
		 	      return testSet
		 	 }()) {
		 		setState(1408)
		 		try collatingSequenceClauseNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CollatingSequenceClauseAlphanumericContext:ParserRuleContext {
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_collatingSequenceClauseAlphanumeric }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCollatingSequenceClauseAlphanumeric(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCollatingSequenceClauseAlphanumeric(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCollatingSequenceClauseAlphanumeric(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCollatingSequenceClauseAlphanumeric(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collatingSequenceClauseAlphanumeric() throws -> CollatingSequenceClauseAlphanumericContext {
		var _localctx: CollatingSequenceClauseAlphanumericContext = CollatingSequenceClauseAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 52, Cobol85Parser.RULE_collatingSequenceClauseAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1412)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1411)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(1414)
		 	try match(Cobol85Parser.ALPHANUMERIC)
		 	setState(1416)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1415)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1418)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CollatingSequenceClauseNationalContext:ParserRuleContext {
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_collatingSequenceClauseNational }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCollatingSequenceClauseNational(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCollatingSequenceClauseNational(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCollatingSequenceClauseNational(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCollatingSequenceClauseNational(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collatingSequenceClauseNational() throws -> CollatingSequenceClauseNationalContext {
		var _localctx: CollatingSequenceClauseNationalContext = CollatingSequenceClauseNationalContext(_ctx, getState())
		try enterRule(_localctx, 54, Cobol85Parser.RULE_collatingSequenceClauseNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1421)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1420)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(1423)
		 	try match(Cobol85Parser.NATIONAL)
		 	setState(1425)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1424)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1427)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SegmentLimitClauseContext:ParserRuleContext {
		open func SEGMENT_LIMIT() -> TerminalNode? { return getToken(Cobol85Parser.SEGMENT_LIMIT, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_segmentLimitClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSegmentLimitClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSegmentLimitClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSegmentLimitClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSegmentLimitClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func segmentLimitClause() throws -> SegmentLimitClauseContext {
		var _localctx: SegmentLimitClauseContext = SegmentLimitClauseContext(_ctx, getState())
		try enterRule(_localctx, 56, Cobol85Parser.RULE_segmentLimitClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1429)
		 	try match(Cobol85Parser.SEGMENT_LIMIT)
		 	setState(1431)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1430)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1433)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CharacterSetClauseContext:ParserRuleContext {
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open func SET() -> TerminalNode? { return getToken(Cobol85Parser.SET, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_characterSetClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCharacterSetClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCharacterSetClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCharacterSetClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCharacterSetClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func characterSetClause() throws -> CharacterSetClauseContext {
		var _localctx: CharacterSetClauseContext = CharacterSetClauseContext(_ctx, getState())
		try enterRule(_localctx, 58, Cobol85Parser.RULE_characterSetClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1435)
		 	try match(Cobol85Parser.CHARACTER)
		 	setState(1436)
		 	try match(Cobol85Parser.SET)
		 	setState(1437)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SpecialNamesParagraphContext:ParserRuleContext {
		open func SPECIAL_NAMES() -> TerminalNode? { return getToken(Cobol85Parser.SPECIAL_NAMES, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func specialNameClause() -> Array<SpecialNameClauseContext> {
			return getRuleContexts(SpecialNameClauseContext.self)
		}
		open func specialNameClause(_ i: Int) -> SpecialNameClauseContext? {
			return getRuleContext(SpecialNameClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_specialNamesParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSpecialNamesParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSpecialNamesParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSpecialNamesParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSpecialNamesParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func specialNamesParagraph() throws -> SpecialNamesParagraphContext {
		var _localctx: SpecialNamesParagraphContext = SpecialNamesParagraphContext(_ctx, getState())
		try enterRule(_localctx, 60, Cobol85Parser.RULE_specialNamesParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1439)
		 	try match(Cobol85Parser.SPECIAL_NAMES)
		 	setState(1440)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1448)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,49,_ctx)) {
		 	case 1:
		 		setState(1442) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(1441)
		 			try specialNameClause()


		 			setState(1444); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ALPHABET,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLASS,Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURRENCY,Cobol85Parser.CURSOR,Cobol85Parser.DECIMAL_POINT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION,Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 131)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT,Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER]
		 		              return  Utils.testBitLeftShiftArray(testArray, 197)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD,Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME]
		 		              return  Utils.testBitLeftShiftArray(testArray, 261)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ODT,Cobol85Parser.OFF,Cobol85Parser.ON,Cobol85Parser.OPTIMIZE,Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF]
		 		              return  Utils.testBitLeftShiftArray(testArray, 326)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REMOVE,Cobol85Parser.REQUIRED,Cobol85Parser.RESERVE,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 395)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.SYMBOLIC,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 		      return testSet
		 		 }())
		 		setState(1446)
		 		try match(Cobol85Parser.DOT_FS)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SpecialNameClauseContext:ParserRuleContext {
		open func channelClause() -> ChannelClauseContext? {
			return getRuleContext(ChannelClauseContext.self,0)
		}
		open func odtClause() -> OdtClauseContext? {
			return getRuleContext(OdtClauseContext.self,0)
		}
		open func alphabetClause() -> AlphabetClauseContext? {
			return getRuleContext(AlphabetClauseContext.self,0)
		}
		open func classClause() -> ClassClauseContext? {
			return getRuleContext(ClassClauseContext.self,0)
		}
		open func currencySignClause() -> CurrencySignClauseContext? {
			return getRuleContext(CurrencySignClauseContext.self,0)
		}
		open func decimalPointClause() -> DecimalPointClauseContext? {
			return getRuleContext(DecimalPointClauseContext.self,0)
		}
		open func symbolicCharactersClause() -> SymbolicCharactersClauseContext? {
			return getRuleContext(SymbolicCharactersClauseContext.self,0)
		}
		open func environmentSwitchNameClause() -> EnvironmentSwitchNameClauseContext? {
			return getRuleContext(EnvironmentSwitchNameClauseContext.self,0)
		}
		open func defaultDisplaySignClause() -> DefaultDisplaySignClauseContext? {
			return getRuleContext(DefaultDisplaySignClauseContext.self,0)
		}
		open func defaultComputationalSignClause() -> DefaultComputationalSignClauseContext? {
			return getRuleContext(DefaultComputationalSignClauseContext.self,0)
		}
		open func reserveNetworkClause() -> ReserveNetworkClauseContext? {
			return getRuleContext(ReserveNetworkClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_specialNameClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSpecialNameClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSpecialNameClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSpecialNameClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSpecialNameClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func specialNameClause() throws -> SpecialNameClauseContext {
		var _localctx: SpecialNameClauseContext = SpecialNameClauseContext(_ctx, getState())
		try enterRule(_localctx, 62, Cobol85Parser.RULE_specialNameClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1461)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,50, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1450)
		 		try channelClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1451)
		 		try odtClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1452)
		 		try alphabetClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1453)
		 		try classClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1454)
		 		try currencySignClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1455)
		 		try decimalPointClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1456)
		 		try symbolicCharactersClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1457)
		 		try environmentSwitchNameClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1458)
		 		try defaultDisplaySignClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1459)
		 		try defaultComputationalSignClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1460)
		 		try reserveNetworkClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetClauseContext:ParserRuleContext {
		open func alphabetClauseFormat1() -> AlphabetClauseFormat1Context? {
			return getRuleContext(AlphabetClauseFormat1Context.self,0)
		}
		open func alphabetClauseFormat2() -> AlphabetClauseFormat2Context? {
			return getRuleContext(AlphabetClauseFormat2Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetClause() throws -> AlphabetClauseContext {
		var _localctx: AlphabetClauseContext = AlphabetClauseContext(_ctx, getState())
		try enterRule(_localctx, 64, Cobol85Parser.RULE_alphabetClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1465)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,51, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1463)
		 		try alphabetClauseFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1464)
		 		try alphabetClauseFormat2()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetClauseFormat1Context:ParserRuleContext {
		open func ALPHABET() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABET, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func EBCDIC() -> TerminalNode? { return getToken(Cobol85Parser.EBCDIC, 0) }
		open func ASCII() -> TerminalNode? { return getToken(Cobol85Parser.ASCII, 0) }
		open func STANDARD_1() -> TerminalNode? { return getToken(Cobol85Parser.STANDARD_1, 0) }
		open func STANDARD_2() -> TerminalNode? { return getToken(Cobol85Parser.STANDARD_2, 0) }
		open func NATIVE() -> TerminalNode? { return getToken(Cobol85Parser.NATIVE, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetLiterals() -> Array<AlphabetLiteralsContext> {
			return getRuleContexts(AlphabetLiteralsContext.self)
		}
		open func alphabetLiterals(_ i: Int) -> AlphabetLiteralsContext? {
			return getRuleContext(AlphabetLiteralsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetClauseFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetClauseFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetClauseFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetClauseFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetClauseFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetClauseFormat1() throws -> AlphabetClauseFormat1Context {
		var _localctx: AlphabetClauseFormat1Context = AlphabetClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 66, Cobol85Parser.RULE_alphabetClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1467)
		 	try match(Cobol85Parser.ALPHABET)
		 	setState(1468)
		 	try alphabetName()
		 	setState(1471)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1469)
		 		try match(Cobol85Parser.FOR)
		 		setState(1470)
		 		try match(Cobol85Parser.ALPHANUMERIC)

		 	}

		 	setState(1474)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1473)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1487)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,55, _ctx)) {
		 	case 1:
		 		setState(1476)
		 		try match(Cobol85Parser.EBCDIC)

		 		break
		 	case 2:
		 		setState(1477)
		 		try match(Cobol85Parser.ASCII)

		 		break
		 	case 3:
		 		setState(1478)
		 		try match(Cobol85Parser.STANDARD_1)

		 		break
		 	case 4:
		 		setState(1479)
		 		try match(Cobol85Parser.STANDARD_2)

		 		break
		 	case 5:
		 		setState(1480)
		 		try match(Cobol85Parser.NATIVE)

		 		break
		 	case 6:
		 		setState(1481)
		 		try cobolWord()

		 		break
		 	case 7:
		 		setState(1483); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(1482)
		 				try alphabetLiterals()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(1485); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,54,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetLiteralsContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func alphabetThrough() -> AlphabetThroughContext? {
			return getRuleContext(AlphabetThroughContext.self,0)
		}
		open func alphabetAlso() -> Array<AlphabetAlsoContext> {
			return getRuleContexts(AlphabetAlsoContext.self)
		}
		open func alphabetAlso(_ i: Int) -> AlphabetAlsoContext? {
			return getRuleContext(AlphabetAlsoContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetLiterals }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetLiterals(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetLiterals(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetLiterals(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetLiterals(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetLiterals() throws -> AlphabetLiteralsContext {
		var _localctx: AlphabetLiteralsContext = AlphabetLiteralsContext(_ctx, getState())
		try enterRule(_localctx, 68, Cobol85Parser.RULE_alphabetLiterals)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1489)
		 	try literal()
		 	setState(1496)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.THROUGH:fallthrough
		 	case Cobol85Parser.THRU:
		 	 	setState(1490)
		 	 	try alphabetThrough()

		 		break

		 	case Cobol85Parser.ALSO:
		 	 	setState(1492) 
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	repeat {
		 	 		setState(1491)
		 	 		try alphabetAlso()


		 	 		setState(1494); 
		 	 		try _errHandler.sync(self)
		 	 		_la = try _input.LA(1)
		 	 	} while (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.ALSO
		 	 	      return testSet
		 	 	 }())

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.ALL:fallthrough
		 	case Cobol85Parser.ALPHABET:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLASS:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURRENCY:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DECIMAL_POINT:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FALSE:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.HIGH_VALUE:fallthrough
		 	case Cobol85Parser.HIGH_VALUES:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.LOW_VALUE:fallthrough
		 	case Cobol85Parser.LOW_VALUES:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NULL:fallthrough
		 	case Cobol85Parser.NULLS:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OFF:fallthrough
		 	case Cobol85Parser.ON:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.QUOTE:fallthrough
		 	case Cobol85Parser.QUOTES:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.RESERVE:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SPACE:fallthrough
		 	case Cobol85Parser.SPACES:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.SYMBOLIC:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUE:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.ZEROS:fallthrough
		 	case Cobol85Parser.ZEROES:fallthrough
		 	case Cobol85Parser.DOT_FS:fallthrough
		 	case Cobol85Parser.NONNUMERICLITERAL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.NUMERICLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetThroughContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetThrough() throws -> AlphabetThroughContext {
		var _localctx: AlphabetThroughContext = AlphabetThroughContext(_ctx, getState())
		try enterRule(_localctx, 70, Cobol85Parser.RULE_alphabetThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1498)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1499)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetAlsoContext:ParserRuleContext {
		open func ALSO() -> TerminalNode? { return getToken(Cobol85Parser.ALSO, 0) }
		open func literal() -> Array<LiteralContext> {
			return getRuleContexts(LiteralContext.self)
		}
		open func literal(_ i: Int) -> LiteralContext? {
			return getRuleContext(LiteralContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetAlso }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetAlso(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetAlso(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetAlso(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetAlso(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetAlso() throws -> AlphabetAlsoContext {
		var _localctx: AlphabetAlsoContext = AlphabetAlsoContext(_ctx, getState())
		try enterRule(_localctx, 72, Cobol85Parser.RULE_alphabetAlso)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1501)
		 	try match(Cobol85Parser.ALSO)
		 	setState(1503); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1502)
		 			try literal()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1505); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,58,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetClauseFormat2Context:ParserRuleContext {
		open func ALPHABET() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABET, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func NATIVE() -> TerminalNode? { return getToken(Cobol85Parser.NATIVE, 0) }
		open func CCSVERSION() -> TerminalNode? { return getToken(Cobol85Parser.CCSVERSION, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetClauseFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetClauseFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetClauseFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetClauseFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetClauseFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetClauseFormat2() throws -> AlphabetClauseFormat2Context {
		var _localctx: AlphabetClauseFormat2Context = AlphabetClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 74, Cobol85Parser.RULE_alphabetClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1507)
		 	try match(Cobol85Parser.ALPHABET)
		 	setState(1508)
		 	try alphabetName()
		 	setState(1510)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1509)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(1512)
		 	try match(Cobol85Parser.NATIONAL)
		 	setState(1514)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1513)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1519)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NATIVE:
		 		setState(1516)
		 		try match(Cobol85Parser.NATIVE)

		 		break

		 	case Cobol85Parser.CCSVERSION:
		 		setState(1517)
		 		try match(Cobol85Parser.CCSVERSION)
		 		setState(1518)
		 		try literal()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ChannelClauseContext:ParserRuleContext {
		open func CHANNEL() -> TerminalNode? { return getToken(Cobol85Parser.CHANNEL, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_channelClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterChannelClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitChannelClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitChannelClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitChannelClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func channelClause() throws -> ChannelClauseContext {
		var _localctx: ChannelClauseContext = ChannelClauseContext(_ctx, getState())
		try enterRule(_localctx, 76, Cobol85Parser.RULE_channelClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1521)
		 	try match(Cobol85Parser.CHANNEL)
		 	setState(1522)
		 	try integerLiteral()
		 	setState(1524)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1523)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1526)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassClauseContext:ParserRuleContext {
		open func CLASS() -> TerminalNode? { return getToken(Cobol85Parser.CLASS, 0) }
		open func className() -> ClassNameContext? {
			return getRuleContext(ClassNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func classClauseThrough() -> Array<ClassClauseThroughContext> {
			return getRuleContexts(ClassClauseThroughContext.self)
		}
		open func classClauseThrough(_ i: Int) -> ClassClauseThroughContext? {
			return getRuleContext(ClassClauseThroughContext.self,i)
		}
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_classClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func classClause() throws -> ClassClauseContext {
		var _localctx: ClassClauseContext = ClassClauseContext(_ctx, getState())
		try enterRule(_localctx, 78, Cobol85Parser.RULE_classClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1528)
		 	try match(Cobol85Parser.CLASS)
		 	setState(1529)
		 	try className()
		 	setState(1534)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,64,_ctx)) {
		 	case 1:
		 		setState(1531)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FOR
		 		      return testSet
		 		 }()) {
		 			setState(1530)
		 			try match(Cobol85Parser.FOR)

		 		}

		 		setState(1533)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.ALPHANUMERIC
		 		          testSet = testSet || _la == Cobol85Parser.NATIONAL
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1537)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1536)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1540); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1539)
		 			try classClauseThrough()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1542); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,66,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassClauseThroughContext:ParserRuleContext {
		open func classClauseFrom() -> ClassClauseFromContext? {
			return getRuleContext(ClassClauseFromContext.self,0)
		}
		open func classClauseTo() -> ClassClauseToContext? {
			return getRuleContext(ClassClauseToContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_classClauseThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassClauseThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassClauseThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassClauseThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassClauseThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func classClauseThrough() throws -> ClassClauseThroughContext {
		var _localctx: ClassClauseThroughContext = ClassClauseThroughContext(_ctx, getState())
		try enterRule(_localctx, 80, Cobol85Parser.RULE_classClauseThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1544)
		 	try classClauseFrom()
		 	setState(1547)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(1545)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(1546)
		 		try classClauseTo()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassClauseFromContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_classClauseFrom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassClauseFrom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassClauseFrom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassClauseFrom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassClauseFrom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func classClauseFrom() throws -> ClassClauseFromContext {
		var _localctx: ClassClauseFromContext = ClassClauseFromContext(_ctx, getState())
		try enterRule(_localctx, 82, Cobol85Parser.RULE_classClauseFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1551)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,68, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1549)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1550)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassClauseToContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_classClauseTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassClauseTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassClauseTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassClauseTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassClauseTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func classClauseTo() throws -> ClassClauseToContext {
		var _localctx: ClassClauseToContext = ClassClauseToContext(_ctx, getState())
		try enterRule(_localctx, 84, Cobol85Parser.RULE_classClauseTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1555)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,69, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1553)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1554)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CurrencySignClauseContext:ParserRuleContext {
		open func CURRENCY() -> TerminalNode? { return getToken(Cobol85Parser.CURRENCY, 0) }
		open func literal() -> Array<LiteralContext> {
			return getRuleContexts(LiteralContext.self)
		}
		open func literal(_ i: Int) -> LiteralContext? {
			return getRuleContext(LiteralContext.self,i)
		}
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func PICTURE() -> TerminalNode? { return getToken(Cobol85Parser.PICTURE, 0) }
		open func SYMBOL() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOL, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_currencySignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCurrencySignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCurrencySignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCurrencySignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCurrencySignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func currencySignClause() throws -> CurrencySignClauseContext {
		var _localctx: CurrencySignClauseContext = CurrencySignClauseContext(_ctx, getState())
		try enterRule(_localctx, 86, Cobol85Parser.RULE_currencySignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1557)
		 	try match(Cobol85Parser.CURRENCY)
		 	setState(1559)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIGN
		 	      return testSet
		 	 }()) {
		 		setState(1558)
		 		try match(Cobol85Parser.SIGN)

		 	}

		 	setState(1562)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1561)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1564)
		 	try literal()
		 	setState(1571)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.PICTURE
		 	          testSet = testSet || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(1566)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(1565)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(1568)
		 		try match(Cobol85Parser.PICTURE)
		 		setState(1569)
		 		try match(Cobol85Parser.SYMBOL)
		 		setState(1570)
		 		try literal()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DecimalPointClauseContext:ParserRuleContext {
		open func DECIMAL_POINT() -> TerminalNode? { return getToken(Cobol85Parser.DECIMAL_POINT, 0) }
		open func COMMA() -> TerminalNode? { return getToken(Cobol85Parser.COMMA, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_decimalPointClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDecimalPointClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDecimalPointClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDecimalPointClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDecimalPointClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func decimalPointClause() throws -> DecimalPointClauseContext {
		var _localctx: DecimalPointClauseContext = DecimalPointClauseContext(_ctx, getState())
		try enterRule(_localctx, 88, Cobol85Parser.RULE_decimalPointClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1573)
		 	try match(Cobol85Parser.DECIMAL_POINT)
		 	setState(1575)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1574)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1577)
		 	try match(Cobol85Parser.COMMA)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DefaultComputationalSignClauseContext:ParserRuleContext {
		open func DEFAULT() -> TerminalNode? { return getToken(Cobol85Parser.DEFAULT, 0) }
		open func SEPARATE() -> TerminalNode? { return getToken(Cobol85Parser.SEPARATE, 0) }
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func COMPUTATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL, 0) }
		open func COMP() -> TerminalNode? { return getToken(Cobol85Parser.COMP, 0) }
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(Cobol85Parser.TRAILING, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_defaultComputationalSignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDefaultComputationalSignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDefaultComputationalSignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDefaultComputationalSignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDefaultComputationalSignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func defaultComputationalSignClause() throws -> DefaultComputationalSignClauseContext {
		var _localctx: DefaultComputationalSignClauseContext = DefaultComputationalSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 90, Cobol85Parser.RULE_defaultComputationalSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1579)
		 	try match(Cobol85Parser.DEFAULT)
		 	setState(1581)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMP || _la == Cobol85Parser.COMPUTATIONAL
		 	      return testSet
		 	 }()) {
		 		setState(1580)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.COMP || _la == Cobol85Parser.COMPUTATIONAL
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(1587)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIGN
		 	      return testSet
		 	 }()) {
		 		setState(1583)
		 		try match(Cobol85Parser.SIGN)
		 		setState(1585)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1584)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(1590)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEADING
		 	          testSet = testSet || _la == Cobol85Parser.TRAILING
		 	      return testSet
		 	 }()) {
		 		setState(1589)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.LEADING
		 		          testSet = testSet || _la == Cobol85Parser.TRAILING
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(1592)
		 	try match(Cobol85Parser.SEPARATE)
		 	setState(1594)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 	      return testSet
		 	 }()) {
		 		setState(1593)
		 		try match(Cobol85Parser.CHARACTER)

		 	}



		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DefaultDisplaySignClauseContext:ParserRuleContext {
		open func DEFAULT_DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DEFAULT_DISPLAY, 0) }
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(Cobol85Parser.TRAILING, 0) }
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func SEPARATE() -> TerminalNode? { return getToken(Cobol85Parser.SEPARATE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_defaultDisplaySignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDefaultDisplaySignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDefaultDisplaySignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDefaultDisplaySignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDefaultDisplaySignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func defaultDisplaySignClause() throws -> DefaultDisplaySignClauseContext {
		var _localctx: DefaultDisplaySignClauseContext = DefaultDisplaySignClauseContext(_ctx, getState())
		try enterRule(_localctx, 92, Cobol85Parser.RULE_defaultDisplaySignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1596)
		 	try match(Cobol85Parser.DEFAULT_DISPLAY)
		 	setState(1601)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIGN
		 	      return testSet
		 	 }()) {
		 		setState(1597)
		 		try match(Cobol85Parser.SIGN)
		 		setState(1599)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1598)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(1603)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEADING
		 	          testSet = testSet || _la == Cobol85Parser.TRAILING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1608)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SEPARATE
		 	      return testSet
		 	 }()) {
		 		setState(1604)
		 		try match(Cobol85Parser.SEPARATE)
		 		setState(1606)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 		      return testSet
		 		 }()) {
		 			setState(1605)
		 			try match(Cobol85Parser.CHARACTER)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnvironmentSwitchNameClauseContext:ParserRuleContext {
		open func environmentName() -> EnvironmentNameContext? {
			return getRuleContext(EnvironmentNameContext.self,0)
		}
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func environmentSwitchNameSpecialNamesStatusPhrase() -> EnvironmentSwitchNameSpecialNamesStatusPhraseContext? {
			return getRuleContext(EnvironmentSwitchNameSpecialNamesStatusPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_environmentSwitchNameClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnvironmentSwitchNameClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnvironmentSwitchNameClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnvironmentSwitchNameClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnvironmentSwitchNameClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func environmentSwitchNameClause() throws -> EnvironmentSwitchNameClauseContext {
		var _localctx: EnvironmentSwitchNameClauseContext = EnvironmentSwitchNameClauseContext(_ctx, getState())
		try enterRule(_localctx, 94, Cobol85Parser.RULE_environmentSwitchNameClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1619)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1610)
		 		try environmentName()
		 		setState(1612)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1611)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(1614)
		 		try mnemonicName()
		 		setState(1616)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,85,_ctx)) {
		 		case 1:
		 			setState(1615)
		 			try environmentSwitchNameSpecialNamesStatusPhrase()

		 			break
		 		default: break
		 		}

		 		break
		 	case Cobol85Parser.OFF:fallthrough
		 	case Cobol85Parser.ON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1618)
		 		try environmentSwitchNameSpecialNamesStatusPhrase()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnvironmentSwitchNameSpecialNamesStatusPhraseContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func condition() -> Array<ConditionContext> {
			return getRuleContexts(ConditionContext.self)
		}
		open func condition(_ i: Int) -> ConditionContext? {
			return getRuleContext(ConditionContext.self,i)
		}
		open func STATUS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.STATUS) }
		open func STATUS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.STATUS, i)
		}
		open func IS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.IS) }
		open func IS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.IS, i)
		}
		open func OFF() -> TerminalNode? { return getToken(Cobol85Parser.OFF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_environmentSwitchNameSpecialNamesStatusPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func environmentSwitchNameSpecialNamesStatusPhrase() throws -> EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
		var _localctx: EnvironmentSwitchNameSpecialNamesStatusPhraseContext = EnvironmentSwitchNameSpecialNamesStatusPhraseContext(_ctx, getState())
		try enterRule(_localctx, 96, Cobol85Parser.RULE_environmentSwitchNameSpecialNamesStatusPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1657)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ON:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1621)
		 		try match(Cobol85Parser.ON)
		 		setState(1623)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.STATUS
		 		      return testSet
		 		 }()) {
		 			setState(1622)
		 			try match(Cobol85Parser.STATUS)

		 		}

		 		setState(1626)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1625)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(1628)
		 		try condition()
		 		setState(1637)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,91,_ctx)) {
		 		case 1:
		 			setState(1629)
		 			try match(Cobol85Parser.OFF)
		 			setState(1631)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.STATUS
		 			      return testSet
		 			 }()) {
		 				setState(1630)
		 				try match(Cobol85Parser.STATUS)

		 			}

		 			setState(1634)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.IS
		 			      return testSet
		 			 }()) {
		 				setState(1633)
		 				try match(Cobol85Parser.IS)

		 			}

		 			setState(1636)
		 			try condition()

		 			break
		 		default: break
		 		}

		 		break

		 	case Cobol85Parser.OFF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1639)
		 		try match(Cobol85Parser.OFF)
		 		setState(1641)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.STATUS
		 		      return testSet
		 		 }()) {
		 			setState(1640)
		 			try match(Cobol85Parser.STATUS)

		 		}

		 		setState(1644)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1643)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(1646)
		 		try condition()
		 		setState(1655)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,96,_ctx)) {
		 		case 1:
		 			setState(1647)
		 			try match(Cobol85Parser.ON)
		 			setState(1649)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.STATUS
		 			      return testSet
		 			 }()) {
		 				setState(1648)
		 				try match(Cobol85Parser.STATUS)

		 			}

		 			setState(1652)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.IS
		 			      return testSet
		 			 }()) {
		 				setState(1651)
		 				try match(Cobol85Parser.IS)

		 			}

		 			setState(1654)
		 			try condition()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OdtClauseContext:ParserRuleContext {
		open func ODT() -> TerminalNode? { return getToken(Cobol85Parser.ODT, 0) }
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_odtClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOdtClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOdtClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOdtClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOdtClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func odtClause() throws -> OdtClauseContext {
		var _localctx: OdtClauseContext = OdtClauseContext(_ctx, getState())
		try enterRule(_localctx, 98, Cobol85Parser.RULE_odtClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1659)
		 	try match(Cobol85Parser.ODT)
		 	setState(1661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1660)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1663)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReserveNetworkClauseContext:ParserRuleContext {
		open func RESERVE() -> TerminalNode? { return getToken(Cobol85Parser.RESERVE, 0) }
		open func NETWORK() -> TerminalNode? { return getToken(Cobol85Parser.NETWORK, 0) }
		open func WORDS() -> TerminalNode? { return getToken(Cobol85Parser.WORDS, 0) }
		open func LIST() -> TerminalNode? { return getToken(Cobol85Parser.LIST, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func CAPABLE() -> TerminalNode? { return getToken(Cobol85Parser.CAPABLE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reserveNetworkClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReserveNetworkClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReserveNetworkClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReserveNetworkClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReserveNetworkClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reserveNetworkClause() throws -> ReserveNetworkClauseContext {
		var _localctx: ReserveNetworkClauseContext = ReserveNetworkClauseContext(_ctx, getState())
		try enterRule(_localctx, 100, Cobol85Parser.RULE_reserveNetworkClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1665)
		 	try match(Cobol85Parser.RESERVE)
		 	setState(1667)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WORDS
		 	      return testSet
		 	 }()) {
		 		setState(1666)
		 		try match(Cobol85Parser.WORDS)

		 	}

		 	setState(1670)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LIST
		 	      return testSet
		 	 }()) {
		 		setState(1669)
		 		try match(Cobol85Parser.LIST)

		 	}

		 	setState(1673)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1672)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1675)
		 	try match(Cobol85Parser.NETWORK)
		 	setState(1677)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,102,_ctx)) {
		 	case 1:
		 		setState(1676)
		 		try match(Cobol85Parser.CAPABLE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicCharactersClauseContext:ParserRuleContext {
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open func symbolicCharacters() -> Array<SymbolicCharactersContext> {
			return getRuleContexts(SymbolicCharactersContext.self)
		}
		open func symbolicCharacters(_ i: Int) -> SymbolicCharactersContext? {
			return getRuleContext(SymbolicCharactersContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicCharactersClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicCharactersClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicCharactersClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicCharactersClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicCharactersClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicCharactersClause() throws -> SymbolicCharactersClauseContext {
		var _localctx: SymbolicCharactersClauseContext = SymbolicCharactersClauseContext(_ctx, getState())
		try enterRule(_localctx, 102, Cobol85Parser.RULE_symbolicCharactersClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1679)
		 	try match(Cobol85Parser.SYMBOLIC)
		 	setState(1681)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 	      return testSet
		 	 }()) {
		 		setState(1680)
		 		try match(Cobol85Parser.CHARACTERS)

		 	}

		 	setState(1687)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,105,_ctx)) {
		 	case 1:
		 		setState(1684)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FOR
		 		      return testSet
		 		 }()) {
		 			setState(1683)
		 			try match(Cobol85Parser.FOR)

		 		}

		 		setState(1686)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.ALPHANUMERIC
		 		          testSet = testSet || _la == Cobol85Parser.NATIONAL
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1690); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1689)
		 			try symbolicCharacters()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1692); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,106,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(1696)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(1694)
		 		try match(Cobol85Parser.IN)
		 		setState(1695)
		 		try alphabetName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicCharactersContext:ParserRuleContext {
		open func symbolicCharacter() -> Array<SymbolicCharacterContext> {
			return getRuleContexts(SymbolicCharacterContext.self)
		}
		open func symbolicCharacter(_ i: Int) -> SymbolicCharacterContext? {
			return getRuleContext(SymbolicCharacterContext.self,i)
		}
		open func integerLiteral() -> Array<IntegerLiteralContext> {
			return getRuleContexts(IntegerLiteralContext.self)
		}
		open func integerLiteral(_ i: Int) -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicCharacters }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicCharacters(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicCharacters(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicCharacters(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicCharacters(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicCharacters() throws -> SymbolicCharactersContext {
		var _localctx: SymbolicCharactersContext = SymbolicCharactersContext(_ctx, getState())
		try enterRule(_localctx, 104, Cobol85Parser.RULE_symbolicCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1699) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1698)
		 		try symbolicCharacter()


		 		setState(1701); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())
		 	setState(1704)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ARE
		 	          testSet = testSet || _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1703)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.ARE
		 		          testSet = testSet || _la == Cobol85Parser.IS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(1707) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1706)
		 		try integerLiteral()


		 		setState(1709); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InputOutputSectionContext:ParserRuleContext {
		open func INPUT_OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT_OUTPUT, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func inputOutputSectionParagraph() -> Array<InputOutputSectionParagraphContext> {
			return getRuleContexts(InputOutputSectionParagraphContext.self)
		}
		open func inputOutputSectionParagraph(_ i: Int) -> InputOutputSectionParagraphContext? {
			return getRuleContext(InputOutputSectionParagraphContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inputOutputSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInputOutputSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInputOutputSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInputOutputSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInputOutputSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inputOutputSection() throws -> InputOutputSectionContext {
		var _localctx: InputOutputSectionContext = InputOutputSectionContext(_ctx, getState())
		try enterRule(_localctx, 106, Cobol85Parser.RULE_inputOutputSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1711)
		 	try match(Cobol85Parser.INPUT_OUTPUT)
		 	setState(1712)
		 	try match(Cobol85Parser.SECTION)
		 	setState(1713)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1717)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FILE_CONTROL || _la == Cobol85Parser.I_O_CONTROL
		 	      return testSet
		 	 }()) {
		 		setState(1714)
		 		try inputOutputSectionParagraph()


		 		setState(1719)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InputOutputSectionParagraphContext:ParserRuleContext {
		open func fileControlParagraph() -> FileControlParagraphContext? {
			return getRuleContext(FileControlParagraphContext.self,0)
		}
		open func ioControlParagraph() -> IoControlParagraphContext? {
			return getRuleContext(IoControlParagraphContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inputOutputSectionParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInputOutputSectionParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInputOutputSectionParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInputOutputSectionParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInputOutputSectionParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inputOutputSectionParagraph() throws -> InputOutputSectionParagraphContext {
		var _localctx: InputOutputSectionParagraphContext = InputOutputSectionParagraphContext(_ctx, getState())
		try enterRule(_localctx, 108, Cobol85Parser.RULE_inputOutputSectionParagraph)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1722)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.FILE_CONTROL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1720)
		 		try fileControlParagraph()

		 		break

		 	case Cobol85Parser.I_O_CONTROL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1721)
		 		try ioControlParagraph()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileControlParagraphContext:ParserRuleContext {
		open func FILE_CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.FILE_CONTROL, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func fileControlEntry() -> Array<FileControlEntryContext> {
			return getRuleContexts(FileControlEntryContext.self)
		}
		open func fileControlEntry(_ i: Int) -> FileControlEntryContext? {
			return getRuleContext(FileControlEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileControlParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileControlParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileControlParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileControlParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileControlParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileControlParagraph() throws -> FileControlParagraphContext {
		var _localctx: FileControlParagraphContext = FileControlParagraphContext(_ctx, getState())
		try enterRule(_localctx, 110, Cobol85Parser.RULE_fileControlParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1724)
		 	try match(Cobol85Parser.FILE_CONTROL)
		 	setState(1731)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,114,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1726)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.DOT_FS
		 			      return testSet
		 			 }()) {
		 				setState(1725)
		 				try match(Cobol85Parser.DOT_FS)

		 			}

		 			setState(1728)
		 			try fileControlEntry()

		 	 
		 		}
		 		setState(1733)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,114,_ctx)
		 	}
		 	setState(1734)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileControlEntryContext:ParserRuleContext {
		open func selectClause() -> SelectClauseContext? {
			return getRuleContext(SelectClauseContext.self,0)
		}
		open func fileControlClause() -> Array<FileControlClauseContext> {
			return getRuleContexts(FileControlClauseContext.self)
		}
		open func fileControlClause(_ i: Int) -> FileControlClauseContext? {
			return getRuleContext(FileControlClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileControlEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileControlEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileControlEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileControlEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileControlEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileControlEntry() throws -> FileControlEntryContext {
		var _localctx: FileControlEntryContext = FileControlEntryContext(_ctx, getState())
		try enterRule(_localctx, 112, Cobol85Parser.RULE_fileControlEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1736)
		 	try selectClause()
		 	setState(1740)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ACCESS,Cobol85Parser.ALTERNATE,Cobol85Parser.ASSIGN,Cobol85Parser.BINARY]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.FILE || _la == Cobol85Parser.INDEXED
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LINE,Cobol85Parser.ORGANIZATION,Cobol85Parser.PADDING]
		 	              return  Utils.testBitLeftShiftArray(testArray, 282)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.PASSWORD,Cobol85Parser.RECORD,Cobol85Parser.RELATIVE,Cobol85Parser.RESERVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 347)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.SEQUENTIAL || _la == Cobol85Parser.STATUS
		 	      return testSet
		 	 }()) {
		 		setState(1737)
		 		try fileControlClause()


		 		setState(1742)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SelectClauseContext:ParserRuleContext {
		open func SELECT() -> TerminalNode? { return getToken(Cobol85Parser.SELECT, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func OPTIONAL() -> TerminalNode? { return getToken(Cobol85Parser.OPTIONAL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_selectClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSelectClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSelectClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSelectClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSelectClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func selectClause() throws -> SelectClauseContext {
		var _localctx: SelectClauseContext = SelectClauseContext(_ctx, getState())
		try enterRule(_localctx, 114, Cobol85Parser.RULE_selectClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1743)
		 	try match(Cobol85Parser.SELECT)
		 	setState(1745)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OPTIONAL
		 	      return testSet
		 	 }()) {
		 		setState(1744)
		 		try match(Cobol85Parser.OPTIONAL)

		 	}

		 	setState(1747)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileControlClauseContext:ParserRuleContext {
		open func assignClause() -> AssignClauseContext? {
			return getRuleContext(AssignClauseContext.self,0)
		}
		open func reserveClause() -> ReserveClauseContext? {
			return getRuleContext(ReserveClauseContext.self,0)
		}
		open func organizationClause() -> OrganizationClauseContext? {
			return getRuleContext(OrganizationClauseContext.self,0)
		}
		open func paddingCharacterClause() -> PaddingCharacterClauseContext? {
			return getRuleContext(PaddingCharacterClauseContext.self,0)
		}
		open func recordDelimiterClause() -> RecordDelimiterClauseContext? {
			return getRuleContext(RecordDelimiterClauseContext.self,0)
		}
		open func accessModeClause() -> AccessModeClauseContext? {
			return getRuleContext(AccessModeClauseContext.self,0)
		}
		open func recordKeyClause() -> RecordKeyClauseContext? {
			return getRuleContext(RecordKeyClauseContext.self,0)
		}
		open func alternateRecordKeyClause() -> AlternateRecordKeyClauseContext? {
			return getRuleContext(AlternateRecordKeyClauseContext.self,0)
		}
		open func fileStatusClause() -> FileStatusClauseContext? {
			return getRuleContext(FileStatusClauseContext.self,0)
		}
		open func passwordClause() -> PasswordClauseContext? {
			return getRuleContext(PasswordClauseContext.self,0)
		}
		open func relativeKeyClause() -> RelativeKeyClauseContext? {
			return getRuleContext(RelativeKeyClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileControlClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileControlClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileControlClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileControlClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileControlClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileControlClause() throws -> FileControlClauseContext {
		var _localctx: FileControlClauseContext = FileControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 116, Cobol85Parser.RULE_fileControlClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1760)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,117, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1749)
		 		try assignClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1750)
		 		try reserveClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1751)
		 		try organizationClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1752)
		 		try paddingCharacterClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1753)
		 		try recordDelimiterClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1754)
		 		try accessModeClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1755)
		 		try recordKeyClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1756)
		 		try alternateRecordKeyClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1757)
		 		try fileStatusClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1758)
		 		try passwordClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1759)
		 		try relativeKeyClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AssignClauseContext:ParserRuleContext {
		open func ASSIGN() -> TerminalNode? { return getToken(Cobol85Parser.ASSIGN, 0) }
		open func DISK() -> TerminalNode? { return getToken(Cobol85Parser.DISK, 0) }
		open func PORT() -> TerminalNode? { return getToken(Cobol85Parser.PORT, 0) }
		open func PRINTER() -> TerminalNode? { return getToken(Cobol85Parser.PRINTER, 0) }
		open func READER() -> TerminalNode? { return getToken(Cobol85Parser.READER, 0) }
		open func REMOTE() -> TerminalNode? { return getToken(Cobol85Parser.REMOTE, 0) }
		open func TAPE() -> TerminalNode? { return getToken(Cobol85Parser.TAPE, 0) }
		open func VIRTUAL() -> TerminalNode? { return getToken(Cobol85Parser.VIRTUAL, 0) }
		open func assignmentName() -> AssignmentNameContext? {
			return getRuleContext(AssignmentNameContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_assignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAssignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAssignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAssignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAssignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func assignClause() throws -> AssignClauseContext {
		var _localctx: AssignClauseContext = AssignClauseContext(_ctx, getState())
		try enterRule(_localctx, 118, Cobol85Parser.RULE_assignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1762)
		 	try match(Cobol85Parser.ASSIGN)
		 	setState(1764)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(1763)
		 		try match(Cobol85Parser.TO)

		 	}

		 	setState(1775)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,119, _ctx)) {
		 	case 1:
		 		setState(1766)
		 		try match(Cobol85Parser.DISK)

		 		break
		 	case 2:
		 		setState(1767)
		 		try match(Cobol85Parser.PORT)

		 		break
		 	case 3:
		 		setState(1768)
		 		try match(Cobol85Parser.PRINTER)

		 		break
		 	case 4:
		 		setState(1769)
		 		try match(Cobol85Parser.READER)

		 		break
		 	case 5:
		 		setState(1770)
		 		try match(Cobol85Parser.REMOTE)

		 		break
		 	case 6:
		 		setState(1771)
		 		try match(Cobol85Parser.TAPE)

		 		break
		 	case 7:
		 		setState(1772)
		 		try match(Cobol85Parser.VIRTUAL)

		 		break
		 	case 8:
		 		setState(1773)
		 		try assignmentName()

		 		break
		 	case 9:
		 		setState(1774)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReserveClauseContext:ParserRuleContext {
		open func RESERVE() -> TerminalNode? { return getToken(Cobol85Parser.RESERVE, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func ALTERNATE() -> TerminalNode? { return getToken(Cobol85Parser.ALTERNATE, 0) }
		open func AREA() -> TerminalNode? { return getToken(Cobol85Parser.AREA, 0) }
		open func AREAS() -> TerminalNode? { return getToken(Cobol85Parser.AREAS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reserveClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReserveClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReserveClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReserveClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReserveClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reserveClause() throws -> ReserveClauseContext {
		var _localctx: ReserveClauseContext = ReserveClauseContext(_ctx, getState())
		try enterRule(_localctx, 120, Cobol85Parser.RULE_reserveClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1777)
		 	try match(Cobol85Parser.RESERVE)
		 	setState(1780)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NO:
		 		setState(1778)
		 		try match(Cobol85Parser.NO)

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(1779)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1783)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,121,_ctx)) {
		 	case 1:
		 		setState(1782)
		 		try match(Cobol85Parser.ALTERNATE)

		 		break
		 	default: break
		 	}
		 	setState(1786)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AREA || _la == Cobol85Parser.AREAS
		 	      return testSet
		 	 }()) {
		 		setState(1785)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.AREA || _la == Cobol85Parser.AREAS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OrganizationClauseContext:ParserRuleContext {
		open func SEQUENTIAL() -> TerminalNode? { return getToken(Cobol85Parser.SEQUENTIAL, 0) }
		open func RELATIVE() -> TerminalNode? { return getToken(Cobol85Parser.RELATIVE, 0) }
		open func INDEXED() -> TerminalNode? { return getToken(Cobol85Parser.INDEXED, 0) }
		open func ORGANIZATION() -> TerminalNode? { return getToken(Cobol85Parser.ORGANIZATION, 0) }
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func BINARY() -> TerminalNode? { return getToken(Cobol85Parser.BINARY, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_organizationClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOrganizationClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOrganizationClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOrganizationClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOrganizationClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func organizationClause() throws -> OrganizationClauseContext {
		var _localctx: OrganizationClauseContext = OrganizationClauseContext(_ctx, getState())
		try enterRule(_localctx, 122, Cobol85Parser.RULE_organizationClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1792)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ORGANIZATION
		 	      return testSet
		 	 }()) {
		 		setState(1788)
		 		try match(Cobol85Parser.ORGANIZATION)
		 		setState(1790)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(1789)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(1799)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,125,_ctx)) {
		 	case 1:
		 		setState(1794)
		 		try match(Cobol85Parser.LINE)

		 		break
		 	case 2:
		 		setState(1795)
		 		try match(Cobol85Parser.RECORD)
		 		setState(1796)
		 		try match(Cobol85Parser.BINARY)

		 		break
		 	case 3:
		 		setState(1797)
		 		try match(Cobol85Parser.RECORD)

		 		break
		 	case 4:
		 		setState(1798)
		 		try match(Cobol85Parser.BINARY)

		 		break
		 	default: break
		 	}
		 	setState(1801)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.INDEXED
		 	          testSet = testSet || _la == Cobol85Parser.RELATIVE || _la == Cobol85Parser.SEQUENTIAL
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PaddingCharacterClauseContext:ParserRuleContext {
		open func PADDING() -> TerminalNode? { return getToken(Cobol85Parser.PADDING, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_paddingCharacterClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPaddingCharacterClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPaddingCharacterClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPaddingCharacterClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPaddingCharacterClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func paddingCharacterClause() throws -> PaddingCharacterClauseContext {
		var _localctx: PaddingCharacterClauseContext = PaddingCharacterClauseContext(_ctx, getState())
		try enterRule(_localctx, 124, Cobol85Parser.RULE_paddingCharacterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1803)
		 	try match(Cobol85Parser.PADDING)
		 	setState(1805)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 	      return testSet
		 	 }()) {
		 		setState(1804)
		 		try match(Cobol85Parser.CHARACTER)

		 	}

		 	setState(1808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1807)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1812)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,128, _ctx)) {
		 	case 1:
		 		setState(1810)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		setState(1811)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordDelimiterClauseContext:ParserRuleContext {
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func DELIMITER() -> TerminalNode? { return getToken(Cobol85Parser.DELIMITER, 0) }
		open func STANDARD_1() -> TerminalNode? { return getToken(Cobol85Parser.STANDARD_1, 0) }
		open func IMPLICIT() -> TerminalNode? { return getToken(Cobol85Parser.IMPLICIT, 0) }
		open func assignmentName() -> AssignmentNameContext? {
			return getRuleContext(AssignmentNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordDelimiterClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordDelimiterClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordDelimiterClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordDelimiterClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordDelimiterClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordDelimiterClause() throws -> RecordDelimiterClauseContext {
		var _localctx: RecordDelimiterClauseContext = RecordDelimiterClauseContext(_ctx, getState())
		try enterRule(_localctx, 126, Cobol85Parser.RULE_recordDelimiterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1814)
		 	try match(Cobol85Parser.RECORD)
		 	setState(1815)
		 	try match(Cobol85Parser.DELIMITER)
		 	setState(1817)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1816)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1822)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,130, _ctx)) {
		 	case 1:
		 		setState(1819)
		 		try match(Cobol85Parser.STANDARD_1)

		 		break
		 	case 2:
		 		setState(1820)
		 		try match(Cobol85Parser.IMPLICIT)

		 		break
		 	case 3:
		 		setState(1821)
		 		try assignmentName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AccessModeClauseContext:ParserRuleContext {
		open func ACCESS() -> TerminalNode? { return getToken(Cobol85Parser.ACCESS, 0) }
		open func SEQUENTIAL() -> TerminalNode? { return getToken(Cobol85Parser.SEQUENTIAL, 0) }
		open func RANDOM() -> TerminalNode? { return getToken(Cobol85Parser.RANDOM, 0) }
		open func DYNAMIC() -> TerminalNode? { return getToken(Cobol85Parser.DYNAMIC, 0) }
		open func EXCLUSIVE() -> TerminalNode? { return getToken(Cobol85Parser.EXCLUSIVE, 0) }
		open func MODE() -> TerminalNode? { return getToken(Cobol85Parser.MODE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_accessModeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAccessModeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAccessModeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAccessModeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAccessModeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func accessModeClause() throws -> AccessModeClauseContext {
		var _localctx: AccessModeClauseContext = AccessModeClauseContext(_ctx, getState())
		try enterRule(_localctx, 128, Cobol85Parser.RULE_accessModeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1824)
		 	try match(Cobol85Parser.ACCESS)
		 	setState(1826)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MODE
		 	      return testSet
		 	 }()) {
		 		setState(1825)
		 		try match(Cobol85Parser.MODE)

		 	}

		 	setState(1829)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1828)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1831)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DYNAMIC || _la == Cobol85Parser.EXCLUSIVE
		 	          testSet = testSet || _la == Cobol85Parser.RANDOM || _la == Cobol85Parser.SEQUENTIAL
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordKeyClauseContext:ParserRuleContext {
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func passwordClause() -> PasswordClauseContext? {
			return getRuleContext(PasswordClauseContext.self,0)
		}
		open func DUPLICATES() -> TerminalNode? { return getToken(Cobol85Parser.DUPLICATES, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordKeyClause() throws -> RecordKeyClauseContext {
		var _localctx: RecordKeyClauseContext = RecordKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 130, Cobol85Parser.RULE_recordKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1833)
		 	try match(Cobol85Parser.RECORD)
		 	setState(1835)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(1834)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(1838)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1837)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1840)
		 	try qualifiedDataName()
		 	setState(1842)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,135,_ctx)) {
		 	case 1:
		 		setState(1841)
		 		try passwordClause()

		 		break
		 	default: break
		 	}
		 	setState(1848)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DUPLICATES
		 	          testSet = testSet || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(1845)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(1844)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(1847)
		 		try match(Cobol85Parser.DUPLICATES)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlternateRecordKeyClauseContext:ParserRuleContext {
		open func ALTERNATE() -> TerminalNode? { return getToken(Cobol85Parser.ALTERNATE, 0) }
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func passwordClause() -> PasswordClauseContext? {
			return getRuleContext(PasswordClauseContext.self,0)
		}
		open func DUPLICATES() -> TerminalNode? { return getToken(Cobol85Parser.DUPLICATES, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alternateRecordKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlternateRecordKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlternateRecordKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlternateRecordKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlternateRecordKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alternateRecordKeyClause() throws -> AlternateRecordKeyClauseContext {
		var _localctx: AlternateRecordKeyClauseContext = AlternateRecordKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 132, Cobol85Parser.RULE_alternateRecordKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1850)
		 	try match(Cobol85Parser.ALTERNATE)
		 	setState(1851)
		 	try match(Cobol85Parser.RECORD)
		 	setState(1853)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(1852)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(1856)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1855)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1858)
		 	try qualifiedDataName()
		 	setState(1860)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,140,_ctx)) {
		 	case 1:
		 		setState(1859)
		 		try passwordClause()

		 		break
		 	default: break
		 	}
		 	setState(1866)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DUPLICATES
		 	          testSet = testSet || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(1863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(1862)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(1865)
		 		try match(Cobol85Parser.DUPLICATES)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PasswordClauseContext:ParserRuleContext {
		open func PASSWORD() -> TerminalNode? { return getToken(Cobol85Parser.PASSWORD, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_passwordClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPasswordClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPasswordClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPasswordClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPasswordClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func passwordClause() throws -> PasswordClauseContext {
		var _localctx: PasswordClauseContext = PasswordClauseContext(_ctx, getState())
		try enterRule(_localctx, 134, Cobol85Parser.RULE_passwordClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1868)
		 	try match(Cobol85Parser.PASSWORD)
		 	setState(1870)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1869)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1872)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileStatusClauseContext:ParserRuleContext {
		open func STATUS() -> TerminalNode? { return getToken(Cobol85Parser.STATUS, 0) }
		open func qualifiedDataName() -> Array<QualifiedDataNameContext> {
			return getRuleContexts(QualifiedDataNameContext.self)
		}
		open func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,i)
		}
		open func FILE() -> TerminalNode? { return getToken(Cobol85Parser.FILE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileStatusClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileStatusClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileStatusClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileStatusClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileStatusClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileStatusClause() throws -> FileStatusClauseContext {
		var _localctx: FileStatusClauseContext = FileStatusClauseContext(_ctx, getState())
		try enterRule(_localctx, 136, Cobol85Parser.RULE_fileStatusClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1875)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FILE
		 	      return testSet
		 	 }()) {
		 		setState(1874)
		 		try match(Cobol85Parser.FILE)

		 	}

		 	setState(1877)
		 	try match(Cobol85Parser.STATUS)
		 	setState(1879)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1878)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1881)
		 	try qualifiedDataName()
		 	setState(1883)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,146,_ctx)) {
		 	case 1:
		 		setState(1882)
		 		try qualifiedDataName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelativeKeyClauseContext:ParserRuleContext {
		open func RELATIVE() -> TerminalNode? { return getToken(Cobol85Parser.RELATIVE, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relativeKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelativeKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelativeKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelativeKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelativeKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relativeKeyClause() throws -> RelativeKeyClauseContext {
		var _localctx: RelativeKeyClauseContext = RelativeKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 138, Cobol85Parser.RULE_relativeKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1885)
		 	try match(Cobol85Parser.RELATIVE)
		 	setState(1887)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(1886)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(1890)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1889)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(1892)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IoControlParagraphContext:ParserRuleContext {
		open func I_O_CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.I_O_CONTROL, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func ioControlClause() -> Array<IoControlClauseContext> {
			return getRuleContexts(IoControlClauseContext.self)
		}
		open func ioControlClause(_ i: Int) -> IoControlClauseContext? {
			return getRuleContext(IoControlClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_ioControlParagraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIoControlParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIoControlParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIoControlParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIoControlParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ioControlParagraph() throws -> IoControlParagraphContext {
		var _localctx: IoControlParagraphContext = IoControlParagraphContext(_ctx, getState())
		try enterRule(_localctx, 140, Cobol85Parser.RULE_ioControlParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1894)
		 	try match(Cobol85Parser.I_O_CONTROL)
		 	setState(1895)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1899)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,149,_ctx)) {
		 	case 1:
		 		setState(1896)
		 		try fileName()
		 		setState(1897)
		 		try match(Cobol85Parser.DOT_FS)

		 		break
		 	default: break
		 	}
		 	setState(1908)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COMMITMENT
		 	          testSet = testSet || _la == Cobol85Parser.MULTIPLE
		 	          testSet = testSet || _la == Cobol85Parser.RERUN || _la == Cobol85Parser.SAME
		 	          testSet = testSet || _la == Cobol85Parser.DOT_FS
		 	      return testSet
		 	 }()) {
		 		setState(1904)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.COMMITMENT
		 		          testSet = testSet || _la == Cobol85Parser.MULTIPLE
		 		          testSet = testSet || _la == Cobol85Parser.RERUN || _la == Cobol85Parser.SAME
		 		      return testSet
		 		 }()) {
		 			setState(1901)
		 			try ioControlClause()


		 			setState(1906)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1907)
		 		try match(Cobol85Parser.DOT_FS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IoControlClauseContext:ParserRuleContext {
		open func rerunClause() -> RerunClauseContext? {
			return getRuleContext(RerunClauseContext.self,0)
		}
		open func sameClause() -> SameClauseContext? {
			return getRuleContext(SameClauseContext.self,0)
		}
		open func multipleFileClause() -> MultipleFileClauseContext? {
			return getRuleContext(MultipleFileClauseContext.self,0)
		}
		open func commitmentControlClause() -> CommitmentControlClauseContext? {
			return getRuleContext(CommitmentControlClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_ioControlClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIoControlClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIoControlClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIoControlClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIoControlClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ioControlClause() throws -> IoControlClauseContext {
		var _localctx: IoControlClauseContext = IoControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 142, Cobol85Parser.RULE_ioControlClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1914)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.RERUN:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1910)
		 		try rerunClause()

		 		break

		 	case Cobol85Parser.SAME:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1911)
		 		try sameClause()

		 		break

		 	case Cobol85Parser.MULTIPLE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1912)
		 		try multipleFileClause()

		 		break

		 	case Cobol85Parser.COMMITMENT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1913)
		 		try commitmentControlClause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RerunClauseContext:ParserRuleContext {
		open func RERUN() -> TerminalNode? { return getToken(Cobol85Parser.RERUN, 0) }
		open func EVERY() -> TerminalNode? { return getToken(Cobol85Parser.EVERY, 0) }
		open func rerunEveryRecords() -> RerunEveryRecordsContext? {
			return getRuleContext(RerunEveryRecordsContext.self,0)
		}
		open func rerunEveryOf() -> RerunEveryOfContext? {
			return getRuleContext(RerunEveryOfContext.self,0)
		}
		open func rerunEveryClock() -> RerunEveryClockContext? {
			return getRuleContext(RerunEveryClockContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func assignmentName() -> AssignmentNameContext? {
			return getRuleContext(AssignmentNameContext.self,0)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rerunClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRerunClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRerunClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRerunClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRerunClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rerunClause() throws -> RerunClauseContext {
		var _localctx: RerunClauseContext = RerunClauseContext(_ctx, getState())
		try enterRule(_localctx, 144, Cobol85Parser.RULE_rerunClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1916)
		 	try match(Cobol85Parser.RERUN)
		 	setState(1922)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(1917)
		 		try match(Cobol85Parser.ON)
		 		setState(1920)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,153, _ctx)) {
		 		case 1:
		 			setState(1918)
		 			try assignmentName()

		 			break
		 		case 2:
		 			setState(1919)
		 			try fileName()

		 			break
		 		default: break
		 		}

		 	}

		 	setState(1924)
		 	try match(Cobol85Parser.EVERY)
		 	setState(1928)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,155, _ctx)) {
		 	case 1:
		 		setState(1925)
		 		try rerunEveryRecords()

		 		break
		 	case 2:
		 		setState(1926)
		 		try rerunEveryOf()

		 		break
		 	case 3:
		 		setState(1927)
		 		try rerunEveryClock()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RerunEveryRecordsContext:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func RECORDS() -> TerminalNode? { return getToken(Cobol85Parser.RECORDS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rerunEveryRecords }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRerunEveryRecords(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRerunEveryRecords(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRerunEveryRecords(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRerunEveryRecords(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rerunEveryRecords() throws -> RerunEveryRecordsContext {
		var _localctx: RerunEveryRecordsContext = RerunEveryRecordsContext(_ctx, getState())
		try enterRule(_localctx, 146, Cobol85Parser.RULE_rerunEveryRecords)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1930)
		 	try integerLiteral()
		 	setState(1931)
		 	try match(Cobol85Parser.RECORDS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RerunEveryOfContext:ParserRuleContext {
		open func OF() -> Array<TerminalNode> { return getTokens(Cobol85Parser.OF) }
		open func OF(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.OF, i)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func REEL() -> TerminalNode? { return getToken(Cobol85Parser.REEL, 0) }
		open func UNIT() -> TerminalNode? { return getToken(Cobol85Parser.UNIT, 0) }
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rerunEveryOf }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRerunEveryOf(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRerunEveryOf(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRerunEveryOf(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRerunEveryOf(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rerunEveryOf() throws -> RerunEveryOfContext {
		var _localctx: RerunEveryOfContext = RerunEveryOfContext(_ctx, getState())
		try enterRule(_localctx, 148, Cobol85Parser.RULE_rerunEveryOf)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1934)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.END
		 	      return testSet
		 	 }()) {
		 		setState(1933)
		 		try match(Cobol85Parser.END)

		 	}

		 	setState(1937)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OF
		 	      return testSet
		 	 }()) {
		 		setState(1936)
		 		try match(Cobol85Parser.OF)

		 	}

		 	setState(1939)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.REEL
		 	          testSet = testSet || _la == Cobol85Parser.UNIT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1940)
		 	try match(Cobol85Parser.OF)
		 	setState(1941)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RerunEveryClockContext:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func CLOCK_UNITS() -> TerminalNode? { return getToken(Cobol85Parser.CLOCK_UNITS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rerunEveryClock }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRerunEveryClock(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRerunEveryClock(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRerunEveryClock(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRerunEveryClock(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rerunEveryClock() throws -> RerunEveryClockContext {
		var _localctx: RerunEveryClockContext = RerunEveryClockContext(_ctx, getState())
		try enterRule(_localctx, 150, Cobol85Parser.RULE_rerunEveryClock)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1943)
		 	try integerLiteral()
		 	setState(1945)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CLOCK_UNITS
		 	      return testSet
		 	 }()) {
		 		setState(1944)
		 		try match(Cobol85Parser.CLOCK_UNITS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SameClauseContext:ParserRuleContext {
		open func SAME() -> TerminalNode? { return getToken(Cobol85Parser.SAME, 0) }
		open func AREA() -> TerminalNode? { return getToken(Cobol85Parser.AREA, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func SORT() -> TerminalNode? { return getToken(Cobol85Parser.SORT, 0) }
		open func SORT_MERGE() -> TerminalNode? { return getToken(Cobol85Parser.SORT_MERGE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sameClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSameClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSameClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSameClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSameClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sameClause() throws -> SameClauseContext {
		var _localctx: SameClauseContext = SameClauseContext(_ctx, getState())
		try enterRule(_localctx, 152, Cobol85Parser.RULE_sameClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1947)
		 	try match(Cobol85Parser.SAME)
		 	setState(1949)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.RECORD || _la == Cobol85Parser.SORT
		 	          testSet = testSet || _la == Cobol85Parser.SORT_MERGE
		 	      return testSet
		 	 }()) {
		 		setState(1948)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.RECORD || _la == Cobol85Parser.SORT
		 		          testSet = testSet || _la == Cobol85Parser.SORT_MERGE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(1952)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AREA
		 	      return testSet
		 	 }()) {
		 		setState(1951)
		 		try match(Cobol85Parser.AREA)

		 	}

		 	setState(1955)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1954)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(1958); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1957)
		 			try fileName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1960); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,162,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultipleFileClauseContext:ParserRuleContext {
		open func MULTIPLE() -> TerminalNode? { return getToken(Cobol85Parser.MULTIPLE, 0) }
		open func FILE() -> TerminalNode? { return getToken(Cobol85Parser.FILE, 0) }
		open func TAPE() -> TerminalNode? { return getToken(Cobol85Parser.TAPE, 0) }
		open func CONTAINS() -> TerminalNode? { return getToken(Cobol85Parser.CONTAINS, 0) }
		open func multipleFilePosition() -> Array<MultipleFilePositionContext> {
			return getRuleContexts(MultipleFilePositionContext.self)
		}
		open func multipleFilePosition(_ i: Int) -> MultipleFilePositionContext? {
			return getRuleContext(MultipleFilePositionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multipleFileClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultipleFileClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultipleFileClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultipleFileClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultipleFileClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multipleFileClause() throws -> MultipleFileClauseContext {
		var _localctx: MultipleFileClauseContext = MultipleFileClauseContext(_ctx, getState())
		try enterRule(_localctx, 154, Cobol85Parser.RULE_multipleFileClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1962)
		 	try match(Cobol85Parser.MULTIPLE)
		 	setState(1963)
		 	try match(Cobol85Parser.FILE)
		 	setState(1965)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TAPE
		 	      return testSet
		 	 }()) {
		 		setState(1964)
		 		try match(Cobol85Parser.TAPE)

		 	}

		 	setState(1968)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CONTAINS
		 	      return testSet
		 	 }()) {
		 		setState(1967)
		 		try match(Cobol85Parser.CONTAINS)

		 	}

		 	setState(1971); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1970)
		 			try multipleFilePosition()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1973); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,165,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultipleFilePositionContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func POSITION() -> TerminalNode? { return getToken(Cobol85Parser.POSITION, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multipleFilePosition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultipleFilePosition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultipleFilePosition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultipleFilePosition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultipleFilePosition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multipleFilePosition() throws -> MultipleFilePositionContext {
		var _localctx: MultipleFilePositionContext = MultipleFilePositionContext(_ctx, getState())
		try enterRule(_localctx, 156, Cobol85Parser.RULE_multipleFilePosition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1975)
		 	try fileName()
		 	setState(1978)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.POSITION
		 	      return testSet
		 	 }()) {
		 		setState(1976)
		 		try match(Cobol85Parser.POSITION)
		 		setState(1977)
		 		try integerLiteral()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommitmentControlClauseContext:ParserRuleContext {
		open func COMMITMENT() -> TerminalNode? { return getToken(Cobol85Parser.COMMITMENT, 0) }
		open func CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_commitmentControlClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommitmentControlClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommitmentControlClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommitmentControlClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommitmentControlClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func commitmentControlClause() throws -> CommitmentControlClauseContext {
		var _localctx: CommitmentControlClauseContext = CommitmentControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 158, Cobol85Parser.RULE_commitmentControlClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1980)
		 	try match(Cobol85Parser.COMMITMENT)
		 	setState(1981)
		 	try match(Cobol85Parser.CONTROL)
		 	setState(1983)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1982)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(1985)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDivisionContext:ParserRuleContext {
		open func DATA() -> TerminalNode? { return getToken(Cobol85Parser.DATA, 0) }
		open func DIVISION() -> TerminalNode? { return getToken(Cobol85Parser.DIVISION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataDivisionBody() -> DataDivisionBodyContext? {
			return getRuleContext(DataDivisionBodyContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDivision }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDivision(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDivision(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDivision(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDivision(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDivision() throws -> DataDivisionContext {
		var _localctx: DataDivisionContext = DataDivisionContext(_ctx, getState())
		try enterRule(_localctx, 160, Cobol85Parser.RULE_dataDivision)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1987)
		 	try match(Cobol85Parser.DATA)
		 	setState(1988)
		 	try match(Cobol85Parser.DIVISION)
		 	setState(1989)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(1990)
		 	try dataDivisionBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDivisionBodyContext:ParserRuleContext {
		open func fileSection() -> FileSectionContext? {
			return getRuleContext(FileSectionContext.self,0)
		}
		open func dataBaseSection() -> DataBaseSectionContext? {
			return getRuleContext(DataBaseSectionContext.self,0)
		}
		open func workingStorageSection() -> WorkingStorageSectionContext? {
			return getRuleContext(WorkingStorageSectionContext.self,0)
		}
		open func linkageSection() -> LinkageSectionContext? {
			return getRuleContext(LinkageSectionContext.self,0)
		}
		open func communicationSection() -> CommunicationSectionContext? {
			return getRuleContext(CommunicationSectionContext.self,0)
		}
		open func localStorageSection() -> LocalStorageSectionContext? {
			return getRuleContext(LocalStorageSectionContext.self,0)
		}
		open func screenSection() -> ScreenSectionContext? {
			return getRuleContext(ScreenSectionContext.self,0)
		}
		open func reportSection() -> ReportSectionContext? {
			return getRuleContext(ReportSectionContext.self,0)
		}
		open func programLibrarySection() -> ProgramLibrarySectionContext? {
			return getRuleContext(ProgramLibrarySectionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDivisionBody }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDivisionBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDivisionBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDivisionBody(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDivisionBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDivisionBody() throws -> DataDivisionBodyContext {
		var _localctx: DataDivisionBodyContext = DataDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 162, Cobol85Parser.RULE_dataDivisionBody)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1993)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FILE
		 	      return testSet
		 	 }()) {
		 		setState(1992)
		 		try fileSection()

		 	}

		 	setState(1996)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DATA_BASE
		 	      return testSet
		 	 }()) {
		 		setState(1995)
		 		try dataBaseSection()

		 	}

		 	setState(1999)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WORKING_STORAGE
		 	      return testSet
		 	 }()) {
		 		setState(1998)
		 		try workingStorageSection()

		 	}

		 	setState(2002)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINKAGE
		 	      return testSet
		 	 }()) {
		 		setState(2001)
		 		try linkageSection()

		 	}

		 	setState(2005)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMUNICATION
		 	      return testSet
		 	 }()) {
		 		setState(2004)
		 		try communicationSection()

		 	}

		 	setState(2008)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LOCAL_STORAGE
		 	      return testSet
		 	 }()) {
		 		setState(2007)
		 		try localStorageSection()

		 	}

		 	setState(2011)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SCREEN
		 	      return testSet
		 	 }()) {
		 		setState(2010)
		 		try screenSection()

		 	}

		 	setState(2014)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REPORT
		 	      return testSet
		 	 }()) {
		 		setState(2013)
		 		try reportSection()

		 	}

		 	setState(2017)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROGRAM_LIBRARY
		 	      return testSet
		 	 }()) {
		 		setState(2016)
		 		try programLibrarySection()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileSectionContext:ParserRuleContext {
		open func FILE() -> TerminalNode? { return getToken(Cobol85Parser.FILE, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func fileDescriptionEntry() -> Array<FileDescriptionEntryContext> {
			return getRuleContexts(FileDescriptionEntryContext.self)
		}
		open func fileDescriptionEntry(_ i: Int) -> FileDescriptionEntryContext? {
			return getRuleContext(FileDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileSection() throws -> FileSectionContext {
		var _localctx: FileSectionContext = FileSectionContext(_ctx, getState())
		try enterRule(_localctx, 164, Cobol85Parser.RULE_fileSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2019)
		 	try match(Cobol85Parser.FILE)
		 	setState(2020)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2021)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2025)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FD
		 	          testSet = testSet || _la == Cobol85Parser.SD
		 	      return testSet
		 	 }()) {
		 		setState(2022)
		 		try fileDescriptionEntry()


		 		setState(2027)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileDescriptionEntryContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func FD() -> TerminalNode? { return getToken(Cobol85Parser.FD, 0) }
		open func SD() -> TerminalNode? { return getToken(Cobol85Parser.SD, 0) }
		open func fileDescriptionEntryClause() -> Array<FileDescriptionEntryClauseContext> {
			return getRuleContexts(FileDescriptionEntryClauseContext.self)
		}
		open func fileDescriptionEntryClause(_ i: Int) -> FileDescriptionEntryClauseContext? {
			return getRuleContext(FileDescriptionEntryClauseContext.self,i)
		}
		open func dataDescriptionEntry() -> Array<DataDescriptionEntryContext> {
			return getRuleContexts(DataDescriptionEntryContext.self)
		}
		open func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
			return getRuleContext(DataDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileDescriptionEntry() throws -> FileDescriptionEntryContext {
		var _localctx: FileDescriptionEntryContext = FileDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 166, Cobol85Parser.RULE_fileDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2028)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FD
		 	          testSet = testSet || _la == Cobol85Parser.SD
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2029)
		 	try fileName()
		 	setState(2036)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,179,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2031)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.DOT_FS
		 			      return testSet
		 			 }()) {
		 				setState(2030)
		 				try match(Cobol85Parser.DOT_FS)

		 			}

		 			setState(2033)
		 			try fileDescriptionEntryClause()

		 	 
		 		}
		 		setState(2038)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,179,_ctx)
		 	}
		 	setState(2039)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2043)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.EXECSQLLINE]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2040)
		 		try dataDescriptionEntry()


		 		setState(2045)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileDescriptionEntryClauseContext:ParserRuleContext {
		open func externalClause() -> ExternalClauseContext? {
			return getRuleContext(ExternalClauseContext.self,0)
		}
		open func globalClause() -> GlobalClauseContext? {
			return getRuleContext(GlobalClauseContext.self,0)
		}
		open func blockContainsClause() -> BlockContainsClauseContext? {
			return getRuleContext(BlockContainsClauseContext.self,0)
		}
		open func recordContainsClause() -> RecordContainsClauseContext? {
			return getRuleContext(RecordContainsClauseContext.self,0)
		}
		open func labelRecordsClause() -> LabelRecordsClauseContext? {
			return getRuleContext(LabelRecordsClauseContext.self,0)
		}
		open func valueOfClause() -> ValueOfClauseContext? {
			return getRuleContext(ValueOfClauseContext.self,0)
		}
		open func dataRecordsClause() -> DataRecordsClauseContext? {
			return getRuleContext(DataRecordsClauseContext.self,0)
		}
		open func linageClause() -> LinageClauseContext? {
			return getRuleContext(LinageClauseContext.self,0)
		}
		open func codeSetClause() -> CodeSetClauseContext? {
			return getRuleContext(CodeSetClauseContext.self,0)
		}
		open func reportClause() -> ReportClauseContext? {
			return getRuleContext(ReportClauseContext.self,0)
		}
		open func recordingModeClause() -> RecordingModeClauseContext? {
			return getRuleContext(RecordingModeClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileDescriptionEntryClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileDescriptionEntryClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileDescriptionEntryClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileDescriptionEntryClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileDescriptionEntryClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileDescriptionEntryClause() throws -> FileDescriptionEntryClauseContext {
		var _localctx: FileDescriptionEntryClauseContext = FileDescriptionEntryClauseContext(_ctx, getState())
		try enterRule(_localctx, 168, Cobol85Parser.RULE_fileDescriptionEntryClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2057)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,181, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2046)
		 		try externalClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2047)
		 		try globalClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2048)
		 		try blockContainsClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2049)
		 		try recordContainsClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2050)
		 		try labelRecordsClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2051)
		 		try valueOfClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2052)
		 		try dataRecordsClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2053)
		 		try linageClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2054)
		 		try codeSetClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2055)
		 		try reportClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2056)
		 		try recordingModeClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExternalClauseContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(Cobol85Parser.EXTERNAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_externalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExternalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExternalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExternalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExternalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func externalClause() throws -> ExternalClauseContext {
		var _localctx: ExternalClauseContext = ExternalClauseContext(_ctx, getState())
		try enterRule(_localctx, 170, Cobol85Parser.RULE_externalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2060)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2059)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2062)
		 	try match(Cobol85Parser.EXTERNAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GlobalClauseContext:ParserRuleContext {
		open func GLOBAL() -> TerminalNode? { return getToken(Cobol85Parser.GLOBAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_globalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGlobalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGlobalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGlobalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGlobalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func globalClause() throws -> GlobalClauseContext {
		var _localctx: GlobalClauseContext = GlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 172, Cobol85Parser.RULE_globalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2065)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2064)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2067)
		 	try match(Cobol85Parser.GLOBAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BlockContainsClauseContext:ParserRuleContext {
		open func BLOCK() -> TerminalNode? { return getToken(Cobol85Parser.BLOCK, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func CONTAINS() -> TerminalNode? { return getToken(Cobol85Parser.CONTAINS, 0) }
		open func blockContainsTo() -> BlockContainsToContext? {
			return getRuleContext(BlockContainsToContext.self,0)
		}
		open func RECORDS() -> TerminalNode? { return getToken(Cobol85Parser.RECORDS, 0) }
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_blockContainsClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterBlockContainsClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitBlockContainsClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitBlockContainsClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitBlockContainsClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func blockContainsClause() throws -> BlockContainsClauseContext {
		var _localctx: BlockContainsClauseContext = BlockContainsClauseContext(_ctx, getState())
		try enterRule(_localctx, 174, Cobol85Parser.RULE_blockContainsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2069)
		 	try match(Cobol85Parser.BLOCK)
		 	setState(2071)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CONTAINS
		 	      return testSet
		 	 }()) {
		 		setState(2070)
		 		try match(Cobol85Parser.CONTAINS)

		 	}

		 	setState(2073)
		 	try integerLiteral()
		 	setState(2075)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(2074)
		 		try blockContainsTo()

		 	}

		 	setState(2078)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 	          testSet = testSet || _la == Cobol85Parser.RECORDS
		 	      return testSet
		 	 }()) {
		 		setState(2077)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 		          testSet = testSet || _la == Cobol85Parser.RECORDS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BlockContainsToContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_blockContainsTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterBlockContainsTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitBlockContainsTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitBlockContainsTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitBlockContainsTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func blockContainsTo() throws -> BlockContainsToContext {
		var _localctx: BlockContainsToContext = BlockContainsToContext(_ctx, getState())
		try enterRule(_localctx, 176, Cobol85Parser.RULE_blockContainsTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2080)
		 	try match(Cobol85Parser.TO)
		 	setState(2081)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordContainsClauseContext:ParserRuleContext {
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func recordContainsClauseFormat1() -> RecordContainsClauseFormat1Context? {
			return getRuleContext(RecordContainsClauseFormat1Context.self,0)
		}
		open func recordContainsClauseFormat2() -> RecordContainsClauseFormat2Context? {
			return getRuleContext(RecordContainsClauseFormat2Context.self,0)
		}
		open func recordContainsClauseFormat3() -> RecordContainsClauseFormat3Context? {
			return getRuleContext(RecordContainsClauseFormat3Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordContainsClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordContainsClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordContainsClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordContainsClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordContainsClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordContainsClause() throws -> RecordContainsClauseContext {
		var _localctx: RecordContainsClauseContext = RecordContainsClauseContext(_ctx, getState())
		try enterRule(_localctx, 178, Cobol85Parser.RULE_recordContainsClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2083)
		 	try match(Cobol85Parser.RECORD)
		 	setState(2087)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,187, _ctx)) {
		 	case 1:
		 		setState(2084)
		 		try recordContainsClauseFormat1()

		 		break
		 	case 2:
		 		setState(2085)
		 		try recordContainsClauseFormat2()

		 		break
		 	case 3:
		 		setState(2086)
		 		try recordContainsClauseFormat3()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordContainsClauseFormat1Context:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func CONTAINS() -> TerminalNode? { return getToken(Cobol85Parser.CONTAINS, 0) }
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordContainsClauseFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordContainsClauseFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordContainsClauseFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordContainsClauseFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordContainsClauseFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordContainsClauseFormat1() throws -> RecordContainsClauseFormat1Context {
		var _localctx: RecordContainsClauseFormat1Context = RecordContainsClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 180, Cobol85Parser.RULE_recordContainsClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2090)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CONTAINS
		 	      return testSet
		 	 }()) {
		 		setState(2089)
		 		try match(Cobol85Parser.CONTAINS)

		 	}

		 	setState(2092)
		 	try integerLiteral()
		 	setState(2094)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 	      return testSet
		 	 }()) {
		 		setState(2093)
		 		try match(Cobol85Parser.CHARACTERS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordContainsClauseFormat2Context:ParserRuleContext {
		open func VARYING() -> TerminalNode? { return getToken(Cobol85Parser.VARYING, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func DEPENDING() -> TerminalNode? { return getToken(Cobol85Parser.DEPENDING, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func recordContainsTo() -> RecordContainsToContext? {
			return getRuleContext(RecordContainsToContext.self,0)
		}
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordContainsClauseFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordContainsClauseFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordContainsClauseFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordContainsClauseFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordContainsClauseFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordContainsClauseFormat2() throws -> RecordContainsClauseFormat2Context {
		var _localctx: RecordContainsClauseFormat2Context = RecordContainsClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 182, Cobol85Parser.RULE_recordContainsClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2097)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2096)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2099)
		 	try match(Cobol85Parser.VARYING)
		 	setState(2101)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(2100)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(2104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIZE
		 	      return testSet
		 	 }()) {
		 		setState(2103)
		 		try match(Cobol85Parser.SIZE)

		 	}

		 	setState(2116)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FROM
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2107)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FROM
		 		      return testSet
		 		 }()) {
		 			setState(2106)
		 			try match(Cobol85Parser.FROM)

		 		}

		 		setState(2109)
		 		try integerLiteral()
		 		setState(2111)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TO
		 		      return testSet
		 		 }()) {
		 			setState(2110)
		 			try recordContainsTo()

		 		}

		 		setState(2114)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 		      return testSet
		 		 }()) {
		 			setState(2113)
		 			try match(Cobol85Parser.CHARACTERS)

		 		}


		 	}

		 	setState(2123)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DEPENDING
		 	      return testSet
		 	 }()) {
		 		setState(2118)
		 		try match(Cobol85Parser.DEPENDING)
		 		setState(2120)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ON
		 		      return testSet
		 		 }()) {
		 			setState(2119)
		 			try match(Cobol85Parser.ON)

		 		}

		 		setState(2122)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordContainsClauseFormat3Context:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func recordContainsTo() -> RecordContainsToContext? {
			return getRuleContext(RecordContainsToContext.self,0)
		}
		open func CONTAINS() -> TerminalNode? { return getToken(Cobol85Parser.CONTAINS, 0) }
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordContainsClauseFormat3 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordContainsClauseFormat3(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordContainsClauseFormat3(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordContainsClauseFormat3(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordContainsClauseFormat3(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordContainsClauseFormat3() throws -> RecordContainsClauseFormat3Context {
		var _localctx: RecordContainsClauseFormat3Context = RecordContainsClauseFormat3Context(_ctx, getState())
		try enterRule(_localctx, 184, Cobol85Parser.RULE_recordContainsClauseFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2126)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CONTAINS
		 	      return testSet
		 	 }()) {
		 		setState(2125)
		 		try match(Cobol85Parser.CONTAINS)

		 	}

		 	setState(2128)
		 	try integerLiteral()
		 	setState(2129)
		 	try recordContainsTo()
		 	setState(2131)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTERS
		 	      return testSet
		 	 }()) {
		 		setState(2130)
		 		try match(Cobol85Parser.CHARACTERS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordContainsToContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordContainsTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordContainsTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordContainsTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordContainsTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordContainsTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordContainsTo() throws -> RecordContainsToContext {
		var _localctx: RecordContainsToContext = RecordContainsToContext(_ctx, getState())
		try enterRule(_localctx, 186, Cobol85Parser.RULE_recordContainsTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2133)
		 	try match(Cobol85Parser.TO)
		 	setState(2134)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LabelRecordsClauseContext:ParserRuleContext {
		open func LABEL() -> TerminalNode? { return getToken(Cobol85Parser.LABEL, 0) }
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func RECORDS() -> TerminalNode? { return getToken(Cobol85Parser.RECORDS, 0) }
		open func OMITTED() -> TerminalNode? { return getToken(Cobol85Parser.OMITTED, 0) }
		open func STANDARD() -> TerminalNode? { return getToken(Cobol85Parser.STANDARD, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open func dataName() -> Array<DataNameContext> {
			return getRuleContexts(DataNameContext.self)
		}
		open func dataName(_ i: Int) -> DataNameContext? {
			return getRuleContext(DataNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_labelRecordsClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLabelRecordsClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLabelRecordsClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLabelRecordsClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLabelRecordsClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func labelRecordsClause() throws -> LabelRecordsClauseContext {
		var _localctx: LabelRecordsClauseContext = LabelRecordsClauseContext(_ctx, getState())
		try enterRule(_localctx, 188, Cobol85Parser.RULE_labelRecordsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2136)
		 	try match(Cobol85Parser.LABEL)
		 	setState(2145)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.RECORD:
		 		setState(2137)
		 		try match(Cobol85Parser.RECORD)
		 		setState(2139)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2138)
		 			try match(Cobol85Parser.IS)

		 		}


		 		break

		 	case Cobol85Parser.RECORDS:
		 		setState(2141)
		 		try match(Cobol85Parser.RECORDS)
		 		setState(2143)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ARE
		 		      return testSet
		 		 }()) {
		 			setState(2142)
		 			try match(Cobol85Parser.ARE)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2154)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.OMITTED:
		 		setState(2147)
		 		try match(Cobol85Parser.OMITTED)

		 		break

		 	case Cobol85Parser.STANDARD:
		 		setState(2148)
		 		try match(Cobol85Parser.STANDARD)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2150) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2149)
		 			try dataName()


		 			setState(2152); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 		      return testSet
		 		 }())

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ValueOfClauseContext:ParserRuleContext {
		open func VALUE() -> TerminalNode? { return getToken(Cobol85Parser.VALUE, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open func valuePair() -> Array<ValuePairContext> {
			return getRuleContexts(ValuePairContext.self)
		}
		open func valuePair(_ i: Int) -> ValuePairContext? {
			return getRuleContext(ValuePairContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_valueOfClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterValueOfClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitValueOfClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitValueOfClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitValueOfClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func valueOfClause() throws -> ValueOfClauseContext {
		var _localctx: ValueOfClauseContext = ValueOfClauseContext(_ctx, getState())
		try enterRule(_localctx, 190, Cobol85Parser.RULE_valueOfClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2156)
		 	try match(Cobol85Parser.VALUE)
		 	setState(2157)
		 	try match(Cobol85Parser.OF)
		 	setState(2159) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2158)
		 		try valuePair()


		 		setState(2161); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ValuePairContext:ParserRuleContext {
		open func systemName() -> SystemNameContext? {
			return getRuleContext(SystemNameContext.self,0)
		}
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_valuePair }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterValuePair(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitValuePair(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitValuePair(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitValuePair(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func valuePair() throws -> ValuePairContext {
		var _localctx: ValuePairContext = ValuePairContext(_ctx, getState())
		try enterRule(_localctx, 192, Cobol85Parser.RULE_valuePair)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2163)
		 	try systemName()
		 	setState(2165)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2164)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2169)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,208, _ctx)) {
		 	case 1:
		 		setState(2167)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		setState(2168)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataRecordsClauseContext:ParserRuleContext {
		open func DATA() -> TerminalNode? { return getToken(Cobol85Parser.DATA, 0) }
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func RECORDS() -> TerminalNode? { return getToken(Cobol85Parser.RECORDS, 0) }
		open func dataName() -> Array<DataNameContext> {
			return getRuleContexts(DataNameContext.self)
		}
		open func dataName(_ i: Int) -> DataNameContext? {
			return getRuleContext(DataNameContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataRecordsClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataRecordsClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataRecordsClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataRecordsClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataRecordsClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataRecordsClause() throws -> DataRecordsClauseContext {
		var _localctx: DataRecordsClauseContext = DataRecordsClauseContext(_ctx, getState())
		try enterRule(_localctx, 194, Cobol85Parser.RULE_dataRecordsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2171)
		 	try match(Cobol85Parser.DATA)
		 	setState(2180)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.RECORD:
		 		setState(2172)
		 		try match(Cobol85Parser.RECORD)
		 		setState(2174)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2173)
		 			try match(Cobol85Parser.IS)

		 		}


		 		break

		 	case Cobol85Parser.RECORDS:
		 		setState(2176)
		 		try match(Cobol85Parser.RECORDS)
		 		setState(2178)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ARE
		 		      return testSet
		 		 }()) {
		 			setState(2177)
		 			try match(Cobol85Parser.ARE)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2183) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2182)
		 		try dataName()


		 		setState(2185); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinageClauseContext:ParserRuleContext {
		open func LINAGE() -> TerminalNode? { return getToken(Cobol85Parser.LINAGE, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open func linageAt() -> Array<LinageAtContext> {
			return getRuleContexts(LinageAtContext.self)
		}
		open func linageAt(_ i: Int) -> LinageAtContext? {
			return getRuleContext(LinageAtContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linageClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinageClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinageClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinageClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinageClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linageClause() throws -> LinageClauseContext {
		var _localctx: LinageClauseContext = LinageClauseContext(_ctx, getState())
		try enterRule(_localctx, 196, Cobol85Parser.RULE_linageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2187)
		 	try match(Cobol85Parser.LINAGE)
		 	setState(2189)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2188)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2193)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2191)
		 		try dataName()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2192)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2196)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,215,_ctx)) {
		 	case 1:
		 		setState(2195)
		 		try match(Cobol85Parser.LINES)

		 		break
		 	default: break
		 	}
		 	setState(2201)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.AT || _la == Cobol85Parser.BOTTOM
		 	          testSet = testSet || _la == Cobol85Parser.FOOTING
		 	          testSet = testSet || _la == Cobol85Parser.LINES
		 	          testSet = testSet || _la == Cobol85Parser.TOP || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(2198)
		 		try linageAt()


		 		setState(2203)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinageAtContext:ParserRuleContext {
		open func linageFootingAt() -> LinageFootingAtContext? {
			return getRuleContext(LinageFootingAtContext.self,0)
		}
		open func linageLinesAtTop() -> LinageLinesAtTopContext? {
			return getRuleContext(LinageLinesAtTopContext.self,0)
		}
		open func linageLinesAtBottom() -> LinageLinesAtBottomContext? {
			return getRuleContext(LinageLinesAtBottomContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linageAt }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinageAt(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinageAt(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinageAt(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinageAt(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linageAt() throws -> LinageAtContext {
		var _localctx: LinageAtContext = LinageAtContext(_ctx, getState())
		try enterRule(_localctx, 198, Cobol85Parser.RULE_linageAt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2207)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,217, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2204)
		 		try linageFootingAt()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2205)
		 		try linageLinesAtTop()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2206)
		 		try linageLinesAtBottom()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinageFootingAtContext:ParserRuleContext {
		open func FOOTING() -> TerminalNode? { return getToken(Cobol85Parser.FOOTING, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linageFootingAt }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinageFootingAt(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinageFootingAt(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinageFootingAt(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinageFootingAt(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linageFootingAt() throws -> LinageFootingAtContext {
		var _localctx: LinageFootingAtContext = LinageFootingAtContext(_ctx, getState())
		try enterRule(_localctx, 200, Cobol85Parser.RULE_linageFootingAt)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2210)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(2209)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(2212)
		 	try match(Cobol85Parser.FOOTING)
		 	setState(2214)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(2213)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(2218)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2216)
		 		try dataName()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2217)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinageLinesAtTopContext:ParserRuleContext {
		open func TOP() -> TerminalNode? { return getToken(Cobol85Parser.TOP, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linageLinesAtTop }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinageLinesAtTop(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinageLinesAtTop(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinageLinesAtTop(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinageLinesAtTop(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linageLinesAtTop() throws -> LinageLinesAtTopContext {
		var _localctx: LinageLinesAtTopContext = LinageLinesAtTopContext(_ctx, getState())
		try enterRule(_localctx, 202, Cobol85Parser.RULE_linageLinesAtTop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2221)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINES
		 	      return testSet
		 	 }()) {
		 		setState(2220)
		 		try match(Cobol85Parser.LINES)

		 	}

		 	setState(2224)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(2223)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(2226)
		 	try match(Cobol85Parser.TOP)
		 	setState(2229)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2227)
		 		try dataName()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2228)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinageLinesAtBottomContext:ParserRuleContext {
		open func BOTTOM() -> TerminalNode? { return getToken(Cobol85Parser.BOTTOM, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linageLinesAtBottom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinageLinesAtBottom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinageLinesAtBottom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinageLinesAtBottom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinageLinesAtBottom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linageLinesAtBottom() throws -> LinageLinesAtBottomContext {
		var _localctx: LinageLinesAtBottomContext = LinageLinesAtBottomContext(_ctx, getState())
		try enterRule(_localctx, 204, Cobol85Parser.RULE_linageLinesAtBottom)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2232)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINES
		 	      return testSet
		 	 }()) {
		 		setState(2231)
		 		try match(Cobol85Parser.LINES)

		 	}

		 	setState(2235)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(2234)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(2237)
		 	try match(Cobol85Parser.BOTTOM)
		 	setState(2240)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2238)
		 		try dataName()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2239)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordingModeClauseContext:ParserRuleContext {
		open func RECORDING() -> TerminalNode? { return getToken(Cobol85Parser.RECORDING, 0) }
		open func modeStatement() -> ModeStatementContext? {
			return getRuleContext(ModeStatementContext.self,0)
		}
		open func MODE() -> TerminalNode? { return getToken(Cobol85Parser.MODE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordingModeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordingModeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordingModeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordingModeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordingModeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordingModeClause() throws -> RecordingModeClauseContext {
		var _localctx: RecordingModeClauseContext = RecordingModeClauseContext(_ctx, getState())
		try enterRule(_localctx, 206, Cobol85Parser.RULE_recordingModeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2242)
		 	try match(Cobol85Parser.RECORDING)
		 	setState(2244)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MODE
		 	      return testSet
		 	 }()) {
		 		setState(2243)
		 		try match(Cobol85Parser.MODE)

		 	}

		 	setState(2247)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2246)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2249)
		 	try modeStatement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ModeStatementContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_modeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterModeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitModeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitModeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitModeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func modeStatement() throws -> ModeStatementContext {
		var _localctx: ModeStatementContext = ModeStatementContext(_ctx, getState())
		try enterRule(_localctx, 208, Cobol85Parser.RULE_modeStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2251)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CodeSetClauseContext:ParserRuleContext {
		open func CODE_SET() -> TerminalNode? { return getToken(Cobol85Parser.CODE_SET, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_codeSetClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCodeSetClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCodeSetClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCodeSetClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCodeSetClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func codeSetClause() throws -> CodeSetClauseContext {
		var _localctx: CodeSetClauseContext = CodeSetClauseContext(_ctx, getState())
		try enterRule(_localctx, 210, Cobol85Parser.RULE_codeSetClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2253)
		 	try match(Cobol85Parser.CODE_SET)
		 	setState(2255)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2254)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2257)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportClauseContext:ParserRuleContext {
		open func REPORT() -> TerminalNode? { return getToken(Cobol85Parser.REPORT, 0) }
		open func REPORTS() -> TerminalNode? { return getToken(Cobol85Parser.REPORTS, 0) }
		open func reportName() -> Array<ReportNameContext> {
			return getRuleContexts(ReportNameContext.self)
		}
		open func reportName(_ i: Int) -> ReportNameContext? {
			return getRuleContext(ReportNameContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportClause() throws -> ReportClauseContext {
		var _localctx: ReportClauseContext = ReportClauseContext(_ctx, getState())
		try enterRule(_localctx, 212, Cobol85Parser.RULE_reportClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2267)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.REPORT:
		 		setState(2259)
		 		try match(Cobol85Parser.REPORT)
		 		setState(2261)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2260)
		 			try match(Cobol85Parser.IS)

		 		}


		 		break

		 	case Cobol85Parser.REPORTS:
		 		setState(2263)
		 		try match(Cobol85Parser.REPORTS)
		 		setState(2265)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ARE
		 		      return testSet
		 		 }()) {
		 			setState(2264)
		 			try match(Cobol85Parser.ARE)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2270) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2269)
		 		try reportName()


		 		setState(2272); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataBaseSectionContext:ParserRuleContext {
		open func DATA_BASE() -> TerminalNode? { return getToken(Cobol85Parser.DATA_BASE, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataBaseSectionEntry() -> Array<DataBaseSectionEntryContext> {
			return getRuleContexts(DataBaseSectionEntryContext.self)
		}
		open func dataBaseSectionEntry(_ i: Int) -> DataBaseSectionEntryContext? {
			return getRuleContext(DataBaseSectionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataBaseSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataBaseSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataBaseSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataBaseSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataBaseSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataBaseSection() throws -> DataBaseSectionContext {
		var _localctx: DataBaseSectionContext = DataBaseSectionContext(_ctx, getState())
		try enterRule(_localctx, 214, Cobol85Parser.RULE_dataBaseSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2274)
		 	try match(Cobol85Parser.DATA_BASE)
		 	setState(2275)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2276)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2280)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2277)
		 		try dataBaseSectionEntry()


		 		setState(2282)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataBaseSectionEntryContext:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func literal() -> Array<LiteralContext> {
			return getRuleContexts(LiteralContext.self)
		}
		open func literal(_ i: Int) -> LiteralContext? {
			return getRuleContext(LiteralContext.self,i)
		}
		open func INVOKE() -> TerminalNode? { return getToken(Cobol85Parser.INVOKE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataBaseSectionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataBaseSectionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataBaseSectionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataBaseSectionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataBaseSectionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataBaseSectionEntry() throws -> DataBaseSectionEntryContext {
		var _localctx: DataBaseSectionEntryContext = DataBaseSectionEntryContext(_ctx, getState())
		try enterRule(_localctx, 216, Cobol85Parser.RULE_dataBaseSectionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2283)
		 	try integerLiteral()
		 	setState(2284)
		 	try literal()
		 	setState(2285)
		 	try match(Cobol85Parser.INVOKE)
		 	setState(2286)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WorkingStorageSectionContext:ParserRuleContext {
		open func WORKING_STORAGE() -> TerminalNode? { return getToken(Cobol85Parser.WORKING_STORAGE, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataDescriptionEntry() -> Array<DataDescriptionEntryContext> {
			return getRuleContexts(DataDescriptionEntryContext.self)
		}
		open func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
			return getRuleContext(DataDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_workingStorageSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWorkingStorageSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWorkingStorageSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWorkingStorageSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWorkingStorageSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func workingStorageSection() throws -> WorkingStorageSectionContext {
		var _localctx: WorkingStorageSectionContext = WorkingStorageSectionContext(_ctx, getState())
		try enterRule(_localctx, 218, Cobol85Parser.RULE_workingStorageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2288)
		 	try match(Cobol85Parser.WORKING_STORAGE)
		 	setState(2289)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2290)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2294)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.EXECSQLLINE]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2291)
		 		try dataDescriptionEntry()


		 		setState(2296)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LinkageSectionContext:ParserRuleContext {
		open func LINKAGE() -> TerminalNode? { return getToken(Cobol85Parser.LINKAGE, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataDescriptionEntry() -> Array<DataDescriptionEntryContext> {
			return getRuleContexts(DataDescriptionEntryContext.self)
		}
		open func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
			return getRuleContext(DataDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_linkageSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLinkageSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLinkageSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLinkageSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLinkageSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func linkageSection() throws -> LinkageSectionContext {
		var _localctx: LinkageSectionContext = LinkageSectionContext(_ctx, getState())
		try enterRule(_localctx, 220, Cobol85Parser.RULE_linkageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2297)
		 	try match(Cobol85Parser.LINKAGE)
		 	setState(2298)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2299)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2303)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.EXECSQLLINE]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2300)
		 		try dataDescriptionEntry()


		 		setState(2305)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommunicationSectionContext:ParserRuleContext {
		open func COMMUNICATION() -> TerminalNode? { return getToken(Cobol85Parser.COMMUNICATION, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func communicationDescriptionEntry() -> Array<CommunicationDescriptionEntryContext> {
			return getRuleContexts(CommunicationDescriptionEntryContext.self)
		}
		open func communicationDescriptionEntry(_ i: Int) -> CommunicationDescriptionEntryContext? {
			return getRuleContext(CommunicationDescriptionEntryContext.self,i)
		}
		open func dataDescriptionEntry() -> Array<DataDescriptionEntryContext> {
			return getRuleContexts(DataDescriptionEntryContext.self)
		}
		open func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
			return getRuleContext(DataDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_communicationSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommunicationSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommunicationSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommunicationSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommunicationSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func communicationSection() throws -> CommunicationSectionContext {
		var _localctx: CommunicationSectionContext = CommunicationSectionContext(_ctx, getState())
		try enterRule(_localctx, 222, Cobol85Parser.RULE_communicationSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2306)
		 	try match(Cobol85Parser.COMMUNICATION)
		 	setState(2307)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2308)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2313)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CD
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.EXECSQLLINE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2311)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.CD:
		 			setState(2309)
		 			try communicationDescriptionEntry()

		 			break
		 		case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 		case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 		case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 		case Cobol85Parser.INTEGERLITERAL:fallthrough
		 		case Cobol85Parser.EXECSQLLINE:
		 			setState(2310)
		 			try dataDescriptionEntry()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2315)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommunicationDescriptionEntryContext:ParserRuleContext {
		open func communicationDescriptionEntryFormat1() -> CommunicationDescriptionEntryFormat1Context? {
			return getRuleContext(CommunicationDescriptionEntryFormat1Context.self,0)
		}
		open func communicationDescriptionEntryFormat2() -> CommunicationDescriptionEntryFormat2Context? {
			return getRuleContext(CommunicationDescriptionEntryFormat2Context.self,0)
		}
		open func communicationDescriptionEntryFormat3() -> CommunicationDescriptionEntryFormat3Context? {
			return getRuleContext(CommunicationDescriptionEntryFormat3Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_communicationDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommunicationDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommunicationDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommunicationDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommunicationDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func communicationDescriptionEntry() throws -> CommunicationDescriptionEntryContext {
		var _localctx: CommunicationDescriptionEntryContext = CommunicationDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 224, Cobol85Parser.RULE_communicationDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2319)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,239, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2316)
		 		try communicationDescriptionEntryFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2317)
		 		try communicationDescriptionEntryFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2318)
		 		try communicationDescriptionEntryFormat3()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommunicationDescriptionEntryFormat1Context:ParserRuleContext {
		open func CD() -> TerminalNode? { return getToken(Cobol85Parser.CD, 0) }
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func INITIAL() -> TerminalNode? { return getToken(Cobol85Parser.INITIAL, 0) }
		open func dataDescName() -> Array<DataDescNameContext> {
			return getRuleContexts(DataDescNameContext.self)
		}
		open func dataDescName(_ i: Int) -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,i)
		}
		open func symbolicQueueClause() -> Array<SymbolicQueueClauseContext> {
			return getRuleContexts(SymbolicQueueClauseContext.self)
		}
		open func symbolicQueueClause(_ i: Int) -> SymbolicQueueClauseContext? {
			return getRuleContext(SymbolicQueueClauseContext.self,i)
		}
		open func symbolicSubQueueClause() -> Array<SymbolicSubQueueClauseContext> {
			return getRuleContexts(SymbolicSubQueueClauseContext.self)
		}
		open func symbolicSubQueueClause(_ i: Int) -> SymbolicSubQueueClauseContext? {
			return getRuleContext(SymbolicSubQueueClauseContext.self,i)
		}
		open func messageDateClause() -> Array<MessageDateClauseContext> {
			return getRuleContexts(MessageDateClauseContext.self)
		}
		open func messageDateClause(_ i: Int) -> MessageDateClauseContext? {
			return getRuleContext(MessageDateClauseContext.self,i)
		}
		open func messageTimeClause() -> Array<MessageTimeClauseContext> {
			return getRuleContexts(MessageTimeClauseContext.self)
		}
		open func messageTimeClause(_ i: Int) -> MessageTimeClauseContext? {
			return getRuleContext(MessageTimeClauseContext.self,i)
		}
		open func symbolicSourceClause() -> Array<SymbolicSourceClauseContext> {
			return getRuleContexts(SymbolicSourceClauseContext.self)
		}
		open func symbolicSourceClause(_ i: Int) -> SymbolicSourceClauseContext? {
			return getRuleContext(SymbolicSourceClauseContext.self,i)
		}
		open func textLengthClause() -> Array<TextLengthClauseContext> {
			return getRuleContexts(TextLengthClauseContext.self)
		}
		open func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
			return getRuleContext(TextLengthClauseContext.self,i)
		}
		open func endKeyClause() -> Array<EndKeyClauseContext> {
			return getRuleContexts(EndKeyClauseContext.self)
		}
		open func endKeyClause(_ i: Int) -> EndKeyClauseContext? {
			return getRuleContext(EndKeyClauseContext.self,i)
		}
		open func statusKeyClause() -> Array<StatusKeyClauseContext> {
			return getRuleContexts(StatusKeyClauseContext.self)
		}
		open func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
			return getRuleContext(StatusKeyClauseContext.self,i)
		}
		open func messageCountClause() -> Array<MessageCountClauseContext> {
			return getRuleContexts(MessageCountClauseContext.self)
		}
		open func messageCountClause(_ i: Int) -> MessageCountClauseContext? {
			return getRuleContext(MessageCountClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_communicationDescriptionEntryFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommunicationDescriptionEntryFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommunicationDescriptionEntryFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommunicationDescriptionEntryFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommunicationDescriptionEntryFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func communicationDescriptionEntryFormat1() throws -> CommunicationDescriptionEntryFormat1Context {
		var _localctx: CommunicationDescriptionEntryFormat1Context = CommunicationDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 226, Cobol85Parser.RULE_communicationDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2321)
		 	try match(Cobol85Parser.CD)
		 	setState(2322)
		 	try cdName()
		 	setState(2324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(2323)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(2327)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INITIAL
		 	      return testSet
		 	 }()) {
		 		setState(2326)
		 		try match(Cobol85Parser.INITIAL)

		 	}

		 	setState(2329)
		 	try match(Cobol85Parser.INPUT)
		 	setState(2344)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.COUNT,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.END,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FILLER,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MESSAGE,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUEUE,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SOURCE,Cobol85Parser.SP,Cobol85Parser.STATUS,Cobol85Parser.SUB_QUEUE_1,Cobol85Parser.SUB_QUEUE_2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SUB_QUEUE_3,Cobol85Parser.SYMBOL,Cobol85Parser.SYMBOLIC,Cobol85Parser.TASK,Cobol85Parser.TEXT,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }()) {
		 		setState(2342)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.COUNT:fallthrough
		 		case Cobol85Parser.END:fallthrough
		 		case Cobol85Parser.MESSAGE:fallthrough
		 		case Cobol85Parser.QUEUE:fallthrough
		 		case Cobol85Parser.SOURCE:fallthrough
		 		case Cobol85Parser.STATUS:fallthrough
		 		case Cobol85Parser.SUB_QUEUE_1:fallthrough
		 		case Cobol85Parser.SUB_QUEUE_2:fallthrough
		 		case Cobol85Parser.SUB_QUEUE_3:fallthrough
		 		case Cobol85Parser.SYMBOLIC:fallthrough
		 		case Cobol85Parser.TEXT:
		 			setState(2339)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,242, _ctx)) {
		 			case 1:
		 				setState(2330)
		 				try symbolicQueueClause()

		 				break
		 			case 2:
		 				setState(2331)
		 				try symbolicSubQueueClause()

		 				break
		 			case 3:
		 				setState(2332)
		 				try messageDateClause()

		 				break
		 			case 4:
		 				setState(2333)
		 				try messageTimeClause()

		 				break
		 			case 5:
		 				setState(2334)
		 				try symbolicSourceClause()

		 				break
		 			case 6:
		 				setState(2335)
		 				try textLengthClause()

		 				break
		 			case 7:
		 				setState(2336)
		 				try endKeyClause()

		 				break
		 			case 8:
		 				setState(2337)
		 				try statusKeyClause()

		 				break
		 			case 9:
		 				setState(2338)
		 				try messageCountClause()

		 				break
		 			default: break
		 			}

		 			break
		 		case Cobol85Parser.ABORT:fallthrough
		 		case Cobol85Parser.APOST:fallthrough
		 		case Cobol85Parser.ARITH:fallthrough
		 		case Cobol85Parser.AS:fallthrough
		 		case Cobol85Parser.ASCII:fallthrough
		 		case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 		case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 		case Cobol85Parser.ATTRIBUTE:fallthrough
		 		case Cobol85Parser.AUTO:fallthrough
		 		case Cobol85Parser.AUTO_SKIP:fallthrough
		 		case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 		case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 		case Cobol85Parser.BEEP:fallthrough
		 		case Cobol85Parser.BELL:fallthrough
		 		case Cobol85Parser.BIT:fallthrough
		 		case Cobol85Parser.BLINK:fallthrough
		 		case Cobol85Parser.BOUNDS:fallthrough
		 		case Cobol85Parser.CAPABLE:fallthrough
		 		case Cobol85Parser.CCSVERSION:fallthrough
		 		case Cobol85Parser.CHANGED:fallthrough
		 		case Cobol85Parser.CHANNEL:fallthrough
		 		case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 		case Cobol85Parser.COBOL:fallthrough
		 		case Cobol85Parser.CODEPAGE:fallthrough
		 		case Cobol85Parser.COMMITMENT:fallthrough
		 		case Cobol85Parser.CONTROL_POINT:fallthrough
		 		case Cobol85Parser.CONVENTION:fallthrough
		 		case Cobol85Parser.CRUNCH:fallthrough
		 		case Cobol85Parser.CURSOR:fallthrough
		 		case Cobol85Parser.DEFAULT:fallthrough
		 		case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 		case Cobol85Parser.DEFINITION:fallthrough
		 		case Cobol85Parser.DFHRESP:fallthrough
		 		case Cobol85Parser.DFHVALUE:fallthrough
		 		case Cobol85Parser.DISK:fallthrough
		 		case Cobol85Parser.DONTCARE:fallthrough
		 		case Cobol85Parser.DOUBLE:fallthrough
		 		case Cobol85Parser.EBCDIC:fallthrough
		 		case Cobol85Parser.EMPTY_CHECK:fallthrough
		 		case Cobol85Parser.ENTER:fallthrough
		 		case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 		case Cobol85Parser.ERASE:fallthrough
		 		case Cobol85Parser.EOL:fallthrough
		 		case Cobol85Parser.EOS:fallthrough
		 		case Cobol85Parser.ESCAPE:fallthrough
		 		case Cobol85Parser.EVENT:fallthrough
		 		case Cobol85Parser.EXCLUSIVE:fallthrough
		 		case Cobol85Parser.EXPORT:fallthrough
		 		case Cobol85Parser.EXTENDED:fallthrough
		 		case Cobol85Parser.FILLER:fallthrough
		 		case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 		case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 		case Cobol85Parser.FULL:fallthrough
		 		case Cobol85Parser.FUNCTIONNAME:fallthrough
		 		case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 		case Cobol85Parser.GRID:fallthrough
		 		case Cobol85Parser.HIGHLIGHT:fallthrough
		 		case Cobol85Parser.IMPLICIT:fallthrough
		 		case Cobol85Parser.IMPORT:fallthrough
		 		case Cobol85Parser.INTEGER:fallthrough
		 		case Cobol85Parser.KEPT:fallthrough
		 		case Cobol85Parser.LANGUAGE:fallthrough
		 		case Cobol85Parser.LB:fallthrough
		 		case Cobol85Parser.LD:fallthrough
		 		case Cobol85Parser.LEFTLINE:fallthrough
		 		case Cobol85Parser.LENGTH_CHECK:fallthrough
		 		case Cobol85Parser.LIB:fallthrough
		 		case Cobol85Parser.LIBACCESS:fallthrough
		 		case Cobol85Parser.LIBPARAMETER:fallthrough
		 		case Cobol85Parser.LIBRARY:fallthrough
		 		case Cobol85Parser.LIST:fallthrough
		 		case Cobol85Parser.LOCAL:fallthrough
		 		case Cobol85Parser.LONG_DATE:fallthrough
		 		case Cobol85Parser.LONG_TIME:fallthrough
		 		case Cobol85Parser.LOWER:fallthrough
		 		case Cobol85Parser.LOWLIGHT:fallthrough
		 		case Cobol85Parser.MMDDYYYY:fallthrough
		 		case Cobol85Parser.NAMED:fallthrough
		 		case Cobol85Parser.NATIONAL:fallthrough
		 		case Cobol85Parser.NETWORK:fallthrough
		 		case Cobol85Parser.NO_ECHO:fallthrough
		 		case Cobol85Parser.NOSEQ:fallthrough
		 		case Cobol85Parser.NUMERIC_DATE:fallthrough
		 		case Cobol85Parser.NUMERIC_TIME:fallthrough
		 		case Cobol85Parser.ODT:fallthrough
		 		case Cobol85Parser.OPTIMIZE:fallthrough
		 		case Cobol85Parser.ORDERLY:fallthrough
		 		case Cobol85Parser.OVERLINE:fallthrough
		 		case Cobol85Parser.OWN:fallthrough
		 		case Cobol85Parser.PASSWORD:fallthrough
		 		case Cobol85Parser.PORT:fallthrough
		 		case Cobol85Parser.PRINTER:fallthrough
		 		case Cobol85Parser.PRIVATE:fallthrough
		 		case Cobol85Parser.PROCESS:fallthrough
		 		case Cobol85Parser.PROGRAM:fallthrough
		 		case Cobol85Parser.PROMPT:fallthrough
		 		case Cobol85Parser.READER:fallthrough
		 		case Cobol85Parser.REMOTE:fallthrough
		 		case Cobol85Parser.REAL:fallthrough
		 		case Cobol85Parser.RECEIVED:fallthrough
		 		case Cobol85Parser.REF:fallthrough
		 		case Cobol85Parser.REMOVE:fallthrough
		 		case Cobol85Parser.REQUIRED:fallthrough
		 		case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 		case Cobol85Parser.SAVE:fallthrough
		 		case Cobol85Parser.SECURE:fallthrough
		 		case Cobol85Parser.SHARED:fallthrough
		 		case Cobol85Parser.SHAREDBYALL:fallthrough
		 		case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 		case Cobol85Parser.SHARING:fallthrough
		 		case Cobol85Parser.SHORT_DATE:fallthrough
		 		case Cobol85Parser.SP:fallthrough
		 		case Cobol85Parser.SYMBOL:fallthrough
		 		case Cobol85Parser.TASK:fallthrough
		 		case Cobol85Parser.THREAD:fallthrough
		 		case Cobol85Parser.THREAD_LOCAL:fallthrough
		 		case Cobol85Parser.TIMER:fallthrough
		 		case Cobol85Parser.TODAYS_DATE:fallthrough
		 		case Cobol85Parser.TODAYS_NAME:fallthrough
		 		case Cobol85Parser.TRUNCATED:fallthrough
		 		case Cobol85Parser.TYPEDEF:fallthrough
		 		case Cobol85Parser.UNDERLINE:fallthrough
		 		case Cobol85Parser.VIRTUAL:fallthrough
		 		case Cobol85Parser.WAIT:fallthrough
		 		case Cobol85Parser.XOPTS:fallthrough
		 		case Cobol85Parser.YEAR:fallthrough
		 		case Cobol85Parser.YYYYMMDD:fallthrough
		 		case Cobol85Parser.YYYYDDD:fallthrough
		 		case Cobol85Parser.ZERO_FILL:fallthrough
		 		case Cobol85Parser.IDENTIFIER:
		 			setState(2341)
		 			try dataDescName()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2346)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2347)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommunicationDescriptionEntryFormat2Context:ParserRuleContext {
		open func CD() -> TerminalNode? { return getToken(Cobol85Parser.CD, 0) }
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func destinationCountClause() -> Array<DestinationCountClauseContext> {
			return getRuleContexts(DestinationCountClauseContext.self)
		}
		open func destinationCountClause(_ i: Int) -> DestinationCountClauseContext? {
			return getRuleContext(DestinationCountClauseContext.self,i)
		}
		open func textLengthClause() -> Array<TextLengthClauseContext> {
			return getRuleContexts(TextLengthClauseContext.self)
		}
		open func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
			return getRuleContext(TextLengthClauseContext.self,i)
		}
		open func statusKeyClause() -> Array<StatusKeyClauseContext> {
			return getRuleContexts(StatusKeyClauseContext.self)
		}
		open func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
			return getRuleContext(StatusKeyClauseContext.self,i)
		}
		open func destinationTableClause() -> Array<DestinationTableClauseContext> {
			return getRuleContexts(DestinationTableClauseContext.self)
		}
		open func destinationTableClause(_ i: Int) -> DestinationTableClauseContext? {
			return getRuleContext(DestinationTableClauseContext.self,i)
		}
		open func errorKeyClause() -> Array<ErrorKeyClauseContext> {
			return getRuleContexts(ErrorKeyClauseContext.self)
		}
		open func errorKeyClause(_ i: Int) -> ErrorKeyClauseContext? {
			return getRuleContext(ErrorKeyClauseContext.self,i)
		}
		open func symbolicDestinationClause() -> Array<SymbolicDestinationClauseContext> {
			return getRuleContexts(SymbolicDestinationClauseContext.self)
		}
		open func symbolicDestinationClause(_ i: Int) -> SymbolicDestinationClauseContext? {
			return getRuleContext(SymbolicDestinationClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_communicationDescriptionEntryFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommunicationDescriptionEntryFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommunicationDescriptionEntryFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommunicationDescriptionEntryFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommunicationDescriptionEntryFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func communicationDescriptionEntryFormat2() throws -> CommunicationDescriptionEntryFormat2Context {
		var _localctx: CommunicationDescriptionEntryFormat2Context = CommunicationDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 228, Cobol85Parser.RULE_communicationDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2349)
		 	try match(Cobol85Parser.CD)
		 	setState(2350)
		 	try cdName()
		 	setState(2352)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(2351)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(2354)
		 	try match(Cobol85Parser.OUTPUT)
		 	setState(2363)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DESTINATION || _la == Cobol85Parser.ERROR
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.STATUS,Cobol85Parser.SYMBOLIC,Cobol85Parser.TEXT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 461)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2361)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,246, _ctx)) {
		 		case 1:
		 			setState(2355)
		 			try destinationCountClause()

		 			break
		 		case 2:
		 			setState(2356)
		 			try textLengthClause()

		 			break
		 		case 3:
		 			setState(2357)
		 			try statusKeyClause()

		 			break
		 		case 4:
		 			setState(2358)
		 			try destinationTableClause()

		 			break
		 		case 5:
		 			setState(2359)
		 			try errorKeyClause()

		 			break
		 		case 6:
		 			setState(2360)
		 			try symbolicDestinationClause()

		 			break
		 		default: break
		 		}

		 		setState(2365)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2366)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommunicationDescriptionEntryFormat3Context:ParserRuleContext {
		open func CD() -> TerminalNode? { return getToken(Cobol85Parser.CD, 0) }
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func INITIAL() -> TerminalNode? { return getToken(Cobol85Parser.INITIAL, 0) }
		open func I_O() -> TerminalNode? { return getToken(Cobol85Parser.I_O, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func dataDescName() -> Array<DataDescNameContext> {
			return getRuleContexts(DataDescNameContext.self)
		}
		open func dataDescName(_ i: Int) -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,i)
		}
		open func messageDateClause() -> Array<MessageDateClauseContext> {
			return getRuleContexts(MessageDateClauseContext.self)
		}
		open func messageDateClause(_ i: Int) -> MessageDateClauseContext? {
			return getRuleContext(MessageDateClauseContext.self,i)
		}
		open func messageTimeClause() -> Array<MessageTimeClauseContext> {
			return getRuleContexts(MessageTimeClauseContext.self)
		}
		open func messageTimeClause(_ i: Int) -> MessageTimeClauseContext? {
			return getRuleContext(MessageTimeClauseContext.self,i)
		}
		open func symbolicTerminalClause() -> Array<SymbolicTerminalClauseContext> {
			return getRuleContexts(SymbolicTerminalClauseContext.self)
		}
		open func symbolicTerminalClause(_ i: Int) -> SymbolicTerminalClauseContext? {
			return getRuleContext(SymbolicTerminalClauseContext.self,i)
		}
		open func textLengthClause() -> Array<TextLengthClauseContext> {
			return getRuleContexts(TextLengthClauseContext.self)
		}
		open func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
			return getRuleContext(TextLengthClauseContext.self,i)
		}
		open func endKeyClause() -> Array<EndKeyClauseContext> {
			return getRuleContexts(EndKeyClauseContext.self)
		}
		open func endKeyClause(_ i: Int) -> EndKeyClauseContext? {
			return getRuleContext(EndKeyClauseContext.self,i)
		}
		open func statusKeyClause() -> Array<StatusKeyClauseContext> {
			return getRuleContexts(StatusKeyClauseContext.self)
		}
		open func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
			return getRuleContext(StatusKeyClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_communicationDescriptionEntryFormat3 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommunicationDescriptionEntryFormat3(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommunicationDescriptionEntryFormat3(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommunicationDescriptionEntryFormat3(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommunicationDescriptionEntryFormat3(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func communicationDescriptionEntryFormat3() throws -> CommunicationDescriptionEntryFormat3Context {
		var _localctx: CommunicationDescriptionEntryFormat3Context = CommunicationDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 230, Cobol85Parser.RULE_communicationDescriptionEntryFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2368)
		 	try match(Cobol85Parser.CD)
		 	setState(2369)
		 	try cdName()
		 	setState(2371)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(2370)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(2373)
		 	try match(Cobol85Parser.INITIAL)
		 	setState(2374)
		 	try match(Cobol85Parser.I_O)
		 	setState(2386)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.END,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FILLER,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MESSAGE,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP,Cobol85Parser.STATUS]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.SYMBOLIC,Cobol85Parser.TASK,Cobol85Parser.TERMINAL,Cobol85Parser.TEXT,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }()) {
		 		setState(2384)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.END:fallthrough
		 		case Cobol85Parser.MESSAGE:fallthrough
		 		case Cobol85Parser.STATUS:fallthrough
		 		case Cobol85Parser.SYMBOLIC:fallthrough
		 		case Cobol85Parser.TERMINAL:fallthrough
		 		case Cobol85Parser.TEXT:
		 			setState(2381)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,249, _ctx)) {
		 			case 1:
		 				setState(2375)
		 				try messageDateClause()

		 				break
		 			case 2:
		 				setState(2376)
		 				try messageTimeClause()

		 				break
		 			case 3:
		 				setState(2377)
		 				try symbolicTerminalClause()

		 				break
		 			case 4:
		 				setState(2378)
		 				try textLengthClause()

		 				break
		 			case 5:
		 				setState(2379)
		 				try endKeyClause()

		 				break
		 			case 6:
		 				setState(2380)
		 				try statusKeyClause()

		 				break
		 			default: break
		 			}

		 			break
		 		case Cobol85Parser.ABORT:fallthrough
		 		case Cobol85Parser.APOST:fallthrough
		 		case Cobol85Parser.ARITH:fallthrough
		 		case Cobol85Parser.AS:fallthrough
		 		case Cobol85Parser.ASCII:fallthrough
		 		case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 		case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 		case Cobol85Parser.ATTRIBUTE:fallthrough
		 		case Cobol85Parser.AUTO:fallthrough
		 		case Cobol85Parser.AUTO_SKIP:fallthrough
		 		case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 		case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 		case Cobol85Parser.BEEP:fallthrough
		 		case Cobol85Parser.BELL:fallthrough
		 		case Cobol85Parser.BIT:fallthrough
		 		case Cobol85Parser.BLINK:fallthrough
		 		case Cobol85Parser.BOUNDS:fallthrough
		 		case Cobol85Parser.CAPABLE:fallthrough
		 		case Cobol85Parser.CCSVERSION:fallthrough
		 		case Cobol85Parser.CHANGED:fallthrough
		 		case Cobol85Parser.CHANNEL:fallthrough
		 		case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 		case Cobol85Parser.COBOL:fallthrough
		 		case Cobol85Parser.CODEPAGE:fallthrough
		 		case Cobol85Parser.COMMITMENT:fallthrough
		 		case Cobol85Parser.CONTROL_POINT:fallthrough
		 		case Cobol85Parser.CONVENTION:fallthrough
		 		case Cobol85Parser.CRUNCH:fallthrough
		 		case Cobol85Parser.CURSOR:fallthrough
		 		case Cobol85Parser.DEFAULT:fallthrough
		 		case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 		case Cobol85Parser.DEFINITION:fallthrough
		 		case Cobol85Parser.DFHRESP:fallthrough
		 		case Cobol85Parser.DFHVALUE:fallthrough
		 		case Cobol85Parser.DISK:fallthrough
		 		case Cobol85Parser.DONTCARE:fallthrough
		 		case Cobol85Parser.DOUBLE:fallthrough
		 		case Cobol85Parser.EBCDIC:fallthrough
		 		case Cobol85Parser.EMPTY_CHECK:fallthrough
		 		case Cobol85Parser.ENTER:fallthrough
		 		case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 		case Cobol85Parser.ERASE:fallthrough
		 		case Cobol85Parser.EOL:fallthrough
		 		case Cobol85Parser.EOS:fallthrough
		 		case Cobol85Parser.ESCAPE:fallthrough
		 		case Cobol85Parser.EVENT:fallthrough
		 		case Cobol85Parser.EXCLUSIVE:fallthrough
		 		case Cobol85Parser.EXPORT:fallthrough
		 		case Cobol85Parser.EXTENDED:fallthrough
		 		case Cobol85Parser.FILLER:fallthrough
		 		case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 		case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 		case Cobol85Parser.FULL:fallthrough
		 		case Cobol85Parser.FUNCTIONNAME:fallthrough
		 		case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 		case Cobol85Parser.GRID:fallthrough
		 		case Cobol85Parser.HIGHLIGHT:fallthrough
		 		case Cobol85Parser.IMPLICIT:fallthrough
		 		case Cobol85Parser.IMPORT:fallthrough
		 		case Cobol85Parser.INTEGER:fallthrough
		 		case Cobol85Parser.KEPT:fallthrough
		 		case Cobol85Parser.LANGUAGE:fallthrough
		 		case Cobol85Parser.LB:fallthrough
		 		case Cobol85Parser.LD:fallthrough
		 		case Cobol85Parser.LEFTLINE:fallthrough
		 		case Cobol85Parser.LENGTH_CHECK:fallthrough
		 		case Cobol85Parser.LIB:fallthrough
		 		case Cobol85Parser.LIBACCESS:fallthrough
		 		case Cobol85Parser.LIBPARAMETER:fallthrough
		 		case Cobol85Parser.LIBRARY:fallthrough
		 		case Cobol85Parser.LIST:fallthrough
		 		case Cobol85Parser.LOCAL:fallthrough
		 		case Cobol85Parser.LONG_DATE:fallthrough
		 		case Cobol85Parser.LONG_TIME:fallthrough
		 		case Cobol85Parser.LOWER:fallthrough
		 		case Cobol85Parser.LOWLIGHT:fallthrough
		 		case Cobol85Parser.MMDDYYYY:fallthrough
		 		case Cobol85Parser.NAMED:fallthrough
		 		case Cobol85Parser.NATIONAL:fallthrough
		 		case Cobol85Parser.NETWORK:fallthrough
		 		case Cobol85Parser.NO_ECHO:fallthrough
		 		case Cobol85Parser.NOSEQ:fallthrough
		 		case Cobol85Parser.NUMERIC_DATE:fallthrough
		 		case Cobol85Parser.NUMERIC_TIME:fallthrough
		 		case Cobol85Parser.ODT:fallthrough
		 		case Cobol85Parser.OPTIMIZE:fallthrough
		 		case Cobol85Parser.ORDERLY:fallthrough
		 		case Cobol85Parser.OVERLINE:fallthrough
		 		case Cobol85Parser.OWN:fallthrough
		 		case Cobol85Parser.PASSWORD:fallthrough
		 		case Cobol85Parser.PORT:fallthrough
		 		case Cobol85Parser.PRINTER:fallthrough
		 		case Cobol85Parser.PRIVATE:fallthrough
		 		case Cobol85Parser.PROCESS:fallthrough
		 		case Cobol85Parser.PROGRAM:fallthrough
		 		case Cobol85Parser.PROMPT:fallthrough
		 		case Cobol85Parser.READER:fallthrough
		 		case Cobol85Parser.REMOTE:fallthrough
		 		case Cobol85Parser.REAL:fallthrough
		 		case Cobol85Parser.RECEIVED:fallthrough
		 		case Cobol85Parser.REF:fallthrough
		 		case Cobol85Parser.REMOVE:fallthrough
		 		case Cobol85Parser.REQUIRED:fallthrough
		 		case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 		case Cobol85Parser.SAVE:fallthrough
		 		case Cobol85Parser.SECURE:fallthrough
		 		case Cobol85Parser.SHARED:fallthrough
		 		case Cobol85Parser.SHAREDBYALL:fallthrough
		 		case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 		case Cobol85Parser.SHARING:fallthrough
		 		case Cobol85Parser.SHORT_DATE:fallthrough
		 		case Cobol85Parser.SP:fallthrough
		 		case Cobol85Parser.SYMBOL:fallthrough
		 		case Cobol85Parser.TASK:fallthrough
		 		case Cobol85Parser.THREAD:fallthrough
		 		case Cobol85Parser.THREAD_LOCAL:fallthrough
		 		case Cobol85Parser.TIMER:fallthrough
		 		case Cobol85Parser.TODAYS_DATE:fallthrough
		 		case Cobol85Parser.TODAYS_NAME:fallthrough
		 		case Cobol85Parser.TRUNCATED:fallthrough
		 		case Cobol85Parser.TYPEDEF:fallthrough
		 		case Cobol85Parser.UNDERLINE:fallthrough
		 		case Cobol85Parser.VIRTUAL:fallthrough
		 		case Cobol85Parser.WAIT:fallthrough
		 		case Cobol85Parser.XOPTS:fallthrough
		 		case Cobol85Parser.YEAR:fallthrough
		 		case Cobol85Parser.YYYYMMDD:fallthrough
		 		case Cobol85Parser.YYYYDDD:fallthrough
		 		case Cobol85Parser.ZERO_FILL:fallthrough
		 		case Cobol85Parser.IDENTIFIER:
		 			setState(2383)
		 			try dataDescName()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2388)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2389)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DestinationCountClauseContext:ParserRuleContext {
		open func DESTINATION() -> TerminalNode? { return getToken(Cobol85Parser.DESTINATION, 0) }
		open func COUNT() -> TerminalNode? { return getToken(Cobol85Parser.COUNT, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_destinationCountClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDestinationCountClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDestinationCountClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDestinationCountClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDestinationCountClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func destinationCountClause() throws -> DestinationCountClauseContext {
		var _localctx: DestinationCountClauseContext = DestinationCountClauseContext(_ctx, getState())
		try enterRule(_localctx, 232, Cobol85Parser.RULE_destinationCountClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2391)
		 	try match(Cobol85Parser.DESTINATION)
		 	setState(2392)
		 	try match(Cobol85Parser.COUNT)
		 	setState(2394)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2393)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2396)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DestinationTableClauseContext:ParserRuleContext {
		open func DESTINATION() -> TerminalNode? { return getToken(Cobol85Parser.DESTINATION, 0) }
		open func TABLE() -> TerminalNode? { return getToken(Cobol85Parser.TABLE, 0) }
		open func OCCURS() -> TerminalNode? { return getToken(Cobol85Parser.OCCURS, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func TIMES() -> TerminalNode? { return getToken(Cobol85Parser.TIMES, 0) }
		open func INDEXED() -> TerminalNode? { return getToken(Cobol85Parser.INDEXED, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func indexName() -> Array<IndexNameContext> {
			return getRuleContexts(IndexNameContext.self)
		}
		open func indexName(_ i: Int) -> IndexNameContext? {
			return getRuleContext(IndexNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_destinationTableClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDestinationTableClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDestinationTableClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDestinationTableClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDestinationTableClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func destinationTableClause() throws -> DestinationTableClauseContext {
		var _localctx: DestinationTableClauseContext = DestinationTableClauseContext(_ctx, getState())
		try enterRule(_localctx, 234, Cobol85Parser.RULE_destinationTableClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2398)
		 	try match(Cobol85Parser.DESTINATION)
		 	setState(2399)
		 	try match(Cobol85Parser.TABLE)
		 	setState(2400)
		 	try match(Cobol85Parser.OCCURS)
		 	setState(2401)
		 	try integerLiteral()
		 	setState(2402)
		 	try match(Cobol85Parser.TIMES)
		 	setState(2410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INDEXED
		 	      return testSet
		 	 }()) {
		 		setState(2403)
		 		try match(Cobol85Parser.INDEXED)
		 		setState(2404)
		 		try match(Cobol85Parser.BY)
		 		setState(2406) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2405)
		 			try indexName()


		 			setState(2408); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 		      return testSet
		 		 }())

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EndKeyClauseContext:ParserRuleContext {
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_endKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEndKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEndKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEndKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEndKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func endKeyClause() throws -> EndKeyClauseContext {
		var _localctx: EndKeyClauseContext = EndKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 236, Cobol85Parser.RULE_endKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2412)
		 	try match(Cobol85Parser.END)
		 	setState(2413)
		 	try match(Cobol85Parser.KEY)
		 	setState(2415)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2414)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2417)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ErrorKeyClauseContext:ParserRuleContext {
		open func ERROR() -> TerminalNode? { return getToken(Cobol85Parser.ERROR, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_errorKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterErrorKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitErrorKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitErrorKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitErrorKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func errorKeyClause() throws -> ErrorKeyClauseContext {
		var _localctx: ErrorKeyClauseContext = ErrorKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 238, Cobol85Parser.RULE_errorKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2419)
		 	try match(Cobol85Parser.ERROR)
		 	setState(2420)
		 	try match(Cobol85Parser.KEY)
		 	setState(2422)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2421)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2424)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MessageCountClauseContext:ParserRuleContext {
		open func COUNT() -> TerminalNode? { return getToken(Cobol85Parser.COUNT, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.MESSAGE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_messageCountClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMessageCountClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMessageCountClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMessageCountClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMessageCountClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func messageCountClause() throws -> MessageCountClauseContext {
		var _localctx: MessageCountClauseContext = MessageCountClauseContext(_ctx, getState())
		try enterRule(_localctx, 240, Cobol85Parser.RULE_messageCountClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2427)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MESSAGE
		 	      return testSet
		 	 }()) {
		 		setState(2426)
		 		try match(Cobol85Parser.MESSAGE)

		 	}

		 	setState(2429)
		 	try match(Cobol85Parser.COUNT)
		 	setState(2431)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2430)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2433)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MessageDateClauseContext:ParserRuleContext {
		open func MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.MESSAGE, 0) }
		open func DATE() -> TerminalNode? { return getToken(Cobol85Parser.DATE, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_messageDateClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMessageDateClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMessageDateClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMessageDateClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMessageDateClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func messageDateClause() throws -> MessageDateClauseContext {
		var _localctx: MessageDateClauseContext = MessageDateClauseContext(_ctx, getState())
		try enterRule(_localctx, 242, Cobol85Parser.RULE_messageDateClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2435)
		 	try match(Cobol85Parser.MESSAGE)
		 	setState(2436)
		 	try match(Cobol85Parser.DATE)
		 	setState(2438)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2437)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2440)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MessageTimeClauseContext:ParserRuleContext {
		open func MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.MESSAGE, 0) }
		open func TIME() -> TerminalNode? { return getToken(Cobol85Parser.TIME, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_messageTimeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMessageTimeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMessageTimeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMessageTimeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMessageTimeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func messageTimeClause() throws -> MessageTimeClauseContext {
		var _localctx: MessageTimeClauseContext = MessageTimeClauseContext(_ctx, getState())
		try enterRule(_localctx, 244, Cobol85Parser.RULE_messageTimeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2442)
		 	try match(Cobol85Parser.MESSAGE)
		 	setState(2443)
		 	try match(Cobol85Parser.TIME)
		 	setState(2445)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2444)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2447)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StatusKeyClauseContext:ParserRuleContext {
		open func STATUS() -> TerminalNode? { return getToken(Cobol85Parser.STATUS, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_statusKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStatusKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStatusKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStatusKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStatusKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func statusKeyClause() throws -> StatusKeyClauseContext {
		var _localctx: StatusKeyClauseContext = StatusKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 246, Cobol85Parser.RULE_statusKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2449)
		 	try match(Cobol85Parser.STATUS)
		 	setState(2450)
		 	try match(Cobol85Parser.KEY)
		 	setState(2452)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2451)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2454)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicDestinationClauseContext:ParserRuleContext {
		open func DESTINATION() -> TerminalNode? { return getToken(Cobol85Parser.DESTINATION, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicDestinationClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicDestinationClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicDestinationClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicDestinationClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicDestinationClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicDestinationClause() throws -> SymbolicDestinationClauseContext {
		var _localctx: SymbolicDestinationClauseContext = SymbolicDestinationClauseContext(_ctx, getState())
		try enterRule(_localctx, 248, Cobol85Parser.RULE_symbolicDestinationClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2457)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYMBOLIC
		 	      return testSet
		 	 }()) {
		 		setState(2456)
		 		try match(Cobol85Parser.SYMBOLIC)

		 	}

		 	setState(2459)
		 	try match(Cobol85Parser.DESTINATION)
		 	setState(2461)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2460)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2463)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicQueueClauseContext:ParserRuleContext {
		open func QUEUE() -> TerminalNode? { return getToken(Cobol85Parser.QUEUE, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicQueueClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicQueueClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicQueueClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicQueueClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicQueueClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicQueueClause() throws -> SymbolicQueueClauseContext {
		var _localctx: SymbolicQueueClauseContext = SymbolicQueueClauseContext(_ctx, getState())
		try enterRule(_localctx, 250, Cobol85Parser.RULE_symbolicQueueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2466)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYMBOLIC
		 	      return testSet
		 	 }()) {
		 		setState(2465)
		 		try match(Cobol85Parser.SYMBOLIC)

		 	}

		 	setState(2468)
		 	try match(Cobol85Parser.QUEUE)
		 	setState(2470)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2469)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2472)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicSourceClauseContext:ParserRuleContext {
		open func SOURCE() -> TerminalNode? { return getToken(Cobol85Parser.SOURCE, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicSourceClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicSourceClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicSourceClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicSourceClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicSourceClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicSourceClause() throws -> SymbolicSourceClauseContext {
		var _localctx: SymbolicSourceClauseContext = SymbolicSourceClauseContext(_ctx, getState())
		try enterRule(_localctx, 252, Cobol85Parser.RULE_symbolicSourceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2475)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYMBOLIC
		 	      return testSet
		 	 }()) {
		 		setState(2474)
		 		try match(Cobol85Parser.SYMBOLIC)

		 	}

		 	setState(2477)
		 	try match(Cobol85Parser.SOURCE)
		 	setState(2479)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2478)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2481)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicTerminalClauseContext:ParserRuleContext {
		open func TERMINAL() -> TerminalNode? { return getToken(Cobol85Parser.TERMINAL, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicTerminalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicTerminalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicTerminalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicTerminalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicTerminalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicTerminalClause() throws -> SymbolicTerminalClauseContext {
		var _localctx: SymbolicTerminalClauseContext = SymbolicTerminalClauseContext(_ctx, getState())
		try enterRule(_localctx, 254, Cobol85Parser.RULE_symbolicTerminalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2484)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYMBOLIC
		 	      return testSet
		 	 }()) {
		 		setState(2483)
		 		try match(Cobol85Parser.SYMBOLIC)

		 	}

		 	setState(2486)
		 	try match(Cobol85Parser.TERMINAL)
		 	setState(2488)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2487)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2490)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicSubQueueClauseContext:ParserRuleContext {
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func SUB_QUEUE_1() -> TerminalNode? { return getToken(Cobol85Parser.SUB_QUEUE_1, 0) }
		open func SUB_QUEUE_2() -> TerminalNode? { return getToken(Cobol85Parser.SUB_QUEUE_2, 0) }
		open func SUB_QUEUE_3() -> TerminalNode? { return getToken(Cobol85Parser.SUB_QUEUE_3, 0) }
		open func SYMBOLIC() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOLIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicSubQueueClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicSubQueueClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicSubQueueClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicSubQueueClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicSubQueueClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicSubQueueClause() throws -> SymbolicSubQueueClauseContext {
		var _localctx: SymbolicSubQueueClauseContext = SymbolicSubQueueClauseContext(_ctx, getState())
		try enterRule(_localctx, 256, Cobol85Parser.RULE_symbolicSubQueueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2493)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYMBOLIC
		 	      return testSet
		 	 }()) {
		 		setState(2492)
		 		try match(Cobol85Parser.SYMBOLIC)

		 	}

		 	setState(2495)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.SUB_QUEUE_1,Cobol85Parser.SUB_QUEUE_2,Cobol85Parser.SUB_QUEUE_3]
		 	    return  Utils.testBitLeftShiftArray(testArray, 464)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2497)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2496)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2499)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TextLengthClauseContext:ParserRuleContext {
		open func TEXT() -> TerminalNode? { return getToken(Cobol85Parser.TEXT, 0) }
		open func LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH, 0) }
		open func dataDescName() -> DataDescNameContext? {
			return getRuleContext(DataDescNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_textLengthClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterTextLengthClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitTextLengthClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitTextLengthClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitTextLengthClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func textLengthClause() throws -> TextLengthClauseContext {
		var _localctx: TextLengthClauseContext = TextLengthClauseContext(_ctx, getState())
		try enterRule(_localctx, 258, Cobol85Parser.RULE_textLengthClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2501)
		 	try match(Cobol85Parser.TEXT)
		 	setState(2502)
		 	try match(Cobol85Parser.LENGTH)
		 	setState(2504)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2503)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2506)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LocalStorageSectionContext:ParserRuleContext {
		open func LOCAL_STORAGE() -> TerminalNode? { return getToken(Cobol85Parser.LOCAL_STORAGE, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func LD() -> TerminalNode? { return getToken(Cobol85Parser.LD, 0) }
		open func localName() -> LocalNameContext? {
			return getRuleContext(LocalNameContext.self,0)
		}
		open func dataDescriptionEntry() -> Array<DataDescriptionEntryContext> {
			return getRuleContexts(DataDescriptionEntryContext.self)
		}
		open func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
			return getRuleContext(DataDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_localStorageSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLocalStorageSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLocalStorageSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLocalStorageSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLocalStorageSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func localStorageSection() throws -> LocalStorageSectionContext {
		var _localctx: LocalStorageSectionContext = LocalStorageSectionContext(_ctx, getState())
		try enterRule(_localctx, 260, Cobol85Parser.RULE_localStorageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2508)
		 	try match(Cobol85Parser.LOCAL_STORAGE)
		 	setState(2509)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2510)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2515)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LD
		 	      return testSet
		 	 }()) {
		 		setState(2511)
		 		try match(Cobol85Parser.LD)
		 		setState(2512)
		 		try localName()
		 		setState(2513)
		 		try match(Cobol85Parser.DOT_FS)

		 	}

		 	setState(2520)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.EXECSQLLINE]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2517)
		 		try dataDescriptionEntry()


		 		setState(2522)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenSectionContext:ParserRuleContext {
		open func SCREEN() -> TerminalNode? { return getToken(Cobol85Parser.SCREEN, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func screenDescriptionEntry() -> Array<ScreenDescriptionEntryContext> {
			return getRuleContexts(ScreenDescriptionEntryContext.self)
		}
		open func screenDescriptionEntry(_ i: Int) -> ScreenDescriptionEntryContext? {
			return getRuleContext(ScreenDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenSection() throws -> ScreenSectionContext {
		var _localctx: ScreenSectionContext = ScreenSectionContext(_ctx, getState())
		try enterRule(_localctx, 262, Cobol85Parser.RULE_screenSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2523)
		 	try match(Cobol85Parser.SCREEN)
		 	setState(2524)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2525)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2529)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INTEGERLITERAL
		 	      return testSet
		 	 }()) {
		 		setState(2526)
		 		try screenDescriptionEntry()


		 		setState(2531)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionEntryContext:ParserRuleContext {
		open func INTEGERLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.INTEGERLITERAL, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func FILLER() -> TerminalNode? { return getToken(Cobol85Parser.FILLER, 0) }
		open func screenName() -> ScreenNameContext? {
			return getRuleContext(ScreenNameContext.self,0)
		}
		open func screenDescriptionBlankClause() -> Array<ScreenDescriptionBlankClauseContext> {
			return getRuleContexts(ScreenDescriptionBlankClauseContext.self)
		}
		open func screenDescriptionBlankClause(_ i: Int) -> ScreenDescriptionBlankClauseContext? {
			return getRuleContext(ScreenDescriptionBlankClauseContext.self,i)
		}
		open func screenDescriptionBellClause() -> Array<ScreenDescriptionBellClauseContext> {
			return getRuleContexts(ScreenDescriptionBellClauseContext.self)
		}
		open func screenDescriptionBellClause(_ i: Int) -> ScreenDescriptionBellClauseContext? {
			return getRuleContext(ScreenDescriptionBellClauseContext.self,i)
		}
		open func screenDescriptionBlinkClause() -> Array<ScreenDescriptionBlinkClauseContext> {
			return getRuleContexts(ScreenDescriptionBlinkClauseContext.self)
		}
		open func screenDescriptionBlinkClause(_ i: Int) -> ScreenDescriptionBlinkClauseContext? {
			return getRuleContext(ScreenDescriptionBlinkClauseContext.self,i)
		}
		open func screenDescriptionEraseClause() -> Array<ScreenDescriptionEraseClauseContext> {
			return getRuleContexts(ScreenDescriptionEraseClauseContext.self)
		}
		open func screenDescriptionEraseClause(_ i: Int) -> ScreenDescriptionEraseClauseContext? {
			return getRuleContext(ScreenDescriptionEraseClauseContext.self,i)
		}
		open func screenDescriptionLightClause() -> Array<ScreenDescriptionLightClauseContext> {
			return getRuleContexts(ScreenDescriptionLightClauseContext.self)
		}
		open func screenDescriptionLightClause(_ i: Int) -> ScreenDescriptionLightClauseContext? {
			return getRuleContext(ScreenDescriptionLightClauseContext.self,i)
		}
		open func screenDescriptionGridClause() -> Array<ScreenDescriptionGridClauseContext> {
			return getRuleContexts(ScreenDescriptionGridClauseContext.self)
		}
		open func screenDescriptionGridClause(_ i: Int) -> ScreenDescriptionGridClauseContext? {
			return getRuleContext(ScreenDescriptionGridClauseContext.self,i)
		}
		open func screenDescriptionReverseVideoClause() -> Array<ScreenDescriptionReverseVideoClauseContext> {
			return getRuleContexts(ScreenDescriptionReverseVideoClauseContext.self)
		}
		open func screenDescriptionReverseVideoClause(_ i: Int) -> ScreenDescriptionReverseVideoClauseContext? {
			return getRuleContext(ScreenDescriptionReverseVideoClauseContext.self,i)
		}
		open func screenDescriptionUnderlineClause() -> Array<ScreenDescriptionUnderlineClauseContext> {
			return getRuleContexts(ScreenDescriptionUnderlineClauseContext.self)
		}
		open func screenDescriptionUnderlineClause(_ i: Int) -> ScreenDescriptionUnderlineClauseContext? {
			return getRuleContext(ScreenDescriptionUnderlineClauseContext.self,i)
		}
		open func screenDescriptionSizeClause() -> Array<ScreenDescriptionSizeClauseContext> {
			return getRuleContexts(ScreenDescriptionSizeClauseContext.self)
		}
		open func screenDescriptionSizeClause(_ i: Int) -> ScreenDescriptionSizeClauseContext? {
			return getRuleContext(ScreenDescriptionSizeClauseContext.self,i)
		}
		open func screenDescriptionLineClause() -> Array<ScreenDescriptionLineClauseContext> {
			return getRuleContexts(ScreenDescriptionLineClauseContext.self)
		}
		open func screenDescriptionLineClause(_ i: Int) -> ScreenDescriptionLineClauseContext? {
			return getRuleContext(ScreenDescriptionLineClauseContext.self,i)
		}
		open func screenDescriptionColumnClause() -> Array<ScreenDescriptionColumnClauseContext> {
			return getRuleContexts(ScreenDescriptionColumnClauseContext.self)
		}
		open func screenDescriptionColumnClause(_ i: Int) -> ScreenDescriptionColumnClauseContext? {
			return getRuleContext(ScreenDescriptionColumnClauseContext.self,i)
		}
		open func screenDescriptionForegroundColorClause() -> Array<ScreenDescriptionForegroundColorClauseContext> {
			return getRuleContexts(ScreenDescriptionForegroundColorClauseContext.self)
		}
		open func screenDescriptionForegroundColorClause(_ i: Int) -> ScreenDescriptionForegroundColorClauseContext? {
			return getRuleContext(ScreenDescriptionForegroundColorClauseContext.self,i)
		}
		open func screenDescriptionBackgroundColorClause() -> Array<ScreenDescriptionBackgroundColorClauseContext> {
			return getRuleContexts(ScreenDescriptionBackgroundColorClauseContext.self)
		}
		open func screenDescriptionBackgroundColorClause(_ i: Int) -> ScreenDescriptionBackgroundColorClauseContext? {
			return getRuleContext(ScreenDescriptionBackgroundColorClauseContext.self,i)
		}
		open func screenDescriptionControlClause() -> Array<ScreenDescriptionControlClauseContext> {
			return getRuleContexts(ScreenDescriptionControlClauseContext.self)
		}
		open func screenDescriptionControlClause(_ i: Int) -> ScreenDescriptionControlClauseContext? {
			return getRuleContext(ScreenDescriptionControlClauseContext.self,i)
		}
		open func screenDescriptionValueClause() -> Array<ScreenDescriptionValueClauseContext> {
			return getRuleContexts(ScreenDescriptionValueClauseContext.self)
		}
		open func screenDescriptionValueClause(_ i: Int) -> ScreenDescriptionValueClauseContext? {
			return getRuleContext(ScreenDescriptionValueClauseContext.self,i)
		}
		open func screenDescriptionPictureClause() -> Array<ScreenDescriptionPictureClauseContext> {
			return getRuleContexts(ScreenDescriptionPictureClauseContext.self)
		}
		open func screenDescriptionPictureClause(_ i: Int) -> ScreenDescriptionPictureClauseContext? {
			return getRuleContext(ScreenDescriptionPictureClauseContext.self,i)
		}
		open func screenDescriptionUsageClause() -> Array<ScreenDescriptionUsageClauseContext> {
			return getRuleContexts(ScreenDescriptionUsageClauseContext.self)
		}
		open func screenDescriptionUsageClause(_ i: Int) -> ScreenDescriptionUsageClauseContext? {
			return getRuleContext(ScreenDescriptionUsageClauseContext.self,i)
		}
		open func screenDescriptionBlankWhenZeroClause() -> Array<ScreenDescriptionBlankWhenZeroClauseContext> {
			return getRuleContexts(ScreenDescriptionBlankWhenZeroClauseContext.self)
		}
		open func screenDescriptionBlankWhenZeroClause(_ i: Int) -> ScreenDescriptionBlankWhenZeroClauseContext? {
			return getRuleContext(ScreenDescriptionBlankWhenZeroClauseContext.self,i)
		}
		open func screenDescriptionJustifiedClause() -> Array<ScreenDescriptionJustifiedClauseContext> {
			return getRuleContexts(ScreenDescriptionJustifiedClauseContext.self)
		}
		open func screenDescriptionJustifiedClause(_ i: Int) -> ScreenDescriptionJustifiedClauseContext? {
			return getRuleContext(ScreenDescriptionJustifiedClauseContext.self,i)
		}
		open func screenDescriptionSignClause() -> Array<ScreenDescriptionSignClauseContext> {
			return getRuleContexts(ScreenDescriptionSignClauseContext.self)
		}
		open func screenDescriptionSignClause(_ i: Int) -> ScreenDescriptionSignClauseContext? {
			return getRuleContext(ScreenDescriptionSignClauseContext.self,i)
		}
		open func screenDescriptionAutoClause() -> Array<ScreenDescriptionAutoClauseContext> {
			return getRuleContexts(ScreenDescriptionAutoClauseContext.self)
		}
		open func screenDescriptionAutoClause(_ i: Int) -> ScreenDescriptionAutoClauseContext? {
			return getRuleContext(ScreenDescriptionAutoClauseContext.self,i)
		}
		open func screenDescriptionSecureClause() -> Array<ScreenDescriptionSecureClauseContext> {
			return getRuleContexts(ScreenDescriptionSecureClauseContext.self)
		}
		open func screenDescriptionSecureClause(_ i: Int) -> ScreenDescriptionSecureClauseContext? {
			return getRuleContext(ScreenDescriptionSecureClauseContext.self,i)
		}
		open func screenDescriptionRequiredClause() -> Array<ScreenDescriptionRequiredClauseContext> {
			return getRuleContexts(ScreenDescriptionRequiredClauseContext.self)
		}
		open func screenDescriptionRequiredClause(_ i: Int) -> ScreenDescriptionRequiredClauseContext? {
			return getRuleContext(ScreenDescriptionRequiredClauseContext.self,i)
		}
		open func screenDescriptionPromptClause() -> Array<ScreenDescriptionPromptClauseContext> {
			return getRuleContexts(ScreenDescriptionPromptClauseContext.self)
		}
		open func screenDescriptionPromptClause(_ i: Int) -> ScreenDescriptionPromptClauseContext? {
			return getRuleContext(ScreenDescriptionPromptClauseContext.self,i)
		}
		open func screenDescriptionFullClause() -> Array<ScreenDescriptionFullClauseContext> {
			return getRuleContexts(ScreenDescriptionFullClauseContext.self)
		}
		open func screenDescriptionFullClause(_ i: Int) -> ScreenDescriptionFullClauseContext? {
			return getRuleContext(ScreenDescriptionFullClauseContext.self,i)
		}
		open func screenDescriptionZeroFillClause() -> Array<ScreenDescriptionZeroFillClauseContext> {
			return getRuleContexts(ScreenDescriptionZeroFillClauseContext.self)
		}
		open func screenDescriptionZeroFillClause(_ i: Int) -> ScreenDescriptionZeroFillClauseContext? {
			return getRuleContext(ScreenDescriptionZeroFillClauseContext.self,i)
		}
		open func screenDescriptionFromClause() -> Array<ScreenDescriptionFromClauseContext> {
			return getRuleContexts(ScreenDescriptionFromClauseContext.self)
		}
		open func screenDescriptionFromClause(_ i: Int) -> ScreenDescriptionFromClauseContext? {
			return getRuleContext(ScreenDescriptionFromClauseContext.self,i)
		}
		open func screenDescriptionUsingClause() -> Array<ScreenDescriptionUsingClauseContext> {
			return getRuleContexts(ScreenDescriptionUsingClauseContext.self)
		}
		open func screenDescriptionUsingClause(_ i: Int) -> ScreenDescriptionUsingClauseContext? {
			return getRuleContext(ScreenDescriptionUsingClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionEntry() throws -> ScreenDescriptionEntryContext {
		var _localctx: ScreenDescriptionEntryContext = ScreenDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 264, Cobol85Parser.RULE_screenDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2532)
		 	try match(Cobol85Parser.INTEGERLITERAL)
		 	setState(2535)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,276,_ctx)) {
		 	case 1:
		 		setState(2533)
		 		try match(Cobol85Parser.FILLER)

		 		break
		 	case 2:
		 		setState(2534)
		 		try screenName()

		 		break
		 	default: break
		 	}
		 	setState(2569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BLANK,Cobol85Parser.BLINK,Cobol85Parser.COL,Cobol85Parser.COLUMN]
		 	    return  Utils.testBitLeftShiftArray(testArray, 35)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.CONTROL || _la == Cobol85Parser.EMPTY_CHECK
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ERASE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FROM,Cobol85Parser.FULL,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 190)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.JUST,Cobol85Parser.JUSTIFIED,Cobol85Parser.LEADING,Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LINE,Cobol85Parser.LOWLIGHT,Cobol85Parser.NO_ECHO]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.OVERLINE,Cobol85Parser.PIC,Cobol85Parser.PICTURE,Cobol85Parser.PROMPT,Cobol85Parser.REQUIRED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 341)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SECURE,Cobol85Parser.SIGN,Cobol85Parser.SIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 405)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.TRAILING,Cobol85Parser.UNDERLINE,Cobol85Parser.USAGE,Cobol85Parser.USING,Cobol85Parser.VALUE,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 497)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2567)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,278, _ctx)) {
		 		case 1:
		 			setState(2537)
		 			try screenDescriptionBlankClause()

		 			break
		 		case 2:
		 			setState(2538)
		 			try screenDescriptionBellClause()

		 			break
		 		case 3:
		 			setState(2539)
		 			try screenDescriptionBlinkClause()

		 			break
		 		case 4:
		 			setState(2540)
		 			try screenDescriptionEraseClause()

		 			break
		 		case 5:
		 			setState(2541)
		 			try screenDescriptionLightClause()

		 			break
		 		case 6:
		 			setState(2542)
		 			try screenDescriptionGridClause()

		 			break
		 		case 7:
		 			setState(2543)
		 			try screenDescriptionReverseVideoClause()

		 			break
		 		case 8:
		 			setState(2544)
		 			try screenDescriptionUnderlineClause()

		 			break
		 		case 9:
		 			setState(2545)
		 			try screenDescriptionSizeClause()

		 			break
		 		case 10:
		 			setState(2546)
		 			try screenDescriptionLineClause()

		 			break
		 		case 11:
		 			setState(2547)
		 			try screenDescriptionColumnClause()

		 			break
		 		case 12:
		 			setState(2548)
		 			try screenDescriptionForegroundColorClause()

		 			break
		 		case 13:
		 			setState(2549)
		 			try screenDescriptionBackgroundColorClause()

		 			break
		 		case 14:
		 			setState(2550)
		 			try screenDescriptionControlClause()

		 			break
		 		case 15:
		 			setState(2551)
		 			try screenDescriptionValueClause()

		 			break
		 		case 16:
		 			setState(2552)
		 			try screenDescriptionPictureClause()

		 			break
		 		case 17:
		 			setState(2555)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case Cobol85Parser.FROM:
		 				setState(2553)
		 				try screenDescriptionFromClause()

		 				break

		 			case Cobol85Parser.USING:
		 				setState(2554)
		 				try screenDescriptionUsingClause()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		case 18:
		 			setState(2557)
		 			try screenDescriptionUsageClause()

		 			break
		 		case 19:
		 			setState(2558)
		 			try screenDescriptionBlankWhenZeroClause()

		 			break
		 		case 20:
		 			setState(2559)
		 			try screenDescriptionJustifiedClause()

		 			break
		 		case 21:
		 			setState(2560)
		 			try screenDescriptionSignClause()

		 			break
		 		case 22:
		 			setState(2561)
		 			try screenDescriptionAutoClause()

		 			break
		 		case 23:
		 			setState(2562)
		 			try screenDescriptionSecureClause()

		 			break
		 		case 24:
		 			setState(2563)
		 			try screenDescriptionRequiredClause()

		 			break
		 		case 25:
		 			setState(2564)
		 			try screenDescriptionPromptClause()

		 			break
		 		case 26:
		 			setState(2565)
		 			try screenDescriptionFullClause()

		 			break
		 		case 27:
		 			setState(2566)
		 			try screenDescriptionZeroFillClause()

		 			break
		 		default: break
		 		}

		 		setState(2571)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2572)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionBlankClauseContext:ParserRuleContext {
		open func BLANK() -> TerminalNode? { return getToken(Cobol85Parser.BLANK, 0) }
		open func SCREEN() -> TerminalNode? { return getToken(Cobol85Parser.SCREEN, 0) }
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionBlankClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionBlankClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionBlankClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionBlankClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionBlankClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionBlankClause() throws -> ScreenDescriptionBlankClauseContext {
		var _localctx: ScreenDescriptionBlankClauseContext = ScreenDescriptionBlankClauseContext(_ctx, getState())
		try enterRule(_localctx, 266, Cobol85Parser.RULE_screenDescriptionBlankClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2574)
		 	try match(Cobol85Parser.BLANK)
		 	setState(2575)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LINE
		 	          testSet = testSet || _la == Cobol85Parser.SCREEN
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionBellClauseContext:ParserRuleContext {
		open func BELL() -> TerminalNode? { return getToken(Cobol85Parser.BELL, 0) }
		open func BEEP() -> TerminalNode? { return getToken(Cobol85Parser.BEEP, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionBellClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionBellClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionBellClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionBellClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionBellClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionBellClause() throws -> ScreenDescriptionBellClauseContext {
		var _localctx: ScreenDescriptionBellClauseContext = ScreenDescriptionBellClauseContext(_ctx, getState())
		try enterRule(_localctx, 268, Cobol85Parser.RULE_screenDescriptionBellClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2577)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BEEP || _la == Cobol85Parser.BELL
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionBlinkClauseContext:ParserRuleContext {
		open func BLINK() -> TerminalNode? { return getToken(Cobol85Parser.BLINK, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionBlinkClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionBlinkClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionBlinkClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionBlinkClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionBlinkClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionBlinkClause() throws -> ScreenDescriptionBlinkClauseContext {
		var _localctx: ScreenDescriptionBlinkClauseContext = ScreenDescriptionBlinkClauseContext(_ctx, getState())
		try enterRule(_localctx, 270, Cobol85Parser.RULE_screenDescriptionBlinkClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2579)
		 	try match(Cobol85Parser.BLINK)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionEraseClauseContext:ParserRuleContext {
		open func ERASE() -> TerminalNode? { return getToken(Cobol85Parser.ERASE, 0) }
		open func EOL() -> TerminalNode? { return getToken(Cobol85Parser.EOL, 0) }
		open func EOS() -> TerminalNode? { return getToken(Cobol85Parser.EOS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionEraseClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionEraseClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionEraseClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionEraseClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionEraseClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionEraseClause() throws -> ScreenDescriptionEraseClauseContext {
		var _localctx: ScreenDescriptionEraseClauseContext = ScreenDescriptionEraseClauseContext(_ctx, getState())
		try enterRule(_localctx, 272, Cobol85Parser.RULE_screenDescriptionEraseClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2581)
		 	try match(Cobol85Parser.ERASE)
		 	setState(2582)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.EOL || _la == Cobol85Parser.EOS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionLightClauseContext:ParserRuleContext {
		open func HIGHLIGHT() -> TerminalNode? { return getToken(Cobol85Parser.HIGHLIGHT, 0) }
		open func LOWLIGHT() -> TerminalNode? { return getToken(Cobol85Parser.LOWLIGHT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionLightClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionLightClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionLightClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionLightClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionLightClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionLightClause() throws -> ScreenDescriptionLightClauseContext {
		var _localctx: ScreenDescriptionLightClauseContext = ScreenDescriptionLightClauseContext(_ctx, getState())
		try enterRule(_localctx, 274, Cobol85Parser.RULE_screenDescriptionLightClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2584)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.HIGHLIGHT || _la == Cobol85Parser.LOWLIGHT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionGridClauseContext:ParserRuleContext {
		open func GRID() -> TerminalNode? { return getToken(Cobol85Parser.GRID, 0) }
		open func LEFTLINE() -> TerminalNode? { return getToken(Cobol85Parser.LEFTLINE, 0) }
		open func OVERLINE() -> TerminalNode? { return getToken(Cobol85Parser.OVERLINE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionGridClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionGridClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionGridClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionGridClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionGridClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionGridClause() throws -> ScreenDescriptionGridClauseContext {
		var _localctx: ScreenDescriptionGridClauseContext = ScreenDescriptionGridClauseContext(_ctx, getState())
		try enterRule(_localctx, 276, Cobol85Parser.RULE_screenDescriptionGridClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2586)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.GRID || _la == Cobol85Parser.LEFTLINE
		 	          testSet = testSet || _la == Cobol85Parser.OVERLINE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionReverseVideoClauseContext:ParserRuleContext {
		open func REVERSE_VIDEO() -> TerminalNode? { return getToken(Cobol85Parser.REVERSE_VIDEO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionReverseVideoClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionReverseVideoClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionReverseVideoClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionReverseVideoClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionReverseVideoClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionReverseVideoClause() throws -> ScreenDescriptionReverseVideoClauseContext {
		var _localctx: ScreenDescriptionReverseVideoClauseContext = ScreenDescriptionReverseVideoClauseContext(_ctx, getState())
		try enterRule(_localctx, 278, Cobol85Parser.RULE_screenDescriptionReverseVideoClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2588)
		 	try match(Cobol85Parser.REVERSE_VIDEO)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionUnderlineClauseContext:ParserRuleContext {
		open func UNDERLINE() -> TerminalNode? { return getToken(Cobol85Parser.UNDERLINE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionUnderlineClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionUnderlineClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionUnderlineClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionUnderlineClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionUnderlineClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionUnderlineClause() throws -> ScreenDescriptionUnderlineClauseContext {
		var _localctx: ScreenDescriptionUnderlineClauseContext = ScreenDescriptionUnderlineClauseContext(_ctx, getState())
		try enterRule(_localctx, 280, Cobol85Parser.RULE_screenDescriptionUnderlineClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2590)
		 	try match(Cobol85Parser.UNDERLINE)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionSizeClauseContext:ParserRuleContext {
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionSizeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionSizeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionSizeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionSizeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionSizeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionSizeClause() throws -> ScreenDescriptionSizeClauseContext {
		var _localctx: ScreenDescriptionSizeClauseContext = ScreenDescriptionSizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 282, Cobol85Parser.RULE_screenDescriptionSizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2592)
		 	try match(Cobol85Parser.SIZE)
		 	setState(2594)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2593)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2598)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,281, _ctx)) {
		 	case 1:
		 		setState(2596)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2597)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionLineClauseContext:ParserRuleContext {
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func PLUS() -> TerminalNode? { return getToken(Cobol85Parser.PLUS, 0) }
		open func PLUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.PLUSCHAR, 0) }
		open func MINUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MINUSCHAR, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(Cobol85Parser.NUMBER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionLineClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionLineClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionLineClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionLineClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionLineClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionLineClause() throws -> ScreenDescriptionLineClauseContext {
		var _localctx: ScreenDescriptionLineClauseContext = ScreenDescriptionLineClauseContext(_ctx, getState())
		try enterRule(_localctx, 284, Cobol85Parser.RULE_screenDescriptionLineClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2600)
		 	try match(Cobol85Parser.LINE)
		 	setState(2608)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IS || _la == Cobol85Parser.NUMBER
		 	          testSet = testSet || _la == Cobol85Parser.PLUS
		 	          testSet = testSet || _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 	      return testSet
		 	 }()) {
		 		setState(2602)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.NUMBER
		 		      return testSet
		 		 }()) {
		 			setState(2601)
		 			try match(Cobol85Parser.NUMBER)

		 		}

		 		setState(2605)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2604)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(2607)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.PLUS
		 		          testSet = testSet || _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(2612)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,285, _ctx)) {
		 	case 1:
		 		setState(2610)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2611)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionColumnClauseContext:ParserRuleContext {
		open func COLUMN() -> TerminalNode? { return getToken(Cobol85Parser.COLUMN, 0) }
		open func COL() -> TerminalNode? { return getToken(Cobol85Parser.COL, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func PLUS() -> TerminalNode? { return getToken(Cobol85Parser.PLUS, 0) }
		open func PLUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.PLUSCHAR, 0) }
		open func MINUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MINUSCHAR, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(Cobol85Parser.NUMBER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionColumnClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionColumnClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionColumnClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionColumnClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionColumnClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionColumnClause() throws -> ScreenDescriptionColumnClauseContext {
		var _localctx: ScreenDescriptionColumnClauseContext = ScreenDescriptionColumnClauseContext(_ctx, getState())
		try enterRule(_localctx, 286, Cobol85Parser.RULE_screenDescriptionColumnClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2614)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COL || _la == Cobol85Parser.COLUMN
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2622)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IS || _la == Cobol85Parser.NUMBER
		 	          testSet = testSet || _la == Cobol85Parser.PLUS
		 	          testSet = testSet || _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 	      return testSet
		 	 }()) {
		 		setState(2616)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.NUMBER
		 		      return testSet
		 		 }()) {
		 			setState(2615)
		 			try match(Cobol85Parser.NUMBER)

		 		}

		 		setState(2619)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2618)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(2621)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.PLUS
		 		          testSet = testSet || _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(2626)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,289, _ctx)) {
		 	case 1:
		 		setState(2624)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2625)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionForegroundColorClauseContext:ParserRuleContext {
		open func FOREGROUND_COLOR() -> TerminalNode? { return getToken(Cobol85Parser.FOREGROUND_COLOR, 0) }
		open func FOREGROUND_COLOUR() -> TerminalNode? { return getToken(Cobol85Parser.FOREGROUND_COLOUR, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionForegroundColorClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionForegroundColorClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionForegroundColorClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionForegroundColorClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionForegroundColorClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionForegroundColorClause() throws -> ScreenDescriptionForegroundColorClauseContext {
		var _localctx: ScreenDescriptionForegroundColorClauseContext = ScreenDescriptionForegroundColorClauseContext(_ctx, getState())
		try enterRule(_localctx, 288, Cobol85Parser.RULE_screenDescriptionForegroundColorClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2628)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOREGROUND_COLOR || _la == Cobol85Parser.FOREGROUND_COLOUR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2630)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2629)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2634)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,291, _ctx)) {
		 	case 1:
		 		setState(2632)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2633)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionBackgroundColorClauseContext:ParserRuleContext {
		open func BACKGROUND_COLOR() -> TerminalNode? { return getToken(Cobol85Parser.BACKGROUND_COLOR, 0) }
		open func BACKGROUND_COLOUR() -> TerminalNode? { return getToken(Cobol85Parser.BACKGROUND_COLOUR, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionBackgroundColorClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionBackgroundColorClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionBackgroundColorClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionBackgroundColorClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionBackgroundColorClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionBackgroundColorClause() throws -> ScreenDescriptionBackgroundColorClauseContext {
		var _localctx: ScreenDescriptionBackgroundColorClauseContext = ScreenDescriptionBackgroundColorClauseContext(_ctx, getState())
		try enterRule(_localctx, 290, Cobol85Parser.RULE_screenDescriptionBackgroundColorClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2636)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BACKGROUND_COLOR || _la == Cobol85Parser.BACKGROUND_COLOUR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2638)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2637)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2642)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,293, _ctx)) {
		 	case 1:
		 		setState(2640)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2641)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionControlClauseContext:ParserRuleContext {
		open func CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionControlClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionControlClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionControlClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionControlClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionControlClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionControlClause() throws -> ScreenDescriptionControlClauseContext {
		var _localctx: ScreenDescriptionControlClauseContext = ScreenDescriptionControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 292, Cobol85Parser.RULE_screenDescriptionControlClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2644)
		 	try match(Cobol85Parser.CONTROL)
		 	setState(2646)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2645)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2648)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionValueClauseContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func VALUE() -> TerminalNode? { return getToken(Cobol85Parser.VALUE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionValueClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionValueClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionValueClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionValueClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionValueClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionValueClause() throws -> ScreenDescriptionValueClauseContext {
		var _localctx: ScreenDescriptionValueClauseContext = ScreenDescriptionValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 294, Cobol85Parser.RULE_screenDescriptionValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2650)
		 	try match(Cobol85Parser.VALUE)
		 	setState(2652)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2651)
		 		try match(Cobol85Parser.IS)

		 	}


		 	setState(2654)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionPictureClauseContext:ParserRuleContext {
		open func pictureString() -> PictureStringContext? {
			return getRuleContext(PictureStringContext.self,0)
		}
		open func PICTURE() -> TerminalNode? { return getToken(Cobol85Parser.PICTURE, 0) }
		open func PIC() -> TerminalNode? { return getToken(Cobol85Parser.PIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionPictureClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionPictureClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionPictureClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionPictureClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionPictureClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionPictureClause() throws -> ScreenDescriptionPictureClauseContext {
		var _localctx: ScreenDescriptionPictureClauseContext = ScreenDescriptionPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 296, Cobol85Parser.RULE_screenDescriptionPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2656)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PIC || _la == Cobol85Parser.PICTURE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2658)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2657)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2660)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionFromClauseContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func screenDescriptionToClause() -> ScreenDescriptionToClauseContext? {
			return getRuleContext(ScreenDescriptionToClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionFromClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionFromClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionFromClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionFromClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionFromClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionFromClause() throws -> ScreenDescriptionFromClauseContext {
		var _localctx: ScreenDescriptionFromClauseContext = ScreenDescriptionFromClauseContext(_ctx, getState())
		try enterRule(_localctx, 298, Cobol85Parser.RULE_screenDescriptionFromClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2662)
		 	try match(Cobol85Parser.FROM)
		 	setState(2665)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,297, _ctx)) {
		 	case 1:
		 		setState(2663)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2664)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(2668)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(2667)
		 		try screenDescriptionToClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionToClauseContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionToClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionToClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionToClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionToClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionToClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionToClause() throws -> ScreenDescriptionToClauseContext {
		var _localctx: ScreenDescriptionToClauseContext = ScreenDescriptionToClauseContext(_ctx, getState())
		try enterRule(_localctx, 300, Cobol85Parser.RULE_screenDescriptionToClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2670)
		 	try match(Cobol85Parser.TO)
		 	setState(2671)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionUsingClauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionUsingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionUsingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionUsingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionUsingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionUsingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionUsingClause() throws -> ScreenDescriptionUsingClauseContext {
		var _localctx: ScreenDescriptionUsingClauseContext = ScreenDescriptionUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 302, Cobol85Parser.RULE_screenDescriptionUsingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2673)
		 	try match(Cobol85Parser.USING)
		 	setState(2674)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionUsageClauseContext:ParserRuleContext {
		open func DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY, 0) }
		open func DISPLAY_1() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY_1, 0) }
		open func USAGE() -> TerminalNode? { return getToken(Cobol85Parser.USAGE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionUsageClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionUsageClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionUsageClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionUsageClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionUsageClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionUsageClause() throws -> ScreenDescriptionUsageClauseContext {
		var _localctx: ScreenDescriptionUsageClauseContext = ScreenDescriptionUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 304, Cobol85Parser.RULE_screenDescriptionUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2676)
		 	try match(Cobol85Parser.USAGE)
		 	setState(2678)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2677)
		 		try match(Cobol85Parser.IS)

		 	}


		 	setState(2680)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DISPLAY || _la == Cobol85Parser.DISPLAY_1
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionBlankWhenZeroClauseContext:ParserRuleContext {
		open func BLANK() -> TerminalNode? { return getToken(Cobol85Parser.BLANK, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionBlankWhenZeroClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionBlankWhenZeroClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionBlankWhenZeroClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionBlankWhenZeroClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionBlankWhenZeroClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionBlankWhenZeroClause() throws -> ScreenDescriptionBlankWhenZeroClauseContext {
		var _localctx: ScreenDescriptionBlankWhenZeroClauseContext = ScreenDescriptionBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 306, Cobol85Parser.RULE_screenDescriptionBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2682)
		 	try match(Cobol85Parser.BLANK)
		 	setState(2684)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(2683)
		 		try match(Cobol85Parser.WHEN)

		 	}

		 	setState(2686)
		 	try match(Cobol85Parser.ZERO)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionJustifiedClauseContext:ParserRuleContext {
		open func JUSTIFIED() -> TerminalNode? { return getToken(Cobol85Parser.JUSTIFIED, 0) }
		open func JUST() -> TerminalNode? { return getToken(Cobol85Parser.JUST, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(Cobol85Parser.RIGHT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionJustifiedClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionJustifiedClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionJustifiedClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionJustifiedClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionJustifiedClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionJustifiedClause() throws -> ScreenDescriptionJustifiedClauseContext {
		var _localctx: ScreenDescriptionJustifiedClauseContext = ScreenDescriptionJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 308, Cobol85Parser.RULE_screenDescriptionJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2688)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.JUST || _la == Cobol85Parser.JUSTIFIED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2690)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RIGHT
		 	      return testSet
		 	 }()) {
		 		setState(2689)
		 		try match(Cobol85Parser.RIGHT)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionSignClauseContext:ParserRuleContext {
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(Cobol85Parser.TRAILING, 0) }
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func SEPARATE() -> TerminalNode? { return getToken(Cobol85Parser.SEPARATE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionSignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionSignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionSignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionSignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionSignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionSignClause() throws -> ScreenDescriptionSignClauseContext {
		var _localctx: ScreenDescriptionSignClauseContext = ScreenDescriptionSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 310, Cobol85Parser.RULE_screenDescriptionSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2696)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIGN
		 	      return testSet
		 	 }()) {
		 		setState(2692)
		 		try match(Cobol85Parser.SIGN)
		 		setState(2694)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(2693)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(2698)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEADING
		 	          testSet = testSet || _la == Cobol85Parser.TRAILING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2703)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SEPARATE
		 	      return testSet
		 	 }()) {
		 		setState(2699)
		 		try match(Cobol85Parser.SEPARATE)
		 		setState(2701)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 		      return testSet
		 		 }()) {
		 			setState(2700)
		 			try match(Cobol85Parser.CHARACTER)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionAutoClauseContext:ParserRuleContext {
		open func AUTO() -> TerminalNode? { return getToken(Cobol85Parser.AUTO, 0) }
		open func AUTO_SKIP() -> TerminalNode? { return getToken(Cobol85Parser.AUTO_SKIP, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionAutoClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionAutoClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionAutoClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionAutoClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionAutoClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionAutoClause() throws -> ScreenDescriptionAutoClauseContext {
		var _localctx: ScreenDescriptionAutoClauseContext = ScreenDescriptionAutoClauseContext(_ctx, getState())
		try enterRule(_localctx, 312, Cobol85Parser.RULE_screenDescriptionAutoClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2705)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AUTO || _la == Cobol85Parser.AUTO_SKIP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionSecureClauseContext:ParserRuleContext {
		open func SECURE() -> TerminalNode? { return getToken(Cobol85Parser.SECURE, 0) }
		open func NO_ECHO() -> TerminalNode? { return getToken(Cobol85Parser.NO_ECHO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionSecureClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionSecureClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionSecureClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionSecureClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionSecureClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionSecureClause() throws -> ScreenDescriptionSecureClauseContext {
		var _localctx: ScreenDescriptionSecureClauseContext = ScreenDescriptionSecureClauseContext(_ctx, getState())
		try enterRule(_localctx, 314, Cobol85Parser.RULE_screenDescriptionSecureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2707)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.NO_ECHO
		 	          testSet = testSet || _la == Cobol85Parser.SECURE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionRequiredClauseContext:ParserRuleContext {
		open func REQUIRED() -> TerminalNode? { return getToken(Cobol85Parser.REQUIRED, 0) }
		open func EMPTY_CHECK() -> TerminalNode? { return getToken(Cobol85Parser.EMPTY_CHECK, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionRequiredClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionRequiredClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionRequiredClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionRequiredClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionRequiredClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionRequiredClause() throws -> ScreenDescriptionRequiredClauseContext {
		var _localctx: ScreenDescriptionRequiredClauseContext = ScreenDescriptionRequiredClauseContext(_ctx, getState())
		try enterRule(_localctx, 316, Cobol85Parser.RULE_screenDescriptionRequiredClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2709)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.EMPTY_CHECK
		 	          testSet = testSet || _la == Cobol85Parser.REQUIRED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionPromptClauseContext:ParserRuleContext {
		open func PROMPT() -> TerminalNode? { return getToken(Cobol85Parser.PROMPT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func screenDescriptionPromptOccursClause() -> ScreenDescriptionPromptOccursClauseContext? {
			return getRuleContext(ScreenDescriptionPromptOccursClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionPromptClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionPromptClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionPromptClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionPromptClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionPromptClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionPromptClause() throws -> ScreenDescriptionPromptClauseContext {
		var _localctx: ScreenDescriptionPromptClauseContext = ScreenDescriptionPromptClauseContext(_ctx, getState())
		try enterRule(_localctx, 318, Cobol85Parser.RULE_screenDescriptionPromptClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2711)
		 	try match(Cobol85Parser.PROMPT)
		 	setState(2713)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 	      return testSet
		 	 }()) {
		 		setState(2712)
		 		try match(Cobol85Parser.CHARACTER)

		 	}

		 	setState(2716)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2715)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2720)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,308, _ctx)) {
		 	case 1:
		 		setState(2718)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2719)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(2723)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OCCURS
		 	      return testSet
		 	 }()) {
		 		setState(2722)
		 		try screenDescriptionPromptOccursClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionPromptOccursClauseContext:ParserRuleContext {
		open func OCCURS() -> TerminalNode? { return getToken(Cobol85Parser.OCCURS, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func TIMES() -> TerminalNode? { return getToken(Cobol85Parser.TIMES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionPromptOccursClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionPromptOccursClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionPromptOccursClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionPromptOccursClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionPromptOccursClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionPromptOccursClause() throws -> ScreenDescriptionPromptOccursClauseContext {
		var _localctx: ScreenDescriptionPromptOccursClauseContext = ScreenDescriptionPromptOccursClauseContext(_ctx, getState())
		try enterRule(_localctx, 320, Cobol85Parser.RULE_screenDescriptionPromptOccursClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2725)
		 	try match(Cobol85Parser.OCCURS)
		 	setState(2726)
		 	try integerLiteral()
		 	setState(2728)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TIMES
		 	      return testSet
		 	 }()) {
		 		setState(2727)
		 		try match(Cobol85Parser.TIMES)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionFullClauseContext:ParserRuleContext {
		open func FULL() -> TerminalNode? { return getToken(Cobol85Parser.FULL, 0) }
		open func LENGTH_CHECK() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH_CHECK, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionFullClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionFullClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionFullClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionFullClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionFullClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionFullClause() throws -> ScreenDescriptionFullClauseContext {
		var _localctx: ScreenDescriptionFullClauseContext = ScreenDescriptionFullClauseContext(_ctx, getState())
		try enterRule(_localctx, 322, Cobol85Parser.RULE_screenDescriptionFullClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2730)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FULL || _la == Cobol85Parser.LENGTH_CHECK
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenDescriptionZeroFillClauseContext:ParserRuleContext {
		open func ZERO_FILL() -> TerminalNode? { return getToken(Cobol85Parser.ZERO_FILL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenDescriptionZeroFillClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenDescriptionZeroFillClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenDescriptionZeroFillClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenDescriptionZeroFillClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenDescriptionZeroFillClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenDescriptionZeroFillClause() throws -> ScreenDescriptionZeroFillClauseContext {
		var _localctx: ScreenDescriptionZeroFillClauseContext = ScreenDescriptionZeroFillClauseContext(_ctx, getState())
		try enterRule(_localctx, 324, Cobol85Parser.RULE_screenDescriptionZeroFillClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2732)
		 	try match(Cobol85Parser.ZERO_FILL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportSectionContext:ParserRuleContext {
		open func REPORT() -> TerminalNode? { return getToken(Cobol85Parser.REPORT, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func reportDescription() -> Array<ReportDescriptionContext> {
			return getRuleContexts(ReportDescriptionContext.self)
		}
		open func reportDescription(_ i: Int) -> ReportDescriptionContext? {
			return getRuleContext(ReportDescriptionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportSection() throws -> ReportSectionContext {
		var _localctx: ReportSectionContext = ReportSectionContext(_ctx, getState())
		try enterRule(_localctx, 326, Cobol85Parser.RULE_reportSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2734)
		 	try match(Cobol85Parser.REPORT)
		 	setState(2735)
		 	try match(Cobol85Parser.SECTION)
		 	setState(2736)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(2740)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RD
		 	      return testSet
		 	 }()) {
		 		setState(2737)
		 		try reportDescription()


		 		setState(2742)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionContext:ParserRuleContext {
		open func reportDescriptionEntry() -> ReportDescriptionEntryContext? {
			return getRuleContext(ReportDescriptionEntryContext.self,0)
		}
		open func reportGroupDescriptionEntry() -> Array<ReportGroupDescriptionEntryContext> {
			return getRuleContexts(ReportGroupDescriptionEntryContext.self)
		}
		open func reportGroupDescriptionEntry(_ i: Int) -> ReportGroupDescriptionEntryContext? {
			return getRuleContext(ReportGroupDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescription }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescription(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescription(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescription(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescription(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescription() throws -> ReportDescriptionContext {
		var _localctx: ReportDescriptionContext = ReportDescriptionContext(_ctx, getState())
		try enterRule(_localctx, 328, Cobol85Parser.RULE_reportDescription)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2743)
		 	try reportDescriptionEntry()
		 	setState(2745) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2744)
		 		try reportGroupDescriptionEntry()


		 		setState(2747); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionEntryContext:ParserRuleContext {
		open func RD() -> TerminalNode? { return getToken(Cobol85Parser.RD, 0) }
		open func reportName() -> ReportNameContext? {
			return getRuleContext(ReportNameContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func reportDescriptionGlobalClause() -> ReportDescriptionGlobalClauseContext? {
			return getRuleContext(ReportDescriptionGlobalClauseContext.self,0)
		}
		open func reportDescriptionPageLimitClause() -> ReportDescriptionPageLimitClauseContext? {
			return getRuleContext(ReportDescriptionPageLimitClauseContext.self,0)
		}
		open func reportDescriptionHeadingClause() -> ReportDescriptionHeadingClauseContext? {
			return getRuleContext(ReportDescriptionHeadingClauseContext.self,0)
		}
		open func reportDescriptionFirstDetailClause() -> ReportDescriptionFirstDetailClauseContext? {
			return getRuleContext(ReportDescriptionFirstDetailClauseContext.self,0)
		}
		open func reportDescriptionLastDetailClause() -> ReportDescriptionLastDetailClauseContext? {
			return getRuleContext(ReportDescriptionLastDetailClauseContext.self,0)
		}
		open func reportDescriptionFootingClause() -> ReportDescriptionFootingClauseContext? {
			return getRuleContext(ReportDescriptionFootingClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionEntry() throws -> ReportDescriptionEntryContext {
		var _localctx: ReportDescriptionEntryContext = ReportDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 330, Cobol85Parser.RULE_reportDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2749)
		 	try match(Cobol85Parser.RD)
		 	setState(2750)
		 	try reportName()
		 	setState(2752)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GLOBAL || _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2751)
		 		try reportDescriptionGlobalClause()

		 	}

		 	setState(2767)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PAGE
		 	      return testSet
		 	 }()) {
		 		setState(2754)
		 		try reportDescriptionPageLimitClause()
		 		setState(2756)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.HEADING
		 		      return testSet
		 		 }()) {
		 			setState(2755)
		 			try reportDescriptionHeadingClause()

		 		}

		 		setState(2759)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FIRST
		 		      return testSet
		 		 }()) {
		 			setState(2758)
		 			try reportDescriptionFirstDetailClause()

		 		}

		 		setState(2762)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.LAST
		 		      return testSet
		 		 }()) {
		 			setState(2761)
		 			try reportDescriptionLastDetailClause()

		 		}

		 		setState(2765)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FOOTING
		 		      return testSet
		 		 }()) {
		 			setState(2764)
		 			try reportDescriptionFootingClause()

		 		}


		 	}

		 	setState(2769)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionGlobalClauseContext:ParserRuleContext {
		open func GLOBAL() -> TerminalNode? { return getToken(Cobol85Parser.GLOBAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionGlobalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionGlobalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionGlobalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionGlobalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionGlobalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionGlobalClause() throws -> ReportDescriptionGlobalClauseContext {
		var _localctx: ReportDescriptionGlobalClauseContext = ReportDescriptionGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 332, Cobol85Parser.RULE_reportDescriptionGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2772)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2771)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2774)
		 	try match(Cobol85Parser.GLOBAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionPageLimitClauseContext:ParserRuleContext {
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func LIMIT() -> TerminalNode? { return getToken(Cobol85Parser.LIMIT, 0) }
		open func LIMITS() -> TerminalNode? { return getToken(Cobol85Parser.LIMITS, 0) }
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionPageLimitClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionPageLimitClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionPageLimitClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionPageLimitClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionPageLimitClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionPageLimitClause() throws -> ReportDescriptionPageLimitClauseContext {
		var _localctx: ReportDescriptionPageLimitClauseContext = ReportDescriptionPageLimitClauseContext(_ctx, getState())
		try enterRule(_localctx, 334, Cobol85Parser.RULE_reportDescriptionPageLimitClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2776)
		 	try match(Cobol85Parser.PAGE)
		 	setState(2785)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LIMIT:
		 	 	setState(2777)
		 	 	try match(Cobol85Parser.LIMIT)
		 	 	setState(2779)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2778)
		 	 		try match(Cobol85Parser.IS)

		 	 	}


		 		break

		 	case Cobol85Parser.LIMITS:
		 	 	setState(2781)
		 	 	try match(Cobol85Parser.LIMITS)
		 	 	setState(2783)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.ARE
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2782)
		 	 		try match(Cobol85Parser.ARE)

		 	 	}


		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2787)
		 	try integerLiteral()
		 	setState(2789)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 	      return testSet
		 	 }()) {
		 		setState(2788)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionHeadingClauseContext:ParserRuleContext {
		open func HEADING() -> TerminalNode? { return getToken(Cobol85Parser.HEADING, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionHeadingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionHeadingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionHeadingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionHeadingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionHeadingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionHeadingClause() throws -> ReportDescriptionHeadingClauseContext {
		var _localctx: ReportDescriptionHeadingClauseContext = ReportDescriptionHeadingClauseContext(_ctx, getState())
		try enterRule(_localctx, 336, Cobol85Parser.RULE_reportDescriptionHeadingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2791)
		 	try match(Cobol85Parser.HEADING)
		 	setState(2792)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionFirstDetailClauseContext:ParserRuleContext {
		open func FIRST() -> TerminalNode? { return getToken(Cobol85Parser.FIRST, 0) }
		open func DETAIL() -> TerminalNode? { return getToken(Cobol85Parser.DETAIL, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionFirstDetailClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionFirstDetailClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionFirstDetailClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionFirstDetailClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionFirstDetailClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionFirstDetailClause() throws -> ReportDescriptionFirstDetailClauseContext {
		var _localctx: ReportDescriptionFirstDetailClauseContext = ReportDescriptionFirstDetailClauseContext(_ctx, getState())
		try enterRule(_localctx, 338, Cobol85Parser.RULE_reportDescriptionFirstDetailClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2794)
		 	try match(Cobol85Parser.FIRST)
		 	setState(2795)
		 	try match(Cobol85Parser.DETAIL)
		 	setState(2796)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionLastDetailClauseContext:ParserRuleContext {
		open func LAST() -> TerminalNode? { return getToken(Cobol85Parser.LAST, 0) }
		open func DETAIL() -> TerminalNode? { return getToken(Cobol85Parser.DETAIL, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionLastDetailClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionLastDetailClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionLastDetailClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionLastDetailClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionLastDetailClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionLastDetailClause() throws -> ReportDescriptionLastDetailClauseContext {
		var _localctx: ReportDescriptionLastDetailClauseContext = ReportDescriptionLastDetailClauseContext(_ctx, getState())
		try enterRule(_localctx, 340, Cobol85Parser.RULE_reportDescriptionLastDetailClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2798)
		 	try match(Cobol85Parser.LAST)
		 	setState(2799)
		 	try match(Cobol85Parser.DETAIL)
		 	setState(2800)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportDescriptionFootingClauseContext:ParserRuleContext {
		open func FOOTING() -> TerminalNode? { return getToken(Cobol85Parser.FOOTING, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportDescriptionFootingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportDescriptionFootingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportDescriptionFootingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportDescriptionFootingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportDescriptionFootingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportDescriptionFootingClause() throws -> ReportDescriptionFootingClauseContext {
		var _localctx: ReportDescriptionFootingClauseContext = ReportDescriptionFootingClauseContext(_ctx, getState())
		try enterRule(_localctx, 342, Cobol85Parser.RULE_reportDescriptionFootingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2802)
		 	try match(Cobol85Parser.FOOTING)
		 	setState(2803)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupDescriptionEntryContext:ParserRuleContext {
		open func reportGroupDescriptionEntryFormat1() -> ReportGroupDescriptionEntryFormat1Context? {
			return getRuleContext(ReportGroupDescriptionEntryFormat1Context.self,0)
		}
		open func reportGroupDescriptionEntryFormat2() -> ReportGroupDescriptionEntryFormat2Context? {
			return getRuleContext(ReportGroupDescriptionEntryFormat2Context.self,0)
		}
		open func reportGroupDescriptionEntryFormat3() -> ReportGroupDescriptionEntryFormat3Context? {
			return getRuleContext(ReportGroupDescriptionEntryFormat3Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupDescriptionEntry() throws -> ReportGroupDescriptionEntryContext {
		var _localctx: ReportGroupDescriptionEntryContext = ReportGroupDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 344, Cobol85Parser.RULE_reportGroupDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2808)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,324, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2805)
		 		try reportGroupDescriptionEntryFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2806)
		 		try reportGroupDescriptionEntryFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2807)
		 		try reportGroupDescriptionEntryFormat3()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupDescriptionEntryFormat1Context:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func reportGroupTypeClause() -> ReportGroupTypeClauseContext? {
			return getRuleContext(ReportGroupTypeClauseContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func reportGroupLineNumberClause() -> ReportGroupLineNumberClauseContext? {
			return getRuleContext(ReportGroupLineNumberClauseContext.self,0)
		}
		open func reportGroupNextGroupClause() -> ReportGroupNextGroupClauseContext? {
			return getRuleContext(ReportGroupNextGroupClauseContext.self,0)
		}
		open func reportGroupUsageClause() -> ReportGroupUsageClauseContext? {
			return getRuleContext(ReportGroupUsageClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupDescriptionEntryFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupDescriptionEntryFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupDescriptionEntryFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupDescriptionEntryFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupDescriptionEntryFormat1() throws -> ReportGroupDescriptionEntryFormat1Context {
		var _localctx: ReportGroupDescriptionEntryFormat1Context = ReportGroupDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 346, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2810)
		 	try integerLiteral()
		 	setState(2811)
		 	try dataName()
		 	setState(2813)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.IS,Cobol85Parser.LINE,Cobol85Parser.NUMBER]
		 	    return  Utils.testBitLeftShiftArray(testArray, 257)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.PLUS
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2812)
		 		try reportGroupLineNumberClause()

		 	}

		 	setState(2816)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NEXT
		 	      return testSet
		 	 }()) {
		 		setState(2815)
		 		try reportGroupNextGroupClause()

		 	}

		 	setState(2818)
		 	try reportGroupTypeClause()
		 	setState(2820)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.DISPLAY || _la == Cobol85Parser.DISPLAY_1
		 	          testSet = testSet || _la == Cobol85Parser.USAGE
		 	      return testSet
		 	 }()) {
		 		setState(2819)
		 		try reportGroupUsageClause()

		 	}

		 	setState(2822)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupDescriptionEntryFormat2Context:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func reportGroupUsageClause() -> ReportGroupUsageClauseContext? {
			return getRuleContext(ReportGroupUsageClauseContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func reportGroupLineNumberClause() -> ReportGroupLineNumberClauseContext? {
			return getRuleContext(ReportGroupLineNumberClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupDescriptionEntryFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupDescriptionEntryFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupDescriptionEntryFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupDescriptionEntryFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupDescriptionEntryFormat2() throws -> ReportGroupDescriptionEntryFormat2Context {
		var _localctx: ReportGroupDescriptionEntryFormat2Context = ReportGroupDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 348, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2824)
		 	try integerLiteral()
		 	setState(2826)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }()) {
		 		setState(2825)
		 		try dataName()

		 	}

		 	setState(2829)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.IS,Cobol85Parser.LINE,Cobol85Parser.NUMBER]
		 	    return  Utils.testBitLeftShiftArray(testArray, 257)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.PLUS
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2828)
		 		try reportGroupLineNumberClause()

		 	}

		 	setState(2831)
		 	try reportGroupUsageClause()
		 	setState(2832)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupDescriptionEntryFormat3Context:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func reportGroupPictureClause() -> Array<ReportGroupPictureClauseContext> {
			return getRuleContexts(ReportGroupPictureClauseContext.self)
		}
		open func reportGroupPictureClause(_ i: Int) -> ReportGroupPictureClauseContext? {
			return getRuleContext(ReportGroupPictureClauseContext.self,i)
		}
		open func reportGroupUsageClause() -> Array<ReportGroupUsageClauseContext> {
			return getRuleContexts(ReportGroupUsageClauseContext.self)
		}
		open func reportGroupUsageClause(_ i: Int) -> ReportGroupUsageClauseContext? {
			return getRuleContext(ReportGroupUsageClauseContext.self,i)
		}
		open func reportGroupSignClause() -> Array<ReportGroupSignClauseContext> {
			return getRuleContexts(ReportGroupSignClauseContext.self)
		}
		open func reportGroupSignClause(_ i: Int) -> ReportGroupSignClauseContext? {
			return getRuleContext(ReportGroupSignClauseContext.self,i)
		}
		open func reportGroupJustifiedClause() -> Array<ReportGroupJustifiedClauseContext> {
			return getRuleContexts(ReportGroupJustifiedClauseContext.self)
		}
		open func reportGroupJustifiedClause(_ i: Int) -> ReportGroupJustifiedClauseContext? {
			return getRuleContext(ReportGroupJustifiedClauseContext.self,i)
		}
		open func reportGroupBlankWhenZeroClause() -> Array<ReportGroupBlankWhenZeroClauseContext> {
			return getRuleContexts(ReportGroupBlankWhenZeroClauseContext.self)
		}
		open func reportGroupBlankWhenZeroClause(_ i: Int) -> ReportGroupBlankWhenZeroClauseContext? {
			return getRuleContext(ReportGroupBlankWhenZeroClauseContext.self,i)
		}
		open func reportGroupLineNumberClause() -> Array<ReportGroupLineNumberClauseContext> {
			return getRuleContexts(ReportGroupLineNumberClauseContext.self)
		}
		open func reportGroupLineNumberClause(_ i: Int) -> ReportGroupLineNumberClauseContext? {
			return getRuleContext(ReportGroupLineNumberClauseContext.self,i)
		}
		open func reportGroupColumnNumberClause() -> Array<ReportGroupColumnNumberClauseContext> {
			return getRuleContexts(ReportGroupColumnNumberClauseContext.self)
		}
		open func reportGroupColumnNumberClause(_ i: Int) -> ReportGroupColumnNumberClauseContext? {
			return getRuleContext(ReportGroupColumnNumberClauseContext.self,i)
		}
		open func reportGroupIndicateClause() -> Array<ReportGroupIndicateClauseContext> {
			return getRuleContexts(ReportGroupIndicateClauseContext.self)
		}
		open func reportGroupIndicateClause(_ i: Int) -> ReportGroupIndicateClauseContext? {
			return getRuleContext(ReportGroupIndicateClauseContext.self,i)
		}
		open func reportGroupSourceClause() -> Array<ReportGroupSourceClauseContext> {
			return getRuleContexts(ReportGroupSourceClauseContext.self)
		}
		open func reportGroupSourceClause(_ i: Int) -> ReportGroupSourceClauseContext? {
			return getRuleContext(ReportGroupSourceClauseContext.self,i)
		}
		open func reportGroupValueClause() -> Array<ReportGroupValueClauseContext> {
			return getRuleContexts(ReportGroupValueClauseContext.self)
		}
		open func reportGroupValueClause(_ i: Int) -> ReportGroupValueClauseContext? {
			return getRuleContext(ReportGroupValueClauseContext.self,i)
		}
		open func reportGroupSumClause() -> Array<ReportGroupSumClauseContext> {
			return getRuleContexts(ReportGroupSumClauseContext.self)
		}
		open func reportGroupSumClause(_ i: Int) -> ReportGroupSumClauseContext? {
			return getRuleContext(ReportGroupSumClauseContext.self,i)
		}
		open func reportGroupResetClause() -> Array<ReportGroupResetClauseContext> {
			return getRuleContexts(ReportGroupResetClauseContext.self)
		}
		open func reportGroupResetClause(_ i: Int) -> ReportGroupResetClauseContext? {
			return getRuleContext(ReportGroupResetClauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat3 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupDescriptionEntryFormat3(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupDescriptionEntryFormat3(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupDescriptionEntryFormat3(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupDescriptionEntryFormat3(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupDescriptionEntryFormat3() throws -> ReportGroupDescriptionEntryFormat3Context {
		var _localctx: ReportGroupDescriptionEntryFormat3Context = ReportGroupDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 350, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2834)
		 	try integerLiteral()
		 	setState(2836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }()) {
		 		setState(2835)
		 		try dataName()

		 	}

		 	setState(2854)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.BLANK || _la == Cobol85Parser.COLUMN
		 	          testSet = testSet || _la == Cobol85Parser.DISPLAY || _la == Cobol85Parser.DISPLAY_1
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.GROUP,Cobol85Parser.IS,Cobol85Parser.JUST,Cobol85Parser.JUSTIFIED,Cobol85Parser.LINE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 230)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NUMBER,Cobol85Parser.PIC,Cobol85Parser.PICTURE,Cobol85Parser.PLUS]
		 	              return  Utils.testBitLeftShiftArray(testArray, 319)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.RESET,Cobol85Parser.SIGN,Cobol85Parser.SOURCE,Cobol85Parser.SUM]
		 	              return  Utils.testBitLeftShiftArray(testArray, 406)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.USAGE,Cobol85Parser.VALUE,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 508)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2852)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.PIC:fallthrough
		 		case Cobol85Parser.PICTURE:
		 			setState(2838)
		 			try reportGroupPictureClause()

		 			break
		 		case Cobol85Parser.DISPLAY:fallthrough
		 		case Cobol85Parser.DISPLAY_1:fallthrough
		 		case Cobol85Parser.USAGE:
		 			setState(2839)
		 			try reportGroupUsageClause()

		 			break

		 		case Cobol85Parser.SIGN:
		 			setState(2840)
		 			try reportGroupSignClause()

		 			break
		 		case Cobol85Parser.JUST:fallthrough
		 		case Cobol85Parser.JUSTIFIED:
		 			setState(2841)
		 			try reportGroupJustifiedClause()

		 			break

		 		case Cobol85Parser.BLANK:
		 			setState(2842)
		 			try reportGroupBlankWhenZeroClause()

		 			break
		 		case Cobol85Parser.IS:fallthrough
		 		case Cobol85Parser.LINE:fallthrough
		 		case Cobol85Parser.NUMBER:fallthrough
		 		case Cobol85Parser.PLUS:fallthrough
		 		case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 		case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 		case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 		case Cobol85Parser.INTEGERLITERAL:
		 			setState(2843)
		 			try reportGroupLineNumberClause()

		 			break

		 		case Cobol85Parser.COLUMN:
		 			setState(2844)
		 			try reportGroupColumnNumberClause()

		 			break
		 		case Cobol85Parser.RESET:fallthrough
		 		case Cobol85Parser.SOURCE:fallthrough
		 		case Cobol85Parser.SUM:fallthrough
		 		case Cobol85Parser.VALUE:
		 			setState(2849)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case Cobol85Parser.SOURCE:
		 				setState(2845)
		 				try reportGroupSourceClause()

		 				break

		 			case Cobol85Parser.VALUE:
		 				setState(2846)
		 				try reportGroupValueClause()

		 				break

		 			case Cobol85Parser.SUM:
		 				setState(2847)
		 				try reportGroupSumClause()

		 				break

		 			case Cobol85Parser.RESET:
		 				setState(2848)
		 				try reportGroupResetClause()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break

		 		case Cobol85Parser.GROUP:
		 			setState(2851)
		 			try reportGroupIndicateClause()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2856)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2857)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupBlankWhenZeroClauseContext:ParserRuleContext {
		open func BLANK() -> TerminalNode? { return getToken(Cobol85Parser.BLANK, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupBlankWhenZeroClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupBlankWhenZeroClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupBlankWhenZeroClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupBlankWhenZeroClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupBlankWhenZeroClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupBlankWhenZeroClause() throws -> ReportGroupBlankWhenZeroClauseContext {
		var _localctx: ReportGroupBlankWhenZeroClauseContext = ReportGroupBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 352, Cobol85Parser.RULE_reportGroupBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2859)
		 	try match(Cobol85Parser.BLANK)
		 	setState(2861)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(2860)
		 		try match(Cobol85Parser.WHEN)

		 	}

		 	setState(2863)
		 	try match(Cobol85Parser.ZERO)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupColumnNumberClauseContext:ParserRuleContext {
		open func COLUMN() -> TerminalNode? { return getToken(Cobol85Parser.COLUMN, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func NUMBER() -> TerminalNode? { return getToken(Cobol85Parser.NUMBER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupColumnNumberClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupColumnNumberClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupColumnNumberClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupColumnNumberClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupColumnNumberClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupColumnNumberClause() throws -> ReportGroupColumnNumberClauseContext {
		var _localctx: ReportGroupColumnNumberClauseContext = ReportGroupColumnNumberClauseContext(_ctx, getState())
		try enterRule(_localctx, 354, Cobol85Parser.RULE_reportGroupColumnNumberClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2865)
		 	try match(Cobol85Parser.COLUMN)
		 	setState(2867)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NUMBER
		 	      return testSet
		 	 }()) {
		 		setState(2866)
		 		try match(Cobol85Parser.NUMBER)

		 	}

		 	setState(2870)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2869)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2872)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupIndicateClauseContext:ParserRuleContext {
		open func GROUP() -> TerminalNode? { return getToken(Cobol85Parser.GROUP, 0) }
		open func INDICATE() -> TerminalNode? { return getToken(Cobol85Parser.INDICATE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupIndicateClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupIndicateClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupIndicateClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupIndicateClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupIndicateClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupIndicateClause() throws -> ReportGroupIndicateClauseContext {
		var _localctx: ReportGroupIndicateClauseContext = ReportGroupIndicateClauseContext(_ctx, getState())
		try enterRule(_localctx, 356, Cobol85Parser.RULE_reportGroupIndicateClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2874)
		 	try match(Cobol85Parser.GROUP)
		 	setState(2876)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INDICATE
		 	      return testSet
		 	 }()) {
		 		setState(2875)
		 		try match(Cobol85Parser.INDICATE)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupJustifiedClauseContext:ParserRuleContext {
		open func JUSTIFIED() -> TerminalNode? { return getToken(Cobol85Parser.JUSTIFIED, 0) }
		open func JUST() -> TerminalNode? { return getToken(Cobol85Parser.JUST, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(Cobol85Parser.RIGHT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupJustifiedClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupJustifiedClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupJustifiedClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupJustifiedClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupJustifiedClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupJustifiedClause() throws -> ReportGroupJustifiedClauseContext {
		var _localctx: ReportGroupJustifiedClauseContext = ReportGroupJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 358, Cobol85Parser.RULE_reportGroupJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2878)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.JUST || _la == Cobol85Parser.JUSTIFIED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2880)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RIGHT
		 	      return testSet
		 	 }()) {
		 		setState(2879)
		 		try match(Cobol85Parser.RIGHT)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupLineNumberClauseContext:ParserRuleContext {
		open func reportGroupLineNumberNextPage() -> ReportGroupLineNumberNextPageContext? {
			return getRuleContext(ReportGroupLineNumberNextPageContext.self,0)
		}
		open func reportGroupLineNumberPlus() -> ReportGroupLineNumberPlusContext? {
			return getRuleContext(ReportGroupLineNumberPlusContext.self,0)
		}
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(Cobol85Parser.NUMBER, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupLineNumberClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupLineNumberClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupLineNumberClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupLineNumberClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupLineNumberClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupLineNumberClause() throws -> ReportGroupLineNumberClauseContext {
		var _localctx: ReportGroupLineNumberClauseContext = ReportGroupLineNumberClauseContext(_ctx, getState())
		try enterRule(_localctx, 360, Cobol85Parser.RULE_reportGroupLineNumberClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2883)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINE
		 	      return testSet
		 	 }()) {
		 		setState(2882)
		 		try match(Cobol85Parser.LINE)

		 	}

		 	setState(2886)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NUMBER
		 	      return testSet
		 	 }()) {
		 		setState(2885)
		 		try match(Cobol85Parser.NUMBER)

		 	}

		 	setState(2889)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2888)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2893)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2891)
		 		try reportGroupLineNumberNextPage()

		 		break

		 	case Cobol85Parser.PLUS:
		 		setState(2892)
		 		try reportGroupLineNumberPlus()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupLineNumberNextPageContext:ParserRuleContext {
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupLineNumberNextPage }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupLineNumberNextPage(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupLineNumberNextPage(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupLineNumberNextPage(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupLineNumberNextPage(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupLineNumberNextPage() throws -> ReportGroupLineNumberNextPageContext {
		var _localctx: ReportGroupLineNumberNextPageContext = ReportGroupLineNumberNextPageContext(_ctx, getState())
		try enterRule(_localctx, 362, Cobol85Parser.RULE_reportGroupLineNumberNextPage)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2895)
		 	try integerLiteral()
		 	setState(2901)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,344,_ctx)) {
		 	case 1:
		 		setState(2897)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ON
		 		      return testSet
		 		 }()) {
		 			setState(2896)
		 			try match(Cobol85Parser.ON)

		 		}

		 		setState(2899)
		 		try match(Cobol85Parser.NEXT)
		 		setState(2900)
		 		try match(Cobol85Parser.PAGE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupLineNumberPlusContext:ParserRuleContext {
		open func PLUS() -> TerminalNode? { return getToken(Cobol85Parser.PLUS, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupLineNumberPlus }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupLineNumberPlus(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupLineNumberPlus(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupLineNumberPlus(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupLineNumberPlus(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupLineNumberPlus() throws -> ReportGroupLineNumberPlusContext {
		var _localctx: ReportGroupLineNumberPlusContext = ReportGroupLineNumberPlusContext(_ctx, getState())
		try enterRule(_localctx, 364, Cobol85Parser.RULE_reportGroupLineNumberPlus)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2903)
		 	try match(Cobol85Parser.PLUS)
		 	setState(2904)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupNextGroupClauseContext:ParserRuleContext {
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func GROUP() -> TerminalNode? { return getToken(Cobol85Parser.GROUP, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func reportGroupNextGroupNextPage() -> ReportGroupNextGroupNextPageContext? {
			return getRuleContext(ReportGroupNextGroupNextPageContext.self,0)
		}
		open func reportGroupNextGroupPlus() -> ReportGroupNextGroupPlusContext? {
			return getRuleContext(ReportGroupNextGroupPlusContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupNextGroupClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupNextGroupClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupNextGroupClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupNextGroupClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupNextGroupClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupNextGroupClause() throws -> ReportGroupNextGroupClauseContext {
		var _localctx: ReportGroupNextGroupClauseContext = ReportGroupNextGroupClauseContext(_ctx, getState())
		try enterRule(_localctx, 366, Cobol85Parser.RULE_reportGroupNextGroupClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2906)
		 	try match(Cobol85Parser.NEXT)
		 	setState(2907)
		 	try match(Cobol85Parser.GROUP)
		 	setState(2909)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2908)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2914)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		setState(2911)
		 		try integerLiteral()

		 		break

		 	case Cobol85Parser.NEXT:
		 		setState(2912)
		 		try reportGroupNextGroupNextPage()

		 		break

		 	case Cobol85Parser.PLUS:
		 		setState(2913)
		 		try reportGroupNextGroupPlus()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupNextGroupPlusContext:ParserRuleContext {
		open func PLUS() -> TerminalNode? { return getToken(Cobol85Parser.PLUS, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupNextGroupPlus }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupNextGroupPlus(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupNextGroupPlus(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupNextGroupPlus(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupNextGroupPlus(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupNextGroupPlus() throws -> ReportGroupNextGroupPlusContext {
		var _localctx: ReportGroupNextGroupPlusContext = ReportGroupNextGroupPlusContext(_ctx, getState())
		try enterRule(_localctx, 368, Cobol85Parser.RULE_reportGroupNextGroupPlus)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2916)
		 	try match(Cobol85Parser.PLUS)
		 	setState(2917)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupNextGroupNextPageContext:ParserRuleContext {
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupNextGroupNextPage }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupNextGroupNextPage(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupNextGroupNextPage(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupNextGroupNextPage(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupNextGroupNextPage(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupNextGroupNextPage() throws -> ReportGroupNextGroupNextPageContext {
		var _localctx: ReportGroupNextGroupNextPageContext = ReportGroupNextGroupNextPageContext(_ctx, getState())
		try enterRule(_localctx, 370, Cobol85Parser.RULE_reportGroupNextGroupNextPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2919)
		 	try match(Cobol85Parser.NEXT)
		 	setState(2920)
		 	try match(Cobol85Parser.PAGE)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupPictureClauseContext:ParserRuleContext {
		open func pictureString() -> PictureStringContext? {
			return getRuleContext(PictureStringContext.self,0)
		}
		open func PICTURE() -> TerminalNode? { return getToken(Cobol85Parser.PICTURE, 0) }
		open func PIC() -> TerminalNode? { return getToken(Cobol85Parser.PIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupPictureClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupPictureClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupPictureClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupPictureClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupPictureClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupPictureClause() throws -> ReportGroupPictureClauseContext {
		var _localctx: ReportGroupPictureClauseContext = ReportGroupPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 372, Cobol85Parser.RULE_reportGroupPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2922)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PIC || _la == Cobol85Parser.PICTURE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2924)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2923)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2926)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupResetClauseContext:ParserRuleContext {
		open func RESET() -> TerminalNode? { return getToken(Cobol85Parser.RESET, 0) }
		open func FINAL() -> TerminalNode? { return getToken(Cobol85Parser.FINAL, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupResetClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupResetClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupResetClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupResetClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupResetClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupResetClause() throws -> ReportGroupResetClauseContext {
		var _localctx: ReportGroupResetClauseContext = ReportGroupResetClauseContext(_ctx, getState())
		try enterRule(_localctx, 374, Cobol85Parser.RULE_reportGroupResetClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2928)
		 	try match(Cobol85Parser.RESET)
		 	setState(2930)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(2929)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(2934)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.FINAL:
		 		setState(2932)
		 		try match(Cobol85Parser.FINAL)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(2933)
		 		try dataName()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupSignClauseContext:ParserRuleContext {
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func SEPARATE() -> TerminalNode? { return getToken(Cobol85Parser.SEPARATE, 0) }
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(Cobol85Parser.TRAILING, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupSignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupSignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupSignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupSignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupSignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupSignClause() throws -> ReportGroupSignClauseContext {
		var _localctx: ReportGroupSignClauseContext = ReportGroupSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 376, Cobol85Parser.RULE_reportGroupSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2936)
		 	try match(Cobol85Parser.SIGN)
		 	setState(2938)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2937)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2940)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEADING
		 	          testSet = testSet || _la == Cobol85Parser.TRAILING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2941)
		 	try match(Cobol85Parser.SEPARATE)
		 	setState(2943)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 	      return testSet
		 	 }()) {
		 		setState(2942)
		 		try match(Cobol85Parser.CHARACTER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupSourceClauseContext:ParserRuleContext {
		open func SOURCE() -> TerminalNode? { return getToken(Cobol85Parser.SOURCE, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupSourceClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupSourceClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupSourceClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupSourceClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupSourceClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupSourceClause() throws -> ReportGroupSourceClauseContext {
		var _localctx: ReportGroupSourceClauseContext = ReportGroupSourceClauseContext(_ctx, getState())
		try enterRule(_localctx, 378, Cobol85Parser.RULE_reportGroupSourceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2945)
		 	try match(Cobol85Parser.SOURCE)
		 	setState(2947)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2946)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2949)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupSumClauseContext:ParserRuleContext {
		open func SUM() -> TerminalNode? { return getToken(Cobol85Parser.SUM, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open func UPON() -> TerminalNode? { return getToken(Cobol85Parser.UPON, 0) }
		open func dataName() -> Array<DataNameContext> {
			return getRuleContexts(DataNameContext.self)
		}
		open func dataName(_ i: Int) -> DataNameContext? {
			return getRuleContext(DataNameContext.self,i)
		}
		open func COMMACHAR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.COMMACHAR) }
		open func COMMACHAR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.COMMACHAR, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupSumClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupSumClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupSumClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupSumClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupSumClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupSumClause() throws -> ReportGroupSumClauseContext {
		var _localctx: ReportGroupSumClauseContext = ReportGroupSumClauseContext(_ctx, getState())
		try enterRule(_localctx, 380, Cobol85Parser.RULE_reportGroupSumClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2951)
		 	try match(Cobol85Parser.SUM)
		 	setState(2952)
		 	try identifier()
		 	setState(2959)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,354,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2954)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.COMMACHAR
		 			      return testSet
		 			 }()) {
		 				setState(2953)
		 				try match(Cobol85Parser.COMMACHAR)

		 			}

		 			setState(2956)
		 			try identifier()

		 	 
		 		}
		 		setState(2961)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,354,_ctx)
		 	}
		 	setState(2973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.UPON
		 	      return testSet
		 	 }()) {
		 		setState(2962)
		 		try match(Cobol85Parser.UPON)
		 		setState(2963)
		 		try dataName()
		 		setState(2970)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.COMMACHAR || _la == Cobol85Parser.IDENTIFIER
		 		      return testSet
		 		 }()) {
		 			setState(2965)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.COMMACHAR
		 			      return testSet
		 			 }()) {
		 				setState(2964)
		 				try match(Cobol85Parser.COMMACHAR)

		 			}

		 			setState(2967)
		 			try dataName()


		 			setState(2972)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeClauseContext:ParserRuleContext {
		open func TYPE() -> TerminalNode? { return getToken(Cobol85Parser.TYPE, 0) }
		open func reportGroupTypeReportHeading() -> ReportGroupTypeReportHeadingContext? {
			return getRuleContext(ReportGroupTypeReportHeadingContext.self,0)
		}
		open func reportGroupTypePageHeading() -> ReportGroupTypePageHeadingContext? {
			return getRuleContext(ReportGroupTypePageHeadingContext.self,0)
		}
		open func reportGroupTypeControlHeading() -> ReportGroupTypeControlHeadingContext? {
			return getRuleContext(ReportGroupTypeControlHeadingContext.self,0)
		}
		open func reportGroupTypeDetail() -> ReportGroupTypeDetailContext? {
			return getRuleContext(ReportGroupTypeDetailContext.self,0)
		}
		open func reportGroupTypeControlFooting() -> ReportGroupTypeControlFootingContext? {
			return getRuleContext(ReportGroupTypeControlFootingContext.self,0)
		}
		open func reportGroupTypePageFooting() -> ReportGroupTypePageFootingContext? {
			return getRuleContext(ReportGroupTypePageFootingContext.self,0)
		}
		open func reportGroupTypeReportFooting() -> ReportGroupTypeReportFootingContext? {
			return getRuleContext(ReportGroupTypeReportFootingContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeClause() throws -> ReportGroupTypeClauseContext {
		var _localctx: ReportGroupTypeClauseContext = ReportGroupTypeClauseContext(_ctx, getState())
		try enterRule(_localctx, 382, Cobol85Parser.RULE_reportGroupTypeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2975)
		 	try match(Cobol85Parser.TYPE)
		 	setState(2977)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2976)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(2986)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,359, _ctx)) {
		 	case 1:
		 		setState(2979)
		 		try reportGroupTypeReportHeading()

		 		break
		 	case 2:
		 		setState(2980)
		 		try reportGroupTypePageHeading()

		 		break
		 	case 3:
		 		setState(2981)
		 		try reportGroupTypeControlHeading()

		 		break
		 	case 4:
		 		setState(2982)
		 		try reportGroupTypeDetail()

		 		break
		 	case 5:
		 		setState(2983)
		 		try reportGroupTypeControlFooting()

		 		break
		 	case 6:
		 		setState(2984)
		 		try reportGroupTypePageFooting()

		 		break
		 	case 7:
		 		setState(2985)
		 		try reportGroupTypeReportFooting()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeReportHeadingContext:ParserRuleContext {
		open func REPORT() -> TerminalNode? { return getToken(Cobol85Parser.REPORT, 0) }
		open func HEADING() -> TerminalNode? { return getToken(Cobol85Parser.HEADING, 0) }
		open func RH() -> TerminalNode? { return getToken(Cobol85Parser.RH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeReportHeading }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeReportHeading(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeReportHeading(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeReportHeading(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeReportHeading(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeReportHeading() throws -> ReportGroupTypeReportHeadingContext {
		var _localctx: ReportGroupTypeReportHeadingContext = ReportGroupTypeReportHeadingContext(_ctx, getState())
		try enterRule(_localctx, 384, Cobol85Parser.RULE_reportGroupTypeReportHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2991)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.REPORT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2988)
		 		try match(Cobol85Parser.REPORT)
		 		setState(2989)
		 		try match(Cobol85Parser.HEADING)

		 		break

		 	case Cobol85Parser.RH:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2990)
		 		try match(Cobol85Parser.RH)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypePageHeadingContext:ParserRuleContext {
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open func HEADING() -> TerminalNode? { return getToken(Cobol85Parser.HEADING, 0) }
		open func PH() -> TerminalNode? { return getToken(Cobol85Parser.PH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypePageHeading }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypePageHeading(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypePageHeading(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypePageHeading(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypePageHeading(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypePageHeading() throws -> ReportGroupTypePageHeadingContext {
		var _localctx: ReportGroupTypePageHeadingContext = ReportGroupTypePageHeadingContext(_ctx, getState())
		try enterRule(_localctx, 386, Cobol85Parser.RULE_reportGroupTypePageHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2996)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.PAGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2993)
		 		try match(Cobol85Parser.PAGE)
		 		setState(2994)
		 		try match(Cobol85Parser.HEADING)

		 		break

		 	case Cobol85Parser.PH:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2995)
		 		try match(Cobol85Parser.PH)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeControlHeadingContext:ParserRuleContext {
		open func CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL, 0) }
		open func HEADING() -> TerminalNode? { return getToken(Cobol85Parser.HEADING, 0) }
		open func CH() -> TerminalNode? { return getToken(Cobol85Parser.CH, 0) }
		open func FINAL() -> TerminalNode? { return getToken(Cobol85Parser.FINAL, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeControlHeading }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeControlHeading(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeControlHeading(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeControlHeading(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeControlHeading(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeControlHeading() throws -> ReportGroupTypeControlHeadingContext {
		var _localctx: ReportGroupTypeControlHeadingContext = ReportGroupTypeControlHeadingContext(_ctx, getState())
		try enterRule(_localctx, 388, Cobol85Parser.RULE_reportGroupTypeControlHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3001)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.CONTROL:
		 		setState(2998)
		 		try match(Cobol85Parser.CONTROL)
		 		setState(2999)
		 		try match(Cobol85Parser.HEADING)

		 		break

		 	case Cobol85Parser.CH:
		 		setState(3000)
		 		try match(Cobol85Parser.CH)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3005)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.FINAL:
		 		setState(3003)
		 		try match(Cobol85Parser.FINAL)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(3004)
		 		try dataName()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeDetailContext:ParserRuleContext {
		open func DETAIL() -> TerminalNode? { return getToken(Cobol85Parser.DETAIL, 0) }
		open func DE() -> TerminalNode? { return getToken(Cobol85Parser.DE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeDetail }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeDetail(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeDetail(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeDetail(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeDetail(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeDetail() throws -> ReportGroupTypeDetailContext {
		var _localctx: ReportGroupTypeDetailContext = ReportGroupTypeDetailContext(_ctx, getState())
		try enterRule(_localctx, 390, Cobol85Parser.RULE_reportGroupTypeDetail)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3007)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DE || _la == Cobol85Parser.DETAIL
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeControlFootingContext:ParserRuleContext {
		open func CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL, 0) }
		open func FOOTING() -> TerminalNode? { return getToken(Cobol85Parser.FOOTING, 0) }
		open func CF() -> TerminalNode? { return getToken(Cobol85Parser.CF, 0) }
		open func FINAL() -> TerminalNode? { return getToken(Cobol85Parser.FINAL, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeControlFooting }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeControlFooting(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeControlFooting(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeControlFooting(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeControlFooting(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeControlFooting() throws -> ReportGroupTypeControlFootingContext {
		var _localctx: ReportGroupTypeControlFootingContext = ReportGroupTypeControlFootingContext(_ctx, getState())
		try enterRule(_localctx, 392, Cobol85Parser.RULE_reportGroupTypeControlFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3012)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.CONTROL:
		 		setState(3009)
		 		try match(Cobol85Parser.CONTROL)
		 		setState(3010)
		 		try match(Cobol85Parser.FOOTING)

		 		break

		 	case Cobol85Parser.CF:
		 		setState(3011)
		 		try match(Cobol85Parser.CF)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3016)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.FINAL:
		 		setState(3014)
		 		try match(Cobol85Parser.FINAL)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(3015)
		 		try dataName()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupUsageClauseContext:ParserRuleContext {
		open func DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY, 0) }
		open func DISPLAY_1() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY_1, 0) }
		open func USAGE() -> TerminalNode? { return getToken(Cobol85Parser.USAGE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupUsageClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupUsageClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupUsageClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupUsageClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupUsageClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupUsageClause() throws -> ReportGroupUsageClauseContext {
		var _localctx: ReportGroupUsageClauseContext = ReportGroupUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 394, Cobol85Parser.RULE_reportGroupUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3022)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USAGE
		 	      return testSet
		 	 }()) {
		 		setState(3018)
		 		try match(Cobol85Parser.USAGE)
		 		setState(3020)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(3019)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(3024)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DISPLAY || _la == Cobol85Parser.DISPLAY_1
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypePageFootingContext:ParserRuleContext {
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open func FOOTING() -> TerminalNode? { return getToken(Cobol85Parser.FOOTING, 0) }
		open func PF() -> TerminalNode? { return getToken(Cobol85Parser.PF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypePageFooting }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypePageFooting(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypePageFooting(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypePageFooting(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypePageFooting(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypePageFooting() throws -> ReportGroupTypePageFootingContext {
		var _localctx: ReportGroupTypePageFootingContext = ReportGroupTypePageFootingContext(_ctx, getState())
		try enterRule(_localctx, 396, Cobol85Parser.RULE_reportGroupTypePageFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3029)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.PAGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3026)
		 		try match(Cobol85Parser.PAGE)
		 		setState(3027)
		 		try match(Cobol85Parser.FOOTING)

		 		break

		 	case Cobol85Parser.PF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3028)
		 		try match(Cobol85Parser.PF)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupTypeReportFootingContext:ParserRuleContext {
		open func REPORT() -> TerminalNode? { return getToken(Cobol85Parser.REPORT, 0) }
		open func FOOTING() -> TerminalNode? { return getToken(Cobol85Parser.FOOTING, 0) }
		open func RF() -> TerminalNode? { return getToken(Cobol85Parser.RF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupTypeReportFooting }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupTypeReportFooting(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupTypeReportFooting(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupTypeReportFooting(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupTypeReportFooting(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupTypeReportFooting() throws -> ReportGroupTypeReportFootingContext {
		var _localctx: ReportGroupTypeReportFootingContext = ReportGroupTypeReportFootingContext(_ctx, getState())
		try enterRule(_localctx, 398, Cobol85Parser.RULE_reportGroupTypeReportFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3034)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.REPORT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3031)
		 		try match(Cobol85Parser.REPORT)
		 		setState(3032)
		 		try match(Cobol85Parser.FOOTING)

		 		break

		 	case Cobol85Parser.RF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3033)
		 		try match(Cobol85Parser.RF)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportGroupValueClauseContext:ParserRuleContext {
		open func VALUE() -> TerminalNode? { return getToken(Cobol85Parser.VALUE, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportGroupValueClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportGroupValueClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportGroupValueClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportGroupValueClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportGroupValueClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportGroupValueClause() throws -> ReportGroupValueClauseContext {
		var _localctx: ReportGroupValueClauseContext = ReportGroupValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 400, Cobol85Parser.RULE_reportGroupValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3036)
		 	try match(Cobol85Parser.VALUE)
		 	setState(3038)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3037)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3040)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProgramLibrarySectionContext:ParserRuleContext {
		open func PROGRAM_LIBRARY() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM_LIBRARY, 0) }
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func libraryDescriptionEntry() -> Array<LibraryDescriptionEntryContext> {
			return getRuleContexts(LibraryDescriptionEntryContext.self)
		}
		open func libraryDescriptionEntry(_ i: Int) -> LibraryDescriptionEntryContext? {
			return getRuleContext(LibraryDescriptionEntryContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_programLibrarySection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProgramLibrarySection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProgramLibrarySection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProgramLibrarySection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProgramLibrarySection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func programLibrarySection() throws -> ProgramLibrarySectionContext {
		var _localctx: ProgramLibrarySectionContext = ProgramLibrarySectionContext(_ctx, getState())
		try enterRule(_localctx, 402, Cobol85Parser.RULE_programLibrarySection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3042)
		 	try match(Cobol85Parser.PROGRAM_LIBRARY)
		 	setState(3043)
		 	try match(Cobol85Parser.SECTION)
		 	setState(3044)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3048)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LB || _la == Cobol85Parser.LD
		 	      return testSet
		 	 }()) {
		 		setState(3045)
		 		try libraryDescriptionEntry()


		 		setState(3050)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryDescriptionEntryContext:ParserRuleContext {
		open func libraryDescriptionEntryFormat1() -> LibraryDescriptionEntryFormat1Context? {
			return getRuleContext(LibraryDescriptionEntryFormat1Context.self,0)
		}
		open func libraryDescriptionEntryFormat2() -> LibraryDescriptionEntryFormat2Context? {
			return getRuleContext(LibraryDescriptionEntryFormat2Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryDescriptionEntry() throws -> LibraryDescriptionEntryContext {
		var _localctx: LibraryDescriptionEntryContext = LibraryDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 404, Cobol85Parser.RULE_libraryDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3053)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3051)
		 		try libraryDescriptionEntryFormat1()

		 		break

		 	case Cobol85Parser.LB:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3052)
		 		try libraryDescriptionEntryFormat2()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryDescriptionEntryFormat1Context:ParserRuleContext {
		open func LD() -> TerminalNode? { return getToken(Cobol85Parser.LD, 0) }
		open func libraryName() -> LibraryNameContext? {
			return getRuleContext(LibraryNameContext.self,0)
		}
		open func EXPORT() -> TerminalNode? { return getToken(Cobol85Parser.EXPORT, 0) }
		open func libraryAttributeClauseFormat1() -> LibraryAttributeClauseFormat1Context? {
			return getRuleContext(LibraryAttributeClauseFormat1Context.self,0)
		}
		open func libraryEntryProcedureClauseFormat1() -> LibraryEntryProcedureClauseFormat1Context? {
			return getRuleContext(LibraryEntryProcedureClauseFormat1Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryDescriptionEntryFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryDescriptionEntryFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryDescriptionEntryFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryDescriptionEntryFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryDescriptionEntryFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryDescriptionEntryFormat1() throws -> LibraryDescriptionEntryFormat1Context {
		var _localctx: LibraryDescriptionEntryFormat1Context = LibraryDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 406, Cobol85Parser.RULE_libraryDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3055)
		 	try match(Cobol85Parser.LD)
		 	setState(3056)
		 	try libraryName()
		 	setState(3057)
		 	try match(Cobol85Parser.EXPORT)
		 	setState(3059)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ATTRIBUTE
		 	      return testSet
		 	 }()) {
		 		setState(3058)
		 		try libraryAttributeClauseFormat1()

		 	}

		 	setState(3062)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ENTRY_PROCEDURE
		 	      return testSet
		 	 }()) {
		 		setState(3061)
		 		try libraryEntryProcedureClauseFormat1()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryDescriptionEntryFormat2Context:ParserRuleContext {
		open func LB() -> TerminalNode? { return getToken(Cobol85Parser.LB, 0) }
		open func libraryName() -> LibraryNameContext? {
			return getRuleContext(LibraryNameContext.self,0)
		}
		open func IMPORT() -> TerminalNode? { return getToken(Cobol85Parser.IMPORT, 0) }
		open func libraryIsGlobalClause() -> LibraryIsGlobalClauseContext? {
			return getRuleContext(LibraryIsGlobalClauseContext.self,0)
		}
		open func libraryIsCommonClause() -> LibraryIsCommonClauseContext? {
			return getRuleContext(LibraryIsCommonClauseContext.self,0)
		}
		open func libraryAttributeClauseFormat2() -> Array<LibraryAttributeClauseFormat2Context> {
			return getRuleContexts(LibraryAttributeClauseFormat2Context.self)
		}
		open func libraryAttributeClauseFormat2(_ i: Int) -> LibraryAttributeClauseFormat2Context? {
			return getRuleContext(LibraryAttributeClauseFormat2Context.self,i)
		}
		open func libraryEntryProcedureClauseFormat2() -> Array<LibraryEntryProcedureClauseFormat2Context> {
			return getRuleContexts(LibraryEntryProcedureClauseFormat2Context.self)
		}
		open func libraryEntryProcedureClauseFormat2(_ i: Int) -> LibraryEntryProcedureClauseFormat2Context? {
			return getRuleContext(LibraryEntryProcedureClauseFormat2Context.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryDescriptionEntryFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryDescriptionEntryFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryDescriptionEntryFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryDescriptionEntryFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryDescriptionEntryFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryDescriptionEntryFormat2() throws -> LibraryDescriptionEntryFormat2Context {
		var _localctx: LibraryDescriptionEntryFormat2Context = LibraryDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 408, Cobol85Parser.RULE_libraryDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3064)
		 	try match(Cobol85Parser.LB)
		 	setState(3065)
		 	try libraryName()
		 	setState(3066)
		 	try match(Cobol85Parser.IMPORT)
		 	setState(3068)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,375,_ctx)) {
		 	case 1:
		 		setState(3067)
		 		try libraryIsGlobalClause()

		 		break
		 	default: break
		 	}
		 	setState(3071)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COMMON
		 	          testSet = testSet || _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3070)
		 		try libraryIsCommonClause()

		 	}

		 	setState(3077)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ATTRIBUTE
		 	          testSet = testSet || _la == Cobol85Parser.ENTRY_PROCEDURE
		 	      return testSet
		 	 }()) {
		 		setState(3075)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.ATTRIBUTE:
		 			setState(3073)
		 			try libraryAttributeClauseFormat2()

		 			break

		 		case Cobol85Parser.ENTRY_PROCEDURE:
		 			setState(3074)
		 			try libraryEntryProcedureClauseFormat2()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3079)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryAttributeClauseFormat1Context:ParserRuleContext {
		open func ATTRIBUTE() -> TerminalNode? { return getToken(Cobol85Parser.ATTRIBUTE, 0) }
		open func SHARING() -> TerminalNode? { return getToken(Cobol85Parser.SHARING, 0) }
		open func DONTCARE() -> TerminalNode? { return getToken(Cobol85Parser.DONTCARE, 0) }
		open func PRIVATE() -> TerminalNode? { return getToken(Cobol85Parser.PRIVATE, 0) }
		open func SHAREDBYRUNUNIT() -> TerminalNode? { return getToken(Cobol85Parser.SHAREDBYRUNUNIT, 0) }
		open func SHAREDBYALL() -> TerminalNode? { return getToken(Cobol85Parser.SHAREDBYALL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryAttributeClauseFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryAttributeClauseFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryAttributeClauseFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryAttributeClauseFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryAttributeClauseFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryAttributeClauseFormat1() throws -> LibraryAttributeClauseFormat1Context {
		var _localctx: LibraryAttributeClauseFormat1Context = LibraryAttributeClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 410, Cobol85Parser.RULE_libraryAttributeClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3080)
		 	try match(Cobol85Parser.ATTRIBUTE)
		 	setState(3086)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SHARING
		 	      return testSet
		 	 }()) {
		 		setState(3081)
		 		try match(Cobol85Parser.SHARING)
		 		setState(3083)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(3082)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(3085)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.DONTCARE
		 		          testSet = testSet || _la == Cobol85Parser.PRIVATE
		 		          testSet = testSet || _la == Cobol85Parser.SHAREDBYALL || _la == Cobol85Parser.SHAREDBYRUNUNIT
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryAttributeClauseFormat2Context:ParserRuleContext {
		open func ATTRIBUTE() -> TerminalNode? { return getToken(Cobol85Parser.ATTRIBUTE, 0) }
		open func libraryAttributeFunction() -> LibraryAttributeFunctionContext? {
			return getRuleContext(LibraryAttributeFunctionContext.self,0)
		}
		open func LIBACCESS() -> TerminalNode? { return getToken(Cobol85Parser.LIBACCESS, 0) }
		open func libraryAttributeParameter() -> LibraryAttributeParameterContext? {
			return getRuleContext(LibraryAttributeParameterContext.self,0)
		}
		open func libraryAttributeTitle() -> LibraryAttributeTitleContext? {
			return getRuleContext(LibraryAttributeTitleContext.self,0)
		}
		open func BYFUNCTION() -> TerminalNode? { return getToken(Cobol85Parser.BYFUNCTION, 0) }
		open func BYTITLE() -> TerminalNode? { return getToken(Cobol85Parser.BYTITLE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryAttributeClauseFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryAttributeClauseFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryAttributeClauseFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryAttributeClauseFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryAttributeClauseFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryAttributeClauseFormat2() throws -> LibraryAttributeClauseFormat2Context {
		var _localctx: LibraryAttributeClauseFormat2Context = LibraryAttributeClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 412, Cobol85Parser.RULE_libraryAttributeClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3088)
		 	try match(Cobol85Parser.ATTRIBUTE)
		 	setState(3090)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FUNCTIONNAME
		 	      return testSet
		 	 }()) {
		 		setState(3089)
		 		try libraryAttributeFunction()

		 	}

		 	setState(3097)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LIBACCESS
		 	      return testSet
		 	 }()) {
		 		setState(3092)
		 		try match(Cobol85Parser.LIBACCESS)
		 		setState(3094)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(3093)
		 			try match(Cobol85Parser.IS)

		 		}

		 		setState(3096)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.BYFUNCTION || _la == Cobol85Parser.BYTITLE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(3100)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LIBPARAMETER
		 	      return testSet
		 	 }()) {
		 		setState(3099)
		 		try libraryAttributeParameter()

		 	}

		 	setState(3103)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TITLE
		 	      return testSet
		 	 }()) {
		 		setState(3102)
		 		try libraryAttributeTitle()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryAttributeFunctionContext:ParserRuleContext {
		open func FUNCTIONNAME() -> TerminalNode? { return getToken(Cobol85Parser.FUNCTIONNAME, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryAttributeFunction }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryAttributeFunction(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryAttributeFunction(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryAttributeFunction(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryAttributeFunction(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryAttributeFunction() throws -> LibraryAttributeFunctionContext {
		var _localctx: LibraryAttributeFunctionContext = LibraryAttributeFunctionContext(_ctx, getState())
		try enterRule(_localctx, 414, Cobol85Parser.RULE_libraryAttributeFunction)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3105)
		 	try match(Cobol85Parser.FUNCTIONNAME)
		 	setState(3106)
		 	try match(Cobol85Parser.IS)
		 	setState(3107)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryAttributeParameterContext:ParserRuleContext {
		open func LIBPARAMETER() -> TerminalNode? { return getToken(Cobol85Parser.LIBPARAMETER, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryAttributeParameter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryAttributeParameter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryAttributeParameter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryAttributeParameter(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryAttributeParameter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryAttributeParameter() throws -> LibraryAttributeParameterContext {
		var _localctx: LibraryAttributeParameterContext = LibraryAttributeParameterContext(_ctx, getState())
		try enterRule(_localctx, 416, Cobol85Parser.RULE_libraryAttributeParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3109)
		 	try match(Cobol85Parser.LIBPARAMETER)
		 	setState(3111)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3110)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3113)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryAttributeTitleContext:ParserRuleContext {
		open func TITLE() -> TerminalNode? { return getToken(Cobol85Parser.TITLE, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryAttributeTitle }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryAttributeTitle(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryAttributeTitle(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryAttributeTitle(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryAttributeTitle(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryAttributeTitle() throws -> LibraryAttributeTitleContext {
		var _localctx: LibraryAttributeTitleContext = LibraryAttributeTitleContext(_ctx, getState())
		try enterRule(_localctx, 418, Cobol85Parser.RULE_libraryAttributeTitle)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3115)
		 	try match(Cobol85Parser.TITLE)
		 	setState(3117)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3116)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3119)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureClauseFormat1Context:ParserRuleContext {
		open func ENTRY_PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.ENTRY_PROCEDURE, 0) }
		open func programName() -> ProgramNameContext? {
			return getRuleContext(ProgramNameContext.self,0)
		}
		open func libraryEntryProcedureForClause() -> LibraryEntryProcedureForClauseContext? {
			return getRuleContext(LibraryEntryProcedureForClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureClauseFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureClauseFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureClauseFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureClauseFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureClauseFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureClauseFormat1() throws -> LibraryEntryProcedureClauseFormat1Context {
		var _localctx: LibraryEntryProcedureClauseFormat1Context = LibraryEntryProcedureClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 420, Cobol85Parser.RULE_libraryEntryProcedureClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3121)
		 	try match(Cobol85Parser.ENTRY_PROCEDURE)
		 	setState(3122)
		 	try programName()
		 	setState(3124)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(3123)
		 		try libraryEntryProcedureForClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureClauseFormat2Context:ParserRuleContext {
		open func ENTRY_PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.ENTRY_PROCEDURE, 0) }
		open func programName() -> ProgramNameContext? {
			return getRuleContext(ProgramNameContext.self,0)
		}
		open func libraryEntryProcedureForClause() -> LibraryEntryProcedureForClauseContext? {
			return getRuleContext(LibraryEntryProcedureForClauseContext.self,0)
		}
		open func libraryEntryProcedureWithClause() -> LibraryEntryProcedureWithClauseContext? {
			return getRuleContext(LibraryEntryProcedureWithClauseContext.self,0)
		}
		open func libraryEntryProcedureUsingClause() -> LibraryEntryProcedureUsingClauseContext? {
			return getRuleContext(LibraryEntryProcedureUsingClauseContext.self,0)
		}
		open func libraryEntryProcedureGivingClause() -> LibraryEntryProcedureGivingClauseContext? {
			return getRuleContext(LibraryEntryProcedureGivingClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureClauseFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureClauseFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureClauseFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureClauseFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureClauseFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureClauseFormat2() throws -> LibraryEntryProcedureClauseFormat2Context {
		var _localctx: LibraryEntryProcedureClauseFormat2Context = LibraryEntryProcedureClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 422, Cobol85Parser.RULE_libraryEntryProcedureClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3126)
		 	try match(Cobol85Parser.ENTRY_PROCEDURE)
		 	setState(3127)
		 	try programName()
		 	setState(3129)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(3128)
		 		try libraryEntryProcedureForClause()

		 	}

		 	setState(3132)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(3131)
		 		try libraryEntryProcedureWithClause()

		 	}

		 	setState(3135)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(3134)
		 		try libraryEntryProcedureUsingClause()

		 	}

		 	setState(3138)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(3137)
		 		try libraryEntryProcedureGivingClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureForClauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureForClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureForClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureForClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureForClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureForClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureForClause() throws -> LibraryEntryProcedureForClauseContext {
		var _localctx: LibraryEntryProcedureForClauseContext = LibraryEntryProcedureForClauseContext(_ctx, getState())
		try enterRule(_localctx, 424, Cobol85Parser.RULE_libraryEntryProcedureForClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3140)
		 	try match(Cobol85Parser.FOR)
		 	setState(3141)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureGivingClauseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureGivingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureGivingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureGivingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureGivingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureGivingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureGivingClause() throws -> LibraryEntryProcedureGivingClauseContext {
		var _localctx: LibraryEntryProcedureGivingClauseContext = LibraryEntryProcedureGivingClauseContext(_ctx, getState())
		try enterRule(_localctx, 426, Cobol85Parser.RULE_libraryEntryProcedureGivingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3143)
		 	try match(Cobol85Parser.GIVING)
		 	setState(3144)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureUsingClauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func libraryEntryProcedureUsingName() -> Array<LibraryEntryProcedureUsingNameContext> {
			return getRuleContexts(LibraryEntryProcedureUsingNameContext.self)
		}
		open func libraryEntryProcedureUsingName(_ i: Int) -> LibraryEntryProcedureUsingNameContext? {
			return getRuleContext(LibraryEntryProcedureUsingNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureUsingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureUsingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureUsingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureUsingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureUsingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureUsingClause() throws -> LibraryEntryProcedureUsingClauseContext {
		var _localctx: LibraryEntryProcedureUsingClauseContext = LibraryEntryProcedureUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 428, Cobol85Parser.RULE_libraryEntryProcedureUsingClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3146)
		 	try match(Cobol85Parser.USING)
		 	setState(3148); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3147)
		 			try libraryEntryProcedureUsingName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3150); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,393,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureUsingNameContext:ParserRuleContext {
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureUsingName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureUsingName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureUsingName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureUsingName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureUsingName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureUsingName() throws -> LibraryEntryProcedureUsingNameContext {
		var _localctx: LibraryEntryProcedureUsingNameContext = LibraryEntryProcedureUsingNameContext(_ctx, getState())
		try enterRule(_localctx, 430, Cobol85Parser.RULE_libraryEntryProcedureUsingName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3154)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,394, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3152)
		 		try dataName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3153)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureWithClauseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func libraryEntryProcedureWithName() -> Array<LibraryEntryProcedureWithNameContext> {
			return getRuleContexts(LibraryEntryProcedureWithNameContext.self)
		}
		open func libraryEntryProcedureWithName(_ i: Int) -> LibraryEntryProcedureWithNameContext? {
			return getRuleContext(LibraryEntryProcedureWithNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureWithClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureWithClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureWithClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureWithClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureWithClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureWithClause() throws -> LibraryEntryProcedureWithClauseContext {
		var _localctx: LibraryEntryProcedureWithClauseContext = LibraryEntryProcedureWithClauseContext(_ctx, getState())
		try enterRule(_localctx, 432, Cobol85Parser.RULE_libraryEntryProcedureWithClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3156)
		 	try match(Cobol85Parser.WITH)
		 	setState(3158); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3157)
		 			try libraryEntryProcedureWithName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3160); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,395,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryEntryProcedureWithNameContext:ParserRuleContext {
		open func localName() -> LocalNameContext? {
			return getRuleContext(LocalNameContext.self,0)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryEntryProcedureWithName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryEntryProcedureWithName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryEntryProcedureWithName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryEntryProcedureWithName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryEntryProcedureWithName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryEntryProcedureWithName() throws -> LibraryEntryProcedureWithNameContext {
		var _localctx: LibraryEntryProcedureWithNameContext = LibraryEntryProcedureWithNameContext(_ctx, getState())
		try enterRule(_localctx, 434, Cobol85Parser.RULE_libraryEntryProcedureWithName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3164)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,396, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3162)
		 		try localName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3163)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryIsCommonClauseContext:ParserRuleContext {
		open func COMMON() -> TerminalNode? { return getToken(Cobol85Parser.COMMON, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryIsCommonClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryIsCommonClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryIsCommonClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryIsCommonClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryIsCommonClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryIsCommonClause() throws -> LibraryIsCommonClauseContext {
		var _localctx: LibraryIsCommonClauseContext = LibraryIsCommonClauseContext(_ctx, getState())
		try enterRule(_localctx, 436, Cobol85Parser.RULE_libraryIsCommonClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3167)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3166)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3169)
		 	try match(Cobol85Parser.COMMON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryIsGlobalClauseContext:ParserRuleContext {
		open func GLOBAL() -> TerminalNode? { return getToken(Cobol85Parser.GLOBAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryIsGlobalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryIsGlobalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryIsGlobalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryIsGlobalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryIsGlobalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryIsGlobalClause() throws -> LibraryIsGlobalClauseContext {
		var _localctx: LibraryIsGlobalClauseContext = LibraryIsGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 438, Cobol85Parser.RULE_libraryIsGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3172)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3171)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3174)
		 	try match(Cobol85Parser.GLOBAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescriptionEntryContext:ParserRuleContext {
		open func dataDescriptionEntryFormat1() -> DataDescriptionEntryFormat1Context? {
			return getRuleContext(DataDescriptionEntryFormat1Context.self,0)
		}
		open func dataDescriptionEntryFormat2() -> DataDescriptionEntryFormat2Context? {
			return getRuleContext(DataDescriptionEntryFormat2Context.self,0)
		}
		open func dataDescriptionEntryFormat3() -> DataDescriptionEntryFormat3Context? {
			return getRuleContext(DataDescriptionEntryFormat3Context.self,0)
		}
		open func dataDescriptionEntryExecSql() -> DataDescriptionEntryExecSqlContext? {
			return getRuleContext(DataDescriptionEntryExecSqlContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescriptionEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescriptionEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescriptionEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescriptionEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescriptionEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescriptionEntry() throws -> DataDescriptionEntryContext {
		var _localctx: DataDescriptionEntryContext = DataDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 440, Cobol85Parser.RULE_dataDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3180)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3176)
		 		try dataDescriptionEntryFormat1()

		 		break

		 	case Cobol85Parser.LEVEL_NUMBER_66:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3177)
		 		try dataDescriptionEntryFormat2()

		 		break

		 	case Cobol85Parser.LEVEL_NUMBER_88:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3178)
		 		try dataDescriptionEntryFormat3()

		 		break

		 	case Cobol85Parser.EXECSQLLINE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3179)
		 		try dataDescriptionEntryExecSql()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescriptionEntryFormat1Context:ParserRuleContext {
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func INTEGERLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.INTEGERLITERAL, 0) }
		open func LEVEL_NUMBER_77() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_77, 0) }
		open func FILLER() -> TerminalNode? { return getToken(Cobol85Parser.FILLER, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func dataRedefinesClause() -> DataRedefinesClauseContext? {
			return getRuleContext(DataRedefinesClauseContext.self,0)
		}
		open func dataIntegerStringClause() -> DataIntegerStringClauseContext? {
			return getRuleContext(DataIntegerStringClauseContext.self,0)
		}
		open func dataExternalClause() -> DataExternalClauseContext? {
			return getRuleContext(DataExternalClauseContext.self,0)
		}
		open func dataGlobalClause() -> DataGlobalClauseContext? {
			return getRuleContext(DataGlobalClauseContext.self,0)
		}
		open func dataTypeDefClause() -> DataTypeDefClauseContext? {
			return getRuleContext(DataTypeDefClauseContext.self,0)
		}
		open func dataThreadLocalClause() -> DataThreadLocalClauseContext? {
			return getRuleContext(DataThreadLocalClauseContext.self,0)
		}
		open func dataPictureClause() -> Array<DataPictureClauseContext> {
			return getRuleContexts(DataPictureClauseContext.self)
		}
		open func dataPictureClause(_ i: Int) -> DataPictureClauseContext? {
			return getRuleContext(DataPictureClauseContext.self,i)
		}
		open func dataCommonOwnLocalClause() -> Array<DataCommonOwnLocalClauseContext> {
			return getRuleContexts(DataCommonOwnLocalClauseContext.self)
		}
		open func dataCommonOwnLocalClause(_ i: Int) -> DataCommonOwnLocalClauseContext? {
			return getRuleContext(DataCommonOwnLocalClauseContext.self,i)
		}
		open func dataTypeClause() -> Array<DataTypeClauseContext> {
			return getRuleContexts(DataTypeClauseContext.self)
		}
		open func dataTypeClause(_ i: Int) -> DataTypeClauseContext? {
			return getRuleContext(DataTypeClauseContext.self,i)
		}
		open func dataUsingClause() -> Array<DataUsingClauseContext> {
			return getRuleContexts(DataUsingClauseContext.self)
		}
		open func dataUsingClause(_ i: Int) -> DataUsingClauseContext? {
			return getRuleContext(DataUsingClauseContext.self,i)
		}
		open func dataValueClause() -> Array<DataValueClauseContext> {
			return getRuleContexts(DataValueClauseContext.self)
		}
		open func dataValueClause(_ i: Int) -> DataValueClauseContext? {
			return getRuleContext(DataValueClauseContext.self,i)
		}
		open func dataUsageClause() -> Array<DataUsageClauseContext> {
			return getRuleContexts(DataUsageClauseContext.self)
		}
		open func dataUsageClause(_ i: Int) -> DataUsageClauseContext? {
			return getRuleContext(DataUsageClauseContext.self,i)
		}
		open func dataReceivedByClause() -> Array<DataReceivedByClauseContext> {
			return getRuleContexts(DataReceivedByClauseContext.self)
		}
		open func dataReceivedByClause(_ i: Int) -> DataReceivedByClauseContext? {
			return getRuleContext(DataReceivedByClauseContext.self,i)
		}
		open func dataOccursClause() -> Array<DataOccursClauseContext> {
			return getRuleContexts(DataOccursClauseContext.self)
		}
		open func dataOccursClause(_ i: Int) -> DataOccursClauseContext? {
			return getRuleContext(DataOccursClauseContext.self,i)
		}
		open func dataSignClause() -> Array<DataSignClauseContext> {
			return getRuleContexts(DataSignClauseContext.self)
		}
		open func dataSignClause(_ i: Int) -> DataSignClauseContext? {
			return getRuleContext(DataSignClauseContext.self,i)
		}
		open func dataSynchronizedClause() -> Array<DataSynchronizedClauseContext> {
			return getRuleContexts(DataSynchronizedClauseContext.self)
		}
		open func dataSynchronizedClause(_ i: Int) -> DataSynchronizedClauseContext? {
			return getRuleContext(DataSynchronizedClauseContext.self,i)
		}
		open func dataJustifiedClause() -> Array<DataJustifiedClauseContext> {
			return getRuleContexts(DataJustifiedClauseContext.self)
		}
		open func dataJustifiedClause(_ i: Int) -> DataJustifiedClauseContext? {
			return getRuleContext(DataJustifiedClauseContext.self,i)
		}
		open func dataBlankWhenZeroClause() -> Array<DataBlankWhenZeroClauseContext> {
			return getRuleContexts(DataBlankWhenZeroClauseContext.self)
		}
		open func dataBlankWhenZeroClause(_ i: Int) -> DataBlankWhenZeroClauseContext? {
			return getRuleContext(DataBlankWhenZeroClauseContext.self,i)
		}
		open func dataWithLowerBoundsClause() -> DataWithLowerBoundsClauseContext? {
			return getRuleContext(DataWithLowerBoundsClauseContext.self,0)
		}
		open func dataAlignedClause() -> DataAlignedClauseContext? {
			return getRuleContext(DataAlignedClauseContext.self,0)
		}
		open func dataRecordAreaClause() -> DataRecordAreaClauseContext? {
			return getRuleContext(DataRecordAreaClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescriptionEntryFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescriptionEntryFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescriptionEntryFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescriptionEntryFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescriptionEntryFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescriptionEntryFormat1() throws -> DataDescriptionEntryFormat1Context {
		var _localctx: DataDescriptionEntryFormat1Context = DataDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 442, Cobol85Parser.RULE_dataDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3182)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LEVEL_NUMBER_77 || _la == Cobol85Parser.INTEGERLITERAL
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3185)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,400,_ctx)) {
		 	case 1:
		 		setState(3183)
		 		try match(Cobol85Parser.FILLER)

		 		break
		 	case 2:
		 		setState(3184)
		 		try dataName()

		 		break
		 	default: break
		 	}
		 	setState(3188)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REDEFINES
		 	      return testSet
		 	 }()) {
		 		setState(3187)
		 		try dataRedefinesClause()

		 	}

		 	setState(3191)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,402,_ctx)) {
		 	case 1:
		 		setState(3190)
		 		try dataIntegerStringClause()

		 		break
		 	default: break
		 	}
		 	setState(3194)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,403,_ctx)) {
		 	case 1:
		 		setState(3193)
		 		try dataExternalClause()

		 		break
		 	default: break
		 	}
		 	setState(3197)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,404,_ctx)) {
		 	case 1:
		 		setState(3196)
		 		try dataGlobalClause()

		 		break
		 	default: break
		 	}
		 	setState(3200)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,405,_ctx)) {
		 	case 1:
		 		setState(3199)
		 		try dataTypeDefClause()

		 		break
		 	default: break
		 	}
		 	setState(3203)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,406,_ctx)) {
		 	case 1:
		 		setState(3202)
		 		try dataThreadLocalClause()

		 		break
		 	default: break
		 	}
		 	setState(3219)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,408,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3217)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,407, _ctx)) {
		 			case 1:
		 				setState(3205)
		 				try dataPictureClause()

		 				break
		 			case 2:
		 				setState(3206)
		 				try dataCommonOwnLocalClause()

		 				break
		 			case 3:
		 				setState(3207)
		 				try dataTypeClause()

		 				break
		 			case 4:
		 				setState(3208)
		 				try dataUsingClause()

		 				break
		 			case 5:
		 				setState(3209)
		 				try dataValueClause()

		 				break
		 			case 6:
		 				setState(3210)
		 				try dataUsageClause()

		 				break
		 			case 7:
		 				setState(3211)
		 				try dataReceivedByClause()

		 				break
		 			case 8:
		 				setState(3212)
		 				try dataOccursClause()

		 				break
		 			case 9:
		 				setState(3213)
		 				try dataSignClause()

		 				break
		 			case 10:
		 				setState(3214)
		 				try dataSynchronizedClause()

		 				break
		 			case 11:
		 				setState(3215)
		 				try dataJustifiedClause()

		 				break
		 			case 12:
		 				setState(3216)
		 				try dataBlankWhenZeroClause()

		 				break
		 			default: break
		 			}
		 	 
		 		}
		 		setState(3221)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,408,_ctx)
		 	}
		 	setState(3223)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LOWER
		 	          testSet = testSet || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(3222)
		 		try dataWithLowerBoundsClause()

		 	}

		 	setState(3226)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ALIGNED
		 	      return testSet
		 	 }()) {
		 		setState(3225)
		 		try dataAlignedClause()

		 	}

		 	setState(3229)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RECORD
		 	      return testSet
		 	 }()) {
		 		setState(3228)
		 		try dataRecordAreaClause()

		 	}

		 	setState(3231)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescriptionEntryFormat2Context:ParserRuleContext {
		open func LEVEL_NUMBER_66() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_66, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func dataRenamesClause() -> DataRenamesClauseContext? {
			return getRuleContext(DataRenamesClauseContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescriptionEntryFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescriptionEntryFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescriptionEntryFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescriptionEntryFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescriptionEntryFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescriptionEntryFormat2() throws -> DataDescriptionEntryFormat2Context {
		var _localctx: DataDescriptionEntryFormat2Context = DataDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 444, Cobol85Parser.RULE_dataDescriptionEntryFormat2)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3233)
		 	try match(Cobol85Parser.LEVEL_NUMBER_66)
		 	setState(3234)
		 	try dataName()
		 	setState(3235)
		 	try dataRenamesClause()
		 	setState(3236)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescriptionEntryFormat3Context:ParserRuleContext {
		open func LEVEL_NUMBER_88() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_88, 0) }
		open func conditionName() -> ConditionNameContext? {
			return getRuleContext(ConditionNameContext.self,0)
		}
		open func dataValueClause() -> DataValueClauseContext? {
			return getRuleContext(DataValueClauseContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescriptionEntryFormat3 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescriptionEntryFormat3(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescriptionEntryFormat3(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescriptionEntryFormat3(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescriptionEntryFormat3(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescriptionEntryFormat3() throws -> DataDescriptionEntryFormat3Context {
		var _localctx: DataDescriptionEntryFormat3Context = DataDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 446, Cobol85Parser.RULE_dataDescriptionEntryFormat3)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3238)
		 	try match(Cobol85Parser.LEVEL_NUMBER_88)
		 	setState(3239)
		 	try conditionName()
		 	setState(3240)
		 	try dataValueClause()
		 	setState(3241)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescriptionEntryExecSqlContext:ParserRuleContext {
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func EXECSQLLINE() -> Array<TerminalNode> { return getTokens(Cobol85Parser.EXECSQLLINE) }
		open func EXECSQLLINE(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.EXECSQLLINE, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescriptionEntryExecSql }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescriptionEntryExecSql(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescriptionEntryExecSql(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescriptionEntryExecSql(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescriptionEntryExecSql(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescriptionEntryExecSql() throws -> DataDescriptionEntryExecSqlContext {
		var _localctx: DataDescriptionEntryExecSqlContext = DataDescriptionEntryExecSqlContext(_ctx, getState())
		try enterRule(_localctx, 448, Cobol85Parser.RULE_dataDescriptionEntryExecSql)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3244) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3243)
		 		try match(Cobol85Parser.EXECSQLLINE)


		 		setState(3246); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.EXECSQLLINE
		 	      return testSet
		 	 }())
		 	setState(3248)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataAlignedClauseContext:ParserRuleContext {
		open func ALIGNED() -> TerminalNode? { return getToken(Cobol85Parser.ALIGNED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataAlignedClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataAlignedClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataAlignedClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataAlignedClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataAlignedClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataAlignedClause() throws -> DataAlignedClauseContext {
		var _localctx: DataAlignedClauseContext = DataAlignedClauseContext(_ctx, getState())
		try enterRule(_localctx, 450, Cobol85Parser.RULE_dataAlignedClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3250)
		 	try match(Cobol85Parser.ALIGNED)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataBlankWhenZeroClauseContext:ParserRuleContext {
		open func BLANK() -> TerminalNode? { return getToken(Cobol85Parser.BLANK, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func ZEROS() -> TerminalNode? { return getToken(Cobol85Parser.ZEROS, 0) }
		open func ZEROES() -> TerminalNode? { return getToken(Cobol85Parser.ZEROES, 0) }
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataBlankWhenZeroClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataBlankWhenZeroClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataBlankWhenZeroClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataBlankWhenZeroClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataBlankWhenZeroClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataBlankWhenZeroClause() throws -> DataBlankWhenZeroClauseContext {
		var _localctx: DataBlankWhenZeroClauseContext = DataBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 452, Cobol85Parser.RULE_dataBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3252)
		 	try match(Cobol85Parser.BLANK)
		 	setState(3254)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(3253)
		 		try match(Cobol85Parser.WHEN)

		 	}

		 	setState(3256)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ZERO,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	    return  Utils.testBitLeftShiftArray(testArray, 526)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataCommonOwnLocalClauseContext:ParserRuleContext {
		open func COMMON() -> TerminalNode? { return getToken(Cobol85Parser.COMMON, 0) }
		open func OWN() -> TerminalNode? { return getToken(Cobol85Parser.OWN, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(Cobol85Parser.LOCAL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataCommonOwnLocalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataCommonOwnLocalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataCommonOwnLocalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataCommonOwnLocalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataCommonOwnLocalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataCommonOwnLocalClause() throws -> DataCommonOwnLocalClauseContext {
		var _localctx: DataCommonOwnLocalClauseContext = DataCommonOwnLocalClauseContext(_ctx, getState())
		try enterRule(_localctx, 454, Cobol85Parser.RULE_dataCommonOwnLocalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3258)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COMMON
		 	          testSet = testSet || _la == Cobol85Parser.LOCAL || _la == Cobol85Parser.OWN
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataExternalClauseContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(Cobol85Parser.EXTERNAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataExternalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataExternalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataExternalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataExternalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataExternalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataExternalClause() throws -> DataExternalClauseContext {
		var _localctx: DataExternalClauseContext = DataExternalClauseContext(_ctx, getState())
		try enterRule(_localctx, 456, Cobol85Parser.RULE_dataExternalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3261)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3260)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3263)
		 	try match(Cobol85Parser.EXTERNAL)
		 	setState(3266)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,415,_ctx)) {
		 	case 1:
		 		setState(3264)
		 		try match(Cobol85Parser.BY)
		 		setState(3265)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataGlobalClauseContext:ParserRuleContext {
		open func GLOBAL() -> TerminalNode? { return getToken(Cobol85Parser.GLOBAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataGlobalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataGlobalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataGlobalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataGlobalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataGlobalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataGlobalClause() throws -> DataGlobalClauseContext {
		var _localctx: DataGlobalClauseContext = DataGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 458, Cobol85Parser.RULE_dataGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3269)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3268)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3271)
		 	try match(Cobol85Parser.GLOBAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataIntegerStringClauseContext:ParserRuleContext {
		open func INTEGER() -> TerminalNode? { return getToken(Cobol85Parser.INTEGER, 0) }
		open func STRING() -> TerminalNode? { return getToken(Cobol85Parser.STRING, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataIntegerStringClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataIntegerStringClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataIntegerStringClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataIntegerStringClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataIntegerStringClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataIntegerStringClause() throws -> DataIntegerStringClauseContext {
		var _localctx: DataIntegerStringClauseContext = DataIntegerStringClauseContext(_ctx, getState())
		try enterRule(_localctx, 460, Cobol85Parser.RULE_dataIntegerStringClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3273)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.INTEGER
		 	          testSet = testSet || _la == Cobol85Parser.STRING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataJustifiedClauseContext:ParserRuleContext {
		open func JUSTIFIED() -> TerminalNode? { return getToken(Cobol85Parser.JUSTIFIED, 0) }
		open func JUST() -> TerminalNode? { return getToken(Cobol85Parser.JUST, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(Cobol85Parser.RIGHT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataJustifiedClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataJustifiedClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataJustifiedClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataJustifiedClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataJustifiedClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataJustifiedClause() throws -> DataJustifiedClauseContext {
		var _localctx: DataJustifiedClauseContext = DataJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 462, Cobol85Parser.RULE_dataJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3275)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.JUST || _la == Cobol85Parser.JUSTIFIED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3277)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RIGHT
		 	      return testSet
		 	 }()) {
		 		setState(3276)
		 		try match(Cobol85Parser.RIGHT)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataOccursClauseContext:ParserRuleContext {
		open func OCCURS() -> TerminalNode? { return getToken(Cobol85Parser.OCCURS, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func dataOccursTo() -> DataOccursToContext? {
			return getRuleContext(DataOccursToContext.self,0)
		}
		open func TIMES() -> TerminalNode? { return getToken(Cobol85Parser.TIMES, 0) }
		open func DEPENDING() -> TerminalNode? { return getToken(Cobol85Parser.DEPENDING, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func dataOccursSort() -> Array<DataOccursSortContext> {
			return getRuleContexts(DataOccursSortContext.self)
		}
		open func dataOccursSort(_ i: Int) -> DataOccursSortContext? {
			return getRuleContext(DataOccursSortContext.self,i)
		}
		open func INDEXED() -> TerminalNode? { return getToken(Cobol85Parser.INDEXED, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(Cobol85Parser.LOCAL, 0) }
		open func indexName() -> Array<IndexNameContext> {
			return getRuleContexts(IndexNameContext.self)
		}
		open func indexName(_ i: Int) -> IndexNameContext? {
			return getRuleContext(IndexNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataOccursClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataOccursClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataOccursClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataOccursClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataOccursClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataOccursClause() throws -> DataOccursClauseContext {
		var _localctx: DataOccursClauseContext = DataOccursClauseContext(_ctx, getState())
		try enterRule(_localctx, 464, Cobol85Parser.RULE_dataOccursClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3279)
		 	try match(Cobol85Parser.OCCURS)
		 	setState(3280)
		 	try integerLiteral()
		 	setState(3282)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(3281)
		 		try dataOccursTo()

		 	}

		 	setState(3285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TIMES
		 	      return testSet
		 	 }()) {
		 		setState(3284)
		 		try match(Cobol85Parser.TIMES)

		 	}

		 	setState(3292)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DEPENDING
		 	      return testSet
		 	 }()) {
		 		setState(3287)
		 		try match(Cobol85Parser.DEPENDING)
		 		setState(3289)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.ON
		 		      return testSet
		 		 }()) {
		 			setState(3288)
		 			try match(Cobol85Parser.ON)

		 		}

		 		setState(3291)
		 		try qualifiedDataName()

		 	}

		 	setState(3297)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ASCENDING
		 	          testSet = testSet || _la == Cobol85Parser.DESCENDING
		 	      return testSet
		 	 }()) {
		 		setState(3294)
		 		try dataOccursSort()


		 		setState(3299)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3312)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INDEXED
		 	      return testSet
		 	 }()) {
		 		setState(3300)
		 		try match(Cobol85Parser.INDEXED)
		 		setState(3302)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.BY
		 		      return testSet
		 		 }()) {
		 			setState(3301)
		 			try match(Cobol85Parser.BY)

		 		}

		 		setState(3305)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,424,_ctx)) {
		 		case 1:
		 			setState(3304)
		 			try match(Cobol85Parser.LOCAL)

		 			break
		 		default: break
		 		}
		 		setState(3308); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3307)
		 				try indexName()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3310); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,425,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataOccursToContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataOccursTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataOccursTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataOccursTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataOccursTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataOccursTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataOccursTo() throws -> DataOccursToContext {
		var _localctx: DataOccursToContext = DataOccursToContext(_ctx, getState())
		try enterRule(_localctx, 466, Cobol85Parser.RULE_dataOccursTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3314)
		 	try match(Cobol85Parser.TO)
		 	setState(3315)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataOccursSortContext:ParserRuleContext {
		open func ASCENDING() -> TerminalNode? { return getToken(Cobol85Parser.ASCENDING, 0) }
		open func DESCENDING() -> TerminalNode? { return getToken(Cobol85Parser.DESCENDING, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func qualifiedDataName() -> Array<QualifiedDataNameContext> {
			return getRuleContexts(QualifiedDataNameContext.self)
		}
		open func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataOccursSort }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataOccursSort(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataOccursSort(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataOccursSort(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataOccursSort(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataOccursSort() throws -> DataOccursSortContext {
		var _localctx: DataOccursSortContext = DataOccursSortContext(_ctx, getState())
		try enterRule(_localctx, 468, Cobol85Parser.RULE_dataOccursSort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3317)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ASCENDING
		 	          testSet = testSet || _la == Cobol85Parser.DESCENDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3319)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(3318)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(3322)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3321)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3325); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3324)
		 			try qualifiedDataName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3327); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,429,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataPictureClauseContext:ParserRuleContext {
		open func pictureString() -> PictureStringContext? {
			return getRuleContext(PictureStringContext.self,0)
		}
		open func PICTURE() -> TerminalNode? { return getToken(Cobol85Parser.PICTURE, 0) }
		open func PIC() -> TerminalNode? { return getToken(Cobol85Parser.PIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataPictureClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataPictureClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataPictureClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataPictureClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataPictureClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataPictureClause() throws -> DataPictureClauseContext {
		var _localctx: DataPictureClauseContext = DataPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 470, Cobol85Parser.RULE_dataPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3329)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PIC || _la == Cobol85Parser.PICTURE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3331)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3330)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3333)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PictureStringContext:ParserRuleContext {
		open func pictureChars() -> Array<PictureCharsContext> {
			return getRuleContexts(PictureCharsContext.self)
		}
		open func pictureChars(_ i: Int) -> PictureCharsContext? {
			return getRuleContext(PictureCharsContext.self,i)
		}
		open func pictureCardinality() -> Array<PictureCardinalityContext> {
			return getRuleContexts(PictureCardinalityContext.self)
		}
		open func pictureCardinality(_ i: Int) -> PictureCardinalityContext? {
			return getRuleContext(PictureCardinalityContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_pictureString }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPictureString(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPictureString(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPictureString(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPictureString(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pictureString() throws -> PictureStringContext {
		var _localctx: PictureStringContext = PictureStringContext(_ctx, getState())
		try enterRule(_localctx, 472, Cobol85Parser.RULE_pictureString)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3343); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3336); 
		 			try _errHandler.sync(self)
		 			_alt = 1;
		 			repeat {
		 				switch (_alt) {
		 				case 1:
		 					setState(3335)
		 					try pictureChars()


		 					break
		 				default:
		 					throw try ANTLRException.recognition(e: NoViableAltException(self))
		 				}
		 				setState(3338); 
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,431,_ctx)
		 			} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 			setState(3341)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,432,_ctx)) {
		 			case 1:
		 				setState(3340)
		 				try pictureCardinality()

		 				break
		 			default: break
		 			}


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3345); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,433,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PictureCharsContext:ParserRuleContext {
		open func DOLLARCHAR() -> TerminalNode? { return getToken(Cobol85Parser.DOLLARCHAR, 0) }
		open func IDENTIFIER() -> TerminalNode? { return getToken(Cobol85Parser.IDENTIFIER, 0) }
		open func NUMERICLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.NUMERICLITERAL, 0) }
		open func SLASHCHAR() -> TerminalNode? { return getToken(Cobol85Parser.SLASHCHAR, 0) }
		open func COMMACHAR() -> TerminalNode? { return getToken(Cobol85Parser.COMMACHAR, 0) }
		open func DOT() -> TerminalNode? { return getToken(Cobol85Parser.DOT, 0) }
		open func COLONCHAR() -> TerminalNode? { return getToken(Cobol85Parser.COLONCHAR, 0) }
		open func ASTERISKCHAR() -> TerminalNode? { return getToken(Cobol85Parser.ASTERISKCHAR, 0) }
		open func DOUBLEASTERISKCHAR() -> TerminalNode? { return getToken(Cobol85Parser.DOUBLEASTERISKCHAR, 0) }
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func PLUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.PLUSCHAR, 0) }
		open func MINUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MINUSCHAR, 0) }
		open func LESSTHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LESSTHANCHAR, 0) }
		open func MORETHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MORETHANCHAR, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func pictureCharsKeyword() -> PictureCharsKeywordContext? {
			return getRuleContext(PictureCharsKeywordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_pictureChars }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPictureChars(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPictureChars(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPictureChars(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPictureChars(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pictureChars() throws -> PictureCharsContext {
		var _localctx: PictureCharsContext = PictureCharsContext(_ctx, getState())
		try enterRule(_localctx, 474, Cobol85Parser.RULE_pictureChars)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3364)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.DOLLARCHAR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3347)
		 		try match(Cobol85Parser.DOLLARCHAR)

		 		break

		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3348)
		 		try match(Cobol85Parser.IDENTIFIER)

		 		break

		 	case Cobol85Parser.NUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3349)
		 		try match(Cobol85Parser.NUMERICLITERAL)

		 		break

		 	case Cobol85Parser.SLASHCHAR:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3350)
		 		try match(Cobol85Parser.SLASHCHAR)

		 		break

		 	case Cobol85Parser.COMMACHAR:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3351)
		 		try match(Cobol85Parser.COMMACHAR)

		 		break

		 	case Cobol85Parser.DOT:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3352)
		 		try match(Cobol85Parser.DOT)

		 		break

		 	case Cobol85Parser.COLONCHAR:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3353)
		 		try match(Cobol85Parser.COLONCHAR)

		 		break

		 	case Cobol85Parser.ASTERISKCHAR:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3354)
		 		try match(Cobol85Parser.ASTERISKCHAR)

		 		break

		 	case Cobol85Parser.DOUBLEASTERISKCHAR:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3355)
		 		try match(Cobol85Parser.DOUBLEASTERISKCHAR)

		 		break

		 	case Cobol85Parser.LPARENCHAR:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3356)
		 		try match(Cobol85Parser.LPARENCHAR)

		 		break

		 	case Cobol85Parser.RPARENCHAR:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3357)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break

		 	case Cobol85Parser.PLUSCHAR:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3358)
		 		try match(Cobol85Parser.PLUSCHAR)

		 		break

		 	case Cobol85Parser.MINUSCHAR:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3359)
		 		try match(Cobol85Parser.MINUSCHAR)

		 		break

		 	case Cobol85Parser.LESSTHANCHAR:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3360)
		 		try match(Cobol85Parser.LESSTHANCHAR)

		 		break

		 	case Cobol85Parser.MORETHANCHAR:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3361)
		 		try match(Cobol85Parser.MORETHANCHAR)

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3362)
		 		try integerLiteral()

		 		break

		 	case Cobol85Parser.SP:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(3363)
		 		try pictureCharsKeyword()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PictureCharsKeywordContext:ParserRuleContext {
		open func SP() -> TerminalNode? { return getToken(Cobol85Parser.SP, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_pictureCharsKeyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPictureCharsKeyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPictureCharsKeyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPictureCharsKeyword(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPictureCharsKeyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pictureCharsKeyword() throws -> PictureCharsKeywordContext {
		var _localctx: PictureCharsKeywordContext = PictureCharsKeywordContext(_ctx, getState())
		try enterRule(_localctx, 476, Cobol85Parser.RULE_pictureCharsKeyword)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3366)
		 	try match(Cobol85Parser.SP)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PictureCardinalityContext:ParserRuleContext {
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_pictureCardinality }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPictureCardinality(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPictureCardinality(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPictureCardinality(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPictureCardinality(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pictureCardinality() throws -> PictureCardinalityContext {
		var _localctx: PictureCardinalityContext = PictureCardinalityContext(_ctx, getState())
		try enterRule(_localctx, 478, Cobol85Parser.RULE_pictureCardinality)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3368)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(3369)
		 	try integerLiteral()
		 	setState(3370)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataReceivedByClauseContext:ParserRuleContext {
		open func CONTENT() -> TerminalNode? { return getToken(Cobol85Parser.CONTENT, 0) }
		open func REFERENCE() -> TerminalNode? { return getToken(Cobol85Parser.REFERENCE, 0) }
		open func REF() -> TerminalNode? { return getToken(Cobol85Parser.REF, 0) }
		open func RECEIVED() -> TerminalNode? { return getToken(Cobol85Parser.RECEIVED, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataReceivedByClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataReceivedByClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataReceivedByClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataReceivedByClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataReceivedByClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataReceivedByClause() throws -> DataReceivedByClauseContext {
		var _localctx: DataReceivedByClauseContext = DataReceivedByClauseContext(_ctx, getState())
		try enterRule(_localctx, 480, Cobol85Parser.RULE_dataReceivedByClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3373)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RECEIVED
		 	      return testSet
		 	 }()) {
		 		setState(3372)
		 		try match(Cobol85Parser.RECEIVED)

		 	}

		 	setState(3376)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BY
		 	      return testSet
		 	 }()) {
		 		setState(3375)
		 		try match(Cobol85Parser.BY)

		 	}

		 	setState(3378)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CONTENT
		 	          testSet = testSet || _la == Cobol85Parser.REF || _la == Cobol85Parser.REFERENCE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataRecordAreaClauseContext:ParserRuleContext {
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func AREA() -> TerminalNode? { return getToken(Cobol85Parser.AREA, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataRecordAreaClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataRecordAreaClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataRecordAreaClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataRecordAreaClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataRecordAreaClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataRecordAreaClause() throws -> DataRecordAreaClauseContext {
		var _localctx: DataRecordAreaClauseContext = DataRecordAreaClauseContext(_ctx, getState())
		try enterRule(_localctx, 482, Cobol85Parser.RULE_dataRecordAreaClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3380)
		 	try match(Cobol85Parser.RECORD)
		 	setState(3381)
		 	try match(Cobol85Parser.AREA)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataRedefinesClauseContext:ParserRuleContext {
		open func REDEFINES() -> TerminalNode? { return getToken(Cobol85Parser.REDEFINES, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataRedefinesClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataRedefinesClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataRedefinesClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataRedefinesClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataRedefinesClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataRedefinesClause() throws -> DataRedefinesClauseContext {
		var _localctx: DataRedefinesClauseContext = DataRedefinesClauseContext(_ctx, getState())
		try enterRule(_localctx, 484, Cobol85Parser.RULE_dataRedefinesClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3383)
		 	try match(Cobol85Parser.REDEFINES)
		 	setState(3384)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataRenamesClauseContext:ParserRuleContext {
		open func RENAMES() -> TerminalNode? { return getToken(Cobol85Parser.RENAMES, 0) }
		open func qualifiedDataName() -> Array<QualifiedDataNameContext> {
			return getRuleContexts(QualifiedDataNameContext.self)
		}
		open func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,i)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataRenamesClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataRenamesClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataRenamesClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataRenamesClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataRenamesClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataRenamesClause() throws -> DataRenamesClauseContext {
		var _localctx: DataRenamesClauseContext = DataRenamesClauseContext(_ctx, getState())
		try enterRule(_localctx, 486, Cobol85Parser.RULE_dataRenamesClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3386)
		 	try match(Cobol85Parser.RENAMES)
		 	setState(3387)
		 	try qualifiedDataName()
		 	setState(3390)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(3388)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(3389)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataSignClauseContext:ParserRuleContext {
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(Cobol85Parser.TRAILING, 0) }
		open func SIGN() -> TerminalNode? { return getToken(Cobol85Parser.SIGN, 0) }
		open func SEPARATE() -> TerminalNode? { return getToken(Cobol85Parser.SEPARATE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTER, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataSignClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataSignClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataSignClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataSignClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataSignClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataSignClause() throws -> DataSignClauseContext {
		var _localctx: DataSignClauseContext = DataSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 488, Cobol85Parser.RULE_dataSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3396)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SIGN
		 	      return testSet
		 	 }()) {
		 		setState(3392)
		 		try match(Cobol85Parser.SIGN)
		 		setState(3394)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(3393)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(3398)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEADING
		 	          testSet = testSet || _la == Cobol85Parser.TRAILING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3403)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SEPARATE
		 	      return testSet
		 	 }()) {
		 		setState(3399)
		 		try match(Cobol85Parser.SEPARATE)
		 		setState(3401)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.CHARACTER
		 		      return testSet
		 		 }()) {
		 			setState(3400)
		 			try match(Cobol85Parser.CHARACTER)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataSynchronizedClauseContext:ParserRuleContext {
		open func SYNCHRONIZED() -> TerminalNode? { return getToken(Cobol85Parser.SYNCHRONIZED, 0) }
		open func SYNC() -> TerminalNode? { return getToken(Cobol85Parser.SYNC, 0) }
		open func LEFT() -> TerminalNode? { return getToken(Cobol85Parser.LEFT, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(Cobol85Parser.RIGHT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataSynchronizedClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataSynchronizedClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataSynchronizedClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataSynchronizedClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataSynchronizedClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataSynchronizedClause() throws -> DataSynchronizedClauseContext {
		var _localctx: DataSynchronizedClauseContext = DataSynchronizedClauseContext(_ctx, getState())
		try enterRule(_localctx, 490, Cobol85Parser.RULE_dataSynchronizedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3405)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.SYNC || _la == Cobol85Parser.SYNCHRONIZED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3407)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.LEFT
		 	          testSet = testSet || _la == Cobol85Parser.RIGHT
		 	      return testSet
		 	 }()) {
		 		setState(3406)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.LEFT
		 		          testSet = testSet || _la == Cobol85Parser.RIGHT
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataThreadLocalClauseContext:ParserRuleContext {
		open func THREAD_LOCAL() -> TerminalNode? { return getToken(Cobol85Parser.THREAD_LOCAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataThreadLocalClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataThreadLocalClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataThreadLocalClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataThreadLocalClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataThreadLocalClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataThreadLocalClause() throws -> DataThreadLocalClauseContext {
		var _localctx: DataThreadLocalClauseContext = DataThreadLocalClauseContext(_ctx, getState())
		try enterRule(_localctx, 492, Cobol85Parser.RULE_dataThreadLocalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3409)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3412)
		 	try match(Cobol85Parser.THREAD_LOCAL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataTypeClauseContext:ParserRuleContext {
		open func TYPE() -> TerminalNode? { return getToken(Cobol85Parser.TYPE, 0) }
		open func SHORT_DATE() -> TerminalNode? { return getToken(Cobol85Parser.SHORT_DATE, 0) }
		open func LONG_DATE() -> TerminalNode? { return getToken(Cobol85Parser.LONG_DATE, 0) }
		open func NUMERIC_DATE() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC_DATE, 0) }
		open func NUMERIC_TIME() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC_TIME, 0) }
		open func LONG_TIME() -> TerminalNode? { return getToken(Cobol85Parser.LONG_TIME, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataTypeClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataTypeClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataTypeClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataTypeClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataTypeClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataTypeClause() throws -> DataTypeClauseContext {
		var _localctx: DataTypeClauseContext = DataTypeClauseContext(_ctx, getState())
		try enterRule(_localctx, 494, Cobol85Parser.RULE_dataTypeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3414)
		 	try match(Cobol85Parser.TYPE)
		 	setState(3416)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3415)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3418)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME]
		 	    return  Utils.testBitLeftShiftArray(testArray, 290)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.SHORT_DATE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataTypeDefClauseContext:ParserRuleContext {
		open func TYPEDEF() -> TerminalNode? { return getToken(Cobol85Parser.TYPEDEF, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataTypeDefClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataTypeDefClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataTypeDefClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataTypeDefClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataTypeDefClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataTypeDefClause() throws -> DataTypeDefClauseContext {
		var _localctx: DataTypeDefClauseContext = DataTypeDefClauseContext(_ctx, getState())
		try enterRule(_localctx, 496, Cobol85Parser.RULE_dataTypeDefClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3421)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(3420)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(3423)
		 	try match(Cobol85Parser.TYPEDEF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataUsageClauseContext:ParserRuleContext {
		open func BINARY() -> TerminalNode? { return getToken(Cobol85Parser.BINARY, 0) }
		open func BIT() -> TerminalNode? { return getToken(Cobol85Parser.BIT, 0) }
		open func COMP() -> TerminalNode? { return getToken(Cobol85Parser.COMP, 0) }
		open func COMP_1() -> TerminalNode? { return getToken(Cobol85Parser.COMP_1, 0) }
		open func COMP_2() -> TerminalNode? { return getToken(Cobol85Parser.COMP_2, 0) }
		open func COMP_3() -> TerminalNode? { return getToken(Cobol85Parser.COMP_3, 0) }
		open func COMP_4() -> TerminalNode? { return getToken(Cobol85Parser.COMP_4, 0) }
		open func COMP_5() -> TerminalNode? { return getToken(Cobol85Parser.COMP_5, 0) }
		open func COMPUTATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL, 0) }
		open func COMPUTATIONAL_1() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL_1, 0) }
		open func COMPUTATIONAL_2() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL_2, 0) }
		open func COMPUTATIONAL_3() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL_3, 0) }
		open func COMPUTATIONAL_4() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL_4, 0) }
		open func COMPUTATIONAL_5() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTATIONAL_5, 0) }
		open func CONTROL_POINT() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL_POINT, 0) }
		open func DATE() -> TerminalNode? { return getToken(Cobol85Parser.DATE, 0) }
		open func DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY, 0) }
		open func DISPLAY_1() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY_1, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(Cobol85Parser.DOUBLE, 0) }
		open func EVENT() -> TerminalNode? { return getToken(Cobol85Parser.EVENT, 0) }
		open func FUNCTION_POINTER() -> TerminalNode? { return getToken(Cobol85Parser.FUNCTION_POINTER, 0) }
		open func INDEX() -> TerminalNode? { return getToken(Cobol85Parser.INDEX, 0) }
		open func KANJI() -> TerminalNode? { return getToken(Cobol85Parser.KANJI, 0) }
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func PACKED_DECIMAL() -> TerminalNode? { return getToken(Cobol85Parser.PACKED_DECIMAL, 0) }
		open func POINTER() -> TerminalNode? { return getToken(Cobol85Parser.POINTER, 0) }
		open func PROCEDURE_POINTER() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE_POINTER, 0) }
		open func REAL() -> TerminalNode? { return getToken(Cobol85Parser.REAL, 0) }
		open func TASK() -> TerminalNode? { return getToken(Cobol85Parser.TASK, 0) }
		open func USAGE() -> TerminalNode? { return getToken(Cobol85Parser.USAGE, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func TRUNCATED() -> TerminalNode? { return getToken(Cobol85Parser.TRUNCATED, 0) }
		open func EXTENDED() -> TerminalNode? { return getToken(Cobol85Parser.EXTENDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataUsageClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataUsageClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataUsageClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataUsageClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataUsageClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataUsageClause() throws -> DataUsageClauseContext {
		var _localctx: DataUsageClauseContext = DataUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 498, Cobol85Parser.RULE_dataUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3429)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USAGE
		 	      return testSet
		 	 }()) {
		 		setState(3425)
		 		try match(Cobol85Parser.USAGE)
		 		setState(3427)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.IS
		 		      return testSet
		 		 }()) {
		 			setState(3426)
		 			try match(Cobol85Parser.IS)

		 		}


		 	}

		 	setState(3464)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.BINARY:
		 		setState(3431)
		 		try match(Cobol85Parser.BINARY)
		 		setState(3433)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,448,_ctx)) {
		 		case 1:
		 			setState(3432)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == Cobol85Parser.EXTENDED
		 			          testSet = testSet || _la == Cobol85Parser.TRUNCATED
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}

		 		break

		 	case Cobol85Parser.BIT:
		 		setState(3435)
		 		try match(Cobol85Parser.BIT)

		 		break

		 	case Cobol85Parser.COMP:
		 		setState(3436)
		 		try match(Cobol85Parser.COMP)

		 		break

		 	case Cobol85Parser.COMP_1:
		 		setState(3437)
		 		try match(Cobol85Parser.COMP_1)

		 		break

		 	case Cobol85Parser.COMP_2:
		 		setState(3438)
		 		try match(Cobol85Parser.COMP_2)

		 		break

		 	case Cobol85Parser.COMP_3:
		 		setState(3439)
		 		try match(Cobol85Parser.COMP_3)

		 		break

		 	case Cobol85Parser.COMP_4:
		 		setState(3440)
		 		try match(Cobol85Parser.COMP_4)

		 		break

		 	case Cobol85Parser.COMP_5:
		 		setState(3441)
		 		try match(Cobol85Parser.COMP_5)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL:
		 		setState(3442)
		 		try match(Cobol85Parser.COMPUTATIONAL)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL_1:
		 		setState(3443)
		 		try match(Cobol85Parser.COMPUTATIONAL_1)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL_2:
		 		setState(3444)
		 		try match(Cobol85Parser.COMPUTATIONAL_2)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL_3:
		 		setState(3445)
		 		try match(Cobol85Parser.COMPUTATIONAL_3)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL_4:
		 		setState(3446)
		 		try match(Cobol85Parser.COMPUTATIONAL_4)

		 		break

		 	case Cobol85Parser.COMPUTATIONAL_5:
		 		setState(3447)
		 		try match(Cobol85Parser.COMPUTATIONAL_5)

		 		break

		 	case Cobol85Parser.CONTROL_POINT:
		 		setState(3448)
		 		try match(Cobol85Parser.CONTROL_POINT)

		 		break

		 	case Cobol85Parser.DATE:
		 		setState(3449)
		 		try match(Cobol85Parser.DATE)

		 		break

		 	case Cobol85Parser.DISPLAY:
		 		setState(3450)
		 		try match(Cobol85Parser.DISPLAY)

		 		break

		 	case Cobol85Parser.DISPLAY_1:
		 		setState(3451)
		 		try match(Cobol85Parser.DISPLAY_1)

		 		break

		 	case Cobol85Parser.DOUBLE:
		 		setState(3452)
		 		try match(Cobol85Parser.DOUBLE)

		 		break

		 	case Cobol85Parser.EVENT:
		 		setState(3453)
		 		try match(Cobol85Parser.EVENT)

		 		break

		 	case Cobol85Parser.FUNCTION_POINTER:
		 		setState(3454)
		 		try match(Cobol85Parser.FUNCTION_POINTER)

		 		break

		 	case Cobol85Parser.INDEX:
		 		setState(3455)
		 		try match(Cobol85Parser.INDEX)

		 		break

		 	case Cobol85Parser.KANJI:
		 		setState(3456)
		 		try match(Cobol85Parser.KANJI)

		 		break

		 	case Cobol85Parser.LOCK:
		 		setState(3457)
		 		try match(Cobol85Parser.LOCK)

		 		break

		 	case Cobol85Parser.NATIONAL:
		 		setState(3458)
		 		try match(Cobol85Parser.NATIONAL)

		 		break

		 	case Cobol85Parser.PACKED_DECIMAL:
		 		setState(3459)
		 		try match(Cobol85Parser.PACKED_DECIMAL)

		 		break

		 	case Cobol85Parser.POINTER:
		 		setState(3460)
		 		try match(Cobol85Parser.POINTER)

		 		break

		 	case Cobol85Parser.PROCEDURE_POINTER:
		 		setState(3461)
		 		try match(Cobol85Parser.PROCEDURE_POINTER)

		 		break

		 	case Cobol85Parser.REAL:
		 		setState(3462)
		 		try match(Cobol85Parser.REAL)

		 		break

		 	case Cobol85Parser.TASK:
		 		setState(3463)
		 		try match(Cobol85Parser.TASK)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataUsingClauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func LANGUAGE() -> TerminalNode? { return getToken(Cobol85Parser.LANGUAGE, 0) }
		open func CONVENTION() -> TerminalNode? { return getToken(Cobol85Parser.CONVENTION, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataUsingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataUsingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataUsingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataUsingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataUsingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataUsingClause() throws -> DataUsingClauseContext {
		var _localctx: DataUsingClauseContext = DataUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 500, Cobol85Parser.RULE_dataUsingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3466)
		 	try match(Cobol85Parser.USING)
		 	setState(3467)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.CONVENTION
		 	          testSet = testSet || _la == Cobol85Parser.LANGUAGE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3469)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OF
		 	      return testSet
		 	 }()) {
		 		setState(3468)
		 		try match(Cobol85Parser.OF)

		 	}

		 	setState(3473)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,451, _ctx)) {
		 	case 1:
		 		setState(3471)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(3472)
		 		try dataName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataValueClauseContext:ParserRuleContext {
		open func VALUE() -> TerminalNode? { return getToken(Cobol85Parser.VALUE, 0) }
		open func VALUES() -> TerminalNode? { return getToken(Cobol85Parser.VALUES, 0) }
		open func dataValueInterval() -> Array<DataValueIntervalContext> {
			return getRuleContexts(DataValueIntervalContext.self)
		}
		open func dataValueInterval(_ i: Int) -> DataValueIntervalContext? {
			return getRuleContext(DataValueIntervalContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataValueClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataValueClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataValueClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataValueClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataValueClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataValueClause() throws -> DataValueClauseContext {
		var _localctx: DataValueClauseContext = DataValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 502, Cobol85Parser.RULE_dataValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3483)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.VALUE:
		 	 	setState(3475)
		 	 	try match(Cobol85Parser.VALUE)
		 	 	setState(3477)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3476)
		 	 		try match(Cobol85Parser.IS)

		 	 	}


		 		break

		 	case Cobol85Parser.VALUES:
		 	 	setState(3479)
		 	 	try match(Cobol85Parser.VALUES)
		 	 	setState(3481)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.ARE
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3480)
		 	 		try match(Cobol85Parser.ARE)

		 	 	}


		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.ALL:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FALSE:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.HIGH_VALUE:fallthrough
		 	case Cobol85Parser.HIGH_VALUES:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.LOW_VALUE:fallthrough
		 	case Cobol85Parser.LOW_VALUES:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NULL:fallthrough
		 	case Cobol85Parser.NULLS:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.QUOTE:fallthrough
		 	case Cobol85Parser.QUOTES:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SPACE:fallthrough
		 	case Cobol85Parser.SPACES:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUE:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.ZEROS:fallthrough
		 	case Cobol85Parser.ZEROES:fallthrough
		 	case Cobol85Parser.NONNUMERICLITERAL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.NUMERICLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3486); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3485)
		 			try dataValueInterval()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3488); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,455,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataValueIntervalContext:ParserRuleContext {
		open func dataValueIntervalFrom() -> DataValueIntervalFromContext? {
			return getRuleContext(DataValueIntervalFromContext.self,0)
		}
		open func dataValueIntervalTo() -> DataValueIntervalToContext? {
			return getRuleContext(DataValueIntervalToContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataValueInterval }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataValueInterval(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataValueInterval(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataValueInterval(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataValueInterval(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataValueInterval() throws -> DataValueIntervalContext {
		var _localctx: DataValueIntervalContext = DataValueIntervalContext(_ctx, getState())
		try enterRule(_localctx, 504, Cobol85Parser.RULE_dataValueInterval)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3490)
		 	try dataValueIntervalFrom()
		 	setState(3492)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(3491)
		 		try dataValueIntervalTo()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataValueIntervalFromContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataValueIntervalFrom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataValueIntervalFrom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataValueIntervalFrom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataValueIntervalFrom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataValueIntervalFrom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataValueIntervalFrom() throws -> DataValueIntervalFromContext {
		var _localctx: DataValueIntervalFromContext = DataValueIntervalFromContext(_ctx, getState())
		try enterRule(_localctx, 506, Cobol85Parser.RULE_dataValueIntervalFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3496)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,457, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3494)
		 		try literal()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3495)
		 		try cobolWord()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataValueIntervalToContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataValueIntervalTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataValueIntervalTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataValueIntervalTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataValueIntervalTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataValueIntervalTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataValueIntervalTo() throws -> DataValueIntervalToContext {
		var _localctx: DataValueIntervalToContext = DataValueIntervalToContext(_ctx, getState())
		try enterRule(_localctx, 508, Cobol85Parser.RULE_dataValueIntervalTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3498)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3499)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataWithLowerBoundsClauseContext:ParserRuleContext {
		open func LOWER() -> TerminalNode? { return getToken(Cobol85Parser.LOWER, 0) }
		open func BOUNDS() -> TerminalNode? { return getToken(Cobol85Parser.BOUNDS, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataWithLowerBoundsClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataWithLowerBoundsClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataWithLowerBoundsClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataWithLowerBoundsClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataWithLowerBoundsClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataWithLowerBoundsClause() throws -> DataWithLowerBoundsClauseContext {
		var _localctx: DataWithLowerBoundsClauseContext = DataWithLowerBoundsClauseContext(_ctx, getState())
		try enterRule(_localctx, 510, Cobol85Parser.RULE_dataWithLowerBoundsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3502)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(3501)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(3504)
		 	try match(Cobol85Parser.LOWER)
		 	setState(3505)
		 	try match(Cobol85Parser.BOUNDS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDivisionContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE, 0) }
		open func DIVISION() -> TerminalNode? { return getToken(Cobol85Parser.DIVISION, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func procedureDivisionBody() -> ProcedureDivisionBodyContext? {
			return getRuleContext(ProcedureDivisionBodyContext.self,0)
		}
		open func procedureDivisionUsingClause() -> ProcedureDivisionUsingClauseContext? {
			return getRuleContext(ProcedureDivisionUsingClauseContext.self,0)
		}
		open func procedureDivisionGivingClause() -> ProcedureDivisionGivingClauseContext? {
			return getRuleContext(ProcedureDivisionGivingClauseContext.self,0)
		}
		open func procedureDeclaratives() -> ProcedureDeclarativesContext? {
			return getRuleContext(ProcedureDeclarativesContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDivision }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDivision(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDivision(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDivision(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDivision(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDivision() throws -> ProcedureDivisionContext {
		var _localctx: ProcedureDivisionContext = ProcedureDivisionContext(_ctx, getState())
		try enterRule(_localctx, 512, Cobol85Parser.RULE_procedureDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3507)
		 	try match(Cobol85Parser.PROCEDURE)
		 	setState(3508)
		 	try match(Cobol85Parser.DIVISION)
		 	setState(3510)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(3509)
		 		try procedureDivisionUsingClause()

		 	}

		 	setState(3513)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(3512)
		 		try procedureDivisionGivingClause()

		 	}

		 	setState(3515)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3517)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DECLARATIVES
		 	      return testSet
		 	 }()) {
		 		setState(3516)
		 		try procedureDeclaratives()

		 	}

		 	setState(3519)
		 	try procedureDivisionBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDivisionUsingClauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(Cobol85Parser.STRING) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.STRING, i)
		}
		open func dataName() -> Array<DataNameContext> {
			return getRuleContexts(DataNameContext.self)
		}
		open func dataName(_ i: Int) -> DataNameContext? {
			return getRuleContext(DataNameContext.self,i)
		}
		open func INTEGER() -> Array<TerminalNode> { return getTokens(Cobol85Parser.INTEGER) }
		open func INTEGER(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.INTEGER, i)
		}
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDivisionUsingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDivisionUsingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDivisionUsingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDivisionUsingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDivisionUsingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDivisionUsingClause() throws -> ProcedureDivisionUsingClauseContext {
		var _localctx: ProcedureDivisionUsingClauseContext = ProcedureDivisionUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 514, Cobol85Parser.RULE_procedureDivisionUsingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3521)
		 	try match(Cobol85Parser.USING)
		 	setState(3528) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3528)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,462, _ctx)) {
		 		case 1:
		 			setState(3522)
		 			try match(Cobol85Parser.STRING)
		 			setState(3523)
		 			try dataName()

		 			break
		 		case 2:
		 			setState(3524)
		 			try match(Cobol85Parser.INTEGER)
		 			setState(3525)
		 			try dataName()

		 			break
		 		case 3:
		 			setState(3526)
		 			try dataName()

		 			break
		 		case 4:
		 			setState(3527)
		 			try fileName()

		 			break
		 		default: break
		 		}

		 		setState(3530); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP,Cobol85Parser.STRING]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDivisionGivingClauseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDivisionGivingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDivisionGivingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDivisionGivingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDivisionGivingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDivisionGivingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDivisionGivingClause() throws -> ProcedureDivisionGivingClauseContext {
		var _localctx: ProcedureDivisionGivingClauseContext = ProcedureDivisionGivingClauseContext(_ctx, getState())
		try enterRule(_localctx, 516, Cobol85Parser.RULE_procedureDivisionGivingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3532)
		 	try match(Cobol85Parser.GIVING)
		 	setState(3533)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDeclarativesContext:ParserRuleContext {
		open func DECLARATIVES() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DECLARATIVES) }
		open func DECLARATIVES(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DECLARATIVES, i)
		}
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open func procedureDeclarative() -> Array<ProcedureDeclarativeContext> {
			return getRuleContexts(ProcedureDeclarativeContext.self)
		}
		open func procedureDeclarative(_ i: Int) -> ProcedureDeclarativeContext? {
			return getRuleContext(ProcedureDeclarativeContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDeclaratives }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDeclaratives(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDeclaratives(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDeclaratives(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDeclaratives(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDeclaratives() throws -> ProcedureDeclarativesContext {
		var _localctx: ProcedureDeclarativesContext = ProcedureDeclarativesContext(_ctx, getState())
		try enterRule(_localctx, 518, Cobol85Parser.RULE_procedureDeclaratives)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3535)
		 	try match(Cobol85Parser.DECLARATIVES)
		 	setState(3536)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3538) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3537)
		 		try procedureDeclarative()


		 		setState(3540); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3542)
		 	try match(Cobol85Parser.END)
		 	setState(3543)
		 	try match(Cobol85Parser.DECLARATIVES)
		 	setState(3544)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDeclarativeContext:ParserRuleContext {
		open func procedureSectionHeader() -> ProcedureSectionHeaderContext? {
			return getRuleContext(ProcedureSectionHeaderContext.self,0)
		}
		open func DOT_FS() -> Array<TerminalNode> { return getTokens(Cobol85Parser.DOT_FS) }
		open func DOT_FS(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.DOT_FS, i)
		}
		open func useStatement() -> UseStatementContext? {
			return getRuleContext(UseStatementContext.self,0)
		}
		open func paragraphs() -> ParagraphsContext? {
			return getRuleContext(ParagraphsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDeclarative }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDeclarative(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDeclarative(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDeclarative(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDeclarative(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDeclarative() throws -> ProcedureDeclarativeContext {
		var _localctx: ProcedureDeclarativeContext = ProcedureDeclarativeContext(_ctx, getState())
		try enterRule(_localctx, 520, Cobol85Parser.RULE_procedureDeclarative)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3546)
		 	try procedureSectionHeader()
		 	setState(3547)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3548)
		 	try useStatement()
		 	setState(3549)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3550)
		 	try paragraphs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureSectionHeaderContext:ParserRuleContext {
		open func sectionName() -> SectionNameContext? {
			return getRuleContext(SectionNameContext.self,0)
		}
		open func SECTION() -> TerminalNode? { return getToken(Cobol85Parser.SECTION, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureSectionHeader }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureSectionHeader(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureSectionHeader(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureSectionHeader(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureSectionHeader(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureSectionHeader() throws -> ProcedureSectionHeaderContext {
		var _localctx: ProcedureSectionHeaderContext = ProcedureSectionHeaderContext(_ctx, getState())
		try enterRule(_localctx, 522, Cobol85Parser.RULE_procedureSectionHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3552)
		 	try sectionName()
		 	setState(3553)
		 	try match(Cobol85Parser.SECTION)
		 	setState(3555)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(3554)
		 		try integerLiteral()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureDivisionBodyContext:ParserRuleContext {
		open func paragraphs() -> ParagraphsContext? {
			return getRuleContext(ParagraphsContext.self,0)
		}
		open func procedureSection() -> Array<ProcedureSectionContext> {
			return getRuleContexts(ProcedureSectionContext.self)
		}
		open func procedureSection(_ i: Int) -> ProcedureSectionContext? {
			return getRuleContext(ProcedureSectionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureDivisionBody }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureDivisionBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureDivisionBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureDivisionBody(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureDivisionBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureDivisionBody() throws -> ProcedureDivisionBodyContext {
		var _localctx: ProcedureDivisionBodyContext = ProcedureDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 524, Cobol85Parser.RULE_procedureDivisionBody)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3557)
		 	try paragraphs()
		 	setState(3561)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,466,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3558)
		 			try procedureSection()

		 	 
		 		}
		 		setState(3563)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,466,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureSectionContext:ParserRuleContext {
		open func procedureSectionHeader() -> ProcedureSectionHeaderContext? {
			return getRuleContext(ProcedureSectionHeaderContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func paragraphs() -> ParagraphsContext? {
			return getRuleContext(ParagraphsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureSection() throws -> ProcedureSectionContext {
		var _localctx: ProcedureSectionContext = ProcedureSectionContext(_ctx, getState())
		try enterRule(_localctx, 526, Cobol85Parser.RULE_procedureSection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3564)
		 	try procedureSectionHeader()
		 	setState(3565)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3566)
		 	try paragraphs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ParagraphsContext:ParserRuleContext {
		open func sentence() -> Array<SentenceContext> {
			return getRuleContexts(SentenceContext.self)
		}
		open func sentence(_ i: Int) -> SentenceContext? {
			return getRuleContext(SentenceContext.self,i)
		}
		open func paragraph() -> Array<ParagraphContext> {
			return getRuleContexts(ParagraphContext.self)
		}
		open func paragraph(_ i: Int) -> ParagraphContext? {
			return getRuleContext(ParagraphContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_paragraphs }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterParagraphs(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitParagraphs(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitParagraphs(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitParagraphs(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func paragraphs() throws -> ParagraphsContext {
		var _localctx: ParagraphsContext = ParagraphsContext(_ctx, getState())
		try enterRule(_localctx, 528, Cobol85Parser.RULE_paragraphs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3571)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ACCEPT,Cobol85Parser.ADD,Cobol85Parser.ALTER,Cobol85Parser.CALL,Cobol85Parser.CANCEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE,Cobol85Parser.COMPUTE,Cobol85Parser.CONTINUE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 69)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DELETE,Cobol85Parser.DISABLE,Cobol85Parser.DISPLAY,Cobol85Parser.DIVIDE,Cobol85Parser.ENABLE,Cobol85Parser.ENTRY,Cobol85Parser.EVALUATE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 134)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXHIBIT,Cobol85Parser.EXIT,Cobol85Parser.GENERATE,Cobol85Parser.GOBACK,Cobol85Parser.GO,Cobol85Parser.IF,Cobol85Parser.INITIALIZE,Cobol85Parser.INITIATE,Cobol85Parser.INSPECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 201)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.MERGE,Cobol85Parser.MOVE,Cobol85Parser.MULTIPLY,Cobol85Parser.OPEN,Cobol85Parser.PERFORM]
		 	              return  Utils.testBitLeftShiftArray(testArray, 297)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.PURGE,Cobol85Parser.READ,Cobol85Parser.RECEIVE,Cobol85Parser.RELEASE,Cobol85Parser.RETURN,Cobol85Parser.REWRITE,Cobol85Parser.SEARCH,Cobol85Parser.SEND,Cobol85Parser.SET]
		 	              return  Utils.testBitLeftShiftArray(testArray, 370)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SORT,Cobol85Parser.START,Cobol85Parser.STOP,Cobol85Parser.STRING,Cobol85Parser.SUBTRACT,Cobol85Parser.TERMINATE,Cobol85Parser.UNSTRING]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.WRITE,Cobol85Parser.DOT_FS,Cobol85Parser.EXECCICSLINE,Cobol85Parser.EXECSQLIMSLINE,Cobol85Parser.EXECSQLLINE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 521)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3568)
		 		try sentence()


		 		setState(3573)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3577)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,468,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3574)
		 			try paragraph()

		 	 
		 		}
		 		setState(3579)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,468,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ParagraphContext:ParserRuleContext {
		open func paragraphName() -> ParagraphNameContext? {
			return getRuleContext(ParagraphNameContext.self,0)
		}
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func alteredGoTo() -> AlteredGoToContext? {
			return getRuleContext(AlteredGoToContext.self,0)
		}
		open func sentence() -> Array<SentenceContext> {
			return getRuleContexts(SentenceContext.self)
		}
		open func sentence(_ i: Int) -> SentenceContext? {
			return getRuleContext(SentenceContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_paragraph }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterParagraph(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitParagraph(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitParagraph(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitParagraph(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func paragraph() throws -> ParagraphContext {
		var _localctx: ParagraphContext = ParagraphContext(_ctx, getState())
		try enterRule(_localctx, 530, Cobol85Parser.RULE_paragraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3580)
		 	try paragraphName()
		 	setState(3581)
		 	try match(Cobol85Parser.DOT_FS)
		 	setState(3589)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,470, _ctx)) {
		 	case 1:
		 		setState(3582)
		 		try alteredGoTo()

		 		break
		 	case 2:
		 		setState(3586)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ACCEPT,Cobol85Parser.ADD,Cobol85Parser.ALTER,Cobol85Parser.CALL,Cobol85Parser.CANCEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE,Cobol85Parser.COMPUTE,Cobol85Parser.CONTINUE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 69)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DELETE,Cobol85Parser.DISABLE,Cobol85Parser.DISPLAY,Cobol85Parser.DIVIDE,Cobol85Parser.ENABLE,Cobol85Parser.ENTRY,Cobol85Parser.EVALUATE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 134)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXHIBIT,Cobol85Parser.EXIT,Cobol85Parser.GENERATE,Cobol85Parser.GOBACK,Cobol85Parser.GO,Cobol85Parser.IF,Cobol85Parser.INITIALIZE,Cobol85Parser.INITIATE,Cobol85Parser.INSPECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 201)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.MERGE,Cobol85Parser.MOVE,Cobol85Parser.MULTIPLY,Cobol85Parser.OPEN,Cobol85Parser.PERFORM]
		 		              return  Utils.testBitLeftShiftArray(testArray, 297)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.PURGE,Cobol85Parser.READ,Cobol85Parser.RECEIVE,Cobol85Parser.RELEASE,Cobol85Parser.RETURN,Cobol85Parser.REWRITE,Cobol85Parser.SEARCH,Cobol85Parser.SEND,Cobol85Parser.SET]
		 		              return  Utils.testBitLeftShiftArray(testArray, 370)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SORT,Cobol85Parser.START,Cobol85Parser.STOP,Cobol85Parser.STRING,Cobol85Parser.SUBTRACT,Cobol85Parser.TERMINATE,Cobol85Parser.UNSTRING]
		 		              return  Utils.testBitLeftShiftArray(testArray, 443)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.WRITE,Cobol85Parser.DOT_FS,Cobol85Parser.EXECCICSLINE,Cobol85Parser.EXECSQLIMSLINE,Cobol85Parser.EXECSQLLINE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 521)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(3583)
		 			try sentence()


		 			setState(3588)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SentenceContext:ParserRuleContext {
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sentence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSentence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSentence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSentence(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSentence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sentence() throws -> SentenceContext {
		var _localctx: SentenceContext = SentenceContext(_ctx, getState())
		try enterRule(_localctx, 532, Cobol85Parser.RULE_sentence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3594)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ACCEPT,Cobol85Parser.ADD,Cobol85Parser.ALTER,Cobol85Parser.CALL,Cobol85Parser.CANCEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE,Cobol85Parser.COMPUTE,Cobol85Parser.CONTINUE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 69)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DELETE,Cobol85Parser.DISABLE,Cobol85Parser.DISPLAY,Cobol85Parser.DIVIDE,Cobol85Parser.ENABLE,Cobol85Parser.ENTRY,Cobol85Parser.EVALUATE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 134)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXHIBIT,Cobol85Parser.EXIT,Cobol85Parser.GENERATE,Cobol85Parser.GOBACK,Cobol85Parser.GO,Cobol85Parser.IF,Cobol85Parser.INITIALIZE,Cobol85Parser.INITIATE,Cobol85Parser.INSPECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 201)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.MERGE,Cobol85Parser.MOVE,Cobol85Parser.MULTIPLY,Cobol85Parser.OPEN,Cobol85Parser.PERFORM]
		 	              return  Utils.testBitLeftShiftArray(testArray, 297)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.PURGE,Cobol85Parser.READ,Cobol85Parser.RECEIVE,Cobol85Parser.RELEASE,Cobol85Parser.RETURN,Cobol85Parser.REWRITE,Cobol85Parser.SEARCH,Cobol85Parser.SEND,Cobol85Parser.SET]
		 	              return  Utils.testBitLeftShiftArray(testArray, 370)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SORT,Cobol85Parser.START,Cobol85Parser.STOP,Cobol85Parser.STRING,Cobol85Parser.SUBTRACT,Cobol85Parser.TERMINATE,Cobol85Parser.UNSTRING]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.WRITE,Cobol85Parser.EXECCICSLINE,Cobol85Parser.EXECSQLIMSLINE,Cobol85Parser.EXECSQLLINE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 521)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3591)
		 		try statement()


		 		setState(3596)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3597)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StatementContext:ParserRuleContext {
		open func acceptStatement() -> AcceptStatementContext? {
			return getRuleContext(AcceptStatementContext.self,0)
		}
		open func addStatement() -> AddStatementContext? {
			return getRuleContext(AddStatementContext.self,0)
		}
		open func alterStatement() -> AlterStatementContext? {
			return getRuleContext(AlterStatementContext.self,0)
		}
		open func callStatement() -> CallStatementContext? {
			return getRuleContext(CallStatementContext.self,0)
		}
		open func cancelStatement() -> CancelStatementContext? {
			return getRuleContext(CancelStatementContext.self,0)
		}
		open func closeStatement() -> CloseStatementContext? {
			return getRuleContext(CloseStatementContext.self,0)
		}
		open func computeStatement() -> ComputeStatementContext? {
			return getRuleContext(ComputeStatementContext.self,0)
		}
		open func continueStatement() -> ContinueStatementContext? {
			return getRuleContext(ContinueStatementContext.self,0)
		}
		open func deleteStatement() -> DeleteStatementContext? {
			return getRuleContext(DeleteStatementContext.self,0)
		}
		open func disableStatement() -> DisableStatementContext? {
			return getRuleContext(DisableStatementContext.self,0)
		}
		open func displayStatement() -> DisplayStatementContext? {
			return getRuleContext(DisplayStatementContext.self,0)
		}
		open func divideStatement() -> DivideStatementContext? {
			return getRuleContext(DivideStatementContext.self,0)
		}
		open func enableStatement() -> EnableStatementContext? {
			return getRuleContext(EnableStatementContext.self,0)
		}
		open func entryStatement() -> EntryStatementContext? {
			return getRuleContext(EntryStatementContext.self,0)
		}
		open func evaluateStatement() -> EvaluateStatementContext? {
			return getRuleContext(EvaluateStatementContext.self,0)
		}
		open func exhibitStatement() -> ExhibitStatementContext? {
			return getRuleContext(ExhibitStatementContext.self,0)
		}
		open func execCicsStatement() -> ExecCicsStatementContext? {
			return getRuleContext(ExecCicsStatementContext.self,0)
		}
		open func execSqlStatement() -> ExecSqlStatementContext? {
			return getRuleContext(ExecSqlStatementContext.self,0)
		}
		open func execSqlImsStatement() -> ExecSqlImsStatementContext? {
			return getRuleContext(ExecSqlImsStatementContext.self,0)
		}
		open func exitStatement() -> ExitStatementContext? {
			return getRuleContext(ExitStatementContext.self,0)
		}
		open func generateStatement() -> GenerateStatementContext? {
			return getRuleContext(GenerateStatementContext.self,0)
		}
		open func gobackStatement() -> GobackStatementContext? {
			return getRuleContext(GobackStatementContext.self,0)
		}
		open func goToStatement() -> GoToStatementContext? {
			return getRuleContext(GoToStatementContext.self,0)
		}
		open func ifStatement() -> IfStatementContext? {
			return getRuleContext(IfStatementContext.self,0)
		}
		open func initializeStatement() -> InitializeStatementContext? {
			return getRuleContext(InitializeStatementContext.self,0)
		}
		open func initiateStatement() -> InitiateStatementContext? {
			return getRuleContext(InitiateStatementContext.self,0)
		}
		open func inspectStatement() -> InspectStatementContext? {
			return getRuleContext(InspectStatementContext.self,0)
		}
		open func mergeStatement() -> MergeStatementContext? {
			return getRuleContext(MergeStatementContext.self,0)
		}
		open func moveStatement() -> MoveStatementContext? {
			return getRuleContext(MoveStatementContext.self,0)
		}
		open func multiplyStatement() -> MultiplyStatementContext? {
			return getRuleContext(MultiplyStatementContext.self,0)
		}
		open func openStatement() -> OpenStatementContext? {
			return getRuleContext(OpenStatementContext.self,0)
		}
		open func performStatement() -> PerformStatementContext? {
			return getRuleContext(PerformStatementContext.self,0)
		}
		open func purgeStatement() -> PurgeStatementContext? {
			return getRuleContext(PurgeStatementContext.self,0)
		}
		open func readStatement() -> ReadStatementContext? {
			return getRuleContext(ReadStatementContext.self,0)
		}
		open func receiveStatement() -> ReceiveStatementContext? {
			return getRuleContext(ReceiveStatementContext.self,0)
		}
		open func releaseStatement() -> ReleaseStatementContext? {
			return getRuleContext(ReleaseStatementContext.self,0)
		}
		open func returnStatement() -> ReturnStatementContext? {
			return getRuleContext(ReturnStatementContext.self,0)
		}
		open func rewriteStatement() -> RewriteStatementContext? {
			return getRuleContext(RewriteStatementContext.self,0)
		}
		open func searchStatement() -> SearchStatementContext? {
			return getRuleContext(SearchStatementContext.self,0)
		}
		open func sendStatement() -> SendStatementContext? {
			return getRuleContext(SendStatementContext.self,0)
		}
		open func setStatement() -> SetStatementContext? {
			return getRuleContext(SetStatementContext.self,0)
		}
		open func sortStatement() -> SortStatementContext? {
			return getRuleContext(SortStatementContext.self,0)
		}
		open func startStatement() -> StartStatementContext? {
			return getRuleContext(StartStatementContext.self,0)
		}
		open func stopStatement() -> StopStatementContext? {
			return getRuleContext(StopStatementContext.self,0)
		}
		open func stringStatement() -> StringStatementContext? {
			return getRuleContext(StringStatementContext.self,0)
		}
		open func subtractStatement() -> SubtractStatementContext? {
			return getRuleContext(SubtractStatementContext.self,0)
		}
		open func terminateStatement() -> TerminateStatementContext? {
			return getRuleContext(TerminateStatementContext.self,0)
		}
		open func unstringStatement() -> UnstringStatementContext? {
			return getRuleContext(UnstringStatementContext.self,0)
		}
		open func writeStatement() -> WriteStatementContext? {
			return getRuleContext(WriteStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func statement() throws -> StatementContext {
		var _localctx: StatementContext = StatementContext(_ctx, getState())
		try enterRule(_localctx, 534, Cobol85Parser.RULE_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3648)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ACCEPT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3599)
		 		try acceptStatement()

		 		break

		 	case Cobol85Parser.ADD:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3600)
		 		try addStatement()

		 		break

		 	case Cobol85Parser.ALTER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3601)
		 		try alterStatement()

		 		break

		 	case Cobol85Parser.CALL:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3602)
		 		try callStatement()

		 		break

		 	case Cobol85Parser.CANCEL:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3603)
		 		try cancelStatement()

		 		break

		 	case Cobol85Parser.CLOSE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3604)
		 		try closeStatement()

		 		break

		 	case Cobol85Parser.COMPUTE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3605)
		 		try computeStatement()

		 		break

		 	case Cobol85Parser.CONTINUE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3606)
		 		try continueStatement()

		 		break

		 	case Cobol85Parser.DELETE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3607)
		 		try deleteStatement()

		 		break

		 	case Cobol85Parser.DISABLE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3608)
		 		try disableStatement()

		 		break

		 	case Cobol85Parser.DISPLAY:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3609)
		 		try displayStatement()

		 		break

		 	case Cobol85Parser.DIVIDE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3610)
		 		try divideStatement()

		 		break

		 	case Cobol85Parser.ENABLE:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3611)
		 		try enableStatement()

		 		break

		 	case Cobol85Parser.ENTRY:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3612)
		 		try entryStatement()

		 		break

		 	case Cobol85Parser.EVALUATE:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3613)
		 		try evaluateStatement()

		 		break

		 	case Cobol85Parser.EXHIBIT:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3614)
		 		try exhibitStatement()

		 		break

		 	case Cobol85Parser.EXECCICSLINE:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(3615)
		 		try execCicsStatement()

		 		break

		 	case Cobol85Parser.EXECSQLLINE:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(3616)
		 		try execSqlStatement()

		 		break

		 	case Cobol85Parser.EXECSQLIMSLINE:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(3617)
		 		try execSqlImsStatement()

		 		break

		 	case Cobol85Parser.EXIT:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(3618)
		 		try exitStatement()

		 		break

		 	case Cobol85Parser.GENERATE:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(3619)
		 		try generateStatement()

		 		break

		 	case Cobol85Parser.GOBACK:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(3620)
		 		try gobackStatement()

		 		break

		 	case Cobol85Parser.GO:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(3621)
		 		try goToStatement()

		 		break

		 	case Cobol85Parser.IF:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(3622)
		 		try ifStatement()

		 		break

		 	case Cobol85Parser.INITIALIZE:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(3623)
		 		try initializeStatement()

		 		break

		 	case Cobol85Parser.INITIATE:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(3624)
		 		try initiateStatement()

		 		break

		 	case Cobol85Parser.INSPECT:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(3625)
		 		try inspectStatement()

		 		break

		 	case Cobol85Parser.MERGE:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(3626)
		 		try mergeStatement()

		 		break

		 	case Cobol85Parser.MOVE:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(3627)
		 		try moveStatement()

		 		break

		 	case Cobol85Parser.MULTIPLY:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(3628)
		 		try multiplyStatement()

		 		break

		 	case Cobol85Parser.OPEN:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(3629)
		 		try openStatement()

		 		break

		 	case Cobol85Parser.PERFORM:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(3630)
		 		try performStatement()

		 		break

		 	case Cobol85Parser.PURGE:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(3631)
		 		try purgeStatement()

		 		break

		 	case Cobol85Parser.READ:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(3632)
		 		try readStatement()

		 		break

		 	case Cobol85Parser.RECEIVE:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(3633)
		 		try receiveStatement()

		 		break

		 	case Cobol85Parser.RELEASE:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(3634)
		 		try releaseStatement()

		 		break

		 	case Cobol85Parser.RETURN:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(3635)
		 		try returnStatement()

		 		break

		 	case Cobol85Parser.REWRITE:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(3636)
		 		try rewriteStatement()

		 		break

		 	case Cobol85Parser.SEARCH:
		 		try enterOuterAlt(_localctx, 39)
		 		setState(3637)
		 		try searchStatement()

		 		break

		 	case Cobol85Parser.SEND:
		 		try enterOuterAlt(_localctx, 40)
		 		setState(3638)
		 		try sendStatement()

		 		break

		 	case Cobol85Parser.SET:
		 		try enterOuterAlt(_localctx, 41)
		 		setState(3639)
		 		try setStatement()

		 		break

		 	case Cobol85Parser.SORT:
		 		try enterOuterAlt(_localctx, 42)
		 		setState(3640)
		 		try sortStatement()

		 		break

		 	case Cobol85Parser.START:
		 		try enterOuterAlt(_localctx, 43)
		 		setState(3641)
		 		try startStatement()

		 		break

		 	case Cobol85Parser.STOP:
		 		try enterOuterAlt(_localctx, 44)
		 		setState(3642)
		 		try stopStatement()

		 		break

		 	case Cobol85Parser.STRING:
		 		try enterOuterAlt(_localctx, 45)
		 		setState(3643)
		 		try stringStatement()

		 		break

		 	case Cobol85Parser.SUBTRACT:
		 		try enterOuterAlt(_localctx, 46)
		 		setState(3644)
		 		try subtractStatement()

		 		break

		 	case Cobol85Parser.TERMINATE:
		 		try enterOuterAlt(_localctx, 47)
		 		setState(3645)
		 		try terminateStatement()

		 		break

		 	case Cobol85Parser.UNSTRING:
		 		try enterOuterAlt(_localctx, 48)
		 		setState(3646)
		 		try unstringStatement()

		 		break

		 	case Cobol85Parser.WRITE:
		 		try enterOuterAlt(_localctx, 49)
		 		setState(3647)
		 		try writeStatement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AcceptStatementContext:ParserRuleContext {
		open func ACCEPT() -> TerminalNode? { return getToken(Cobol85Parser.ACCEPT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func acceptFromDateStatement() -> AcceptFromDateStatementContext? {
			return getRuleContext(AcceptFromDateStatementContext.self,0)
		}
		open func acceptFromEscapeKeyStatement() -> AcceptFromEscapeKeyStatementContext? {
			return getRuleContext(AcceptFromEscapeKeyStatementContext.self,0)
		}
		open func acceptFromMnemonicStatement() -> AcceptFromMnemonicStatementContext? {
			return getRuleContext(AcceptFromMnemonicStatementContext.self,0)
		}
		open func acceptMessageCountStatement() -> AcceptMessageCountStatementContext? {
			return getRuleContext(AcceptMessageCountStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_acceptStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAcceptStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAcceptStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAcceptStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAcceptStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func acceptStatement() throws -> AcceptStatementContext {
		var _localctx: AcceptStatementContext = AcceptStatementContext(_ctx, getState())
		try enterRule(_localctx, 536, Cobol85Parser.RULE_acceptStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3650)
		 	try match(Cobol85Parser.ACCEPT)
		 	setState(3651)
		 	try identifier()
		 	setState(3656)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,473,_ctx)) {
		 	case 1:
		 		setState(3652)
		 		try acceptFromDateStatement()

		 		break
		 	case 2:
		 		setState(3653)
		 		try acceptFromEscapeKeyStatement()

		 		break
		 	case 3:
		 		setState(3654)
		 		try acceptFromMnemonicStatement()

		 		break
		 	case 4:
		 		setState(3655)
		 		try acceptMessageCountStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AcceptFromDateStatementContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func DATE() -> TerminalNode? { return getToken(Cobol85Parser.DATE, 0) }
		open func DAY() -> TerminalNode? { return getToken(Cobol85Parser.DAY, 0) }
		open func DAY_OF_WEEK() -> TerminalNode? { return getToken(Cobol85Parser.DAY_OF_WEEK, 0) }
		open func TIME() -> TerminalNode? { return getToken(Cobol85Parser.TIME, 0) }
		open func TIMER() -> TerminalNode? { return getToken(Cobol85Parser.TIMER, 0) }
		open func TODAYS_DATE() -> TerminalNode? { return getToken(Cobol85Parser.TODAYS_DATE, 0) }
		open func TODAYS_NAME() -> TerminalNode? { return getToken(Cobol85Parser.TODAYS_NAME, 0) }
		open func YEAR() -> TerminalNode? { return getToken(Cobol85Parser.YEAR, 0) }
		open func YYYYMMDD() -> TerminalNode? { return getToken(Cobol85Parser.YYYYMMDD, 0) }
		open func YYYYDDD() -> TerminalNode? { return getToken(Cobol85Parser.YYYYDDD, 0) }
		open func MMDDYYYY() -> TerminalNode? { return getToken(Cobol85Parser.MMDDYYYY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_acceptFromDateStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAcceptFromDateStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAcceptFromDateStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAcceptFromDateStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAcceptFromDateStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func acceptFromDateStatement() throws -> AcceptFromDateStatementContext {
		var _localctx: AcceptFromDateStatementContext = AcceptFromDateStatementContext(_ctx, getState())
		try enterRule(_localctx, 538, Cobol85Parser.RULE_acceptFromDateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3658)
		 	try match(Cobol85Parser.FROM)
		 	setState(3678)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.DATE:
		 		setState(3659)
		 		try match(Cobol85Parser.DATE)
		 		setState(3661)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.YYYYMMDD
		 		      return testSet
		 		 }()) {
		 			setState(3660)
		 			try match(Cobol85Parser.YYYYMMDD)

		 		}


		 		break

		 	case Cobol85Parser.DAY:
		 		setState(3663)
		 		try match(Cobol85Parser.DAY)
		 		setState(3665)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.YYYYDDD
		 		      return testSet
		 		 }()) {
		 			setState(3664)
		 			try match(Cobol85Parser.YYYYDDD)

		 		}


		 		break

		 	case Cobol85Parser.DAY_OF_WEEK:
		 		setState(3667)
		 		try match(Cobol85Parser.DAY_OF_WEEK)

		 		break

		 	case Cobol85Parser.TIME:
		 		setState(3668)
		 		try match(Cobol85Parser.TIME)

		 		break

		 	case Cobol85Parser.TIMER:
		 		setState(3669)
		 		try match(Cobol85Parser.TIMER)

		 		break

		 	case Cobol85Parser.TODAYS_DATE:
		 		setState(3670)
		 		try match(Cobol85Parser.TODAYS_DATE)
		 		setState(3672)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.MMDDYYYY
		 		      return testSet
		 		 }()) {
		 			setState(3671)
		 			try match(Cobol85Parser.MMDDYYYY)

		 		}


		 		break

		 	case Cobol85Parser.TODAYS_NAME:
		 		setState(3674)
		 		try match(Cobol85Parser.TODAYS_NAME)

		 		break

		 	case Cobol85Parser.YEAR:
		 		setState(3675)
		 		try match(Cobol85Parser.YEAR)

		 		break

		 	case Cobol85Parser.YYYYMMDD:
		 		setState(3676)
		 		try match(Cobol85Parser.YYYYMMDD)

		 		break

		 	case Cobol85Parser.YYYYDDD:
		 		setState(3677)
		 		try match(Cobol85Parser.YYYYDDD)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AcceptFromMnemonicStatementContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_acceptFromMnemonicStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAcceptFromMnemonicStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAcceptFromMnemonicStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAcceptFromMnemonicStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAcceptFromMnemonicStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func acceptFromMnemonicStatement() throws -> AcceptFromMnemonicStatementContext {
		var _localctx: AcceptFromMnemonicStatementContext = AcceptFromMnemonicStatementContext(_ctx, getState())
		try enterRule(_localctx, 540, Cobol85Parser.RULE_acceptFromMnemonicStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3680)
		 	try match(Cobol85Parser.FROM)
		 	setState(3681)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AcceptFromEscapeKeyStatementContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func ESCAPE() -> TerminalNode? { return getToken(Cobol85Parser.ESCAPE, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_acceptFromEscapeKeyStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAcceptFromEscapeKeyStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAcceptFromEscapeKeyStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAcceptFromEscapeKeyStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAcceptFromEscapeKeyStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func acceptFromEscapeKeyStatement() throws -> AcceptFromEscapeKeyStatementContext {
		var _localctx: AcceptFromEscapeKeyStatementContext = AcceptFromEscapeKeyStatementContext(_ctx, getState())
		try enterRule(_localctx, 542, Cobol85Parser.RULE_acceptFromEscapeKeyStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3683)
		 	try match(Cobol85Parser.FROM)
		 	setState(3684)
		 	try match(Cobol85Parser.ESCAPE)
		 	setState(3685)
		 	try match(Cobol85Parser.KEY)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AcceptMessageCountStatementContext:ParserRuleContext {
		open func COUNT() -> TerminalNode? { return getToken(Cobol85Parser.COUNT, 0) }
		open func MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.MESSAGE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_acceptMessageCountStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAcceptMessageCountStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAcceptMessageCountStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAcceptMessageCountStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAcceptMessageCountStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func acceptMessageCountStatement() throws -> AcceptMessageCountStatementContext {
		var _localctx: AcceptMessageCountStatementContext = AcceptMessageCountStatementContext(_ctx, getState())
		try enterRule(_localctx, 544, Cobol85Parser.RULE_acceptMessageCountStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3688)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MESSAGE
		 	      return testSet
		 	 }()) {
		 		setState(3687)
		 		try match(Cobol85Parser.MESSAGE)

		 	}

		 	setState(3690)
		 	try match(Cobol85Parser.COUNT)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddStatementContext:ParserRuleContext {
		open func ADD() -> TerminalNode? { return getToken(Cobol85Parser.ADD, 0) }
		open func addToStatement() -> AddToStatementContext? {
			return getRuleContext(AddToStatementContext.self,0)
		}
		open func addToGivingStatement() -> AddToGivingStatementContext? {
			return getRuleContext(AddToGivingStatementContext.self,0)
		}
		open func addCorrespondingStatement() -> AddCorrespondingStatementContext? {
			return getRuleContext(AddCorrespondingStatementContext.self,0)
		}
		open func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
			return getRuleContext(OnSizeErrorPhraseContext.self,0)
		}
		open func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
			return getRuleContext(NotOnSizeErrorPhraseContext.self,0)
		}
		open func END_ADD() -> TerminalNode? { return getToken(Cobol85Parser.END_ADD, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addStatement() throws -> AddStatementContext {
		var _localctx: AddStatementContext = AddStatementContext(_ctx, getState())
		try enterRule(_localctx, 546, Cobol85Parser.RULE_addStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3692)
		 	try match(Cobol85Parser.ADD)
		 	setState(3696)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,479, _ctx)) {
		 	case 1:
		 		setState(3693)
		 		try addToStatement()

		 		break
		 	case 2:
		 		setState(3694)
		 		try addToGivingStatement()

		 		break
		 	case 3:
		 		setState(3695)
		 		try addCorrespondingStatement()

		 		break
		 	default: break
		 	}
		 	setState(3699)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,480,_ctx)) {
		 	case 1:
		 		setState(3698)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3702)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,481,_ctx)) {
		 	case 1:
		 		setState(3701)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3705)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,482,_ctx)) {
		 	case 1:
		 		setState(3704)
		 		try match(Cobol85Parser.END_ADD)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddToStatementContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func addFrom() -> Array<AddFromContext> {
			return getRuleContexts(AddFromContext.self)
		}
		open func addFrom(_ i: Int) -> AddFromContext? {
			return getRuleContext(AddFromContext.self,i)
		}
		open func addTo() -> Array<AddToContext> {
			return getRuleContexts(AddToContext.self)
		}
		open func addTo(_ i: Int) -> AddToContext? {
			return getRuleContext(AddToContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addToStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddToStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddToStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddToStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddToStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addToStatement() throws -> AddToStatementContext {
		var _localctx: AddToStatementContext = AddToStatementContext(_ctx, getState())
		try enterRule(_localctx, 548, Cobol85Parser.RULE_addToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3708) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3707)
		 		try addFrom()


		 		setState(3710); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3712)
		 	try match(Cobol85Parser.TO)
		 	setState(3714) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3713)
		 		try addTo()


		 		setState(3716); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddToGivingStatementContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func addFrom() -> Array<AddFromContext> {
			return getRuleContexts(AddFromContext.self)
		}
		open func addFrom(_ i: Int) -> AddFromContext? {
			return getRuleContext(AddFromContext.self,i)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func addGiving() -> Array<AddGivingContext> {
			return getRuleContexts(AddGivingContext.self)
		}
		open func addGiving(_ i: Int) -> AddGivingContext? {
			return getRuleContext(AddGivingContext.self,i)
		}
		open func addTo() -> Array<AddToContext> {
			return getRuleContexts(AddToContext.self)
		}
		open func addTo(_ i: Int) -> AddToContext? {
			return getRuleContext(AddToContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addToGivingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddToGivingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddToGivingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddToGivingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddToGivingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addToGivingStatement() throws -> AddToGivingStatementContext {
		var _localctx: AddToGivingStatementContext = AddToGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 550, Cobol85Parser.RULE_addToGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3719) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3718)
		 		try addFrom()


		 		setState(3721); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3729)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(3723)
		 		try match(Cobol85Parser.TO)
		 		setState(3725) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3724)
		 			try addTo()


		 			setState(3727); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 		              return  Utils.testBitLeftShiftArray(testArray, 556)
		 		          }()
		 		      return testSet
		 		 }())

		 	}

		 	setState(3731)
		 	try match(Cobol85Parser.GIVING)
		 	setState(3733) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3732)
		 		try addGiving()


		 		setState(3735); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddCorrespondingStatementContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func addTo() -> AddToContext? {
			return getRuleContext(AddToContext.self,0)
		}
		open func CORRESPONDING() -> TerminalNode? { return getToken(Cobol85Parser.CORRESPONDING, 0) }
		open func CORR() -> TerminalNode? { return getToken(Cobol85Parser.CORR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addCorrespondingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddCorrespondingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddCorrespondingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddCorrespondingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddCorrespondingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addCorrespondingStatement() throws -> AddCorrespondingStatementContext {
		var _localctx: AddCorrespondingStatementContext = AddCorrespondingStatementContext(_ctx, getState())
		try enterRule(_localctx, 552, Cobol85Parser.RULE_addCorrespondingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3737)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CORR || _la == Cobol85Parser.CORRESPONDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3738)
		 	try identifier()
		 	setState(3739)
		 	try match(Cobol85Parser.TO)
		 	setState(3740)
		 	try addTo()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddFromContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addFrom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddFrom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddFrom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddFrom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddFrom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addFrom() throws -> AddFromContext {
		var _localctx: AddFromContext = AddFromContext(_ctx, getState())
		try enterRule(_localctx, 554, Cobol85Parser.RULE_addFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3744)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,489, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3742)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3743)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddToContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addTo() throws -> AddToContext {
		var _localctx: AddToContext = AddToContext(_ctx, getState())
		try enterRule(_localctx, 556, Cobol85Parser.RULE_addTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3746)
		 	try identifier()
		 	setState(3748)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(3747)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AddGivingContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_addGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAddGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAddGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAddGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAddGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func addGiving() throws -> AddGivingContext {
		var _localctx: AddGivingContext = AddGivingContext(_ctx, getState())
		try enterRule(_localctx, 558, Cobol85Parser.RULE_addGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3750)
		 	try identifier()
		 	setState(3752)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(3751)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlteredGoToContext:ParserRuleContext {
		open func GO() -> TerminalNode? { return getToken(Cobol85Parser.GO, 0) }
		open func DOT_FS() -> TerminalNode? { return getToken(Cobol85Parser.DOT_FS, 0) }
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alteredGoTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlteredGoTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlteredGoTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlteredGoTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlteredGoTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alteredGoTo() throws -> AlteredGoToContext {
		var _localctx: AlteredGoToContext = AlteredGoToContext(_ctx, getState())
		try enterRule(_localctx, 560, Cobol85Parser.RULE_alteredGoTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3754)
		 	try match(Cobol85Parser.GO)
		 	setState(3756)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(3755)
		 		try match(Cobol85Parser.TO)

		 	}

		 	setState(3758)
		 	try match(Cobol85Parser.DOT_FS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlterStatementContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(Cobol85Parser.ALTER, 0) }
		open func alterProceedTo() -> Array<AlterProceedToContext> {
			return getRuleContexts(AlterProceedToContext.self)
		}
		open func alterProceedTo(_ i: Int) -> AlterProceedToContext? {
			return getRuleContext(AlterProceedToContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alterStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlterStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlterStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlterStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlterStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alterStatement() throws -> AlterStatementContext {
		var _localctx: AlterStatementContext = AlterStatementContext(_ctx, getState())
		try enterRule(_localctx, 562, Cobol85Parser.RULE_alterStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3760)
		 	try match(Cobol85Parser.ALTER)
		 	setState(3762) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3761)
		 		try alterProceedTo()


		 		setState(3764); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlterProceedToContext:ParserRuleContext {
		open func procedureName() -> Array<ProcedureNameContext> {
			return getRuleContexts(ProcedureNameContext.self)
		}
		open func procedureName(_ i: Int) -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,i)
		}
		open func TO() -> Array<TerminalNode> { return getTokens(Cobol85Parser.TO) }
		open func TO(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.TO, i)
		}
		open func PROCEED() -> TerminalNode? { return getToken(Cobol85Parser.PROCEED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alterProceedTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlterProceedTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlterProceedTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlterProceedTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlterProceedTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alterProceedTo() throws -> AlterProceedToContext {
		var _localctx: AlterProceedToContext = AlterProceedToContext(_ctx, getState())
		try enterRule(_localctx, 564, Cobol85Parser.RULE_alterProceedTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3766)
		 	try procedureName()
		 	setState(3767)
		 	try match(Cobol85Parser.TO)
		 	setState(3770)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROCEED
		 	      return testSet
		 	 }()) {
		 		setState(3768)
		 		try match(Cobol85Parser.PROCEED)
		 		setState(3769)
		 		try match(Cobol85Parser.TO)

		 	}

		 	setState(3772)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallStatementContext:ParserRuleContext {
		open func CALL() -> TerminalNode? { return getToken(Cobol85Parser.CALL, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func callGivingPhrase() -> CallGivingPhraseContext? {
			return getRuleContext(CallGivingPhraseContext.self,0)
		}
		open func onOverflowPhrase() -> OnOverflowPhraseContext? {
			return getRuleContext(OnOverflowPhraseContext.self,0)
		}
		open func onExceptionClause() -> OnExceptionClauseContext? {
			return getRuleContext(OnExceptionClauseContext.self,0)
		}
		open func notOnExceptionClause() -> NotOnExceptionClauseContext? {
			return getRuleContext(NotOnExceptionClauseContext.self,0)
		}
		open func END_CALL() -> TerminalNode? { return getToken(Cobol85Parser.END_CALL, 0) }
		open func callByReferenceStatement() -> Array<CallByReferenceStatementContext> {
			return getRuleContexts(CallByReferenceStatementContext.self)
		}
		open func callByReferenceStatement(_ i: Int) -> CallByReferenceStatementContext? {
			return getRuleContext(CallByReferenceStatementContext.self,i)
		}
		open func callByValueStatement() -> Array<CallByValueStatementContext> {
			return getRuleContexts(CallByValueStatementContext.self)
		}
		open func callByValueStatement(_ i: Int) -> CallByValueStatementContext? {
			return getRuleContext(CallByValueStatementContext.self,i)
		}
		open func callByContentStatement() -> Array<CallByContentStatementContext> {
			return getRuleContexts(CallByContentStatementContext.self)
		}
		open func callByContentStatement(_ i: Int) -> CallByContentStatementContext? {
			return getRuleContext(CallByContentStatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callStatement() throws -> CallStatementContext {
		var _localctx: CallStatementContext = CallStatementContext(_ctx, getState())
		try enterRule(_localctx, 566, Cobol85Parser.RULE_callStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3774)
		 	try match(Cobol85Parser.CALL)
		 	setState(3777)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,495, _ctx)) {
		 	case 1:
		 		setState(3775)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3776)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(3787)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(3779)
		 		try match(Cobol85Parser.USING)
		 		setState(3783); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3783)
		 				try _errHandler.sync(self)
		 				switch(try getInterpreter().adaptivePredict(_input,496, _ctx)) {
		 				case 1:
		 					setState(3780)
		 					try callByReferenceStatement()

		 					break
		 				case 2:
		 					setState(3781)
		 					try callByValueStatement()

		 					break
		 				case 3:
		 					setState(3782)
		 					try callByContentStatement()

		 					break
		 				default: break
		 				}

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3785); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,497,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}

		 	setState(3790)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(3789)
		 		try callGivingPhrase()

		 	}

		 	setState(3793)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,500,_ctx)) {
		 	case 1:
		 		setState(3792)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3796)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,501,_ctx)) {
		 	case 1:
		 		setState(3795)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3799)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,502,_ctx)) {
		 	case 1:
		 		setState(3798)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3802)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,503,_ctx)) {
		 	case 1:
		 		setState(3801)
		 		try match(Cobol85Parser.END_CALL)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByReferenceStatementContext:ParserRuleContext {
		open func REFERENCE() -> TerminalNode? { return getToken(Cobol85Parser.REFERENCE, 0) }
		open func callByReference() -> Array<CallByReferenceContext> {
			return getRuleContexts(CallByReferenceContext.self)
		}
		open func callByReference(_ i: Int) -> CallByReferenceContext? {
			return getRuleContext(CallByReferenceContext.self,i)
		}
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByReferenceStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByReferenceStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByReferenceStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByReferenceStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByReferenceStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByReferenceStatement() throws -> CallByReferenceStatementContext {
		var _localctx: CallByReferenceStatementContext = CallByReferenceStatementContext(_ctx, getState())
		try enterRule(_localctx, 568, Cobol85Parser.RULE_callByReferenceStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.BY
		 	          testSet = testSet || _la == Cobol85Parser.REFERENCE
		 	      return testSet
		 	 }()) {
		 		setState(3805)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.BY
		 		      return testSet
		 		 }()) {
		 			setState(3804)
		 			try match(Cobol85Parser.BY)

		 		}

		 		setState(3807)
		 		try match(Cobol85Parser.REFERENCE)

		 	}

		 	setState(3811); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3810)
		 			try callByReference()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3813); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,506,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByReferenceContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ADDRESS() -> TerminalNode? { return getToken(Cobol85Parser.ADDRESS, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(Cobol85Parser.INTEGER, 0) }
		open func STRING() -> TerminalNode? { return getToken(Cobol85Parser.STRING, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByReference }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByReference(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByReference(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByReference(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByReference(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByReference() throws -> CallByReferenceContext {
		var _localctx: CallByReferenceContext = CallByReferenceContext(_ctx, getState())
		try enterRule(_localctx, 570, Cobol85Parser.RULE_callByReference)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3823)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,508, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3819)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,507,_ctx)) {
		 		case 1:
		 			setState(3815)
		 			try match(Cobol85Parser.ADDRESS)
		 			setState(3816)
		 			try match(Cobol85Parser.OF)

		 			break
		 		case 2:
		 			setState(3817)
		 			try match(Cobol85Parser.INTEGER)

		 			break
		 		case 3:
		 			setState(3818)
		 			try match(Cobol85Parser.STRING)

		 			break
		 		default: break
		 		}
		 		setState(3821)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3822)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByValueStatementContext:ParserRuleContext {
		open func VALUE() -> TerminalNode? { return getToken(Cobol85Parser.VALUE, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func callByValue() -> Array<CallByValueContext> {
			return getRuleContexts(CallByValueContext.self)
		}
		open func callByValue(_ i: Int) -> CallByValueContext? {
			return getRuleContext(CallByValueContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByValueStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByValueStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByValueStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByValueStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByValueStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByValueStatement() throws -> CallByValueStatementContext {
		var _localctx: CallByValueStatementContext = CallByValueStatementContext(_ctx, getState())
		try enterRule(_localctx, 572, Cobol85Parser.RULE_callByValueStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3826)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BY
		 	      return testSet
		 	 }()) {
		 		setState(3825)
		 		try match(Cobol85Parser.BY)

		 	}

		 	setState(3828)
		 	try match(Cobol85Parser.VALUE)
		 	setState(3830); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3829)
		 			try callByValue()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3832); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,510,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByValueContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByValue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByValue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByValue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByValue(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByValue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByValue() throws -> CallByValueContext {
		var _localctx: CallByValueContext = CallByValueContext(_ctx, getState())
		try enterRule(_localctx, 574, Cobol85Parser.RULE_callByValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3836)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,511, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3834)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3835)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByContentStatementContext:ParserRuleContext {
		open func CONTENT() -> TerminalNode? { return getToken(Cobol85Parser.CONTENT, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func callByContent() -> Array<CallByContentContext> {
			return getRuleContexts(CallByContentContext.self)
		}
		open func callByContent(_ i: Int) -> CallByContentContext? {
			return getRuleContext(CallByContentContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByContentStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByContentStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByContentStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByContentStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByContentStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByContentStatement() throws -> CallByContentStatementContext {
		var _localctx: CallByContentStatementContext = CallByContentStatementContext(_ctx, getState())
		try enterRule(_localctx, 576, Cobol85Parser.RULE_callByContentStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3839)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BY
		 	      return testSet
		 	 }()) {
		 		setState(3838)
		 		try match(Cobol85Parser.BY)

		 	}

		 	setState(3841)
		 	try match(Cobol85Parser.CONTENT)
		 	setState(3843); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3842)
		 			try callByContent()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3845); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,513,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallByContentContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ADDRESS() -> TerminalNode? { return getToken(Cobol85Parser.ADDRESS, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open func LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callByContent }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallByContent(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallByContent(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallByContent(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallByContent(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callByContent() throws -> CallByContentContext {
		var _localctx: CallByContentContext = CallByContentContext(_ctx, getState())
		try enterRule(_localctx, 578, Cobol85Parser.RULE_callByContent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3855)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,515, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3851)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,514,_ctx)) {
		 		case 1:
		 			setState(3847)
		 			try match(Cobol85Parser.ADDRESS)
		 			setState(3848)
		 			try match(Cobol85Parser.OF)

		 			break
		 		case 2:
		 			setState(3849)
		 			try match(Cobol85Parser.LENGTH)
		 			setState(3850)
		 			try match(Cobol85Parser.OF)

		 			break
		 		default: break
		 		}
		 		setState(3853)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3854)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CallGivingPhraseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_callGivingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCallGivingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCallGivingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCallGivingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCallGivingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func callGivingPhrase() throws -> CallGivingPhraseContext {
		var _localctx: CallGivingPhraseContext = CallGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 580, Cobol85Parser.RULE_callGivingPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3857)
		 	try match(Cobol85Parser.GIVING)
		 	setState(3858)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CancelStatementContext:ParserRuleContext {
		open func CANCEL() -> TerminalNode? { return getToken(Cobol85Parser.CANCEL, 0) }
		open func cancelCall() -> Array<CancelCallContext> {
			return getRuleContexts(CancelCallContext.self)
		}
		open func cancelCall(_ i: Int) -> CancelCallContext? {
			return getRuleContext(CancelCallContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cancelStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCancelStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCancelStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCancelStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCancelStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cancelStatement() throws -> CancelStatementContext {
		var _localctx: CancelStatementContext = CancelStatementContext(_ctx, getState())
		try enterRule(_localctx, 582, Cobol85Parser.RULE_cancelStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3860)
		 	try match(Cobol85Parser.CANCEL)
		 	setState(3862) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3861)
		 		try cancelCall()


		 		setState(3864); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CancelCallContext:ParserRuleContext {
		open func libraryName() -> LibraryNameContext? {
			return getRuleContext(LibraryNameContext.self,0)
		}
		open func BYTITLE() -> TerminalNode? { return getToken(Cobol85Parser.BYTITLE, 0) }
		open func BYFUNCTION() -> TerminalNode? { return getToken(Cobol85Parser.BYFUNCTION, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cancelCall }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCancelCall(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCancelCall(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCancelCall(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCancelCall(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cancelCall() throws -> CancelCallContext {
		var _localctx: CancelCallContext = CancelCallContext(_ctx, getState())
		try enterRule(_localctx, 584, Cobol85Parser.RULE_cancelCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3871)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,517, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3866)
		 		try libraryName()
		 		setState(3867)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.BYFUNCTION || _la == Cobol85Parser.BYTITLE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3869)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3870)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CloseStatementContext:ParserRuleContext {
		open func CLOSE() -> TerminalNode? { return getToken(Cobol85Parser.CLOSE, 0) }
		open func closeFile() -> Array<CloseFileContext> {
			return getRuleContexts(CloseFileContext.self)
		}
		open func closeFile(_ i: Int) -> CloseFileContext? {
			return getRuleContext(CloseFileContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCloseStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCloseStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCloseStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCloseStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closeStatement() throws -> CloseStatementContext {
		var _localctx: CloseStatementContext = CloseStatementContext(_ctx, getState())
		try enterRule(_localctx, 586, Cobol85Parser.RULE_closeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3873)
		 	try match(Cobol85Parser.CLOSE)
		 	setState(3875) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3874)
		 		try closeFile()


		 		setState(3877); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CloseFileContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func closeReelUnitStatement() -> CloseReelUnitStatementContext? {
			return getRuleContext(CloseReelUnitStatementContext.self,0)
		}
		open func closeRelativeStatement() -> CloseRelativeStatementContext? {
			return getRuleContext(CloseRelativeStatementContext.self,0)
		}
		open func closePortFileIOStatement() -> ClosePortFileIOStatementContext? {
			return getRuleContext(ClosePortFileIOStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closeFile }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCloseFile(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCloseFile(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCloseFile(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCloseFile(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closeFile() throws -> CloseFileContext {
		var _localctx: CloseFileContext = CloseFileContext(_ctx, getState())
		try enterRule(_localctx, 588, Cobol85Parser.RULE_closeFile)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3879)
		 	try fileName()
		 	setState(3883)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,519,_ctx)) {
		 	case 1:
		 		setState(3880)
		 		try closeReelUnitStatement()

		 		break
		 	case 2:
		 		setState(3881)
		 		try closeRelativeStatement()

		 		break
		 	case 3:
		 		setState(3882)
		 		try closePortFileIOStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CloseReelUnitStatementContext:ParserRuleContext {
		open func REEL() -> TerminalNode? { return getToken(Cobol85Parser.REEL, 0) }
		open func UNIT() -> TerminalNode? { return getToken(Cobol85Parser.UNIT, 0) }
		open func REMOVAL() -> TerminalNode? { return getToken(Cobol85Parser.REMOVAL, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closeReelUnitStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCloseReelUnitStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCloseReelUnitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCloseReelUnitStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCloseReelUnitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closeReelUnitStatement() throws -> CloseReelUnitStatementContext {
		var _localctx: CloseReelUnitStatementContext = CloseReelUnitStatementContext(_ctx, getState())
		try enterRule(_localctx, 590, Cobol85Parser.RULE_closeReelUnitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3885)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.REEL
		 	          testSet = testSet || _la == Cobol85Parser.UNIT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3890)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FOR
		 	          testSet = testSet || _la == Cobol85Parser.REMOVAL
		 	      return testSet
		 	 }()) {
		 		setState(3887)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.FOR
		 		      return testSet
		 		 }()) {
		 			setState(3886)
		 			try match(Cobol85Parser.FOR)

		 		}

		 		setState(3889)
		 		try match(Cobol85Parser.REMOVAL)

		 	}

		 	setState(3900)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,524,_ctx)) {
		 	case 1:
		 		setState(3893)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(3892)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(3898)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.NO:
		 			setState(3895)
		 			try match(Cobol85Parser.NO)
		 			setState(3896)
		 			try match(Cobol85Parser.REWIND)

		 			break

		 		case Cobol85Parser.LOCK:
		 			setState(3897)
		 			try match(Cobol85Parser.LOCK)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CloseRelativeStatementContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closeRelativeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCloseRelativeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCloseRelativeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCloseRelativeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCloseRelativeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closeRelativeStatement() throws -> CloseRelativeStatementContext {
		var _localctx: CloseRelativeStatementContext = CloseRelativeStatementContext(_ctx, getState())
		try enterRule(_localctx, 592, Cobol85Parser.RULE_closeRelativeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3903)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(3902)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(3908)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NO:
		 		setState(3905)
		 		try match(Cobol85Parser.NO)
		 		setState(3906)
		 		try match(Cobol85Parser.REWIND)

		 		break

		 	case Cobol85Parser.LOCK:
		 		setState(3907)
		 		try match(Cobol85Parser.LOCK)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClosePortFileIOStatementContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func WAIT() -> TerminalNode? { return getToken(Cobol85Parser.WAIT, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func closePortFileIOUsing() -> Array<ClosePortFileIOUsingContext> {
			return getRuleContexts(ClosePortFileIOUsingContext.self)
		}
		open func closePortFileIOUsing(_ i: Int) -> ClosePortFileIOUsingContext? {
			return getRuleContext(ClosePortFileIOUsingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closePortFileIOStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClosePortFileIOStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClosePortFileIOStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClosePortFileIOStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClosePortFileIOStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closePortFileIOStatement() throws -> ClosePortFileIOStatementContext {
		var _localctx: ClosePortFileIOStatementContext = ClosePortFileIOStatementContext(_ctx, getState())
		try enterRule(_localctx, 594, Cobol85Parser.RULE_closePortFileIOStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3917)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,528, _ctx)) {
		 	case 1:
		 		setState(3911)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(3910)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(3913)
		 		try match(Cobol85Parser.NO)
		 		setState(3914)
		 		try match(Cobol85Parser.WAIT)

		 		break
		 	case 2:
		 		setState(3915)
		 		try match(Cobol85Parser.WITH)
		 		setState(3916)
		 		try match(Cobol85Parser.WAIT)

		 		break
		 	default: break
		 	}
		 	setState(3925)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(3919)
		 		try match(Cobol85Parser.USING)
		 		setState(3921); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3920)
		 				try closePortFileIOUsing()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3923); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,529,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClosePortFileIOUsingContext:ParserRuleContext {
		open func closePortFileIOUsingCloseDisposition() -> ClosePortFileIOUsingCloseDispositionContext? {
			return getRuleContext(ClosePortFileIOUsingCloseDispositionContext.self,0)
		}
		open func closePortFileIOUsingAssociatedData() -> ClosePortFileIOUsingAssociatedDataContext? {
			return getRuleContext(ClosePortFileIOUsingAssociatedDataContext.self,0)
		}
		open func closePortFileIOUsingAssociatedDataLength() -> ClosePortFileIOUsingAssociatedDataLengthContext? {
			return getRuleContext(ClosePortFileIOUsingAssociatedDataLengthContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closePortFileIOUsing }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClosePortFileIOUsing(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClosePortFileIOUsing(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClosePortFileIOUsing(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClosePortFileIOUsing(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closePortFileIOUsing() throws -> ClosePortFileIOUsingContext {
		var _localctx: ClosePortFileIOUsingContext = ClosePortFileIOUsingContext(_ctx, getState())
		try enterRule(_localctx, 596, Cobol85Parser.RULE_closePortFileIOUsing)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3930)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.CLOSE_DISPOSITION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3927)
		 		try closePortFileIOUsingCloseDisposition()

		 		break

		 	case Cobol85Parser.ASSOCIATED_DATA:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3928)
		 		try closePortFileIOUsingAssociatedData()

		 		break

		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3929)
		 		try closePortFileIOUsingAssociatedDataLength()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClosePortFileIOUsingCloseDispositionContext:ParserRuleContext {
		open func CLOSE_DISPOSITION() -> TerminalNode? { return getToken(Cobol85Parser.CLOSE_DISPOSITION, 0) }
		open func ABORT() -> TerminalNode? { return getToken(Cobol85Parser.ABORT, 0) }
		open func ORDERLY() -> TerminalNode? { return getToken(Cobol85Parser.ORDERLY, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closePortFileIOUsingCloseDisposition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClosePortFileIOUsingCloseDisposition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClosePortFileIOUsingCloseDisposition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClosePortFileIOUsingCloseDisposition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClosePortFileIOUsingCloseDisposition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closePortFileIOUsingCloseDisposition() throws -> ClosePortFileIOUsingCloseDispositionContext {
		var _localctx: ClosePortFileIOUsingCloseDispositionContext = ClosePortFileIOUsingCloseDispositionContext(_ctx, getState())
		try enterRule(_localctx, 598, Cobol85Parser.RULE_closePortFileIOUsingCloseDisposition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3932)
		 	try match(Cobol85Parser.CLOSE_DISPOSITION)
		 	setState(3934)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OF
		 	      return testSet
		 	 }()) {
		 		setState(3933)
		 		try match(Cobol85Parser.OF)

		 	}

		 	setState(3936)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ABORT
		 	          testSet = testSet || _la == Cobol85Parser.ORDERLY
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClosePortFileIOUsingAssociatedDataContext:ParserRuleContext {
		open func ASSOCIATED_DATA() -> TerminalNode? { return getToken(Cobol85Parser.ASSOCIATED_DATA, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closePortFileIOUsingAssociatedData }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClosePortFileIOUsingAssociatedData(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClosePortFileIOUsingAssociatedData(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClosePortFileIOUsingAssociatedData(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClosePortFileIOUsingAssociatedData(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closePortFileIOUsingAssociatedData() throws -> ClosePortFileIOUsingAssociatedDataContext {
		var _localctx: ClosePortFileIOUsingAssociatedDataContext = ClosePortFileIOUsingAssociatedDataContext(_ctx, getState())
		try enterRule(_localctx, 600, Cobol85Parser.RULE_closePortFileIOUsingAssociatedData)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3938)
		 	try match(Cobol85Parser.ASSOCIATED_DATA)
		 	setState(3941)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,533, _ctx)) {
		 	case 1:
		 		setState(3939)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3940)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClosePortFileIOUsingAssociatedDataLengthContext:ParserRuleContext {
		open func ASSOCIATED_DATA_LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.ASSOCIATED_DATA_LENGTH, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_closePortFileIOUsingAssociatedDataLength }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClosePortFileIOUsingAssociatedDataLength(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClosePortFileIOUsingAssociatedDataLength(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClosePortFileIOUsingAssociatedDataLength(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClosePortFileIOUsingAssociatedDataLength(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func closePortFileIOUsingAssociatedDataLength() throws -> ClosePortFileIOUsingAssociatedDataLengthContext {
		var _localctx: ClosePortFileIOUsingAssociatedDataLengthContext = ClosePortFileIOUsingAssociatedDataLengthContext(_ctx, getState())
		try enterRule(_localctx, 602, Cobol85Parser.RULE_closePortFileIOUsingAssociatedDataLength)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3943)
		 	try match(Cobol85Parser.ASSOCIATED_DATA_LENGTH)
		 	setState(3945)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OF
		 	      return testSet
		 	 }()) {
		 		setState(3944)
		 		try match(Cobol85Parser.OF)

		 	}

		 	setState(3949)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,535, _ctx)) {
		 	case 1:
		 		setState(3947)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3948)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ComputeStatementContext:ParserRuleContext {
		open func COMPUTE() -> TerminalNode? { return getToken(Cobol85Parser.COMPUTE, 0) }
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func EQUALCHAR() -> TerminalNode? { return getToken(Cobol85Parser.EQUALCHAR, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(Cobol85Parser.EQUAL, 0) }
		open func computeStore() -> Array<ComputeStoreContext> {
			return getRuleContexts(ComputeStoreContext.self)
		}
		open func computeStore(_ i: Int) -> ComputeStoreContext? {
			return getRuleContext(ComputeStoreContext.self,i)
		}
		open func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
			return getRuleContext(OnSizeErrorPhraseContext.self,0)
		}
		open func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
			return getRuleContext(NotOnSizeErrorPhraseContext.self,0)
		}
		open func END_COMPUTE() -> TerminalNode? { return getToken(Cobol85Parser.END_COMPUTE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_computeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterComputeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitComputeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitComputeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitComputeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func computeStatement() throws -> ComputeStatementContext {
		var _localctx: ComputeStatementContext = ComputeStatementContext(_ctx, getState())
		try enterRule(_localctx, 604, Cobol85Parser.RULE_computeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3951)
		 	try match(Cobol85Parser.COMPUTE)
		 	setState(3953) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3952)
		 		try computeStore()


		 		setState(3955); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3957)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.EQUAL
		 	          testSet = testSet || _la == Cobol85Parser.EQUALCHAR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3958)
		 	try arithmeticExpression()
		 	setState(3960)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,537,_ctx)) {
		 	case 1:
		 		setState(3959)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3963)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,538,_ctx)) {
		 	case 1:
		 		setState(3962)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3966)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,539,_ctx)) {
		 	case 1:
		 		setState(3965)
		 		try match(Cobol85Parser.END_COMPUTE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ComputeStoreContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_computeStore }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterComputeStore(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitComputeStore(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitComputeStore(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitComputeStore(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func computeStore() throws -> ComputeStoreContext {
		var _localctx: ComputeStoreContext = ComputeStoreContext(_ctx, getState())
		try enterRule(_localctx, 606, Cobol85Parser.RULE_computeStore)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3968)
		 	try identifier()
		 	setState(3970)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(3969)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ContinueStatementContext:ParserRuleContext {
		open func CONTINUE() -> TerminalNode? { return getToken(Cobol85Parser.CONTINUE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_continueStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterContinueStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitContinueStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitContinueStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitContinueStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func continueStatement() throws -> ContinueStatementContext {
		var _localctx: ContinueStatementContext = ContinueStatementContext(_ctx, getState())
		try enterRule(_localctx, 608, Cobol85Parser.RULE_continueStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3972)
		 	try match(Cobol85Parser.CONTINUE)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DeleteStatementContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(Cobol85Parser.DELETE, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
			return getRuleContext(InvalidKeyPhraseContext.self,0)
		}
		open func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
			return getRuleContext(NotInvalidKeyPhraseContext.self,0)
		}
		open func END_DELETE() -> TerminalNode? { return getToken(Cobol85Parser.END_DELETE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_deleteStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDeleteStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDeleteStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDeleteStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDeleteStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func deleteStatement() throws -> DeleteStatementContext {
		var _localctx: DeleteStatementContext = DeleteStatementContext(_ctx, getState())
		try enterRule(_localctx, 610, Cobol85Parser.RULE_deleteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3974)
		 	try match(Cobol85Parser.DELETE)
		 	setState(3975)
		 	try fileName()
		 	setState(3977)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RECORD
		 	      return testSet
		 	 }()) {
		 		setState(3976)
		 		try match(Cobol85Parser.RECORD)

		 	}

		 	setState(3980)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,542,_ctx)) {
		 	case 1:
		 		setState(3979)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3983)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,543,_ctx)) {
		 	case 1:
		 		setState(3982)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3986)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,544,_ctx)) {
		 	case 1:
		 		setState(3985)
		 		try match(Cobol85Parser.END_DELETE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisableStatementContext:ParserRuleContext {
		open func DISABLE() -> TerminalNode? { return getToken(Cobol85Parser.DISABLE, 0) }
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func I_O() -> TerminalNode? { return getToken(Cobol85Parser.I_O, 0) }
		open func TERMINAL() -> TerminalNode? { return getToken(Cobol85Parser.TERMINAL, 0) }
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_disableStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisableStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisableStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisableStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisableStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func disableStatement() throws -> DisableStatementContext {
		var _localctx: DisableStatementContext = DisableStatementContext(_ctx, getState())
		try enterRule(_localctx, 612, Cobol85Parser.RULE_disableStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3988)
		 	try match(Cobol85Parser.DISABLE)
		 	setState(3996)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.INPUT:
		 		setState(3989)
		 		try match(Cobol85Parser.INPUT)
		 		setState(3991)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TERMINAL
		 		      return testSet
		 		 }()) {
		 			setState(3990)
		 			try match(Cobol85Parser.TERMINAL)

		 		}


		 		break

		 	case Cobol85Parser.I_O:
		 		setState(3993)
		 		try match(Cobol85Parser.I_O)
		 		setState(3994)
		 		try match(Cobol85Parser.TERMINAL)

		 		break

		 	case Cobol85Parser.OUTPUT:
		 		setState(3995)
		 		try match(Cobol85Parser.OUTPUT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3998)
		 	try cdName()
		 	setState(4000)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(3999)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4002)
		 	try match(Cobol85Parser.KEY)
		 	setState(4005)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,548, _ctx)) {
		 	case 1:
		 		setState(4003)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4004)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisplayStatementContext:ParserRuleContext {
		open func DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DISPLAY, 0) }
		open func displayOperand() -> Array<DisplayOperandContext> {
			return getRuleContexts(DisplayOperandContext.self)
		}
		open func displayOperand(_ i: Int) -> DisplayOperandContext? {
			return getRuleContext(DisplayOperandContext.self,i)
		}
		open func displayAt() -> DisplayAtContext? {
			return getRuleContext(DisplayAtContext.self,0)
		}
		open func displayUpon() -> DisplayUponContext? {
			return getRuleContext(DisplayUponContext.self,0)
		}
		open func displayWith() -> DisplayWithContext? {
			return getRuleContext(DisplayWithContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_displayStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisplayStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisplayStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisplayStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisplayStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func displayStatement() throws -> DisplayStatementContext {
		var _localctx: DisplayStatementContext = DisplayStatementContext(_ctx, getState())
		try enterRule(_localctx, 614, Cobol85Parser.RULE_displayStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4007)
		 	try match(Cobol85Parser.DISPLAY)
		 	setState(4009) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4008)
		 		try displayOperand()


		 		setState(4011); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4014)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,550,_ctx)) {
		 	case 1:
		 		setState(4013)
		 		try displayAt()

		 		break
		 	default: break
		 	}
		 	setState(4017)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.UPON
		 	      return testSet
		 	 }()) {
		 		setState(4016)
		 		try displayUpon()

		 	}

		 	setState(4020)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,552,_ctx)) {
		 	case 1:
		 		setState(4019)
		 		try displayWith()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisplayOperandContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_displayOperand }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisplayOperand(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisplayOperand(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisplayOperand(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisplayOperand(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func displayOperand() throws -> DisplayOperandContext {
		var _localctx: DisplayOperandContext = DisplayOperandContext(_ctx, getState())
		try enterRule(_localctx, 616, Cobol85Parser.RULE_displayOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4024)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,553, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4022)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4023)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisplayAtContext:ParserRuleContext {
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_displayAt }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisplayAt(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisplayAt(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisplayAt(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisplayAt(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func displayAt() throws -> DisplayAtContext {
		var _localctx: DisplayAtContext = DisplayAtContext(_ctx, getState())
		try enterRule(_localctx, 618, Cobol85Parser.RULE_displayAt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4026)
		 	try match(Cobol85Parser.AT)
		 	setState(4029)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,554, _ctx)) {
		 	case 1:
		 		setState(4027)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4028)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisplayUponContext:ParserRuleContext {
		open func UPON() -> TerminalNode? { return getToken(Cobol85Parser.UPON, 0) }
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open func environmentName() -> EnvironmentNameContext? {
			return getRuleContext(EnvironmentNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_displayUpon }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisplayUpon(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisplayUpon(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisplayUpon(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisplayUpon(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func displayUpon() throws -> DisplayUponContext {
		var _localctx: DisplayUponContext = DisplayUponContext(_ctx, getState())
		try enterRule(_localctx, 620, Cobol85Parser.RULE_displayUpon)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4031)
		 	try match(Cobol85Parser.UPON)
		 	setState(4034)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,555, _ctx)) {
		 	case 1:
		 		setState(4032)
		 		try mnemonicName()

		 		break
		 	case 2:
		 		setState(4033)
		 		try environmentName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DisplayWithContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func ADVANCING() -> TerminalNode? { return getToken(Cobol85Parser.ADVANCING, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_displayWith }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDisplayWith(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDisplayWith(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDisplayWith(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDisplayWith(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func displayWith() throws -> DisplayWithContext {
		var _localctx: DisplayWithContext = DisplayWithContext(_ctx, getState())
		try enterRule(_localctx, 622, Cobol85Parser.RULE_displayWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4037)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4036)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4039)
		 	try match(Cobol85Parser.NO)
		 	setState(4040)
		 	try match(Cobol85Parser.ADVANCING)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideStatementContext:ParserRuleContext {
		open func DIVIDE() -> TerminalNode? { return getToken(Cobol85Parser.DIVIDE, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func divideIntoStatement() -> DivideIntoStatementContext? {
			return getRuleContext(DivideIntoStatementContext.self,0)
		}
		open func divideIntoGivingStatement() -> DivideIntoGivingStatementContext? {
			return getRuleContext(DivideIntoGivingStatementContext.self,0)
		}
		open func divideIntoByGivingStatement() -> DivideIntoByGivingStatementContext? {
			return getRuleContext(DivideIntoByGivingStatementContext.self,0)
		}
		open func divideRemainder() -> DivideRemainderContext? {
			return getRuleContext(DivideRemainderContext.self,0)
		}
		open func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
			return getRuleContext(OnSizeErrorPhraseContext.self,0)
		}
		open func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
			return getRuleContext(NotOnSizeErrorPhraseContext.self,0)
		}
		open func END_DIVIDE() -> TerminalNode? { return getToken(Cobol85Parser.END_DIVIDE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideStatement() throws -> DivideStatementContext {
		var _localctx: DivideStatementContext = DivideStatementContext(_ctx, getState())
		try enterRule(_localctx, 624, Cobol85Parser.RULE_divideStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4042)
		 	try match(Cobol85Parser.DIVIDE)
		 	setState(4045)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,557, _ctx)) {
		 	case 1:
		 		setState(4043)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4044)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4050)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,558, _ctx)) {
		 	case 1:
		 		setState(4047)
		 		try divideIntoStatement()

		 		break
		 	case 2:
		 		setState(4048)
		 		try divideIntoGivingStatement()

		 		break
		 	case 3:
		 		setState(4049)
		 		try divideIntoByGivingStatement()

		 		break
		 	default: break
		 	}
		 	setState(4053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REMAINDER
		 	      return testSet
		 	 }()) {
		 		setState(4052)
		 		try divideRemainder()

		 	}

		 	setState(4056)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,560,_ctx)) {
		 	case 1:
		 		setState(4055)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4059)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,561,_ctx)) {
		 	case 1:
		 		setState(4058)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4062)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,562,_ctx)) {
		 	case 1:
		 		setState(4061)
		 		try match(Cobol85Parser.END_DIVIDE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideIntoStatementContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func divideGivingPhrase() -> DivideGivingPhraseContext? {
			return getRuleContext(DivideGivingPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideIntoStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideIntoStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideIntoStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideIntoStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideIntoStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideIntoStatement() throws -> DivideIntoStatementContext {
		var _localctx: DivideIntoStatementContext = DivideIntoStatementContext(_ctx, getState())
		try enterRule(_localctx, 626, Cobol85Parser.RULE_divideIntoStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4064)
		 	try match(Cobol85Parser.INTO)
		 	setState(4067)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,563, _ctx)) {
		 	case 1:
		 		setState(4065)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4066)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4070)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(4069)
		 		try divideGivingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideIntoGivingStatementContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func divideGiving() -> Array<DivideGivingContext> {
			return getRuleContexts(DivideGivingContext.self)
		}
		open func divideGiving(_ i: Int) -> DivideGivingContext? {
			return getRuleContext(DivideGivingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideIntoGivingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideIntoGivingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideIntoGivingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideIntoGivingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideIntoGivingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideIntoGivingStatement() throws -> DivideIntoGivingStatementContext {
		var _localctx: DivideIntoGivingStatementContext = DivideIntoGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 628, Cobol85Parser.RULE_divideIntoGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4072)
		 	try match(Cobol85Parser.INTO)
		 	setState(4074) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4073)
		 		try divideGiving()


		 		setState(4076); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideIntoByGivingStatementContext:ParserRuleContext {
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func divideGivingPhrase() -> DivideGivingPhraseContext? {
			return getRuleContext(DivideGivingPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideIntoByGivingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideIntoByGivingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideIntoByGivingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideIntoByGivingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideIntoByGivingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideIntoByGivingStatement() throws -> DivideIntoByGivingStatementContext {
		var _localctx: DivideIntoByGivingStatementContext = DivideIntoByGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 630, Cobol85Parser.RULE_divideIntoByGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4078)
		 	try match(Cobol85Parser.BY)
		 	setState(4081)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,566, _ctx)) {
		 	case 1:
		 		setState(4079)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4080)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4084)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(4083)
		 		try divideGivingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideGivingPhraseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func divideGiving() -> Array<DivideGivingContext> {
			return getRuleContexts(DivideGivingContext.self)
		}
		open func divideGiving(_ i: Int) -> DivideGivingContext? {
			return getRuleContext(DivideGivingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideGivingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideGivingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideGivingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideGivingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideGivingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideGivingPhrase() throws -> DivideGivingPhraseContext {
		var _localctx: DivideGivingPhraseContext = DivideGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 632, Cobol85Parser.RULE_divideGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4086)
		 	try match(Cobol85Parser.GIVING)
		 	setState(4088) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4087)
		 		try divideGiving()


		 		setState(4090); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideGivingContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideGiving() throws -> DivideGivingContext {
		var _localctx: DivideGivingContext = DivideGivingContext(_ctx, getState())
		try enterRule(_localctx, 634, Cobol85Parser.RULE_divideGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4092)
		 	try identifier()
		 	setState(4094)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(4093)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DivideRemainderContext:ParserRuleContext {
		open func REMAINDER() -> TerminalNode? { return getToken(Cobol85Parser.REMAINDER, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_divideRemainder }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDivideRemainder(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDivideRemainder(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDivideRemainder(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDivideRemainder(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func divideRemainder() throws -> DivideRemainderContext {
		var _localctx: DivideRemainderContext = DivideRemainderContext(_ctx, getState())
		try enterRule(_localctx, 636, Cobol85Parser.RULE_divideRemainder)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4096)
		 	try match(Cobol85Parser.REMAINDER)
		 	setState(4097)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnableStatementContext:ParserRuleContext {
		open func ENABLE() -> TerminalNode? { return getToken(Cobol85Parser.ENABLE, 0) }
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func I_O() -> TerminalNode? { return getToken(Cobol85Parser.I_O, 0) }
		open func TERMINAL() -> TerminalNode? { return getToken(Cobol85Parser.TERMINAL, 0) }
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_enableStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnableStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnableStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnableStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnableStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func enableStatement() throws -> EnableStatementContext {
		var _localctx: EnableStatementContext = EnableStatementContext(_ctx, getState())
		try enterRule(_localctx, 638, Cobol85Parser.RULE_enableStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4099)
		 	try match(Cobol85Parser.ENABLE)
		 	setState(4107)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.INPUT:
		 		setState(4100)
		 		try match(Cobol85Parser.INPUT)
		 		setState(4102)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TERMINAL
		 		      return testSet
		 		 }()) {
		 			setState(4101)
		 			try match(Cobol85Parser.TERMINAL)

		 		}


		 		break

		 	case Cobol85Parser.I_O:
		 		setState(4104)
		 		try match(Cobol85Parser.I_O)
		 		setState(4105)
		 		try match(Cobol85Parser.TERMINAL)

		 		break

		 	case Cobol85Parser.OUTPUT:
		 		setState(4106)
		 		try match(Cobol85Parser.OUTPUT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4109)
		 	try cdName()
		 	setState(4111)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4110)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4113)
		 	try match(Cobol85Parser.KEY)
		 	setState(4116)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,573, _ctx)) {
		 	case 1:
		 		setState(4114)
		 		try literal()

		 		break
		 	case 2:
		 		setState(4115)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EntryStatementContext:ParserRuleContext {
		open func ENTRY() -> TerminalNode? { return getToken(Cobol85Parser.ENTRY, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_entryStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEntryStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEntryStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEntryStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEntryStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func entryStatement() throws -> EntryStatementContext {
		var _localctx: EntryStatementContext = EntryStatementContext(_ctx, getState())
		try enterRule(_localctx, 640, Cobol85Parser.RULE_entryStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4118)
		 	try match(Cobol85Parser.ENTRY)
		 	setState(4119)
		 	try literal()
		 	setState(4126)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(4120)
		 		try match(Cobol85Parser.USING)
		 		setState(4122) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(4121)
		 			try identifier()


		 			setState(4124); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 		              return  Utils.testBitLeftShiftArray(testArray, 556)
		 		          }()
		 		      return testSet
		 		 }())

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateStatementContext:ParserRuleContext {
		open func EVALUATE() -> TerminalNode? { return getToken(Cobol85Parser.EVALUATE, 0) }
		open func evaluateSelect() -> EvaluateSelectContext? {
			return getRuleContext(EvaluateSelectContext.self,0)
		}
		open func evaluateAlsoSelect() -> Array<EvaluateAlsoSelectContext> {
			return getRuleContexts(EvaluateAlsoSelectContext.self)
		}
		open func evaluateAlsoSelect(_ i: Int) -> EvaluateAlsoSelectContext? {
			return getRuleContext(EvaluateAlsoSelectContext.self,i)
		}
		open func evaluateWhenPhrase() -> Array<EvaluateWhenPhraseContext> {
			return getRuleContexts(EvaluateWhenPhraseContext.self)
		}
		open func evaluateWhenPhrase(_ i: Int) -> EvaluateWhenPhraseContext? {
			return getRuleContext(EvaluateWhenPhraseContext.self,i)
		}
		open func evaluateWhenOther() -> EvaluateWhenOtherContext? {
			return getRuleContext(EvaluateWhenOtherContext.self,0)
		}
		open func END_EVALUATE() -> TerminalNode? { return getToken(Cobol85Parser.END_EVALUATE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateStatement() throws -> EvaluateStatementContext {
		var _localctx: EvaluateStatementContext = EvaluateStatementContext(_ctx, getState())
		try enterRule(_localctx, 642, Cobol85Parser.RULE_evaluateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4128)
		 	try match(Cobol85Parser.EVALUATE)
		 	setState(4129)
		 	try evaluateSelect()
		 	setState(4133)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ALSO
		 	      return testSet
		 	 }()) {
		 		setState(4130)
		 		try evaluateAlsoSelect()


		 		setState(4135)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4137); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4136)
		 			try evaluateWhenPhrase()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4139); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,577,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4142)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,578,_ctx)) {
		 	case 1:
		 		setState(4141)
		 		try evaluateWhenOther()

		 		break
		 	default: break
		 	}
		 	setState(4145)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,579,_ctx)) {
		 	case 1:
		 		setState(4144)
		 		try match(Cobol85Parser.END_EVALUATE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateSelectContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateSelect }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateSelect(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateSelect(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateSelect(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateSelect(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateSelect() throws -> EvaluateSelectContext {
		var _localctx: EvaluateSelectContext = EvaluateSelectContext(_ctx, getState())
		try enterRule(_localctx, 644, Cobol85Parser.RULE_evaluateSelect)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4151)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,580, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4147)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4148)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4149)
		 		try arithmeticExpression()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4150)
		 		try condition()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateAlsoSelectContext:ParserRuleContext {
		open func ALSO() -> TerminalNode? { return getToken(Cobol85Parser.ALSO, 0) }
		open func evaluateSelect() -> EvaluateSelectContext? {
			return getRuleContext(EvaluateSelectContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateAlsoSelect }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateAlsoSelect(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateAlsoSelect(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateAlsoSelect(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateAlsoSelect(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateAlsoSelect() throws -> EvaluateAlsoSelectContext {
		var _localctx: EvaluateAlsoSelectContext = EvaluateAlsoSelectContext(_ctx, getState())
		try enterRule(_localctx, 646, Cobol85Parser.RULE_evaluateAlsoSelect)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4153)
		 	try match(Cobol85Parser.ALSO)
		 	setState(4154)
		 	try evaluateSelect()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateWhenPhraseContext:ParserRuleContext {
		open func evaluateWhen() -> Array<EvaluateWhenContext> {
			return getRuleContexts(EvaluateWhenContext.self)
		}
		open func evaluateWhen(_ i: Int) -> EvaluateWhenContext? {
			return getRuleContext(EvaluateWhenContext.self,i)
		}
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateWhenPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateWhenPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateWhenPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateWhenPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateWhenPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateWhenPhrase() throws -> EvaluateWhenPhraseContext {
		var _localctx: EvaluateWhenPhraseContext = EvaluateWhenPhraseContext(_ctx, getState())
		try enterRule(_localctx, 648, Cobol85Parser.RULE_evaluateWhenPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4157); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4156)
		 			try evaluateWhen()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4159); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,581,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4164)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,582,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4161)
		 			try statement()

		 	 
		 		}
		 		setState(4166)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,582,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateWhenContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open func evaluateCondition() -> EvaluateConditionContext? {
			return getRuleContext(EvaluateConditionContext.self,0)
		}
		open func evaluateAlsoCondition() -> Array<EvaluateAlsoConditionContext> {
			return getRuleContexts(EvaluateAlsoConditionContext.self)
		}
		open func evaluateAlsoCondition(_ i: Int) -> EvaluateAlsoConditionContext? {
			return getRuleContext(EvaluateAlsoConditionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateWhen }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateWhen(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateWhen(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateWhen(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateWhen(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateWhen() throws -> EvaluateWhenContext {
		var _localctx: EvaluateWhenContext = EvaluateWhenContext(_ctx, getState())
		try enterRule(_localctx, 650, Cobol85Parser.RULE_evaluateWhen)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4167)
		 	try match(Cobol85Parser.WHEN)
		 	setState(4168)
		 	try evaluateCondition()
		 	setState(4172)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ALSO
		 	      return testSet
		 	 }()) {
		 		setState(4169)
		 		try evaluateAlsoCondition()


		 		setState(4174)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateConditionContext:ParserRuleContext {
		open func ANY() -> TerminalNode? { return getToken(Cobol85Parser.ANY, 0) }
		open func evaluateValue() -> EvaluateValueContext? {
			return getRuleContext(EvaluateValueContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func evaluateThrough() -> EvaluateThroughContext? {
			return getRuleContext(EvaluateThroughContext.self,0)
		}
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func booleanLiteral() -> BooleanLiteralContext? {
			return getRuleContext(BooleanLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateCondition() throws -> EvaluateConditionContext {
		var _localctx: EvaluateConditionContext = EvaluateConditionContext(_ctx, getState())
		try enterRule(_localctx, 652, Cobol85Parser.RULE_evaluateCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4185)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,586, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4175)
		 		try match(Cobol85Parser.ANY)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4177)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.NOT
		 		      return testSet
		 		 }()) {
		 			setState(4176)
		 			try match(Cobol85Parser.NOT)

		 		}

		 		setState(4179)
		 		try evaluateValue()
		 		setState(4181)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 		      return testSet
		 		 }()) {
		 			setState(4180)
		 			try evaluateThrough()

		 		}


		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4183)
		 		try condition()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4184)
		 		try booleanLiteral()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateThroughContext:ParserRuleContext {
		open func evaluateValue() -> EvaluateValueContext? {
			return getRuleContext(EvaluateValueContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateThrough() throws -> EvaluateThroughContext {
		var _localctx: EvaluateThroughContext = EvaluateThroughContext(_ctx, getState())
		try enterRule(_localctx, 654, Cobol85Parser.RULE_evaluateThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4187)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4188)
		 	try evaluateValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateAlsoConditionContext:ParserRuleContext {
		open func ALSO() -> TerminalNode? { return getToken(Cobol85Parser.ALSO, 0) }
		open func evaluateCondition() -> EvaluateConditionContext? {
			return getRuleContext(EvaluateConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateAlsoCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateAlsoCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateAlsoCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateAlsoCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateAlsoCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateAlsoCondition() throws -> EvaluateAlsoConditionContext {
		var _localctx: EvaluateAlsoConditionContext = EvaluateAlsoConditionContext(_ctx, getState())
		try enterRule(_localctx, 656, Cobol85Parser.RULE_evaluateAlsoCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4190)
		 	try match(Cobol85Parser.ALSO)
		 	setState(4191)
		 	try evaluateCondition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateWhenOtherContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open func OTHER() -> TerminalNode? { return getToken(Cobol85Parser.OTHER, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateWhenOther }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateWhenOther(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateWhenOther(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateWhenOther(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateWhenOther(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateWhenOther() throws -> EvaluateWhenOtherContext {
		var _localctx: EvaluateWhenOtherContext = EvaluateWhenOtherContext(_ctx, getState())
		try enterRule(_localctx, 658, Cobol85Parser.RULE_evaluateWhenOther)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4193)
		 	try match(Cobol85Parser.WHEN)
		 	setState(4194)
		 	try match(Cobol85Parser.OTHER)
		 	setState(4198)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,587,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4195)
		 			try statement()

		 	 
		 		}
		 		setState(4200)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,587,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EvaluateValueContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_evaluateValue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEvaluateValue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEvaluateValue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEvaluateValue(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEvaluateValue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func evaluateValue() throws -> EvaluateValueContext {
		var _localctx: EvaluateValueContext = EvaluateValueContext(_ctx, getState())
		try enterRule(_localctx, 660, Cobol85Parser.RULE_evaluateValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4204)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,588, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4201)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4202)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4203)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExecCicsStatementContext:ParserRuleContext {
		open func EXECCICSLINE() -> Array<TerminalNode> { return getTokens(Cobol85Parser.EXECCICSLINE) }
		open func EXECCICSLINE(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.EXECCICSLINE, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_execCicsStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExecCicsStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExecCicsStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExecCicsStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExecCicsStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execCicsStatement() throws -> ExecCicsStatementContext {
		var _localctx: ExecCicsStatementContext = ExecCicsStatementContext(_ctx, getState())
		try enterRule(_localctx, 662, Cobol85Parser.RULE_execCicsStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4207); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4206)
		 			try match(Cobol85Parser.EXECCICSLINE)


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4209); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,589,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExecSqlStatementContext:ParserRuleContext {
		open func EXECSQLLINE() -> Array<TerminalNode> { return getTokens(Cobol85Parser.EXECSQLLINE) }
		open func EXECSQLLINE(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.EXECSQLLINE, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_execSqlStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExecSqlStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExecSqlStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExecSqlStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExecSqlStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execSqlStatement() throws -> ExecSqlStatementContext {
		var _localctx: ExecSqlStatementContext = ExecSqlStatementContext(_ctx, getState())
		try enterRule(_localctx, 664, Cobol85Parser.RULE_execSqlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4212); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4211)
		 			try match(Cobol85Parser.EXECSQLLINE)


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4214); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,590,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExecSqlImsStatementContext:ParserRuleContext {
		open func EXECSQLIMSLINE() -> Array<TerminalNode> { return getTokens(Cobol85Parser.EXECSQLIMSLINE) }
		open func EXECSQLIMSLINE(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.EXECSQLIMSLINE, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_execSqlImsStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExecSqlImsStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExecSqlImsStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExecSqlImsStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExecSqlImsStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execSqlImsStatement() throws -> ExecSqlImsStatementContext {
		var _localctx: ExecSqlImsStatementContext = ExecSqlImsStatementContext(_ctx, getState())
		try enterRule(_localctx, 666, Cobol85Parser.RULE_execSqlImsStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4217); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4216)
		 			try match(Cobol85Parser.EXECSQLIMSLINE)


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4219); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,591,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExhibitStatementContext:ParserRuleContext {
		open func EXHIBIT() -> TerminalNode? { return getToken(Cobol85Parser.EXHIBIT, 0) }
		open func NAMED() -> TerminalNode? { return getToken(Cobol85Parser.NAMED, 0) }
		open func CHANGED() -> TerminalNode? { return getToken(Cobol85Parser.CHANGED, 0) }
		open func exhibitOperand() -> Array<ExhibitOperandContext> {
			return getRuleContexts(ExhibitOperandContext.self)
		}
		open func exhibitOperand(_ i: Int) -> ExhibitOperandContext? {
			return getRuleContext(ExhibitOperandContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_exhibitStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExhibitStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExhibitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExhibitStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExhibitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exhibitStatement() throws -> ExhibitStatementContext {
		var _localctx: ExhibitStatementContext = ExhibitStatementContext(_ctx, getState())
		try enterRule(_localctx, 668, Cobol85Parser.RULE_exhibitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4221)
		 	try match(Cobol85Parser.EXHIBIT)
		 	setState(4223)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,592,_ctx)) {
		 	case 1:
		 		setState(4222)
		 		try match(Cobol85Parser.NAMED)

		 		break
		 	default: break
		 	}
		 	setState(4226)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,593,_ctx)) {
		 	case 1:
		 		setState(4225)
		 		try match(Cobol85Parser.CHANGED)

		 		break
		 	default: break
		 	}
		 	setState(4229) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4228)
		 		try exhibitOperand()


		 		setState(4231); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExhibitOperandContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_exhibitOperand }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExhibitOperand(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExhibitOperand(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExhibitOperand(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExhibitOperand(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exhibitOperand() throws -> ExhibitOperandContext {
		var _localctx: ExhibitOperandContext = ExhibitOperandContext(_ctx, getState())
		try enterRule(_localctx, 670, Cobol85Parser.RULE_exhibitOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4235)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,595, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4233)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4234)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExitStatementContext:ParserRuleContext {
		open func EXIT() -> TerminalNode? { return getToken(Cobol85Parser.EXIT, 0) }
		open func PROGRAM() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_exitStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterExitStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitExitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitExitStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitExitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exitStatement() throws -> ExitStatementContext {
		var _localctx: ExitStatementContext = ExitStatementContext(_ctx, getState())
		try enterRule(_localctx, 672, Cobol85Parser.RULE_exitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4237)
		 	try match(Cobol85Parser.EXIT)
		 	setState(4239)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.PROGRAM
		 	      return testSet
		 	 }()) {
		 		setState(4238)
		 		try match(Cobol85Parser.PROGRAM)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GenerateStatementContext:ParserRuleContext {
		open func GENERATE() -> TerminalNode? { return getToken(Cobol85Parser.GENERATE, 0) }
		open func reportName() -> ReportNameContext? {
			return getRuleContext(ReportNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_generateStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGenerateStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGenerateStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGenerateStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGenerateStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func generateStatement() throws -> GenerateStatementContext {
		var _localctx: GenerateStatementContext = GenerateStatementContext(_ctx, getState())
		try enterRule(_localctx, 674, Cobol85Parser.RULE_generateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4241)
		 	try match(Cobol85Parser.GENERATE)
		 	setState(4242)
		 	try reportName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GobackStatementContext:ParserRuleContext {
		open func GOBACK() -> TerminalNode? { return getToken(Cobol85Parser.GOBACK, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_gobackStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGobackStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGobackStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGobackStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGobackStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func gobackStatement() throws -> GobackStatementContext {
		var _localctx: GobackStatementContext = GobackStatementContext(_ctx, getState())
		try enterRule(_localctx, 676, Cobol85Parser.RULE_gobackStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4244)
		 	try match(Cobol85Parser.GOBACK)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GoToStatementContext:ParserRuleContext {
		open func GO() -> TerminalNode? { return getToken(Cobol85Parser.GO, 0) }
		open func goToStatementSimple() -> GoToStatementSimpleContext? {
			return getRuleContext(GoToStatementSimpleContext.self,0)
		}
		open func goToDependingOnStatement() -> GoToDependingOnStatementContext? {
			return getRuleContext(GoToDependingOnStatementContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_goToStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGoToStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGoToStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGoToStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGoToStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func goToStatement() throws -> GoToStatementContext {
		var _localctx: GoToStatementContext = GoToStatementContext(_ctx, getState())
		try enterRule(_localctx, 678, Cobol85Parser.RULE_goToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4246)
		 	try match(Cobol85Parser.GO)
		 	setState(4248)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TO
		 	      return testSet
		 	 }()) {
		 		setState(4247)
		 		try match(Cobol85Parser.TO)

		 	}

		 	setState(4252)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,598, _ctx)) {
		 	case 1:
		 		setState(4250)
		 		try goToStatementSimple()

		 		break
		 	case 2:
		 		setState(4251)
		 		try goToDependingOnStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GoToStatementSimpleContext:ParserRuleContext {
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_goToStatementSimple }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGoToStatementSimple(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGoToStatementSimple(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGoToStatementSimple(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGoToStatementSimple(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func goToStatementSimple() throws -> GoToStatementSimpleContext {
		var _localctx: GoToStatementSimpleContext = GoToStatementSimpleContext(_ctx, getState())
		try enterRule(_localctx, 680, Cobol85Parser.RULE_goToStatementSimple)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4254)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class GoToDependingOnStatementContext:ParserRuleContext {
		open func MORE_LABELS() -> TerminalNode? { return getToken(Cobol85Parser.MORE_LABELS, 0) }
		open func procedureName() -> Array<ProcedureNameContext> {
			return getRuleContexts(ProcedureNameContext.self)
		}
		open func procedureName(_ i: Int) -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,i)
		}
		open func DEPENDING() -> TerminalNode? { return getToken(Cobol85Parser.DEPENDING, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_goToDependingOnStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterGoToDependingOnStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitGoToDependingOnStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitGoToDependingOnStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitGoToDependingOnStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func goToDependingOnStatement() throws -> GoToDependingOnStatementContext {
		var _localctx: GoToDependingOnStatementContext = GoToDependingOnStatementContext(_ctx, getState())
		try enterRule(_localctx, 682, Cobol85Parser.RULE_goToDependingOnStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4269)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.MORE_LABELS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4256)
		 		try match(Cobol85Parser.MORE_LABELS)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4258) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(4257)
		 			try procedureName()


		 			setState(4260); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 		              return  Utils.testBitLeftShiftArray(testArray, 556)
		 		          }()
		 		      return testSet
		 		 }())
		 		setState(4267)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.DEPENDING
		 		      return testSet
		 		 }()) {
		 			setState(4262)
		 			try match(Cobol85Parser.DEPENDING)
		 			setState(4264)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.ON
		 			      return testSet
		 			 }()) {
		 				setState(4263)
		 				try match(Cobol85Parser.ON)

		 			}

		 			setState(4266)
		 			try identifier()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IfStatementContext:ParserRuleContext {
		open func IF() -> TerminalNode? { return getToken(Cobol85Parser.IF, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func ifThen() -> IfThenContext? {
			return getRuleContext(IfThenContext.self,0)
		}
		open func ifElse() -> IfElseContext? {
			return getRuleContext(IfElseContext.self,0)
		}
		open func END_IF() -> TerminalNode? { return getToken(Cobol85Parser.END_IF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_ifStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIfStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIfStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIfStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIfStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ifStatement() throws -> IfStatementContext {
		var _localctx: IfStatementContext = IfStatementContext(_ctx, getState())
		try enterRule(_localctx, 684, Cobol85Parser.RULE_ifStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4271)
		 	try match(Cobol85Parser.IF)
		 	setState(4272)
		 	try condition()
		 	setState(4273)
		 	try ifThen()
		 	setState(4275)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,603,_ctx)) {
		 	case 1:
		 		setState(4274)
		 		try ifElse()

		 		break
		 	default: break
		 	}
		 	setState(4278)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,604,_ctx)) {
		 	case 1:
		 		setState(4277)
		 		try match(Cobol85Parser.END_IF)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IfThenContext:ParserRuleContext {
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func SENTENCE() -> TerminalNode? { return getToken(Cobol85Parser.SENTENCE, 0) }
		open func THEN() -> TerminalNode? { return getToken(Cobol85Parser.THEN, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_ifThen }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIfThen(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIfThen(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIfThen(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIfThen(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ifThen() throws -> IfThenContext {
		var _localctx: IfThenContext = IfThenContext(_ctx, getState())
		try enterRule(_localctx, 686, Cobol85Parser.RULE_ifThen)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THEN
		 	      return testSet
		 	 }()) {
		 		setState(4280)
		 		try match(Cobol85Parser.THEN)

		 	}

		 	setState(4291)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NEXT:
		 		setState(4283)
		 		try match(Cobol85Parser.NEXT)
		 		setState(4284)
		 		try match(Cobol85Parser.SENTENCE)

		 		break
		 	case Cobol85Parser.ACCEPT:fallthrough
		 	case Cobol85Parser.ADD:fallthrough
		 	case Cobol85Parser.ALTER:fallthrough
		 	case Cobol85Parser.AT:fallthrough
		 	case Cobol85Parser.CALL:fallthrough
		 	case Cobol85Parser.CANCEL:fallthrough
		 	case Cobol85Parser.CLOSE:fallthrough
		 	case Cobol85Parser.COMPUTE:fallthrough
		 	case Cobol85Parser.CONTINUE:fallthrough
		 	case Cobol85Parser.DELETE:fallthrough
		 	case Cobol85Parser.DISABLE:fallthrough
		 	case Cobol85Parser.DISPLAY:fallthrough
		 	case Cobol85Parser.DIVIDE:fallthrough
		 	case Cobol85Parser.ELSE:fallthrough
		 	case Cobol85Parser.ENABLE:fallthrough
		 	case Cobol85Parser.END:fallthrough
		 	case Cobol85Parser.END_ADD:fallthrough
		 	case Cobol85Parser.END_CALL:fallthrough
		 	case Cobol85Parser.END_COMPUTE:fallthrough
		 	case Cobol85Parser.END_DELETE:fallthrough
		 	case Cobol85Parser.END_DIVIDE:fallthrough
		 	case Cobol85Parser.END_EVALUATE:fallthrough
		 	case Cobol85Parser.END_IF:fallthrough
		 	case Cobol85Parser.END_MULTIPLY:fallthrough
		 	case Cobol85Parser.END_PERFORM:fallthrough
		 	case Cobol85Parser.END_READ:fallthrough
		 	case Cobol85Parser.END_RECEIVE:fallthrough
		 	case Cobol85Parser.END_RETURN:fallthrough
		 	case Cobol85Parser.END_REWRITE:fallthrough
		 	case Cobol85Parser.END_SEARCH:fallthrough
		 	case Cobol85Parser.END_START:fallthrough
		 	case Cobol85Parser.END_STRING:fallthrough
		 	case Cobol85Parser.END_SUBTRACT:fallthrough
		 	case Cobol85Parser.END_UNSTRING:fallthrough
		 	case Cobol85Parser.END_WRITE:fallthrough
		 	case Cobol85Parser.ENTRY:fallthrough
		 	case Cobol85Parser.EVALUATE:fallthrough
		 	case Cobol85Parser.EXCEPTION:fallthrough
		 	case Cobol85Parser.EXHIBIT:fallthrough
		 	case Cobol85Parser.EXIT:fallthrough
		 	case Cobol85Parser.GENERATE:fallthrough
		 	case Cobol85Parser.GOBACK:fallthrough
		 	case Cobol85Parser.GO:fallthrough
		 	case Cobol85Parser.IF:fallthrough
		 	case Cobol85Parser.INITIALIZE:fallthrough
		 	case Cobol85Parser.INITIATE:fallthrough
		 	case Cobol85Parser.INSPECT:fallthrough
		 	case Cobol85Parser.INVALID:fallthrough
		 	case Cobol85Parser.MERGE:fallthrough
		 	case Cobol85Parser.MOVE:fallthrough
		 	case Cobol85Parser.MULTIPLY:fallthrough
		 	case Cobol85Parser.NOT:fallthrough
		 	case Cobol85Parser.ON:fallthrough
		 	case Cobol85Parser.OPEN:fallthrough
		 	case Cobol85Parser.PERFORM:fallthrough
		 	case Cobol85Parser.PURGE:fallthrough
		 	case Cobol85Parser.READ:fallthrough
		 	case Cobol85Parser.RECEIVE:fallthrough
		 	case Cobol85Parser.RELEASE:fallthrough
		 	case Cobol85Parser.RETURN:fallthrough
		 	case Cobol85Parser.REWRITE:fallthrough
		 	case Cobol85Parser.SEARCH:fallthrough
		 	case Cobol85Parser.SEND:fallthrough
		 	case Cobol85Parser.SET:fallthrough
		 	case Cobol85Parser.SORT:fallthrough
		 	case Cobol85Parser.START:fallthrough
		 	case Cobol85Parser.STOP:fallthrough
		 	case Cobol85Parser.STRING:fallthrough
		 	case Cobol85Parser.SUBTRACT:fallthrough
		 	case Cobol85Parser.TERMINATE:fallthrough
		 	case Cobol85Parser.UNSTRING:fallthrough
		 	case Cobol85Parser.WHEN:fallthrough
		 	case Cobol85Parser.WITH:fallthrough
		 	case Cobol85Parser.WRITE:fallthrough
		 	case Cobol85Parser.DOT_FS:fallthrough
		 	case Cobol85Parser.EXECCICSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLIMSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLLINE:
		 		setState(4288)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,606,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4285)
		 				try statement()

		 		 
		 			}
		 			setState(4290)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,606,_ctx)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IfElseContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(Cobol85Parser.ELSE, 0) }
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func SENTENCE() -> TerminalNode? { return getToken(Cobol85Parser.SENTENCE, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_ifElse }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIfElse(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIfElse(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIfElse(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIfElse(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ifElse() throws -> IfElseContext {
		var _localctx: IfElseContext = IfElseContext(_ctx, getState())
		try enterRule(_localctx, 688, Cobol85Parser.RULE_ifElse)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4293)
		 	try match(Cobol85Parser.ELSE)
		 	setState(4302)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NEXT:
		 		setState(4294)
		 		try match(Cobol85Parser.NEXT)
		 		setState(4295)
		 		try match(Cobol85Parser.SENTENCE)

		 		break
		 	case Cobol85Parser.ACCEPT:fallthrough
		 	case Cobol85Parser.ADD:fallthrough
		 	case Cobol85Parser.ALTER:fallthrough
		 	case Cobol85Parser.AT:fallthrough
		 	case Cobol85Parser.CALL:fallthrough
		 	case Cobol85Parser.CANCEL:fallthrough
		 	case Cobol85Parser.CLOSE:fallthrough
		 	case Cobol85Parser.COMPUTE:fallthrough
		 	case Cobol85Parser.CONTINUE:fallthrough
		 	case Cobol85Parser.DELETE:fallthrough
		 	case Cobol85Parser.DISABLE:fallthrough
		 	case Cobol85Parser.DISPLAY:fallthrough
		 	case Cobol85Parser.DIVIDE:fallthrough
		 	case Cobol85Parser.ELSE:fallthrough
		 	case Cobol85Parser.ENABLE:fallthrough
		 	case Cobol85Parser.END:fallthrough
		 	case Cobol85Parser.END_ADD:fallthrough
		 	case Cobol85Parser.END_CALL:fallthrough
		 	case Cobol85Parser.END_COMPUTE:fallthrough
		 	case Cobol85Parser.END_DELETE:fallthrough
		 	case Cobol85Parser.END_DIVIDE:fallthrough
		 	case Cobol85Parser.END_EVALUATE:fallthrough
		 	case Cobol85Parser.END_IF:fallthrough
		 	case Cobol85Parser.END_MULTIPLY:fallthrough
		 	case Cobol85Parser.END_PERFORM:fallthrough
		 	case Cobol85Parser.END_READ:fallthrough
		 	case Cobol85Parser.END_RECEIVE:fallthrough
		 	case Cobol85Parser.END_RETURN:fallthrough
		 	case Cobol85Parser.END_REWRITE:fallthrough
		 	case Cobol85Parser.END_SEARCH:fallthrough
		 	case Cobol85Parser.END_START:fallthrough
		 	case Cobol85Parser.END_STRING:fallthrough
		 	case Cobol85Parser.END_SUBTRACT:fallthrough
		 	case Cobol85Parser.END_UNSTRING:fallthrough
		 	case Cobol85Parser.END_WRITE:fallthrough
		 	case Cobol85Parser.ENTRY:fallthrough
		 	case Cobol85Parser.EVALUATE:fallthrough
		 	case Cobol85Parser.EXCEPTION:fallthrough
		 	case Cobol85Parser.EXHIBIT:fallthrough
		 	case Cobol85Parser.EXIT:fallthrough
		 	case Cobol85Parser.GENERATE:fallthrough
		 	case Cobol85Parser.GOBACK:fallthrough
		 	case Cobol85Parser.GO:fallthrough
		 	case Cobol85Parser.IF:fallthrough
		 	case Cobol85Parser.INITIALIZE:fallthrough
		 	case Cobol85Parser.INITIATE:fallthrough
		 	case Cobol85Parser.INSPECT:fallthrough
		 	case Cobol85Parser.INVALID:fallthrough
		 	case Cobol85Parser.MERGE:fallthrough
		 	case Cobol85Parser.MOVE:fallthrough
		 	case Cobol85Parser.MULTIPLY:fallthrough
		 	case Cobol85Parser.NOT:fallthrough
		 	case Cobol85Parser.ON:fallthrough
		 	case Cobol85Parser.OPEN:fallthrough
		 	case Cobol85Parser.PERFORM:fallthrough
		 	case Cobol85Parser.PURGE:fallthrough
		 	case Cobol85Parser.READ:fallthrough
		 	case Cobol85Parser.RECEIVE:fallthrough
		 	case Cobol85Parser.RELEASE:fallthrough
		 	case Cobol85Parser.RETURN:fallthrough
		 	case Cobol85Parser.REWRITE:fallthrough
		 	case Cobol85Parser.SEARCH:fallthrough
		 	case Cobol85Parser.SEND:fallthrough
		 	case Cobol85Parser.SET:fallthrough
		 	case Cobol85Parser.SORT:fallthrough
		 	case Cobol85Parser.START:fallthrough
		 	case Cobol85Parser.STOP:fallthrough
		 	case Cobol85Parser.STRING:fallthrough
		 	case Cobol85Parser.SUBTRACT:fallthrough
		 	case Cobol85Parser.TERMINATE:fallthrough
		 	case Cobol85Parser.UNSTRING:fallthrough
		 	case Cobol85Parser.WHEN:fallthrough
		 	case Cobol85Parser.WITH:fallthrough
		 	case Cobol85Parser.WRITE:fallthrough
		 	case Cobol85Parser.DOT_FS:fallthrough
		 	case Cobol85Parser.EXECCICSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLIMSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLLINE:
		 		setState(4299)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,608,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4296)
		 				try statement()

		 		 
		 			}
		 			setState(4301)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,608,_ctx)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InitializeStatementContext:ParserRuleContext {
		open func INITIALIZE() -> TerminalNode? { return getToken(Cobol85Parser.INITIALIZE, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open func initializeReplacingPhrase() -> InitializeReplacingPhraseContext? {
			return getRuleContext(InitializeReplacingPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_initializeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInitializeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInitializeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInitializeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInitializeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func initializeStatement() throws -> InitializeStatementContext {
		var _localctx: InitializeStatementContext = InitializeStatementContext(_ctx, getState())
		try enterRule(_localctx, 690, Cobol85Parser.RULE_initializeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4304)
		 	try match(Cobol85Parser.INITIALIZE)
		 	setState(4306) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4305)
		 		try identifier()


		 		setState(4308); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4311)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REPLACING
		 	      return testSet
		 	 }()) {
		 		setState(4310)
		 		try initializeReplacingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InitializeReplacingPhraseContext:ParserRuleContext {
		open func REPLACING() -> TerminalNode? { return getToken(Cobol85Parser.REPLACING, 0) }
		open func initializeReplacingBy() -> Array<InitializeReplacingByContext> {
			return getRuleContexts(InitializeReplacingByContext.self)
		}
		open func initializeReplacingBy(_ i: Int) -> InitializeReplacingByContext? {
			return getRuleContext(InitializeReplacingByContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_initializeReplacingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInitializeReplacingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInitializeReplacingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInitializeReplacingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInitializeReplacingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func initializeReplacingPhrase() throws -> InitializeReplacingPhraseContext {
		var _localctx: InitializeReplacingPhraseContext = InitializeReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 692, Cobol85Parser.RULE_initializeReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4313)
		 	try match(Cobol85Parser.REPLACING)
		 	setState(4315) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4314)
		 		try initializeReplacingBy()


		 		setState(4317); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ALPHABETIC,Cobol85Parser.ALPHANUMERIC,Cobol85Parser.ALPHANUMERIC_EDITED]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.DBCS || _la == Cobol85Parser.EGCS
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NATIONAL,Cobol85Parser.NUMERIC,Cobol85Parser.NUMERIC_EDITED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 307)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InitializeReplacingByContext:ParserRuleContext {
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func ALPHABETIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABETIC, 0) }
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func NUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC, 0) }
		open func ALPHANUMERIC_EDITED() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC_EDITED, 0) }
		open func NUMERIC_EDITED() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC_EDITED, 0) }
		open func DBCS() -> TerminalNode? { return getToken(Cobol85Parser.DBCS, 0) }
		open func EGCS() -> TerminalNode? { return getToken(Cobol85Parser.EGCS, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func DATA() -> TerminalNode? { return getToken(Cobol85Parser.DATA, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_initializeReplacingBy }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInitializeReplacingBy(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInitializeReplacingBy(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInitializeReplacingBy(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInitializeReplacingBy(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func initializeReplacingBy() throws -> InitializeReplacingByContext {
		var _localctx: InitializeReplacingByContext = InitializeReplacingByContext(_ctx, getState())
		try enterRule(_localctx, 694, Cobol85Parser.RULE_initializeReplacingBy)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4319)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ALPHABETIC,Cobol85Parser.ALPHANUMERIC,Cobol85Parser.ALPHANUMERIC_EDITED]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.DBCS || _la == Cobol85Parser.EGCS
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NATIONAL,Cobol85Parser.NUMERIC,Cobol85Parser.NUMERIC_EDITED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 307)
		 	          }()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4321)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DATA
		 	      return testSet
		 	 }()) {
		 		setState(4320)
		 		try match(Cobol85Parser.DATA)

		 	}

		 	setState(4323)
		 	try match(Cobol85Parser.BY)
		 	setState(4326)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,614, _ctx)) {
		 	case 1:
		 		setState(4324)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4325)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InitiateStatementContext:ParserRuleContext {
		open func INITIATE() -> TerminalNode? { return getToken(Cobol85Parser.INITIATE, 0) }
		open func reportName() -> Array<ReportNameContext> {
			return getRuleContexts(ReportNameContext.self)
		}
		open func reportName(_ i: Int) -> ReportNameContext? {
			return getRuleContext(ReportNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_initiateStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInitiateStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInitiateStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInitiateStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInitiateStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func initiateStatement() throws -> InitiateStatementContext {
		var _localctx: InitiateStatementContext = InitiateStatementContext(_ctx, getState())
		try enterRule(_localctx, 696, Cobol85Parser.RULE_initiateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4328)
		 	try match(Cobol85Parser.INITIATE)
		 	setState(4330) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4329)
		 		try reportName()


		 		setState(4332); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectStatementContext:ParserRuleContext {
		open func INSPECT() -> TerminalNode? { return getToken(Cobol85Parser.INSPECT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func inspectTallyingPhrase() -> InspectTallyingPhraseContext? {
			return getRuleContext(InspectTallyingPhraseContext.self,0)
		}
		open func inspectReplacingPhrase() -> InspectReplacingPhraseContext? {
			return getRuleContext(InspectReplacingPhraseContext.self,0)
		}
		open func inspectTallyingReplacingPhrase() -> InspectTallyingReplacingPhraseContext? {
			return getRuleContext(InspectTallyingReplacingPhraseContext.self,0)
		}
		open func inspectConvertingPhrase() -> InspectConvertingPhraseContext? {
			return getRuleContext(InspectConvertingPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectStatement() throws -> InspectStatementContext {
		var _localctx: InspectStatementContext = InspectStatementContext(_ctx, getState())
		try enterRule(_localctx, 698, Cobol85Parser.RULE_inspectStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4334)
		 	try match(Cobol85Parser.INSPECT)
		 	setState(4335)
		 	try identifier()
		 	setState(4340)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,616, _ctx)) {
		 	case 1:
		 		setState(4336)
		 		try inspectTallyingPhrase()

		 		break
		 	case 2:
		 		setState(4337)
		 		try inspectReplacingPhrase()

		 		break
		 	case 3:
		 		setState(4338)
		 		try inspectTallyingReplacingPhrase()

		 		break
		 	case 4:
		 		setState(4339)
		 		try inspectConvertingPhrase()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectTallyingPhraseContext:ParserRuleContext {
		open func TALLYING() -> TerminalNode? { return getToken(Cobol85Parser.TALLYING, 0) }
		open func inspectFor() -> Array<InspectForContext> {
			return getRuleContexts(InspectForContext.self)
		}
		open func inspectFor(_ i: Int) -> InspectForContext? {
			return getRuleContext(InspectForContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectTallyingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectTallyingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectTallyingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectTallyingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectTallyingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectTallyingPhrase() throws -> InspectTallyingPhraseContext {
		var _localctx: InspectTallyingPhraseContext = InspectTallyingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 700, Cobol85Parser.RULE_inspectTallyingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4342)
		 	try match(Cobol85Parser.TALLYING)
		 	setState(4344) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4343)
		 		try inspectFor()


		 		setState(4346); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectReplacingPhraseContext:ParserRuleContext {
		open func REPLACING() -> TerminalNode? { return getToken(Cobol85Parser.REPLACING, 0) }
		open func inspectReplacingCharacters() -> Array<InspectReplacingCharactersContext> {
			return getRuleContexts(InspectReplacingCharactersContext.self)
		}
		open func inspectReplacingCharacters(_ i: Int) -> InspectReplacingCharactersContext? {
			return getRuleContext(InspectReplacingCharactersContext.self,i)
		}
		open func inspectReplacingAllLeadings() -> Array<InspectReplacingAllLeadingsContext> {
			return getRuleContexts(InspectReplacingAllLeadingsContext.self)
		}
		open func inspectReplacingAllLeadings(_ i: Int) -> InspectReplacingAllLeadingsContext? {
			return getRuleContext(InspectReplacingAllLeadingsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectReplacingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectReplacingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectReplacingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectReplacingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectReplacingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectReplacingPhrase() throws -> InspectReplacingPhraseContext {
		var _localctx: InspectReplacingPhraseContext = InspectReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 702, Cobol85Parser.RULE_inspectReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4348)
		 	try match(Cobol85Parser.REPLACING)
		 	setState(4351) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4351)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.CHARACTERS:
		 			setState(4349)
		 			try inspectReplacingCharacters()

		 			break
		 		case Cobol85Parser.ALL:fallthrough
		 		case Cobol85Parser.FIRST:fallthrough
		 		case Cobol85Parser.LEADING:
		 			setState(4350)
		 			try inspectReplacingAllLeadings()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4353); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ALL || _la == Cobol85Parser.CHARACTERS
		 	          testSet = testSet || _la == Cobol85Parser.FIRST || _la == Cobol85Parser.LEADING
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectTallyingReplacingPhraseContext:ParserRuleContext {
		open func TALLYING() -> TerminalNode? { return getToken(Cobol85Parser.TALLYING, 0) }
		open func inspectFor() -> Array<InspectForContext> {
			return getRuleContexts(InspectForContext.self)
		}
		open func inspectFor(_ i: Int) -> InspectForContext? {
			return getRuleContext(InspectForContext.self,i)
		}
		open func inspectReplacingPhrase() -> Array<InspectReplacingPhraseContext> {
			return getRuleContexts(InspectReplacingPhraseContext.self)
		}
		open func inspectReplacingPhrase(_ i: Int) -> InspectReplacingPhraseContext? {
			return getRuleContext(InspectReplacingPhraseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectTallyingReplacingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectTallyingReplacingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectTallyingReplacingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectTallyingReplacingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectTallyingReplacingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectTallyingReplacingPhrase() throws -> InspectTallyingReplacingPhraseContext {
		var _localctx: InspectTallyingReplacingPhraseContext = InspectTallyingReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 704, Cobol85Parser.RULE_inspectTallyingReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4355)
		 	try match(Cobol85Parser.TALLYING)
		 	setState(4357) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4356)
		 		try inspectFor()


		 		setState(4359); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4362) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4361)
		 		try inspectReplacingPhrase()


		 		setState(4364); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REPLACING
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectConvertingPhraseContext:ParserRuleContext {
		open func CONVERTING() -> TerminalNode? { return getToken(Cobol85Parser.CONVERTING, 0) }
		open func inspectTo() -> InspectToContext? {
			return getRuleContext(InspectToContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func inspectBeforeAfter() -> Array<InspectBeforeAfterContext> {
			return getRuleContexts(InspectBeforeAfterContext.self)
		}
		open func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
			return getRuleContext(InspectBeforeAfterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectConvertingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectConvertingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectConvertingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectConvertingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectConvertingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectConvertingPhrase() throws -> InspectConvertingPhraseContext {
		var _localctx: InspectConvertingPhraseContext = InspectConvertingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 706, Cobol85Parser.RULE_inspectConvertingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4366)
		 	try match(Cobol85Parser.CONVERTING)
		 	setState(4369)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,622, _ctx)) {
		 	case 1:
		 		setState(4367)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4368)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4371)
		 	try inspectTo()
		 	setState(4375)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(4372)
		 		try inspectBeforeAfter()


		 		setState(4377)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectForContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func inspectCharacters() -> Array<InspectCharactersContext> {
			return getRuleContexts(InspectCharactersContext.self)
		}
		open func inspectCharacters(_ i: Int) -> InspectCharactersContext? {
			return getRuleContext(InspectCharactersContext.self,i)
		}
		open func inspectAllLeadings() -> Array<InspectAllLeadingsContext> {
			return getRuleContexts(InspectAllLeadingsContext.self)
		}
		open func inspectAllLeadings(_ i: Int) -> InspectAllLeadingsContext? {
			return getRuleContext(InspectAllLeadingsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectFor }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectFor(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectFor(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectFor(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectFor(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectFor() throws -> InspectForContext {
		var _localctx: InspectForContext = InspectForContext(_ctx, getState())
		try enterRule(_localctx, 708, Cobol85Parser.RULE_inspectFor)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4378)
		 	try identifier()
		 	setState(4379)
		 	try match(Cobol85Parser.FOR)
		 	setState(4382) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4382)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.CHARACTERS:
		 			setState(4380)
		 			try inspectCharacters()

		 			break
		 		case Cobol85Parser.ALL:fallthrough
		 		case Cobol85Parser.LEADING:
		 			setState(4381)
		 			try inspectAllLeadings()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4384); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ALL || _la == Cobol85Parser.CHARACTERS
		 	          testSet = testSet || _la == Cobol85Parser.LEADING
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectCharactersContext:ParserRuleContext {
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open func inspectBeforeAfter() -> Array<InspectBeforeAfterContext> {
			return getRuleContexts(InspectBeforeAfterContext.self)
		}
		open func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
			return getRuleContext(InspectBeforeAfterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectCharacters }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectCharacters(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectCharacters(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectCharacters(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectCharacters(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectCharacters() throws -> InspectCharactersContext {
		var _localctx: InspectCharactersContext = InspectCharactersContext(_ctx, getState())
		try enterRule(_localctx, 710, Cobol85Parser.RULE_inspectCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4386)
		 	try match(Cobol85Parser.CHARACTERS)
		 	setState(4390)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(4387)
		 		try inspectBeforeAfter()


		 		setState(4392)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectReplacingCharactersContext:ParserRuleContext {
		open func CHARACTERS() -> TerminalNode? { return getToken(Cobol85Parser.CHARACTERS, 0) }
		open func inspectBy() -> InspectByContext? {
			return getRuleContext(InspectByContext.self,0)
		}
		open func inspectBeforeAfter() -> Array<InspectBeforeAfterContext> {
			return getRuleContexts(InspectBeforeAfterContext.self)
		}
		open func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
			return getRuleContext(InspectBeforeAfterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectReplacingCharacters }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectReplacingCharacters(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectReplacingCharacters(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectReplacingCharacters(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectReplacingCharacters(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectReplacingCharacters() throws -> InspectReplacingCharactersContext {
		var _localctx: InspectReplacingCharactersContext = InspectReplacingCharactersContext(_ctx, getState())
		try enterRule(_localctx, 712, Cobol85Parser.RULE_inspectReplacingCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4393)
		 	try match(Cobol85Parser.CHARACTERS)
		 	setState(4394)
		 	try inspectBy()
		 	setState(4398)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(4395)
		 		try inspectBeforeAfter()


		 		setState(4400)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectAllLeadingsContext:ParserRuleContext {
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func inspectAllLeading() -> Array<InspectAllLeadingContext> {
			return getRuleContexts(InspectAllLeadingContext.self)
		}
		open func inspectAllLeading(_ i: Int) -> InspectAllLeadingContext? {
			return getRuleContext(InspectAllLeadingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectAllLeadings }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectAllLeadings(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectAllLeadings(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectAllLeadings(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectAllLeadings(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectAllLeadings() throws -> InspectAllLeadingsContext {
		var _localctx: InspectAllLeadingsContext = InspectAllLeadingsContext(_ctx, getState())
		try enterRule(_localctx, 714, Cobol85Parser.RULE_inspectAllLeadings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4401)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ALL
		 	          testSet = testSet || _la == Cobol85Parser.LEADING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4403); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4402)
		 			try inspectAllLeading()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4405); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,628,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectReplacingAllLeadingsContext:ParserRuleContext {
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func LEADING() -> TerminalNode? { return getToken(Cobol85Parser.LEADING, 0) }
		open func FIRST() -> TerminalNode? { return getToken(Cobol85Parser.FIRST, 0) }
		open func inspectReplacingAllLeading() -> Array<InspectReplacingAllLeadingContext> {
			return getRuleContexts(InspectReplacingAllLeadingContext.self)
		}
		open func inspectReplacingAllLeading(_ i: Int) -> InspectReplacingAllLeadingContext? {
			return getRuleContext(InspectReplacingAllLeadingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectReplacingAllLeadings }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectReplacingAllLeadings(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectReplacingAllLeadings(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectReplacingAllLeadings(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectReplacingAllLeadings(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectReplacingAllLeadings() throws -> InspectReplacingAllLeadingsContext {
		var _localctx: InspectReplacingAllLeadingsContext = InspectReplacingAllLeadingsContext(_ctx, getState())
		try enterRule(_localctx, 716, Cobol85Parser.RULE_inspectReplacingAllLeadings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4407)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ALL
		 	          testSet = testSet || _la == Cobol85Parser.FIRST || _la == Cobol85Parser.LEADING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4409); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4408)
		 			try inspectReplacingAllLeading()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4411); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,629,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectAllLeadingContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func inspectBeforeAfter() -> Array<InspectBeforeAfterContext> {
			return getRuleContexts(InspectBeforeAfterContext.self)
		}
		open func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
			return getRuleContext(InspectBeforeAfterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectAllLeading }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectAllLeading(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectAllLeading(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectAllLeading(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectAllLeading(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectAllLeading() throws -> InspectAllLeadingContext {
		var _localctx: InspectAllLeadingContext = InspectAllLeadingContext(_ctx, getState())
		try enterRule(_localctx, 718, Cobol85Parser.RULE_inspectAllLeading)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4415)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,630, _ctx)) {
		 	case 1:
		 		setState(4413)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4414)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4420)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(4417)
		 		try inspectBeforeAfter()


		 		setState(4422)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectReplacingAllLeadingContext:ParserRuleContext {
		open func inspectBy() -> InspectByContext? {
			return getRuleContext(InspectByContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func inspectBeforeAfter() -> Array<InspectBeforeAfterContext> {
			return getRuleContexts(InspectBeforeAfterContext.self)
		}
		open func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
			return getRuleContext(InspectBeforeAfterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectReplacingAllLeading }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectReplacingAllLeading(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectReplacingAllLeading(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectReplacingAllLeading(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectReplacingAllLeading(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectReplacingAllLeading() throws -> InspectReplacingAllLeadingContext {
		var _localctx: InspectReplacingAllLeadingContext = InspectReplacingAllLeadingContext(_ctx, getState())
		try enterRule(_localctx, 720, Cobol85Parser.RULE_inspectReplacingAllLeading)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4425)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,632, _ctx)) {
		 	case 1:
		 		setState(4423)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4424)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4427)
		 	try inspectBy()
		 	setState(4431)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(4428)
		 		try inspectBeforeAfter()


		 		setState(4433)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectByContext:ParserRuleContext {
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectBy }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectBy(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectBy(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectBy(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectBy(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectBy() throws -> InspectByContext {
		var _localctx: InspectByContext = InspectByContext(_ctx, getState())
		try enterRule(_localctx, 722, Cobol85Parser.RULE_inspectBy)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4434)
		 	try match(Cobol85Parser.BY)
		 	setState(4437)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,634, _ctx)) {
		 	case 1:
		 		setState(4435)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4436)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectToContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectTo() throws -> InspectToContext {
		var _localctx: InspectToContext = InspectToContext(_ctx, getState())
		try enterRule(_localctx, 724, Cobol85Parser.RULE_inspectTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4439)
		 	try match(Cobol85Parser.TO)
		 	setState(4442)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,635, _ctx)) {
		 	case 1:
		 		setState(4440)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4441)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InspectBeforeAfterContext:ParserRuleContext {
		open func BEFORE() -> TerminalNode? { return getToken(Cobol85Parser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(Cobol85Parser.AFTER, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func INITIAL() -> TerminalNode? { return getToken(Cobol85Parser.INITIAL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inspectBeforeAfter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInspectBeforeAfter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInspectBeforeAfter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInspectBeforeAfter(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInspectBeforeAfter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inspectBeforeAfter() throws -> InspectBeforeAfterContext {
		var _localctx: InspectBeforeAfterContext = InspectBeforeAfterContext(_ctx, getState())
		try enterRule(_localctx, 726, Cobol85Parser.RULE_inspectBeforeAfter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4444)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4446)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INITIAL
		 	      return testSet
		 	 }()) {
		 		setState(4445)
		 		try match(Cobol85Parser.INITIAL)

		 	}

		 	setState(4450)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,637, _ctx)) {
		 	case 1:
		 		setState(4448)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4449)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeStatementContext:ParserRuleContext {
		open func MERGE() -> TerminalNode? { return getToken(Cobol85Parser.MERGE, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func mergeOnKeyClause() -> Array<MergeOnKeyClauseContext> {
			return getRuleContexts(MergeOnKeyClauseContext.self)
		}
		open func mergeOnKeyClause(_ i: Int) -> MergeOnKeyClauseContext? {
			return getRuleContext(MergeOnKeyClauseContext.self,i)
		}
		open func mergeCollatingSequencePhrase() -> MergeCollatingSequencePhraseContext? {
			return getRuleContext(MergeCollatingSequencePhraseContext.self,0)
		}
		open func mergeUsing() -> Array<MergeUsingContext> {
			return getRuleContexts(MergeUsingContext.self)
		}
		open func mergeUsing(_ i: Int) -> MergeUsingContext? {
			return getRuleContext(MergeUsingContext.self,i)
		}
		open func mergeOutputProcedurePhrase() -> MergeOutputProcedurePhraseContext? {
			return getRuleContext(MergeOutputProcedurePhraseContext.self,0)
		}
		open func mergeGivingPhrase() -> Array<MergeGivingPhraseContext> {
			return getRuleContexts(MergeGivingPhraseContext.self)
		}
		open func mergeGivingPhrase(_ i: Int) -> MergeGivingPhraseContext? {
			return getRuleContext(MergeGivingPhraseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeStatement() throws -> MergeStatementContext {
		var _localctx: MergeStatementContext = MergeStatementContext(_ctx, getState())
		try enterRule(_localctx, 728, Cobol85Parser.RULE_mergeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4452)
		 	try match(Cobol85Parser.MERGE)
		 	setState(4453)
		 	try fileName()
		 	setState(4455); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4454)
		 			try mergeOnKeyClause()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4457); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,638,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4460)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COLLATING
		 	          testSet = testSet || _la == Cobol85Parser.SEQUENCE
		 	      return testSet
		 	 }()) {
		 		setState(4459)
		 		try mergeCollatingSequencePhrase()

		 	}

		 	setState(4465)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(4462)
		 		try mergeUsing()


		 		setState(4467)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4469)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OUTPUT
		 	      return testSet
		 	 }()) {
		 		setState(4468)
		 		try mergeOutputProcedurePhrase()

		 	}

		 	setState(4474)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(4471)
		 		try mergeGivingPhrase()


		 		setState(4476)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeOnKeyClauseContext:ParserRuleContext {
		open func ASCENDING() -> TerminalNode? { return getToken(Cobol85Parser.ASCENDING, 0) }
		open func DESCENDING() -> TerminalNode? { return getToken(Cobol85Parser.DESCENDING, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func qualifiedDataName() -> Array<QualifiedDataNameContext> {
			return getRuleContexts(QualifiedDataNameContext.self)
		}
		open func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeOnKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeOnKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeOnKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeOnKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeOnKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeOnKeyClause() throws -> MergeOnKeyClauseContext {
		var _localctx: MergeOnKeyClauseContext = MergeOnKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 730, Cobol85Parser.RULE_mergeOnKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4478)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(4477)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(4480)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ASCENDING
		 	          testSet = testSet || _la == Cobol85Parser.DESCENDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4482)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(4481)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(4485) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4484)
		 		try qualifiedDataName()


		 		setState(4487); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeCollatingSequencePhraseContext:ParserRuleContext {
		open func SEQUENCE() -> TerminalNode? { return getToken(Cobol85Parser.SEQUENCE, 0) }
		open func COLLATING() -> TerminalNode? { return getToken(Cobol85Parser.COLLATING, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetName() -> Array<AlphabetNameContext> {
			return getRuleContexts(AlphabetNameContext.self)
		}
		open func alphabetName(_ i: Int) -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,i)
		}
		open func mergeCollatingAlphanumeric() -> MergeCollatingAlphanumericContext? {
			return getRuleContext(MergeCollatingAlphanumericContext.self,0)
		}
		open func mergeCollatingNational() -> MergeCollatingNationalContext? {
			return getRuleContext(MergeCollatingNationalContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeCollatingSequencePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeCollatingSequencePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeCollatingSequencePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeCollatingSequencePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeCollatingSequencePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeCollatingSequencePhrase() throws -> MergeCollatingSequencePhraseContext {
		var _localctx: MergeCollatingSequencePhraseContext = MergeCollatingSequencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 732, Cobol85Parser.RULE_mergeCollatingSequencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4490)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COLLATING
		 	      return testSet
		 	 }()) {
		 		setState(4489)
		 		try match(Cobol85Parser.COLLATING)

		 	}

		 	setState(4492)
		 	try match(Cobol85Parser.SEQUENCE)
		 	setState(4494)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(4493)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(4497); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4496)
		 			try alphabetName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4499); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,648,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4502)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,649,_ctx)) {
		 	case 1:
		 		setState(4501)
		 		try mergeCollatingAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(4505)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FOR
		 	          testSet = testSet || _la == Cobol85Parser.NATIONAL
		 	      return testSet
		 	 }()) {
		 		setState(4504)
		 		try mergeCollatingNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeCollatingAlphanumericContext:ParserRuleContext {
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeCollatingAlphanumeric }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeCollatingAlphanumeric(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeCollatingAlphanumeric(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeCollatingAlphanumeric(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeCollatingAlphanumeric(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeCollatingAlphanumeric() throws -> MergeCollatingAlphanumericContext {
		var _localctx: MergeCollatingAlphanumericContext = MergeCollatingAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 734, Cobol85Parser.RULE_mergeCollatingAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4508)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(4507)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(4510)
		 	try match(Cobol85Parser.ALPHANUMERIC)
		 	setState(4511)
		 	try match(Cobol85Parser.IS)
		 	setState(4512)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeCollatingNationalContext:ParserRuleContext {
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeCollatingNational }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeCollatingNational(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeCollatingNational(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeCollatingNational(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeCollatingNational(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeCollatingNational() throws -> MergeCollatingNationalContext {
		var _localctx: MergeCollatingNationalContext = MergeCollatingNationalContext(_ctx, getState())
		try enterRule(_localctx, 736, Cobol85Parser.RULE_mergeCollatingNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4515)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(4514)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(4517)
		 	try match(Cobol85Parser.NATIONAL)
		 	setState(4519)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(4518)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(4521)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeUsingContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeUsing }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeUsing(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeUsing(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeUsing(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeUsing(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeUsing() throws -> MergeUsingContext {
		var _localctx: MergeUsingContext = MergeUsingContext(_ctx, getState())
		try enterRule(_localctx, 738, Cobol85Parser.RULE_mergeUsing)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4523)
		 	try match(Cobol85Parser.USING)
		 	setState(4525) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4524)
		 		try fileName()


		 		setState(4527); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeOutputProcedurePhraseContext:ParserRuleContext {
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE, 0) }
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func mergeOutputThrough() -> MergeOutputThroughContext? {
			return getRuleContext(MergeOutputThroughContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeOutputProcedurePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeOutputProcedurePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeOutputProcedurePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeOutputProcedurePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeOutputProcedurePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeOutputProcedurePhrase() throws -> MergeOutputProcedurePhraseContext {
		var _localctx: MergeOutputProcedurePhraseContext = MergeOutputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 740, Cobol85Parser.RULE_mergeOutputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4529)
		 	try match(Cobol85Parser.OUTPUT)
		 	setState(4530)
		 	try match(Cobol85Parser.PROCEDURE)
		 	setState(4532)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(4531)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(4534)
		 	try procedureName()
		 	setState(4536)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(4535)
		 		try mergeOutputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeOutputThroughContext:ParserRuleContext {
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeOutputThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeOutputThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeOutputThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeOutputThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeOutputThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeOutputThrough() throws -> MergeOutputThroughContext {
		var _localctx: MergeOutputThroughContext = MergeOutputThroughContext(_ctx, getState())
		try enterRule(_localctx, 742, Cobol85Parser.RULE_mergeOutputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4538)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4539)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeGivingPhraseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func mergeGiving() -> Array<MergeGivingContext> {
			return getRuleContexts(MergeGivingContext.self)
		}
		open func mergeGiving(_ i: Int) -> MergeGivingContext? {
			return getRuleContext(MergeGivingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeGivingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeGivingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeGivingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeGivingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeGivingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeGivingPhrase() throws -> MergeGivingPhraseContext {
		var _localctx: MergeGivingPhraseContext = MergeGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 744, Cobol85Parser.RULE_mergeGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4541)
		 	try match(Cobol85Parser.GIVING)
		 	setState(4543) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4542)
		 		try mergeGiving()


		 		setState(4545); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MergeGivingContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func SAVE() -> TerminalNode? { return getToken(Cobol85Parser.SAVE, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func CRUNCH() -> TerminalNode? { return getToken(Cobol85Parser.CRUNCH, 0) }
		open func RELEASE() -> TerminalNode? { return getToken(Cobol85Parser.RELEASE, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func REMOVE() -> TerminalNode? { return getToken(Cobol85Parser.REMOVE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mergeGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMergeGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMergeGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMergeGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMergeGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mergeGiving() throws -> MergeGivingContext {
		var _localctx: MergeGivingContext = MergeGivingContext(_ctx, getState())
		try enterRule(_localctx, 746, Cobol85Parser.RULE_mergeGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4547)
		 	try fileName()
		 	setState(4557)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,658,_ctx)) {
		 	case 1:
		 		setState(4548)
		 		try match(Cobol85Parser.LOCK)

		 		break
		 	case 2:
		 		setState(4549)
		 		try match(Cobol85Parser.SAVE)

		 		break
		 	case 3:
		 		setState(4550)
		 		try match(Cobol85Parser.NO)
		 		setState(4551)
		 		try match(Cobol85Parser.REWIND)

		 		break
		 	case 4:
		 		setState(4552)
		 		try match(Cobol85Parser.CRUNCH)

		 		break
		 	case 5:
		 		setState(4553)
		 		try match(Cobol85Parser.RELEASE)

		 		break
		 	case 6:
		 		setState(4554)
		 		try match(Cobol85Parser.WITH)
		 		setState(4555)
		 		try match(Cobol85Parser.REMOVE)
		 		setState(4556)
		 		try match(Cobol85Parser.CRUNCH)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MoveStatementContext:ParserRuleContext {
		open func MOVE() -> TerminalNode? { return getToken(Cobol85Parser.MOVE, 0) }
		open func moveToStatement() -> MoveToStatementContext? {
			return getRuleContext(MoveToStatementContext.self,0)
		}
		open func moveCorrespondingToStatement() -> MoveCorrespondingToStatementContext? {
			return getRuleContext(MoveCorrespondingToStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_moveStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMoveStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMoveStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMoveStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMoveStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func moveStatement() throws -> MoveStatementContext {
		var _localctx: MoveStatementContext = MoveStatementContext(_ctx, getState())
		try enterRule(_localctx, 748, Cobol85Parser.RULE_moveStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4559)
		 	try match(Cobol85Parser.MOVE)
		 	setState(4562)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.ADDRESS:fallthrough
		 	case Cobol85Parser.ALL:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DATE:fallthrough
		 	case Cobol85Parser.DAY:fallthrough
		 	case Cobol85Parser.DAY_OF_WEEK:fallthrough
		 	case Cobol85Parser.DEBUG_CONTENTS:fallthrough
		 	case Cobol85Parser.DEBUG_ITEM:fallthrough
		 	case Cobol85Parser.DEBUG_LINE:fallthrough
		 	case Cobol85Parser.DEBUG_NAME:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_1:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_2:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_3:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FALSE:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTION:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.HIGH_VALUE:fallthrough
		 	case Cobol85Parser.HIGH_VALUES:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LINAGE_COUNTER:fallthrough
		 	case Cobol85Parser.LINE_COUNTER:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.LOW_VALUE:fallthrough
		 	case Cobol85Parser.LOW_VALUES:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NULL:fallthrough
		 	case Cobol85Parser.NULLS:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PAGE_COUNTER:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.QUOTE:fallthrough
		 	case Cobol85Parser.QUOTES:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.RETURN_CODE:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHIFT_IN:fallthrough
		 	case Cobol85Parser.SHIFT_OUT:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SORT_CONTROL:fallthrough
		 	case Cobol85Parser.SORT_CORE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_FILE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_MESSAGE:fallthrough
		 	case Cobol85Parser.SORT_MODE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_RETURN:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SPACE:fallthrough
		 	case Cobol85Parser.SPACES:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TALLY:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIME:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUE:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.WHEN_COMPILED:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.ZEROS:fallthrough
		 	case Cobol85Parser.ZEROES:fallthrough
		 	case Cobol85Parser.NONNUMERICLITERAL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.NUMERICLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(4560)
		 		try moveToStatement()

		 		break
		 	case Cobol85Parser.CORR:fallthrough
		 	case Cobol85Parser.CORRESPONDING:
		 		setState(4561)
		 		try moveCorrespondingToStatement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MoveToStatementContext:ParserRuleContext {
		open func moveToSendingArea() -> MoveToSendingAreaContext? {
			return getRuleContext(MoveToSendingAreaContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_moveToStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMoveToStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMoveToStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMoveToStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMoveToStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func moveToStatement() throws -> MoveToStatementContext {
		var _localctx: MoveToStatementContext = MoveToStatementContext(_ctx, getState())
		try enterRule(_localctx, 750, Cobol85Parser.RULE_moveToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4564)
		 	try moveToSendingArea()
		 	setState(4565)
		 	try match(Cobol85Parser.TO)
		 	setState(4567) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4566)
		 		try identifier()


		 		setState(4569); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MoveToSendingAreaContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_moveToSendingArea }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMoveToSendingArea(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMoveToSendingArea(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMoveToSendingArea(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMoveToSendingArea(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func moveToSendingArea() throws -> MoveToSendingAreaContext {
		var _localctx: MoveToSendingAreaContext = MoveToSendingAreaContext(_ctx, getState())
		try enterRule(_localctx, 752, Cobol85Parser.RULE_moveToSendingArea)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4573)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,661, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4571)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4572)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MoveCorrespondingToStatementContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func CORRESPONDING() -> TerminalNode? { return getToken(Cobol85Parser.CORRESPONDING, 0) }
		open func CORR() -> TerminalNode? { return getToken(Cobol85Parser.CORR, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_moveCorrespondingToStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMoveCorrespondingToStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMoveCorrespondingToStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMoveCorrespondingToStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMoveCorrespondingToStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func moveCorrespondingToStatement() throws -> MoveCorrespondingToStatementContext {
		var _localctx: MoveCorrespondingToStatementContext = MoveCorrespondingToStatementContext(_ctx, getState())
		try enterRule(_localctx, 754, Cobol85Parser.RULE_moveCorrespondingToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4575)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CORR || _la == Cobol85Parser.CORRESPONDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4576)
		 	try qualifiedDataName()
		 	setState(4577)
		 	try match(Cobol85Parser.TO)
		 	setState(4579) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4578)
		 		try identifier()


		 		setState(4581); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyStatementContext:ParserRuleContext {
		open func MULTIPLY() -> TerminalNode? { return getToken(Cobol85Parser.MULTIPLY, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func multiplyRegular() -> MultiplyRegularContext? {
			return getRuleContext(MultiplyRegularContext.self,0)
		}
		open func multiplyGiving() -> MultiplyGivingContext? {
			return getRuleContext(MultiplyGivingContext.self,0)
		}
		open func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
			return getRuleContext(OnSizeErrorPhraseContext.self,0)
		}
		open func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
			return getRuleContext(NotOnSizeErrorPhraseContext.self,0)
		}
		open func END_MULTIPLY() -> TerminalNode? { return getToken(Cobol85Parser.END_MULTIPLY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyStatement() throws -> MultiplyStatementContext {
		var _localctx: MultiplyStatementContext = MultiplyStatementContext(_ctx, getState())
		try enterRule(_localctx, 756, Cobol85Parser.RULE_multiplyStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4583)
		 	try match(Cobol85Parser.MULTIPLY)
		 	setState(4586)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,663, _ctx)) {
		 	case 1:
		 		setState(4584)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4585)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4588)
		 	try match(Cobol85Parser.BY)
		 	setState(4591)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,664, _ctx)) {
		 	case 1:
		 		setState(4589)
		 		try multiplyRegular()

		 		break
		 	case 2:
		 		setState(4590)
		 		try multiplyGiving()

		 		break
		 	default: break
		 	}
		 	setState(4594)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,665,_ctx)) {
		 	case 1:
		 		setState(4593)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4597)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,666,_ctx)) {
		 	case 1:
		 		setState(4596)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4600)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,667,_ctx)) {
		 	case 1:
		 		setState(4599)
		 		try match(Cobol85Parser.END_MULTIPLY)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyRegularContext:ParserRuleContext {
		open func multiplyRegularOperand() -> Array<MultiplyRegularOperandContext> {
			return getRuleContexts(MultiplyRegularOperandContext.self)
		}
		open func multiplyRegularOperand(_ i: Int) -> MultiplyRegularOperandContext? {
			return getRuleContext(MultiplyRegularOperandContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyRegular }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyRegular(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyRegular(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyRegular(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyRegular(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyRegular() throws -> MultiplyRegularContext {
		var _localctx: MultiplyRegularContext = MultiplyRegularContext(_ctx, getState())
		try enterRule(_localctx, 758, Cobol85Parser.RULE_multiplyRegular)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4603) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4602)
		 		try multiplyRegularOperand()


		 		setState(4605); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyRegularOperandContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyRegularOperand }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyRegularOperand(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyRegularOperand(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyRegularOperand(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyRegularOperand(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyRegularOperand() throws -> MultiplyRegularOperandContext {
		var _localctx: MultiplyRegularOperandContext = MultiplyRegularOperandContext(_ctx, getState())
		try enterRule(_localctx, 760, Cobol85Parser.RULE_multiplyRegularOperand)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4607)
		 	try identifier()
		 	setState(4609)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(4608)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyGivingContext:ParserRuleContext {
		open func multiplyGivingOperand() -> MultiplyGivingOperandContext? {
			return getRuleContext(MultiplyGivingOperandContext.self,0)
		}
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func multiplyGivingResult() -> Array<MultiplyGivingResultContext> {
			return getRuleContexts(MultiplyGivingResultContext.self)
		}
		open func multiplyGivingResult(_ i: Int) -> MultiplyGivingResultContext? {
			return getRuleContext(MultiplyGivingResultContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyGiving() throws -> MultiplyGivingContext {
		var _localctx: MultiplyGivingContext = MultiplyGivingContext(_ctx, getState())
		try enterRule(_localctx, 762, Cobol85Parser.RULE_multiplyGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4611)
		 	try multiplyGivingOperand()
		 	setState(4612)
		 	try match(Cobol85Parser.GIVING)
		 	setState(4614) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4613)
		 		try multiplyGivingResult()


		 		setState(4616); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyGivingOperandContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyGivingOperand }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyGivingOperand(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyGivingOperand(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyGivingOperand(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyGivingOperand(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyGivingOperand() throws -> MultiplyGivingOperandContext {
		var _localctx: MultiplyGivingOperandContext = MultiplyGivingOperandContext(_ctx, getState())
		try enterRule(_localctx, 764, Cobol85Parser.RULE_multiplyGivingOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4620)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,671, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4618)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4619)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultiplyGivingResultContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multiplyGivingResult }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultiplyGivingResult(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultiplyGivingResult(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultiplyGivingResult(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultiplyGivingResult(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiplyGivingResult() throws -> MultiplyGivingResultContext {
		var _localctx: MultiplyGivingResultContext = MultiplyGivingResultContext(_ctx, getState())
		try enterRule(_localctx, 766, Cobol85Parser.RULE_multiplyGivingResult)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4622)
		 	try identifier()
		 	setState(4624)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(4623)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenStatementContext:ParserRuleContext {
		open func OPEN() -> TerminalNode? { return getToken(Cobol85Parser.OPEN, 0) }
		open func openInputStatement() -> Array<OpenInputStatementContext> {
			return getRuleContexts(OpenInputStatementContext.self)
		}
		open func openInputStatement(_ i: Int) -> OpenInputStatementContext? {
			return getRuleContext(OpenInputStatementContext.self,i)
		}
		open func openOutputStatement() -> Array<OpenOutputStatementContext> {
			return getRuleContexts(OpenOutputStatementContext.self)
		}
		open func openOutputStatement(_ i: Int) -> OpenOutputStatementContext? {
			return getRuleContext(OpenOutputStatementContext.self,i)
		}
		open func openIOStatement() -> Array<OpenIOStatementContext> {
			return getRuleContexts(OpenIOStatementContext.self)
		}
		open func openIOStatement(_ i: Int) -> OpenIOStatementContext? {
			return getRuleContext(OpenIOStatementContext.self,i)
		}
		open func openExtendStatement() -> Array<OpenExtendStatementContext> {
			return getRuleContexts(OpenExtendStatementContext.self)
		}
		open func openExtendStatement(_ i: Int) -> OpenExtendStatementContext? {
			return getRuleContext(OpenExtendStatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openStatement() throws -> OpenStatementContext {
		var _localctx: OpenStatementContext = OpenStatementContext(_ctx, getState())
		try enterRule(_localctx, 768, Cobol85Parser.RULE_openStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4626)
		 	try match(Cobol85Parser.OPEN)
		 	setState(4631) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4631)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.INPUT:
		 			setState(4627)
		 			try openInputStatement()

		 			break

		 		case Cobol85Parser.OUTPUT:
		 			setState(4628)
		 			try openOutputStatement()

		 			break

		 		case Cobol85Parser.I_O:
		 			setState(4629)
		 			try openIOStatement()

		 			break

		 		case Cobol85Parser.EXTEND:
		 			setState(4630)
		 			try openExtendStatement()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4633); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.EXTEND,Cobol85Parser.I_O,Cobol85Parser.INPUT]
		 	    return  Utils.testBitLeftShiftArray(testArray, 204)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.OUTPUT
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenInputStatementContext:ParserRuleContext {
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func openInput() -> Array<OpenInputContext> {
			return getRuleContexts(OpenInputContext.self)
		}
		open func openInput(_ i: Int) -> OpenInputContext? {
			return getRuleContext(OpenInputContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openInputStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenInputStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenInputStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenInputStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenInputStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openInputStatement() throws -> OpenInputStatementContext {
		var _localctx: OpenInputStatementContext = OpenInputStatementContext(_ctx, getState())
		try enterRule(_localctx, 770, Cobol85Parser.RULE_openInputStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4635)
		 	try match(Cobol85Parser.INPUT)
		 	setState(4637) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4636)
		 		try openInput()


		 		setState(4639); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenInputContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func REVERSED() -> TerminalNode? { return getToken(Cobol85Parser.REVERSED, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openInput }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenInput(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenInput(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenInput(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenInput(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openInput() throws -> OpenInputContext {
		var _localctx: OpenInputContext = OpenInputContext(_ctx, getState())
		try enterRule(_localctx, 772, Cobol85Parser.RULE_openInput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4641)
		 	try fileName()
		 	setState(4648)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,677,_ctx)) {
		 	case 1:
		 		setState(4642)
		 		try match(Cobol85Parser.REVERSED)

		 		break
		 	case 2:
		 		setState(4644)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(4643)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(4646)
		 		try match(Cobol85Parser.NO)
		 		setState(4647)
		 		try match(Cobol85Parser.REWIND)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenOutputStatementContext:ParserRuleContext {
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func openOutput() -> Array<OpenOutputContext> {
			return getRuleContexts(OpenOutputContext.self)
		}
		open func openOutput(_ i: Int) -> OpenOutputContext? {
			return getRuleContext(OpenOutputContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openOutputStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenOutputStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenOutputStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenOutputStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenOutputStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openOutputStatement() throws -> OpenOutputStatementContext {
		var _localctx: OpenOutputStatementContext = OpenOutputStatementContext(_ctx, getState())
		try enterRule(_localctx, 774, Cobol85Parser.RULE_openOutputStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4650)
		 	try match(Cobol85Parser.OUTPUT)
		 	setState(4652) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4651)
		 		try openOutput()


		 		setState(4654); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenOutputContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openOutput }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenOutput(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenOutput(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenOutput(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenOutput(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openOutput() throws -> OpenOutputContext {
		var _localctx: OpenOutputContext = OpenOutputContext(_ctx, getState())
		try enterRule(_localctx, 776, Cobol85Parser.RULE_openOutput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4656)
		 	try fileName()
		 	setState(4662)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,680,_ctx)) {
		 	case 1:
		 		setState(4658)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(4657)
		 			try match(Cobol85Parser.WITH)

		 		}

		 		setState(4660)
		 		try match(Cobol85Parser.NO)
		 		setState(4661)
		 		try match(Cobol85Parser.REWIND)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenIOStatementContext:ParserRuleContext {
		open func I_O() -> TerminalNode? { return getToken(Cobol85Parser.I_O, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openIOStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenIOStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenIOStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenIOStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenIOStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openIOStatement() throws -> OpenIOStatementContext {
		var _localctx: OpenIOStatementContext = OpenIOStatementContext(_ctx, getState())
		try enterRule(_localctx, 778, Cobol85Parser.RULE_openIOStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4664)
		 	try match(Cobol85Parser.I_O)
		 	setState(4666) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4665)
		 		try fileName()


		 		setState(4668); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenExtendStatementContext:ParserRuleContext {
		open func EXTEND() -> TerminalNode? { return getToken(Cobol85Parser.EXTEND, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_openExtendStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOpenExtendStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOpenExtendStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOpenExtendStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOpenExtendStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openExtendStatement() throws -> OpenExtendStatementContext {
		var _localctx: OpenExtendStatementContext = OpenExtendStatementContext(_ctx, getState())
		try enterRule(_localctx, 780, Cobol85Parser.RULE_openExtendStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4670)
		 	try match(Cobol85Parser.EXTEND)
		 	setState(4672) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4671)
		 		try fileName()


		 		setState(4674); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformStatementContext:ParserRuleContext {
		open func PERFORM() -> TerminalNode? { return getToken(Cobol85Parser.PERFORM, 0) }
		open func performInlineStatement() -> PerformInlineStatementContext? {
			return getRuleContext(PerformInlineStatementContext.self,0)
		}
		open func performProcedureStatement() -> PerformProcedureStatementContext? {
			return getRuleContext(PerformProcedureStatementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performStatement() throws -> PerformStatementContext {
		var _localctx: PerformStatementContext = PerformStatementContext(_ctx, getState())
		try enterRule(_localctx, 782, Cobol85Parser.RULE_performStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4676)
		 	try match(Cobol85Parser.PERFORM)
		 	setState(4679)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,683, _ctx)) {
		 	case 1:
		 		setState(4677)
		 		try performInlineStatement()

		 		break
		 	case 2:
		 		setState(4678)
		 		try performProcedureStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformInlineStatementContext:ParserRuleContext {
		open func END_PERFORM() -> TerminalNode? { return getToken(Cobol85Parser.END_PERFORM, 0) }
		open func performType() -> PerformTypeContext? {
			return getRuleContext(PerformTypeContext.self,0)
		}
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performInlineStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformInlineStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformInlineStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformInlineStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformInlineStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performInlineStatement() throws -> PerformInlineStatementContext {
		var _localctx: PerformInlineStatementContext = PerformInlineStatementContext(_ctx, getState())
		try enterRule(_localctx, 784, Cobol85Parser.RULE_performInlineStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4682)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.TEST,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.UNTIL,Cobol85Parser.VARYING,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.WITH,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4681)
		 		try performType()

		 	}

		 	setState(4685) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4684)
		 		try statement()


		 		setState(4687); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ACCEPT,Cobol85Parser.ADD,Cobol85Parser.ALTER,Cobol85Parser.CALL,Cobol85Parser.CANCEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE,Cobol85Parser.COMPUTE,Cobol85Parser.CONTINUE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 69)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DELETE,Cobol85Parser.DISABLE,Cobol85Parser.DISPLAY,Cobol85Parser.DIVIDE,Cobol85Parser.ENABLE,Cobol85Parser.ENTRY,Cobol85Parser.EVALUATE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 134)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXHIBIT,Cobol85Parser.EXIT,Cobol85Parser.GENERATE,Cobol85Parser.GOBACK,Cobol85Parser.GO,Cobol85Parser.IF,Cobol85Parser.INITIALIZE,Cobol85Parser.INITIATE,Cobol85Parser.INSPECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 201)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.MERGE,Cobol85Parser.MOVE,Cobol85Parser.MULTIPLY,Cobol85Parser.OPEN,Cobol85Parser.PERFORM]
		 	              return  Utils.testBitLeftShiftArray(testArray, 297)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.PURGE,Cobol85Parser.READ,Cobol85Parser.RECEIVE,Cobol85Parser.RELEASE,Cobol85Parser.RETURN,Cobol85Parser.REWRITE,Cobol85Parser.SEARCH,Cobol85Parser.SEND,Cobol85Parser.SET]
		 	              return  Utils.testBitLeftShiftArray(testArray, 370)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SORT,Cobol85Parser.START,Cobol85Parser.STOP,Cobol85Parser.STRING,Cobol85Parser.SUBTRACT,Cobol85Parser.TERMINATE,Cobol85Parser.UNSTRING]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.WRITE,Cobol85Parser.EXECCICSLINE,Cobol85Parser.EXECSQLIMSLINE,Cobol85Parser.EXECSQLLINE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 521)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4689)
		 	try match(Cobol85Parser.END_PERFORM)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformProcedureStatementContext:ParserRuleContext {
		open func procedureName() -> Array<ProcedureNameContext> {
			return getRuleContexts(ProcedureNameContext.self)
		}
		open func procedureName(_ i: Int) -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,i)
		}
		open func performType() -> PerformTypeContext? {
			return getRuleContext(PerformTypeContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performProcedureStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformProcedureStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformProcedureStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformProcedureStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformProcedureStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performProcedureStatement() throws -> PerformProcedureStatementContext {
		var _localctx: PerformProcedureStatementContext = PerformProcedureStatementContext(_ctx, getState())
		try enterRule(_localctx, 786, Cobol85Parser.RULE_performProcedureStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4691)
		 	try procedureName()
		 	setState(4694)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(4692)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4693)
		 		try procedureName()

		 	}

		 	setState(4697)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,687,_ctx)) {
		 	case 1:
		 		setState(4696)
		 		try performType()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformTypeContext:ParserRuleContext {
		open func performTimes() -> PerformTimesContext? {
			return getRuleContext(PerformTimesContext.self,0)
		}
		open func performUntil() -> PerformUntilContext? {
			return getRuleContext(PerformUntilContext.self,0)
		}
		open func performVarying() -> PerformVaryingContext? {
			return getRuleContext(PerformVaryingContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performType }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformType(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformType(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformType(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformType(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performType() throws -> PerformTypeContext {
		var _localctx: PerformTypeContext = PerformTypeContext(_ctx, getState())
		try enterRule(_localctx, 788, Cobol85Parser.RULE_performType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4702)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,688, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4699)
		 		try performTimes()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4700)
		 		try performUntil()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4701)
		 		try performVarying()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformTimesContext:ParserRuleContext {
		open func TIMES() -> TerminalNode? { return getToken(Cobol85Parser.TIMES, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performTimes }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformTimes(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformTimes(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformTimes(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformTimes(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performTimes() throws -> PerformTimesContext {
		var _localctx: PerformTimesContext = PerformTimesContext(_ctx, getState())
		try enterRule(_localctx, 790, Cobol85Parser.RULE_performTimes)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4706)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,689, _ctx)) {
		 	case 1:
		 		setState(4704)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4705)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}
		 	setState(4708)
		 	try match(Cobol85Parser.TIMES)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformUntilContext:ParserRuleContext {
		open func UNTIL() -> TerminalNode? { return getToken(Cobol85Parser.UNTIL, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func performTestClause() -> PerformTestClauseContext? {
			return getRuleContext(PerformTestClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performUntil }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformUntil(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformUntil(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformUntil(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformUntil(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performUntil() throws -> PerformUntilContext {
		var _localctx: PerformUntilContext = PerformUntilContext(_ctx, getState())
		try enterRule(_localctx, 792, Cobol85Parser.RULE_performUntil)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4711)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TEST || _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4710)
		 		try performTestClause()

		 	}

		 	setState(4713)
		 	try match(Cobol85Parser.UNTIL)
		 	setState(4714)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformVaryingContext:ParserRuleContext {
		open func performTestClause() -> PerformTestClauseContext? {
			return getRuleContext(PerformTestClauseContext.self,0)
		}
		open func performVaryingClause() -> PerformVaryingClauseContext? {
			return getRuleContext(PerformVaryingClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performVarying }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformVarying(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformVarying(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformVarying(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformVarying(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performVarying() throws -> PerformVaryingContext {
		var _localctx: PerformVaryingContext = PerformVaryingContext(_ctx, getState())
		try enterRule(_localctx, 794, Cobol85Parser.RULE_performVarying)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4723)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.TEST:fallthrough
		 	case Cobol85Parser.WITH:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4716)
		 		try performTestClause()
		 		setState(4717)
		 		try performVaryingClause()

		 		break

		 	case Cobol85Parser.VARYING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4719)
		 		try performVaryingClause()
		 		setState(4721)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,691,_ctx)) {
		 		case 1:
		 			setState(4720)
		 			try performTestClause()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformVaryingClauseContext:ParserRuleContext {
		open func VARYING() -> TerminalNode? { return getToken(Cobol85Parser.VARYING, 0) }
		open func FROM() -> Array<TerminalNode> { return getTokens(Cobol85Parser.FROM) }
		open func FROM(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.FROM, i)
		}
		open func BY() -> Array<TerminalNode> { return getTokens(Cobol85Parser.BY) }
		open func BY(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.BY, i)
		}
		open func performUntil() -> Array<PerformUntilContext> {
			return getRuleContexts(PerformUntilContext.self)
		}
		open func performUntil(_ i: Int) -> PerformUntilContext? {
			return getRuleContext(PerformUntilContext.self,i)
		}
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open func literal() -> Array<LiteralContext> {
			return getRuleContexts(LiteralContext.self)
		}
		open func literal(_ i: Int) -> LiteralContext? {
			return getRuleContext(LiteralContext.self,i)
		}
		open func arithmeticExpression() -> Array<ArithmeticExpressionContext> {
			return getRuleContexts(ArithmeticExpressionContext.self)
		}
		open func arithmeticExpression(_ i: Int) -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,i)
		}
		open func AFTER() -> Array<TerminalNode> { return getTokens(Cobol85Parser.AFTER) }
		open func AFTER(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.AFTER, i)
		}
		open func END_PERFORM() -> TerminalNode? { return getToken(Cobol85Parser.END_PERFORM, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performVaryingClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformVaryingClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformVaryingClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformVaryingClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformVaryingClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performVaryingClause() throws -> PerformVaryingClauseContext {
		var _localctx: PerformVaryingClauseContext = PerformVaryingClauseContext(_ctx, getState())
		try enterRule(_localctx, 796, Cobol85Parser.RULE_performVaryingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4725)
		 	try match(Cobol85Parser.VARYING)
		 	setState(4728)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,693, _ctx)) {
		 	case 1:
		 		setState(4726)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4727)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4730)
		 	try match(Cobol85Parser.FROM)
		 	setState(4734)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,694, _ctx)) {
		 	case 1:
		 		setState(4731)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4732)
		 		try literal()

		 		break
		 	case 3:
		 		setState(4733)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		 	setState(4736)
		 	try match(Cobol85Parser.BY)
		 	setState(4740)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,695, _ctx)) {
		 	case 1:
		 		setState(4737)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4738)
		 		try literal()

		 		break
		 	case 3:
		 		setState(4739)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		 	setState(4742)
		 	try performUntil()
		 	setState(4761)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER
		 	      return testSet
		 	 }()) {
		 		setState(4743)
		 		try match(Cobol85Parser.AFTER)

		 		setState(4744)
		 		try identifier()

		 		setState(4745)
		 		try match(Cobol85Parser.FROM)
		 		setState(4749)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,696, _ctx)) {
		 		case 1:
		 			setState(4746)
		 			try identifier()

		 			break
		 		case 2:
		 			setState(4747)
		 			try literal()

		 			break
		 		case 3:
		 			setState(4748)
		 			try arithmeticExpression()

		 			break
		 		default: break
		 		}
		 		setState(4751)
		 		try match(Cobol85Parser.BY)
		 		setState(4755)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,697, _ctx)) {
		 		case 1:
		 			setState(4752)
		 			try identifier()

		 			break
		 		case 2:
		 			setState(4753)
		 			try literal()

		 			break
		 		case 3:
		 			setState(4754)
		 			try arithmeticExpression()

		 			break
		 		default: break
		 		}
		 		setState(4757)
		 		try performUntil()


		 		setState(4763)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4771)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,700,_ctx)) {
		 	case 1:
		 		setState(4765) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(4764)
		 			try statement()


		 			setState(4767); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ACCEPT,Cobol85Parser.ADD,Cobol85Parser.ALTER,Cobol85Parser.CALL,Cobol85Parser.CANCEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE,Cobol85Parser.COMPUTE,Cobol85Parser.CONTINUE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 69)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DELETE,Cobol85Parser.DISABLE,Cobol85Parser.DISPLAY,Cobol85Parser.DIVIDE,Cobol85Parser.ENABLE,Cobol85Parser.ENTRY,Cobol85Parser.EVALUATE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 134)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXHIBIT,Cobol85Parser.EXIT,Cobol85Parser.GENERATE,Cobol85Parser.GOBACK,Cobol85Parser.GO,Cobol85Parser.IF,Cobol85Parser.INITIALIZE,Cobol85Parser.INITIATE,Cobol85Parser.INSPECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 201)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.MERGE,Cobol85Parser.MOVE,Cobol85Parser.MULTIPLY,Cobol85Parser.OPEN,Cobol85Parser.PERFORM]
		 		              return  Utils.testBitLeftShiftArray(testArray, 297)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.PURGE,Cobol85Parser.READ,Cobol85Parser.RECEIVE,Cobol85Parser.RELEASE,Cobol85Parser.RETURN,Cobol85Parser.REWRITE,Cobol85Parser.SEARCH,Cobol85Parser.SEND,Cobol85Parser.SET]
		 		              return  Utils.testBitLeftShiftArray(testArray, 370)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SORT,Cobol85Parser.START,Cobol85Parser.STOP,Cobol85Parser.STRING,Cobol85Parser.SUBTRACT,Cobol85Parser.TERMINATE,Cobol85Parser.UNSTRING]
		 		              return  Utils.testBitLeftShiftArray(testArray, 443)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.WRITE,Cobol85Parser.EXECCICSLINE,Cobol85Parser.EXECSQLIMSLINE,Cobol85Parser.EXECSQLLINE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 521)
		 		          }()
		 		      return testSet
		 		 }())
		 		setState(4769)
		 		try match(Cobol85Parser.END_PERFORM)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PerformTestClauseContext:ParserRuleContext {
		open func TEST() -> TerminalNode? { return getToken(Cobol85Parser.TEST, 0) }
		open func BEFORE() -> TerminalNode? { return getToken(Cobol85Parser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(Cobol85Parser.AFTER, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_performTestClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPerformTestClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPerformTestClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPerformTestClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPerformTestClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func performTestClause() throws -> PerformTestClauseContext {
		var _localctx: PerformTestClauseContext = PerformTestClauseContext(_ctx, getState())
		try enterRule(_localctx, 798, Cobol85Parser.RULE_performTestClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4774)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4773)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4776)
		 	try match(Cobol85Parser.TEST)
		 	setState(4777)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PurgeStatementContext:ParserRuleContext {
		open func PURGE() -> TerminalNode? { return getToken(Cobol85Parser.PURGE, 0) }
		open func cdName() -> Array<CdNameContext> {
			return getRuleContexts(CdNameContext.self)
		}
		open func cdName(_ i: Int) -> CdNameContext? {
			return getRuleContext(CdNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_purgeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPurgeStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPurgeStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPurgeStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPurgeStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func purgeStatement() throws -> PurgeStatementContext {
		var _localctx: PurgeStatementContext = PurgeStatementContext(_ctx, getState())
		try enterRule(_localctx, 800, Cobol85Parser.RULE_purgeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4779)
		 	try match(Cobol85Parser.PURGE)
		 	setState(4781) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4780)
		 		try cdName()


		 		setState(4783); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReadStatementContext:ParserRuleContext {
		open func READ() -> TerminalNode? { return getToken(Cobol85Parser.READ, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func readInto() -> ReadIntoContext? {
			return getRuleContext(ReadIntoContext.self,0)
		}
		open func readWith() -> ReadWithContext? {
			return getRuleContext(ReadWithContext.self,0)
		}
		open func readKey() -> ReadKeyContext? {
			return getRuleContext(ReadKeyContext.self,0)
		}
		open func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
			return getRuleContext(InvalidKeyPhraseContext.self,0)
		}
		open func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
			return getRuleContext(NotInvalidKeyPhraseContext.self,0)
		}
		open func atEndPhrase() -> AtEndPhraseContext? {
			return getRuleContext(AtEndPhraseContext.self,0)
		}
		open func notAtEndPhrase() -> NotAtEndPhraseContext? {
			return getRuleContext(NotAtEndPhraseContext.self,0)
		}
		open func END_READ() -> TerminalNode? { return getToken(Cobol85Parser.END_READ, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_readStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReadStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReadStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReadStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReadStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func readStatement() throws -> ReadStatementContext {
		var _localctx: ReadStatementContext = ReadStatementContext(_ctx, getState())
		try enterRule(_localctx, 802, Cobol85Parser.RULE_readStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4785)
		 	try match(Cobol85Parser.READ)
		 	setState(4786)
		 	try fileName()
		 	setState(4788)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NEXT
		 	      return testSet
		 	 }()) {
		 		setState(4787)
		 		try match(Cobol85Parser.NEXT)

		 	}

		 	setState(4791)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RECORD
		 	      return testSet
		 	 }()) {
		 		setState(4790)
		 		try match(Cobol85Parser.RECORD)

		 	}

		 	setState(4794)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INTO
		 	      return testSet
		 	 }()) {
		 		setState(4793)
		 		try readInto()

		 	}

		 	setState(4797)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,706,_ctx)) {
		 	case 1:
		 		setState(4796)
		 		try readWith()

		 		break
		 	default: break
		 	}
		 	setState(4800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(4799)
		 		try readKey()

		 	}

		 	setState(4803)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,708,_ctx)) {
		 	case 1:
		 		setState(4802)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4806)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,709,_ctx)) {
		 	case 1:
		 		setState(4805)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4809)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,710,_ctx)) {
		 	case 1:
		 		setState(4808)
		 		try atEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4812)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,711,_ctx)) {
		 	case 1:
		 		setState(4811)
		 		try notAtEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4815)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,712,_ctx)) {
		 	case 1:
		 		setState(4814)
		 		try match(Cobol85Parser.END_READ)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReadIntoContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_readInto }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReadInto(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReadInto(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReadInto(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReadInto(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func readInto() throws -> ReadIntoContext {
		var _localctx: ReadIntoContext = ReadIntoContext(_ctx, getState())
		try enterRule(_localctx, 804, Cobol85Parser.RULE_readInto)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4817)
		 	try match(Cobol85Parser.INTO)
		 	setState(4818)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReadWithContext:ParserRuleContext {
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func WAIT() -> TerminalNode? { return getToken(Cobol85Parser.WAIT, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func KEPT() -> TerminalNode? { return getToken(Cobol85Parser.KEPT, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_readWith }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReadWith(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReadWith(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReadWith(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReadWith(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func readWith() throws -> ReadWithContext {
		var _localctx: ReadWithContext = ReadWithContext(_ctx, getState())
		try enterRule(_localctx, 806, Cobol85Parser.RULE_readWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4821)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4820)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4826)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.NO:
		 		setState(4823)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.KEPT || _la == Cobol85Parser.NO
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4824)
		 		try match(Cobol85Parser.LOCK)

		 		break

		 	case Cobol85Parser.WAIT:
		 		setState(4825)
		 		try match(Cobol85Parser.WAIT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReadKeyContext:ParserRuleContext {
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_readKey }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReadKey(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReadKey(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReadKey(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReadKey(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func readKey() throws -> ReadKeyContext {
		var _localctx: ReadKeyContext = ReadKeyContext(_ctx, getState())
		try enterRule(_localctx, 808, Cobol85Parser.RULE_readKey)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4828)
		 	try match(Cobol85Parser.KEY)
		 	setState(4830)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(4829)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(4832)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveStatementContext:ParserRuleContext {
		open func RECEIVE() -> TerminalNode? { return getToken(Cobol85Parser.RECEIVE, 0) }
		open func receiveFromStatement() -> ReceiveFromStatementContext? {
			return getRuleContext(ReceiveFromStatementContext.self,0)
		}
		open func receiveIntoStatement() -> ReceiveIntoStatementContext? {
			return getRuleContext(ReceiveIntoStatementContext.self,0)
		}
		open func onExceptionClause() -> OnExceptionClauseContext? {
			return getRuleContext(OnExceptionClauseContext.self,0)
		}
		open func notOnExceptionClause() -> NotOnExceptionClauseContext? {
			return getRuleContext(NotOnExceptionClauseContext.self,0)
		}
		open func END_RECEIVE() -> TerminalNode? { return getToken(Cobol85Parser.END_RECEIVE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveStatement() throws -> ReceiveStatementContext {
		var _localctx: ReceiveStatementContext = ReceiveStatementContext(_ctx, getState())
		try enterRule(_localctx, 810, Cobol85Parser.RULE_receiveStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4834)
		 	try match(Cobol85Parser.RECEIVE)
		 	setState(4837)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,716, _ctx)) {
		 	case 1:
		 		setState(4835)
		 		try receiveFromStatement()

		 		break
		 	case 2:
		 		setState(4836)
		 		try receiveIntoStatement()

		 		break
		 	default: break
		 	}
		 	setState(4840)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,717,_ctx)) {
		 	case 1:
		 		setState(4839)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(4843)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,718,_ctx)) {
		 	case 1:
		 		setState(4842)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(4846)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,719,_ctx)) {
		 	case 1:
		 		setState(4845)
		 		try match(Cobol85Parser.END_RECEIVE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveFromStatementContext:ParserRuleContext {
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func receiveFrom() -> ReceiveFromContext? {
			return getRuleContext(ReceiveFromContext.self,0)
		}
		open func receiveBefore() -> Array<ReceiveBeforeContext> {
			return getRuleContexts(ReceiveBeforeContext.self)
		}
		open func receiveBefore(_ i: Int) -> ReceiveBeforeContext? {
			return getRuleContext(ReceiveBeforeContext.self,i)
		}
		open func receiveWith() -> Array<ReceiveWithContext> {
			return getRuleContexts(ReceiveWithContext.self)
		}
		open func receiveWith(_ i: Int) -> ReceiveWithContext? {
			return getRuleContext(ReceiveWithContext.self,i)
		}
		open func receiveThread() -> Array<ReceiveThreadContext> {
			return getRuleContexts(ReceiveThreadContext.self)
		}
		open func receiveThread(_ i: Int) -> ReceiveThreadContext? {
			return getRuleContext(ReceiveThreadContext.self,i)
		}
		open func receiveSize() -> Array<ReceiveSizeContext> {
			return getRuleContexts(ReceiveSizeContext.self)
		}
		open func receiveSize(_ i: Int) -> ReceiveSizeContext? {
			return getRuleContext(ReceiveSizeContext.self,i)
		}
		open func receiveStatus() -> Array<ReceiveStatusContext> {
			return getRuleContexts(ReceiveStatusContext.self)
		}
		open func receiveStatus(_ i: Int) -> ReceiveStatusContext? {
			return getRuleContext(ReceiveStatusContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveFromStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveFromStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveFromStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveFromStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveFromStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveFromStatement() throws -> ReceiveFromStatementContext {
		var _localctx: ReceiveFromStatementContext = ReceiveFromStatementContext(_ctx, getState())
		try enterRule(_localctx, 812, Cobol85Parser.RULE_receiveFromStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4848)
		 	try dataName()
		 	setState(4849)
		 	try match(Cobol85Parser.FROM)
		 	setState(4850)
		 	try receiveFrom()
		 	setState(4858)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,721,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4856)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case Cobol85Parser.BEFORE:
		 				setState(4851)
		 				try receiveBefore()

		 				break
		 			case Cobol85Parser.NO:fallthrough
		 			case Cobol85Parser.WITH:
		 				setState(4852)
		 				try receiveWith()

		 				break

		 			case Cobol85Parser.THREAD:
		 				setState(4853)
		 				try receiveThread()

		 				break

		 			case Cobol85Parser.SIZE:
		 				setState(4854)
		 				try receiveSize()

		 				break

		 			case Cobol85Parser.STATUS:
		 				setState(4855)
		 				try receiveStatus()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(4860)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,721,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveFromContext:ParserRuleContext {
		open func THREAD() -> TerminalNode? { return getToken(Cobol85Parser.THREAD, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func LAST() -> TerminalNode? { return getToken(Cobol85Parser.LAST, 0) }
		open func ANY() -> TerminalNode? { return getToken(Cobol85Parser.ANY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveFrom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveFrom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveFrom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveFrom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveFrom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveFrom() throws -> ReceiveFromContext {
		var _localctx: ReceiveFromContext = ReceiveFromContext(_ctx, getState())
		try enterRule(_localctx, 814, Cobol85Parser.RULE_receiveFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4867)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.THREAD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4861)
		 		try match(Cobol85Parser.THREAD)
		 		setState(4862)
		 		try dataName()

		 		break

		 	case Cobol85Parser.LAST:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4863)
		 		try match(Cobol85Parser.LAST)
		 		setState(4864)
		 		try match(Cobol85Parser.THREAD)

		 		break

		 	case Cobol85Parser.ANY:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4865)
		 		try match(Cobol85Parser.ANY)
		 		setState(4866)
		 		try match(Cobol85Parser.THREAD)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveIntoStatementContext:ParserRuleContext {
		open func cdName() -> CdNameContext? {
			return getRuleContext(CdNameContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.MESSAGE, 0) }
		open func SEGMENT() -> TerminalNode? { return getToken(Cobol85Parser.SEGMENT, 0) }
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func receiveNoData() -> ReceiveNoDataContext? {
			return getRuleContext(ReceiveNoDataContext.self,0)
		}
		open func receiveWithData() -> ReceiveWithDataContext? {
			return getRuleContext(ReceiveWithDataContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveIntoStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveIntoStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveIntoStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveIntoStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveIntoStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveIntoStatement() throws -> ReceiveIntoStatementContext {
		var _localctx: ReceiveIntoStatementContext = ReceiveIntoStatementContext(_ctx, getState())
		try enterRule(_localctx, 816, Cobol85Parser.RULE_receiveIntoStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4869)
		 	try cdName()
		 	setState(4870)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.MESSAGE
		 	          testSet = testSet || _la == Cobol85Parser.SEGMENT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4872)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INTO
		 	      return testSet
		 	 }()) {
		 		setState(4871)
		 		try match(Cobol85Parser.INTO)

		 	}

		 	setState(4874)
		 	try identifier()
		 	setState(4876)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NO
		 	      return testSet
		 	 }()) {
		 		setState(4875)
		 		try receiveNoData()

		 	}

		 	setState(4879)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,725,_ctx)) {
		 	case 1:
		 		setState(4878)
		 		try receiveWithData()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveNoDataContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func DATA() -> TerminalNode? { return getToken(Cobol85Parser.DATA, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveNoData }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveNoData(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveNoData(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveNoData(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveNoData(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveNoData() throws -> ReceiveNoDataContext {
		var _localctx: ReceiveNoDataContext = ReceiveNoDataContext(_ctx, getState())
		try enterRule(_localctx, 818, Cobol85Parser.RULE_receiveNoData)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4881)
		 	try match(Cobol85Parser.NO)
		 	setState(4882)
		 	try match(Cobol85Parser.DATA)
		 	setState(4886)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,726,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4883)
		 			try statement()

		 	 
		 		}
		 		setState(4888)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,726,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveWithDataContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func DATA() -> TerminalNode? { return getToken(Cobol85Parser.DATA, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveWithData }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveWithData(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveWithData(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveWithData(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveWithData(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveWithData() throws -> ReceiveWithDataContext {
		var _localctx: ReceiveWithDataContext = ReceiveWithDataContext(_ctx, getState())
		try enterRule(_localctx, 820, Cobol85Parser.RULE_receiveWithData)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4889)
		 	try match(Cobol85Parser.WITH)
		 	setState(4890)
		 	try match(Cobol85Parser.DATA)
		 	setState(4894)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,727,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4891)
		 			try statement()

		 	 
		 		}
		 		setState(4896)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,727,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveBeforeContext:ParserRuleContext {
		open func BEFORE() -> TerminalNode? { return getToken(Cobol85Parser.BEFORE, 0) }
		open func numericLiteral() -> NumericLiteralContext? {
			return getRuleContext(NumericLiteralContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func TIME() -> TerminalNode? { return getToken(Cobol85Parser.TIME, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveBefore }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveBefore(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveBefore(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveBefore(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveBefore(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveBefore() throws -> ReceiveBeforeContext {
		var _localctx: ReceiveBeforeContext = ReceiveBeforeContext(_ctx, getState())
		try enterRule(_localctx, 822, Cobol85Parser.RULE_receiveBefore)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4897)
		 	try match(Cobol85Parser.BEFORE)
		 	setState(4899)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,728,_ctx)) {
		 	case 1:
		 		setState(4898)
		 		try match(Cobol85Parser.TIME)

		 		break
		 	default: break
		 	}
		 	setState(4903)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,729, _ctx)) {
		 	case 1:
		 		setState(4901)
		 		try numericLiteral()

		 		break
		 	case 2:
		 		setState(4902)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveWithContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func WAIT() -> TerminalNode? { return getToken(Cobol85Parser.WAIT, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveWith }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveWith(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveWith(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveWith(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveWith(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveWith() throws -> ReceiveWithContext {
		var _localctx: ReceiveWithContext = ReceiveWithContext(_ctx, getState())
		try enterRule(_localctx, 824, Cobol85Parser.RULE_receiveWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4906)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(4905)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(4908)
		 	try match(Cobol85Parser.NO)
		 	setState(4909)
		 	try match(Cobol85Parser.WAIT)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveThreadContext:ParserRuleContext {
		open func THREAD() -> TerminalNode? { return getToken(Cobol85Parser.THREAD, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveThread }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveThread(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveThread(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveThread(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveThread(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveThread() throws -> ReceiveThreadContext {
		var _localctx: ReceiveThreadContext = ReceiveThreadContext(_ctx, getState())
		try enterRule(_localctx, 826, Cobol85Parser.RULE_receiveThread)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4911)
		 	try match(Cobol85Parser.THREAD)
		 	setState(4913)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(4912)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(4915)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveSizeContext:ParserRuleContext {
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func numericLiteral() -> NumericLiteralContext? {
			return getRuleContext(NumericLiteralContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveSize }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveSize(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveSize(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveSize(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveSize(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveSize() throws -> ReceiveSizeContext {
		var _localctx: ReceiveSizeContext = ReceiveSizeContext(_ctx, getState())
		try enterRule(_localctx, 828, Cobol85Parser.RULE_receiveSize)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4917)
		 	try match(Cobol85Parser.SIZE)
		 	setState(4919)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(4918)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(4923)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,733, _ctx)) {
		 	case 1:
		 		setState(4921)
		 		try numericLiteral()

		 		break
		 	case 2:
		 		setState(4922)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReceiveStatusContext:ParserRuleContext {
		open func STATUS() -> TerminalNode? { return getToken(Cobol85Parser.STATUS, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_receiveStatus }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReceiveStatus(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReceiveStatus(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReceiveStatus(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReceiveStatus(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receiveStatus() throws -> ReceiveStatusContext {
		var _localctx: ReceiveStatusContext = ReceiveStatusContext(_ctx, getState())
		try enterRule(_localctx, 830, Cobol85Parser.RULE_receiveStatus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4925)
		 	try match(Cobol85Parser.STATUS)
		 	setState(4927)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(4926)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(4929)
		 	try identifier()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReleaseStatementContext:ParserRuleContext {
		open func RELEASE() -> TerminalNode? { return getToken(Cobol85Parser.RELEASE, 0) }
		open func recordName() -> RecordNameContext? {
			return getRuleContext(RecordNameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_releaseStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReleaseStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReleaseStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReleaseStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReleaseStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func releaseStatement() throws -> ReleaseStatementContext {
		var _localctx: ReleaseStatementContext = ReleaseStatementContext(_ctx, getState())
		try enterRule(_localctx, 832, Cobol85Parser.RULE_releaseStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4931)
		 	try match(Cobol85Parser.RELEASE)
		 	setState(4932)
		 	try recordName()
		 	setState(4935)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FROM
		 	      return testSet
		 	 }()) {
		 		setState(4933)
		 		try match(Cobol85Parser.FROM)
		 		setState(4934)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReturnStatementContext:ParserRuleContext {
		open func RETURN() -> TerminalNode? { return getToken(Cobol85Parser.RETURN, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func atEndPhrase() -> AtEndPhraseContext? {
			return getRuleContext(AtEndPhraseContext.self,0)
		}
		open func RECORD() -> TerminalNode? { return getToken(Cobol85Parser.RECORD, 0) }
		open func returnInto() -> ReturnIntoContext? {
			return getRuleContext(ReturnIntoContext.self,0)
		}
		open func notAtEndPhrase() -> NotAtEndPhraseContext? {
			return getRuleContext(NotAtEndPhraseContext.self,0)
		}
		open func END_RETURN() -> TerminalNode? { return getToken(Cobol85Parser.END_RETURN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_returnStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReturnStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReturnStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReturnStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReturnStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func returnStatement() throws -> ReturnStatementContext {
		var _localctx: ReturnStatementContext = ReturnStatementContext(_ctx, getState())
		try enterRule(_localctx, 834, Cobol85Parser.RULE_returnStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4937)
		 	try match(Cobol85Parser.RETURN)
		 	setState(4938)
		 	try fileName()
		 	setState(4940)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.RECORD
		 	      return testSet
		 	 }()) {
		 		setState(4939)
		 		try match(Cobol85Parser.RECORD)

		 	}

		 	setState(4943)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INTO
		 	      return testSet
		 	 }()) {
		 		setState(4942)
		 		try returnInto()

		 	}

		 	setState(4945)
		 	try atEndPhrase()
		 	setState(4947)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,738,_ctx)) {
		 	case 1:
		 		setState(4946)
		 		try notAtEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4950)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,739,_ctx)) {
		 	case 1:
		 		setState(4949)
		 		try match(Cobol85Parser.END_RETURN)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReturnIntoContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_returnInto }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReturnInto(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReturnInto(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReturnInto(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReturnInto(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func returnInto() throws -> ReturnIntoContext {
		var _localctx: ReturnIntoContext = ReturnIntoContext(_ctx, getState())
		try enterRule(_localctx, 836, Cobol85Parser.RULE_returnInto)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4952)
		 	try match(Cobol85Parser.INTO)
		 	setState(4953)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RewriteStatementContext:ParserRuleContext {
		open func REWRITE() -> TerminalNode? { return getToken(Cobol85Parser.REWRITE, 0) }
		open func recordName() -> RecordNameContext? {
			return getRuleContext(RecordNameContext.self,0)
		}
		open func rewriteFrom() -> RewriteFromContext? {
			return getRuleContext(RewriteFromContext.self,0)
		}
		open func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
			return getRuleContext(InvalidKeyPhraseContext.self,0)
		}
		open func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
			return getRuleContext(NotInvalidKeyPhraseContext.self,0)
		}
		open func END_REWRITE() -> TerminalNode? { return getToken(Cobol85Parser.END_REWRITE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rewriteStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRewriteStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRewriteStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRewriteStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRewriteStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rewriteStatement() throws -> RewriteStatementContext {
		var _localctx: RewriteStatementContext = RewriteStatementContext(_ctx, getState())
		try enterRule(_localctx, 838, Cobol85Parser.RULE_rewriteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4955)
		 	try match(Cobol85Parser.REWRITE)
		 	setState(4956)
		 	try recordName()
		 	setState(4958)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FROM
		 	      return testSet
		 	 }()) {
		 		setState(4957)
		 		try rewriteFrom()

		 	}

		 	setState(4961)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,741,_ctx)) {
		 	case 1:
		 		setState(4960)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4964)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,742,_ctx)) {
		 	case 1:
		 		setState(4963)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4967)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,743,_ctx)) {
		 	case 1:
		 		setState(4966)
		 		try match(Cobol85Parser.END_REWRITE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RewriteFromContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_rewriteFrom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRewriteFrom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRewriteFrom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRewriteFrom(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRewriteFrom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rewriteFrom() throws -> RewriteFromContext {
		var _localctx: RewriteFromContext = RewriteFromContext(_ctx, getState())
		try enterRule(_localctx, 840, Cobol85Parser.RULE_rewriteFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4969)
		 	try match(Cobol85Parser.FROM)
		 	setState(4970)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SearchStatementContext:ParserRuleContext {
		open func SEARCH() -> TerminalNode? { return getToken(Cobol85Parser.SEARCH, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func searchVarying() -> SearchVaryingContext? {
			return getRuleContext(SearchVaryingContext.self,0)
		}
		open func atEndPhrase() -> AtEndPhraseContext? {
			return getRuleContext(AtEndPhraseContext.self,0)
		}
		open func searchWhen() -> Array<SearchWhenContext> {
			return getRuleContexts(SearchWhenContext.self)
		}
		open func searchWhen(_ i: Int) -> SearchWhenContext? {
			return getRuleContext(SearchWhenContext.self,i)
		}
		open func END_SEARCH() -> TerminalNode? { return getToken(Cobol85Parser.END_SEARCH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_searchStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSearchStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSearchStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSearchStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSearchStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searchStatement() throws -> SearchStatementContext {
		var _localctx: SearchStatementContext = SearchStatementContext(_ctx, getState())
		try enterRule(_localctx, 842, Cobol85Parser.RULE_searchStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4972)
		 	try match(Cobol85Parser.SEARCH)
		 	setState(4974)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ALL
		 	      return testSet
		 	 }()) {
		 		setState(4973)
		 		try match(Cobol85Parser.ALL)

		 	}

		 	setState(4976)
		 	try qualifiedDataName()
		 	setState(4978)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.VARYING
		 	      return testSet
		 	 }()) {
		 		setState(4977)
		 		try searchVarying()

		 	}

		 	setState(4981)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.AT
		 	          testSet = testSet || _la == Cobol85Parser.END
		 	      return testSet
		 	 }()) {
		 		setState(4980)
		 		try atEndPhrase()

		 	}

		 	setState(4984); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4983)
		 			try searchWhen()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4986); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,747,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4989)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,748,_ctx)) {
		 	case 1:
		 		setState(4988)
		 		try match(Cobol85Parser.END_SEARCH)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SearchVaryingContext:ParserRuleContext {
		open func VARYING() -> TerminalNode? { return getToken(Cobol85Parser.VARYING, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_searchVarying }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSearchVarying(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSearchVarying(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSearchVarying(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSearchVarying(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searchVarying() throws -> SearchVaryingContext {
		var _localctx: SearchVaryingContext = SearchVaryingContext(_ctx, getState())
		try enterRule(_localctx, 844, Cobol85Parser.RULE_searchVarying)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4991)
		 	try match(Cobol85Parser.VARYING)
		 	setState(4992)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SearchWhenContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(Cobol85Parser.WHEN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func NEXT() -> TerminalNode? { return getToken(Cobol85Parser.NEXT, 0) }
		open func SENTENCE() -> TerminalNode? { return getToken(Cobol85Parser.SENTENCE, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_searchWhen }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSearchWhen(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSearchWhen(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSearchWhen(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSearchWhen(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searchWhen() throws -> SearchWhenContext {
		var _localctx: SearchWhenContext = SearchWhenContext(_ctx, getState())
		try enterRule(_localctx, 846, Cobol85Parser.RULE_searchWhen)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4994)
		 	try match(Cobol85Parser.WHEN)
		 	setState(4995)
		 	try condition()
		 	setState(5004)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NEXT:
		 		setState(4996)
		 		try match(Cobol85Parser.NEXT)
		 		setState(4997)
		 		try match(Cobol85Parser.SENTENCE)

		 		break
		 	case Cobol85Parser.ACCEPT:fallthrough
		 	case Cobol85Parser.ADD:fallthrough
		 	case Cobol85Parser.ALTER:fallthrough
		 	case Cobol85Parser.AT:fallthrough
		 	case Cobol85Parser.CALL:fallthrough
		 	case Cobol85Parser.CANCEL:fallthrough
		 	case Cobol85Parser.CLOSE:fallthrough
		 	case Cobol85Parser.COMPUTE:fallthrough
		 	case Cobol85Parser.CONTINUE:fallthrough
		 	case Cobol85Parser.DELETE:fallthrough
		 	case Cobol85Parser.DISABLE:fallthrough
		 	case Cobol85Parser.DISPLAY:fallthrough
		 	case Cobol85Parser.DIVIDE:fallthrough
		 	case Cobol85Parser.ELSE:fallthrough
		 	case Cobol85Parser.ENABLE:fallthrough
		 	case Cobol85Parser.END:fallthrough
		 	case Cobol85Parser.END_ADD:fallthrough
		 	case Cobol85Parser.END_CALL:fallthrough
		 	case Cobol85Parser.END_COMPUTE:fallthrough
		 	case Cobol85Parser.END_DELETE:fallthrough
		 	case Cobol85Parser.END_DIVIDE:fallthrough
		 	case Cobol85Parser.END_EVALUATE:fallthrough
		 	case Cobol85Parser.END_IF:fallthrough
		 	case Cobol85Parser.END_MULTIPLY:fallthrough
		 	case Cobol85Parser.END_PERFORM:fallthrough
		 	case Cobol85Parser.END_READ:fallthrough
		 	case Cobol85Parser.END_RECEIVE:fallthrough
		 	case Cobol85Parser.END_RETURN:fallthrough
		 	case Cobol85Parser.END_REWRITE:fallthrough
		 	case Cobol85Parser.END_SEARCH:fallthrough
		 	case Cobol85Parser.END_START:fallthrough
		 	case Cobol85Parser.END_STRING:fallthrough
		 	case Cobol85Parser.END_SUBTRACT:fallthrough
		 	case Cobol85Parser.END_UNSTRING:fallthrough
		 	case Cobol85Parser.END_WRITE:fallthrough
		 	case Cobol85Parser.ENTRY:fallthrough
		 	case Cobol85Parser.EVALUATE:fallthrough
		 	case Cobol85Parser.EXCEPTION:fallthrough
		 	case Cobol85Parser.EXHIBIT:fallthrough
		 	case Cobol85Parser.EXIT:fallthrough
		 	case Cobol85Parser.GENERATE:fallthrough
		 	case Cobol85Parser.GOBACK:fallthrough
		 	case Cobol85Parser.GO:fallthrough
		 	case Cobol85Parser.IF:fallthrough
		 	case Cobol85Parser.INITIALIZE:fallthrough
		 	case Cobol85Parser.INITIATE:fallthrough
		 	case Cobol85Parser.INSPECT:fallthrough
		 	case Cobol85Parser.INVALID:fallthrough
		 	case Cobol85Parser.MERGE:fallthrough
		 	case Cobol85Parser.MOVE:fallthrough
		 	case Cobol85Parser.MULTIPLY:fallthrough
		 	case Cobol85Parser.NOT:fallthrough
		 	case Cobol85Parser.ON:fallthrough
		 	case Cobol85Parser.OPEN:fallthrough
		 	case Cobol85Parser.PERFORM:fallthrough
		 	case Cobol85Parser.PURGE:fallthrough
		 	case Cobol85Parser.READ:fallthrough
		 	case Cobol85Parser.RECEIVE:fallthrough
		 	case Cobol85Parser.RELEASE:fallthrough
		 	case Cobol85Parser.RETURN:fallthrough
		 	case Cobol85Parser.REWRITE:fallthrough
		 	case Cobol85Parser.SEARCH:fallthrough
		 	case Cobol85Parser.SEND:fallthrough
		 	case Cobol85Parser.SET:fallthrough
		 	case Cobol85Parser.SORT:fallthrough
		 	case Cobol85Parser.START:fallthrough
		 	case Cobol85Parser.STOP:fallthrough
		 	case Cobol85Parser.STRING:fallthrough
		 	case Cobol85Parser.SUBTRACT:fallthrough
		 	case Cobol85Parser.TERMINATE:fallthrough
		 	case Cobol85Parser.UNSTRING:fallthrough
		 	case Cobol85Parser.WHEN:fallthrough
		 	case Cobol85Parser.WITH:fallthrough
		 	case Cobol85Parser.WRITE:fallthrough
		 	case Cobol85Parser.DOT_FS:fallthrough
		 	case Cobol85Parser.EXECCICSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLIMSLINE:fallthrough
		 	case Cobol85Parser.EXECSQLLINE:
		 		setState(5001)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,749,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4998)
		 				try statement()

		 		 
		 			}
		 			setState(5003)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,749,_ctx)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendStatementContext:ParserRuleContext {
		open func SEND() -> TerminalNode? { return getToken(Cobol85Parser.SEND, 0) }
		open func sendStatementSync() -> SendStatementSyncContext? {
			return getRuleContext(SendStatementSyncContext.self,0)
		}
		open func sendStatementAsync() -> SendStatementAsyncContext? {
			return getRuleContext(SendStatementAsyncContext.self,0)
		}
		open func onExceptionClause() -> OnExceptionClauseContext? {
			return getRuleContext(OnExceptionClauseContext.self,0)
		}
		open func notOnExceptionClause() -> NotOnExceptionClauseContext? {
			return getRuleContext(NotOnExceptionClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendStatement() throws -> SendStatementContext {
		var _localctx: SendStatementContext = SendStatementContext(_ctx, getState())
		try enterRule(_localctx, 848, Cobol85Parser.RULE_sendStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5006)
		 	try match(Cobol85Parser.SEND)
		 	setState(5009)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.ADDRESS:fallthrough
		 	case Cobol85Parser.ALL:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DATE:fallthrough
		 	case Cobol85Parser.DAY:fallthrough
		 	case Cobol85Parser.DAY_OF_WEEK:fallthrough
		 	case Cobol85Parser.DEBUG_CONTENTS:fallthrough
		 	case Cobol85Parser.DEBUG_ITEM:fallthrough
		 	case Cobol85Parser.DEBUG_LINE:fallthrough
		 	case Cobol85Parser.DEBUG_NAME:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_1:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_2:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_3:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FALSE:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTION:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.HIGH_VALUE:fallthrough
		 	case Cobol85Parser.HIGH_VALUES:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LINAGE_COUNTER:fallthrough
		 	case Cobol85Parser.LINE_COUNTER:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.LOW_VALUE:fallthrough
		 	case Cobol85Parser.LOW_VALUES:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NULL:fallthrough
		 	case Cobol85Parser.NULLS:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PAGE_COUNTER:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.QUOTE:fallthrough
		 	case Cobol85Parser.QUOTES:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.RETURN_CODE:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHIFT_IN:fallthrough
		 	case Cobol85Parser.SHIFT_OUT:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SORT_CONTROL:fallthrough
		 	case Cobol85Parser.SORT_CORE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_FILE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_MESSAGE:fallthrough
		 	case Cobol85Parser.SORT_MODE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_RETURN:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SPACE:fallthrough
		 	case Cobol85Parser.SPACES:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TALLY:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIME:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUE:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.WHEN_COMPILED:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.ZEROS:fallthrough
		 	case Cobol85Parser.ZEROES:fallthrough
		 	case Cobol85Parser.NONNUMERICLITERAL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.NUMERICLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(5007)
		 		try sendStatementSync()

		 		break

		 	case Cobol85Parser.TO:
		 		setState(5008)
		 		try sendStatementAsync()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5012)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,752,_ctx)) {
		 	case 1:
		 		setState(5011)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(5015)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,753,_ctx)) {
		 	case 1:
		 		setState(5014)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendStatementSyncContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func sendFromPhrase() -> SendFromPhraseContext? {
			return getRuleContext(SendFromPhraseContext.self,0)
		}
		open func sendWithPhrase() -> SendWithPhraseContext? {
			return getRuleContext(SendWithPhraseContext.self,0)
		}
		open func sendReplacingPhrase() -> SendReplacingPhraseContext? {
			return getRuleContext(SendReplacingPhraseContext.self,0)
		}
		open func sendAdvancingPhrase() -> SendAdvancingPhraseContext? {
			return getRuleContext(SendAdvancingPhraseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendStatementSync }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendStatementSync(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendStatementSync(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendStatementSync(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendStatementSync(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendStatementSync() throws -> SendStatementSyncContext {
		var _localctx: SendStatementSyncContext = SendStatementSyncContext(_ctx, getState())
		try enterRule(_localctx, 850, Cobol85Parser.RULE_sendStatementSync)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5019)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,754, _ctx)) {
		 	case 1:
		 		setState(5017)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5018)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5022)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FROM
		 	      return testSet
		 	 }()) {
		 		setState(5021)
		 		try sendFromPhrase()

		 	}

		 	setState(5025)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,756,_ctx)) {
		 	case 1:
		 		setState(5024)
		 		try sendWithPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5028)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.REPLACING
		 	      return testSet
		 	 }()) {
		 		setState(5027)
		 		try sendReplacingPhrase()

		 	}

		 	setState(5031)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(5030)
		 		try sendAdvancingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendStatementAsyncContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func TOP() -> TerminalNode? { return getToken(Cobol85Parser.TOP, 0) }
		open func BOTTOM() -> TerminalNode? { return getToken(Cobol85Parser.BOTTOM, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendStatementAsync }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendStatementAsync(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendStatementAsync(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendStatementAsync(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendStatementAsync(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendStatementAsync() throws -> SendStatementAsyncContext {
		var _localctx: SendStatementAsyncContext = SendStatementAsyncContext(_ctx, getState())
		try enterRule(_localctx, 852, Cobol85Parser.RULE_sendStatementAsync)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5033)
		 	try match(Cobol85Parser.TO)
		 	setState(5034)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.BOTTOM
		 	          testSet = testSet || _la == Cobol85Parser.TOP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5035)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendFromPhraseContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendFromPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendFromPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendFromPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendFromPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendFromPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendFromPhrase() throws -> SendFromPhraseContext {
		var _localctx: SendFromPhraseContext = SendFromPhraseContext(_ctx, getState())
		try enterRule(_localctx, 854, Cobol85Parser.RULE_sendFromPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5037)
		 	try match(Cobol85Parser.FROM)
		 	setState(5038)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendWithPhraseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func EGI() -> TerminalNode? { return getToken(Cobol85Parser.EGI, 0) }
		open func EMI() -> TerminalNode? { return getToken(Cobol85Parser.EMI, 0) }
		open func ESI() -> TerminalNode? { return getToken(Cobol85Parser.ESI, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendWithPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendWithPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendWithPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendWithPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendWithPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendWithPhrase() throws -> SendWithPhraseContext {
		var _localctx: SendWithPhraseContext = SendWithPhraseContext(_ctx, getState())
		try enterRule(_localctx, 856, Cobol85Parser.RULE_sendWithPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5040)
		 	try match(Cobol85Parser.WITH)
		 	setState(5045)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.EGI:
		 		setState(5041)
		 		try match(Cobol85Parser.EGI)

		 		break

		 	case Cobol85Parser.EMI:
		 		setState(5042)
		 		try match(Cobol85Parser.EMI)

		 		break

		 	case Cobol85Parser.ESI:
		 		setState(5043)
		 		try match(Cobol85Parser.ESI)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.ADDRESS:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DATE:fallthrough
		 	case Cobol85Parser.DAY:fallthrough
		 	case Cobol85Parser.DAY_OF_WEEK:fallthrough
		 	case Cobol85Parser.DEBUG_CONTENTS:fallthrough
		 	case Cobol85Parser.DEBUG_ITEM:fallthrough
		 	case Cobol85Parser.DEBUG_LINE:fallthrough
		 	case Cobol85Parser.DEBUG_NAME:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_1:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_2:fallthrough
		 	case Cobol85Parser.DEBUG_SUB_3:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTION:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LINAGE_COUNTER:fallthrough
		 	case Cobol85Parser.LINE_COUNTER:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PAGE_COUNTER:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.RETURN_CODE:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHIFT_IN:fallthrough
		 	case Cobol85Parser.SHIFT_OUT:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SORT_CONTROL:fallthrough
		 	case Cobol85Parser.SORT_CORE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_FILE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_MESSAGE:fallthrough
		 	case Cobol85Parser.SORT_MODE_SIZE:fallthrough
		 	case Cobol85Parser.SORT_RETURN:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TALLY:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIME:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.WHEN_COMPILED:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(5044)
		 		try identifier()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendReplacingPhraseContext:ParserRuleContext {
		open func REPLACING() -> TerminalNode? { return getToken(Cobol85Parser.REPLACING, 0) }
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendReplacingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendReplacingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendReplacingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendReplacingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendReplacingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendReplacingPhrase() throws -> SendReplacingPhraseContext {
		var _localctx: SendReplacingPhraseContext = SendReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 858, Cobol85Parser.RULE_sendReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5047)
		 	try match(Cobol85Parser.REPLACING)
		 	setState(5049)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINE
		 	      return testSet
		 	 }()) {
		 		setState(5048)
		 		try match(Cobol85Parser.LINE)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendAdvancingPhraseContext:ParserRuleContext {
		open func BEFORE() -> TerminalNode? { return getToken(Cobol85Parser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(Cobol85Parser.AFTER, 0) }
		open func sendAdvancingPage() -> SendAdvancingPageContext? {
			return getRuleContext(SendAdvancingPageContext.self,0)
		}
		open func sendAdvancingLines() -> SendAdvancingLinesContext? {
			return getRuleContext(SendAdvancingLinesContext.self,0)
		}
		open func sendAdvancingMnemonic() -> SendAdvancingMnemonicContext? {
			return getRuleContext(SendAdvancingMnemonicContext.self,0)
		}
		open func ADVANCING() -> TerminalNode? { return getToken(Cobol85Parser.ADVANCING, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendAdvancingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendAdvancingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendAdvancingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendAdvancingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendAdvancingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendAdvancingPhrase() throws -> SendAdvancingPhraseContext {
		var _localctx: SendAdvancingPhraseContext = SendAdvancingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 860, Cobol85Parser.RULE_sendAdvancingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5051)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ADVANCING
		 	      return testSet
		 	 }()) {
		 		setState(5052)
		 		try match(Cobol85Parser.ADVANCING)

		 	}

		 	setState(5058)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,762, _ctx)) {
		 	case 1:
		 		setState(5055)
		 		try sendAdvancingPage()

		 		break
		 	case 2:
		 		setState(5056)
		 		try sendAdvancingLines()

		 		break
		 	case 3:
		 		setState(5057)
		 		try sendAdvancingMnemonic()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendAdvancingPageContext:ParserRuleContext {
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendAdvancingPage }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendAdvancingPage(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendAdvancingPage(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendAdvancingPage(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendAdvancingPage(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendAdvancingPage() throws -> SendAdvancingPageContext {
		var _localctx: SendAdvancingPageContext = SendAdvancingPageContext(_ctx, getState())
		try enterRule(_localctx, 862, Cobol85Parser.RULE_sendAdvancingPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5060)
		 	try match(Cobol85Parser.PAGE)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendAdvancingLinesContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendAdvancingLines }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendAdvancingLines(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendAdvancingLines(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendAdvancingLines(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendAdvancingLines(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendAdvancingLines() throws -> SendAdvancingLinesContext {
		var _localctx: SendAdvancingLinesContext = SendAdvancingLinesContext(_ctx, getState())
		try enterRule(_localctx, 864, Cobol85Parser.RULE_sendAdvancingLines)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5064)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,763, _ctx)) {
		 	case 1:
		 		setState(5062)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5063)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5067)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 	      return testSet
		 	 }()) {
		 		setState(5066)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SendAdvancingMnemonicContext:ParserRuleContext {
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sendAdvancingMnemonic }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSendAdvancingMnemonic(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSendAdvancingMnemonic(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSendAdvancingMnemonic(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSendAdvancingMnemonic(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sendAdvancingMnemonic() throws -> SendAdvancingMnemonicContext {
		var _localctx: SendAdvancingMnemonicContext = SendAdvancingMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 866, Cobol85Parser.RULE_sendAdvancingMnemonic)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5069)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetStatementContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(Cobol85Parser.SET, 0) }
		open func setUpDownByStatement() -> SetUpDownByStatementContext? {
			return getRuleContext(SetUpDownByStatementContext.self,0)
		}
		open func setToStatement() -> Array<SetToStatementContext> {
			return getRuleContexts(SetToStatementContext.self)
		}
		open func setToStatement(_ i: Int) -> SetToStatementContext? {
			return getRuleContext(SetToStatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setStatement() throws -> SetStatementContext {
		var _localctx: SetStatementContext = SetStatementContext(_ctx, getState())
		try enterRule(_localctx, 868, Cobol85Parser.RULE_setStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5071)
		 	try match(Cobol85Parser.SET)
		 	setState(5078)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,766, _ctx)) {
		 	case 1:
		 		setState(5073) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(5072)
		 			try setToStatement()


		 			setState(5075); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 		              return  Utils.testBitLeftShiftArray(testArray, 556)
		 		          }()
		 		      return testSet
		 		 }())

		 		break
		 	case 2:
		 		setState(5077)
		 		try setUpDownByStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetToStatementContext:ParserRuleContext {
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func setTo() -> Array<SetToContext> {
			return getRuleContexts(SetToContext.self)
		}
		open func setTo(_ i: Int) -> SetToContext? {
			return getRuleContext(SetToContext.self,i)
		}
		open func setToValue() -> Array<SetToValueContext> {
			return getRuleContexts(SetToValueContext.self)
		}
		open func setToValue(_ i: Int) -> SetToValueContext? {
			return getRuleContext(SetToValueContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setToStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetToStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetToStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetToStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetToStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setToStatement() throws -> SetToStatementContext {
		var _localctx: SetToStatementContext = SetToStatementContext(_ctx, getState())
		try enterRule(_localctx, 870, Cobol85Parser.RULE_setToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5081) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5080)
		 		try setTo()


		 		setState(5083); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5085)
		 	try match(Cobol85Parser.TO)
		 	setState(5087); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5086)
		 			try setToValue()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5089); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,768,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetUpDownByStatementContext:ParserRuleContext {
		open func setByValue() -> SetByValueContext? {
			return getRuleContext(SetByValueContext.self,0)
		}
		open func UP() -> TerminalNode? { return getToken(Cobol85Parser.UP, 0) }
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func DOWN() -> TerminalNode? { return getToken(Cobol85Parser.DOWN, 0) }
		open func setTo() -> Array<SetToContext> {
			return getRuleContexts(SetToContext.self)
		}
		open func setTo(_ i: Int) -> SetToContext? {
			return getRuleContext(SetToContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setUpDownByStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetUpDownByStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetUpDownByStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetUpDownByStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetUpDownByStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setUpDownByStatement() throws -> SetUpDownByStatementContext {
		var _localctx: SetUpDownByStatementContext = SetUpDownByStatementContext(_ctx, getState())
		try enterRule(_localctx, 872, Cobol85Parser.RULE_setUpDownByStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5092) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5091)
		 		try setTo()


		 		setState(5094); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5100)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.UP:
		 		setState(5096)
		 		try match(Cobol85Parser.UP)
		 		setState(5097)
		 		try match(Cobol85Parser.BY)

		 		break

		 	case Cobol85Parser.DOWN:
		 		setState(5098)
		 		try match(Cobol85Parser.DOWN)
		 		setState(5099)
		 		try match(Cobol85Parser.BY)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5102)
		 	try setByValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetToContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setTo }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetTo(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetTo(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetTo(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetTo(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setTo() throws -> SetToContext {
		var _localctx: SetToContext = SetToContext(_ctx, getState())
		try enterRule(_localctx, 874, Cobol85Parser.RULE_setTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5104)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetToValueContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func OFF() -> TerminalNode? { return getToken(Cobol85Parser.OFF, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setToValue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetToValue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetToValue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetToValue(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetToValue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setToValue() throws -> SetToValueContext {
		var _localctx: SetToValueContext = SetToValueContext(_ctx, getState())
		try enterRule(_localctx, 876, Cobol85Parser.RULE_setToValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5110)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,771, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5106)
		 		try match(Cobol85Parser.ON)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5107)
		 		try match(Cobol85Parser.OFF)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5108)
		 		try identifier()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5109)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SetByValueContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_setByValue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSetByValue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSetByValue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSetByValue(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSetByValue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func setByValue() throws -> SetByValueContext {
		var _localctx: SetByValueContext = SetByValueContext(_ctx, getState())
		try enterRule(_localctx, 878, Cobol85Parser.RULE_setByValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5114)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,772, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5112)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5113)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortStatementContext:ParserRuleContext {
		open func SORT() -> TerminalNode? { return getToken(Cobol85Parser.SORT, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func sortOnKeyClause() -> Array<SortOnKeyClauseContext> {
			return getRuleContexts(SortOnKeyClauseContext.self)
		}
		open func sortOnKeyClause(_ i: Int) -> SortOnKeyClauseContext? {
			return getRuleContext(SortOnKeyClauseContext.self,i)
		}
		open func sortDuplicatesPhrase() -> SortDuplicatesPhraseContext? {
			return getRuleContext(SortDuplicatesPhraseContext.self,0)
		}
		open func sortCollatingSequencePhrase() -> SortCollatingSequencePhraseContext? {
			return getRuleContext(SortCollatingSequencePhraseContext.self,0)
		}
		open func sortInputProcedurePhrase() -> SortInputProcedurePhraseContext? {
			return getRuleContext(SortInputProcedurePhraseContext.self,0)
		}
		open func sortUsing() -> Array<SortUsingContext> {
			return getRuleContexts(SortUsingContext.self)
		}
		open func sortUsing(_ i: Int) -> SortUsingContext? {
			return getRuleContext(SortUsingContext.self,i)
		}
		open func sortOutputProcedurePhrase() -> SortOutputProcedurePhraseContext? {
			return getRuleContext(SortOutputProcedurePhraseContext.self,0)
		}
		open func sortGivingPhrase() -> Array<SortGivingPhraseContext> {
			return getRuleContexts(SortGivingPhraseContext.self)
		}
		open func sortGivingPhrase(_ i: Int) -> SortGivingPhraseContext? {
			return getRuleContext(SortGivingPhraseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortStatement() throws -> SortStatementContext {
		var _localctx: SortStatementContext = SortStatementContext(_ctx, getState())
		try enterRule(_localctx, 880, Cobol85Parser.RULE_sortStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5116)
		 	try match(Cobol85Parser.SORT)
		 	setState(5117)
		 	try fileName()
		 	setState(5119); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5118)
		 			try sortOnKeyClause()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5121); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,773,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(5124)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,774,_ctx)) {
		 	case 1:
		 		setState(5123)
		 		try sortDuplicatesPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5127)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.COLLATING
		 	          testSet = testSet || _la == Cobol85Parser.SEQUENCE
		 	      return testSet
		 	 }()) {
		 		setState(5126)
		 		try sortCollatingSequencePhrase()

		 	}

		 	setState(5130)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.INPUT
		 	      return testSet
		 	 }()) {
		 		setState(5129)
		 		try sortInputProcedurePhrase()

		 	}

		 	setState(5135)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.USING
		 	      return testSet
		 	 }()) {
		 		setState(5132)
		 		try sortUsing()


		 		setState(5137)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5139)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OUTPUT
		 	      return testSet
		 	 }()) {
		 		setState(5138)
		 		try sortOutputProcedurePhrase()

		 	}

		 	setState(5144)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GIVING
		 	      return testSet
		 	 }()) {
		 		setState(5141)
		 		try sortGivingPhrase()


		 		setState(5146)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortOnKeyClauseContext:ParserRuleContext {
		open func ASCENDING() -> TerminalNode? { return getToken(Cobol85Parser.ASCENDING, 0) }
		open func DESCENDING() -> TerminalNode? { return getToken(Cobol85Parser.DESCENDING, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func qualifiedDataName() -> Array<QualifiedDataNameContext> {
			return getRuleContexts(QualifiedDataNameContext.self)
		}
		open func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortOnKeyClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortOnKeyClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortOnKeyClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortOnKeyClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortOnKeyClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortOnKeyClause() throws -> SortOnKeyClauseContext {
		var _localctx: SortOnKeyClauseContext = SortOnKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 882, Cobol85Parser.RULE_sortOnKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5148)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5147)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5150)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ASCENDING
		 	          testSet = testSet || _la == Cobol85Parser.DESCENDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5152)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(5151)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(5155) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5154)
		 		try qualifiedDataName()


		 		setState(5157); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortDuplicatesPhraseContext:ParserRuleContext {
		open func DUPLICATES() -> TerminalNode? { return getToken(Cobol85Parser.DUPLICATES, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func ORDER() -> TerminalNode? { return getToken(Cobol85Parser.ORDER, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortDuplicatesPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortDuplicatesPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortDuplicatesPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortDuplicatesPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortDuplicatesPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortDuplicatesPhrase() throws -> SortDuplicatesPhraseContext {
		var _localctx: SortDuplicatesPhraseContext = SortDuplicatesPhraseContext(_ctx, getState())
		try enterRule(_localctx, 884, Cobol85Parser.RULE_sortDuplicatesPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5160)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(5159)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(5162)
		 	try match(Cobol85Parser.DUPLICATES)
		 	setState(5164)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(5163)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(5167)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(5166)
		 		try match(Cobol85Parser.ORDER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortCollatingSequencePhraseContext:ParserRuleContext {
		open func SEQUENCE() -> TerminalNode? { return getToken(Cobol85Parser.SEQUENCE, 0) }
		open func COLLATING() -> TerminalNode? { return getToken(Cobol85Parser.COLLATING, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetName() -> Array<AlphabetNameContext> {
			return getRuleContexts(AlphabetNameContext.self)
		}
		open func alphabetName(_ i: Int) -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,i)
		}
		open func sortCollatingAlphanumeric() -> SortCollatingAlphanumericContext? {
			return getRuleContext(SortCollatingAlphanumericContext.self,0)
		}
		open func sortCollatingNational() -> SortCollatingNationalContext? {
			return getRuleContext(SortCollatingNationalContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortCollatingSequencePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortCollatingSequencePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortCollatingSequencePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortCollatingSequencePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortCollatingSequencePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortCollatingSequencePhrase() throws -> SortCollatingSequencePhraseContext {
		var _localctx: SortCollatingSequencePhraseContext = SortCollatingSequencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 886, Cobol85Parser.RULE_sortCollatingSequencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5170)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COLLATING
		 	      return testSet
		 	 }()) {
		 		setState(5169)
		 		try match(Cobol85Parser.COLLATING)

		 	}

		 	setState(5172)
		 	try match(Cobol85Parser.SEQUENCE)
		 	setState(5174)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5173)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5177); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5176)
		 			try alphabetName()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5179); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,788,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(5182)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,789,_ctx)) {
		 	case 1:
		 		setState(5181)
		 		try sortCollatingAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(5185)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FOR
		 	          testSet = testSet || _la == Cobol85Parser.NATIONAL
		 	      return testSet
		 	 }()) {
		 		setState(5184)
		 		try sortCollatingNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortCollatingAlphanumericContext:ParserRuleContext {
		open func ALPHANUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHANUMERIC, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortCollatingAlphanumeric }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortCollatingAlphanumeric(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortCollatingAlphanumeric(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortCollatingAlphanumeric(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortCollatingAlphanumeric(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortCollatingAlphanumeric() throws -> SortCollatingAlphanumericContext {
		var _localctx: SortCollatingAlphanumericContext = SortCollatingAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 888, Cobol85Parser.RULE_sortCollatingAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5188)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(5187)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(5190)
		 	try match(Cobol85Parser.ALPHANUMERIC)
		 	setState(5191)
		 	try match(Cobol85Parser.IS)
		 	setState(5192)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortCollatingNationalContext:ParserRuleContext {
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func alphabetName() -> AlphabetNameContext? {
			return getRuleContext(AlphabetNameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortCollatingNational }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortCollatingNational(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortCollatingNational(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortCollatingNational(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortCollatingNational(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortCollatingNational() throws -> SortCollatingNationalContext {
		var _localctx: SortCollatingNationalContext = SortCollatingNationalContext(_ctx, getState())
		try enterRule(_localctx, 890, Cobol85Parser.RULE_sortCollatingNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5195)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(5194)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(5197)
		 	try match(Cobol85Parser.NATIONAL)
		 	setState(5199)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5198)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5201)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortInputProcedurePhraseContext:ParserRuleContext {
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE, 0) }
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func sortInputThrough() -> SortInputThroughContext? {
			return getRuleContext(SortInputThroughContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortInputProcedurePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortInputProcedurePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortInputProcedurePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortInputProcedurePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortInputProcedurePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortInputProcedurePhrase() throws -> SortInputProcedurePhraseContext {
		var _localctx: SortInputProcedurePhraseContext = SortInputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 892, Cobol85Parser.RULE_sortInputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5203)
		 	try match(Cobol85Parser.INPUT)
		 	setState(5204)
		 	try match(Cobol85Parser.PROCEDURE)
		 	setState(5206)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5205)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5208)
		 	try procedureName()
		 	setState(5210)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(5209)
		 		try sortInputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortInputThroughContext:ParserRuleContext {
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortInputThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortInputThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortInputThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortInputThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortInputThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortInputThrough() throws -> SortInputThroughContext {
		var _localctx: SortInputThroughContext = SortInputThroughContext(_ctx, getState())
		try enterRule(_localctx, 894, Cobol85Parser.RULE_sortInputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5212)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5213)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortUsingContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(Cobol85Parser.USING, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortUsing }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortUsing(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortUsing(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortUsing(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortUsing(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortUsing() throws -> SortUsingContext {
		var _localctx: SortUsingContext = SortUsingContext(_ctx, getState())
		try enterRule(_localctx, 896, Cobol85Parser.RULE_sortUsing)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5215)
		 	try match(Cobol85Parser.USING)
		 	setState(5217) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5216)
		 		try fileName()


		 		setState(5219); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortOutputProcedurePhraseContext:ParserRuleContext {
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE, 0) }
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func sortOutputThrough() -> SortOutputThroughContext? {
			return getRuleContext(SortOutputThroughContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortOutputProcedurePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortOutputProcedurePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortOutputProcedurePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortOutputProcedurePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortOutputProcedurePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortOutputProcedurePhrase() throws -> SortOutputProcedurePhraseContext {
		var _localctx: SortOutputProcedurePhraseContext = SortOutputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 898, Cobol85Parser.RULE_sortOutputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5221)
		 	try match(Cobol85Parser.OUTPUT)
		 	setState(5222)
		 	try match(Cobol85Parser.PROCEDURE)
		 	setState(5224)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5223)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5226)
		 	try procedureName()
		 	setState(5228)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }()) {
		 		setState(5227)
		 		try sortOutputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortOutputThroughContext:ParserRuleContext {
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func THROUGH() -> TerminalNode? { return getToken(Cobol85Parser.THROUGH, 0) }
		open func THRU() -> TerminalNode? { return getToken(Cobol85Parser.THRU, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortOutputThrough }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortOutputThrough(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortOutputThrough(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortOutputThrough(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortOutputThrough(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortOutputThrough() throws -> SortOutputThroughContext {
		var _localctx: SortOutputThroughContext = SortOutputThroughContext(_ctx, getState())
		try enterRule(_localctx, 900, Cobol85Parser.RULE_sortOutputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5230)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.THROUGH || _la == Cobol85Parser.THRU
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5231)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortGivingPhraseContext:ParserRuleContext {
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func sortGiving() -> Array<SortGivingContext> {
			return getRuleContexts(SortGivingContext.self)
		}
		open func sortGiving(_ i: Int) -> SortGivingContext? {
			return getRuleContext(SortGivingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortGivingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortGivingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortGivingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortGivingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortGivingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortGivingPhrase() throws -> SortGivingPhraseContext {
		var _localctx: SortGivingPhraseContext = SortGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 902, Cobol85Parser.RULE_sortGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5233)
		 	try match(Cobol85Parser.GIVING)
		 	setState(5235) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5234)
		 		try sortGiving()


		 		setState(5237); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SortGivingContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func LOCK() -> TerminalNode? { return getToken(Cobol85Parser.LOCK, 0) }
		open func SAVE() -> TerminalNode? { return getToken(Cobol85Parser.SAVE, 0) }
		open func NO() -> TerminalNode? { return getToken(Cobol85Parser.NO, 0) }
		open func REWIND() -> TerminalNode? { return getToken(Cobol85Parser.REWIND, 0) }
		open func CRUNCH() -> TerminalNode? { return getToken(Cobol85Parser.CRUNCH, 0) }
		open func RELEASE() -> TerminalNode? { return getToken(Cobol85Parser.RELEASE, 0) }
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open func REMOVE() -> TerminalNode? { return getToken(Cobol85Parser.REMOVE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sortGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSortGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSortGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSortGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSortGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sortGiving() throws -> SortGivingContext {
		var _localctx: SortGivingContext = SortGivingContext(_ctx, getState())
		try enterRule(_localctx, 904, Cobol85Parser.RULE_sortGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5239)
		 	try fileName()
		 	setState(5249)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,800,_ctx)) {
		 	case 1:
		 		setState(5240)
		 		try match(Cobol85Parser.LOCK)

		 		break
		 	case 2:
		 		setState(5241)
		 		try match(Cobol85Parser.SAVE)

		 		break
		 	case 3:
		 		setState(5242)
		 		try match(Cobol85Parser.NO)
		 		setState(5243)
		 		try match(Cobol85Parser.REWIND)

		 		break
		 	case 4:
		 		setState(5244)
		 		try match(Cobol85Parser.CRUNCH)

		 		break
		 	case 5:
		 		setState(5245)
		 		try match(Cobol85Parser.RELEASE)

		 		break
		 	case 6:
		 		setState(5246)
		 		try match(Cobol85Parser.WITH)
		 		setState(5247)
		 		try match(Cobol85Parser.REMOVE)
		 		setState(5248)
		 		try match(Cobol85Parser.CRUNCH)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StartStatementContext:ParserRuleContext {
		open func START() -> TerminalNode? { return getToken(Cobol85Parser.START, 0) }
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func startKey() -> StartKeyContext? {
			return getRuleContext(StartKeyContext.self,0)
		}
		open func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
			return getRuleContext(InvalidKeyPhraseContext.self,0)
		}
		open func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
			return getRuleContext(NotInvalidKeyPhraseContext.self,0)
		}
		open func END_START() -> TerminalNode? { return getToken(Cobol85Parser.END_START, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_startStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStartStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStartStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStartStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStartStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func startStatement() throws -> StartStatementContext {
		var _localctx: StartStatementContext = StartStatementContext(_ctx, getState())
		try enterRule(_localctx, 906, Cobol85Parser.RULE_startStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5251)
		 	try match(Cobol85Parser.START)
		 	setState(5252)
		 	try fileName()
		 	setState(5254)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(5253)
		 		try startKey()

		 	}

		 	setState(5257)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,802,_ctx)) {
		 	case 1:
		 		setState(5256)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5260)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,803,_ctx)) {
		 	case 1:
		 		setState(5259)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5263)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,804,_ctx)) {
		 	case 1:
		 		setState(5262)
		 		try match(Cobol85Parser.END_START)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StartKeyContext:ParserRuleContext {
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func EQUAL() -> TerminalNode? { return getToken(Cobol85Parser.EQUAL, 0) }
		open func EQUALCHAR() -> TerminalNode? { return getToken(Cobol85Parser.EQUALCHAR, 0) }
		open func GREATER() -> TerminalNode? { return getToken(Cobol85Parser.GREATER, 0) }
		open func MORETHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MORETHANCHAR, 0) }
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func LESS() -> TerminalNode? { return getToken(Cobol85Parser.LESS, 0) }
		open func LESSTHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LESSTHANCHAR, 0) }
		open func OR() -> TerminalNode? { return getToken(Cobol85Parser.OR, 0) }
		open func MORETHANOREQUAL() -> TerminalNode? { return getToken(Cobol85Parser.MORETHANOREQUAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open func THAN() -> TerminalNode? { return getToken(Cobol85Parser.THAN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_startKey }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStartKey(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStartKey(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStartKey(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStartKey(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func startKey() throws -> StartKeyContext {
		var _localctx: StartKeyContext = StartKeyContext(_ctx, getState())
		try enterRule(_localctx, 908, Cobol85Parser.RULE_startKey)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5265)
		 	try match(Cobol85Parser.KEY)
		 	setState(5267)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5266)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5296)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,811, _ctx)) {
		 	case 1:
		 		setState(5269)
		 		try match(Cobol85Parser.EQUAL)
		 		setState(5271)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TO
		 		      return testSet
		 		 }()) {
		 			setState(5270)
		 			try match(Cobol85Parser.TO)

		 		}


		 		break
		 	case 2:
		 		setState(5273)
		 		try match(Cobol85Parser.EQUALCHAR)

		 		break
		 	case 3:
		 		setState(5274)
		 		try match(Cobol85Parser.GREATER)
		 		setState(5276)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THAN
		 		      return testSet
		 		 }()) {
		 			setState(5275)
		 			try match(Cobol85Parser.THAN)

		 		}


		 		break
		 	case 4:
		 		setState(5278)
		 		try match(Cobol85Parser.MORETHANCHAR)

		 		break
		 	case 5:
		 		setState(5279)
		 		try match(Cobol85Parser.NOT)
		 		setState(5280)
		 		try match(Cobol85Parser.LESS)
		 		setState(5282)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THAN
		 		      return testSet
		 		 }()) {
		 			setState(5281)
		 			try match(Cobol85Parser.THAN)

		 		}


		 		break
		 	case 6:
		 		setState(5284)
		 		try match(Cobol85Parser.NOT)
		 		setState(5285)
		 		try match(Cobol85Parser.LESSTHANCHAR)

		 		break
		 	case 7:
		 		setState(5286)
		 		try match(Cobol85Parser.GREATER)
		 		setState(5288)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THAN
		 		      return testSet
		 		 }()) {
		 			setState(5287)
		 			try match(Cobol85Parser.THAN)

		 		}

		 		setState(5290)
		 		try match(Cobol85Parser.OR)
		 		setState(5291)
		 		try match(Cobol85Parser.EQUAL)
		 		setState(5293)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TO
		 		      return testSet
		 		 }()) {
		 			setState(5292)
		 			try match(Cobol85Parser.TO)

		 		}


		 		break
		 	case 8:
		 		setState(5295)
		 		try match(Cobol85Parser.MORETHANOREQUAL)

		 		break
		 	default: break
		 	}
		 	setState(5298)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StopStatementContext:ParserRuleContext {
		open func STOP() -> TerminalNode? { return getToken(Cobol85Parser.STOP, 0) }
		open func RUN() -> TerminalNode? { return getToken(Cobol85Parser.RUN, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stopStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStopStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStopStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStopStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStopStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stopStatement() throws -> StopStatementContext {
		var _localctx: StopStatementContext = StopStatementContext(_ctx, getState())
		try enterRule(_localctx, 910, Cobol85Parser.RULE_stopStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5300)
		 	try match(Cobol85Parser.STOP)
		 	setState(5303)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.RUN:
		 		setState(5301)
		 		try match(Cobol85Parser.RUN)

		 		break
		 	case Cobol85Parser.ALL:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.FALSE:fallthrough
		 	case Cobol85Parser.HIGH_VALUE:fallthrough
		 	case Cobol85Parser.HIGH_VALUES:fallthrough
		 	case Cobol85Parser.LOW_VALUE:fallthrough
		 	case Cobol85Parser.LOW_VALUES:fallthrough
		 	case Cobol85Parser.NULL:fallthrough
		 	case Cobol85Parser.NULLS:fallthrough
		 	case Cobol85Parser.QUOTE:fallthrough
		 	case Cobol85Parser.QUOTES:fallthrough
		 	case Cobol85Parser.SPACE:fallthrough
		 	case Cobol85Parser.SPACES:fallthrough
		 	case Cobol85Parser.TRUE:fallthrough
		 	case Cobol85Parser.ZERO:fallthrough
		 	case Cobol85Parser.ZEROS:fallthrough
		 	case Cobol85Parser.ZEROES:fallthrough
		 	case Cobol85Parser.NONNUMERICLITERAL:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:fallthrough
		 	case Cobol85Parser.NUMERICLITERAL:
		 		setState(5302)
		 		try literal()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringStatementContext:ParserRuleContext {
		open func STRING() -> TerminalNode? { return getToken(Cobol85Parser.STRING, 0) }
		open func stringIntoPhrase() -> StringIntoPhraseContext? {
			return getRuleContext(StringIntoPhraseContext.self,0)
		}
		open func stringSendingPhrase() -> Array<StringSendingPhraseContext> {
			return getRuleContexts(StringSendingPhraseContext.self)
		}
		open func stringSendingPhrase(_ i: Int) -> StringSendingPhraseContext? {
			return getRuleContext(StringSendingPhraseContext.self,i)
		}
		open func stringWithPointerPhrase() -> StringWithPointerPhraseContext? {
			return getRuleContext(StringWithPointerPhraseContext.self,0)
		}
		open func onOverflowPhrase() -> OnOverflowPhraseContext? {
			return getRuleContext(OnOverflowPhraseContext.self,0)
		}
		open func notOnOverflowPhrase() -> NotOnOverflowPhraseContext? {
			return getRuleContext(NotOnOverflowPhraseContext.self,0)
		}
		open func END_STRING() -> TerminalNode? { return getToken(Cobol85Parser.END_STRING, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringStatement() throws -> StringStatementContext {
		var _localctx: StringStatementContext = StringStatementContext(_ctx, getState())
		try enterRule(_localctx, 912, Cobol85Parser.RULE_stringStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5305)
		 	try match(Cobol85Parser.STRING)
		 	setState(5307) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5306)
		 		try stringSendingPhrase()


		 		setState(5309); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5311)
		 	try stringIntoPhrase()
		 	setState(5313)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,814,_ctx)) {
		 	case 1:
		 		setState(5312)
		 		try stringWithPointerPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5316)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,815,_ctx)) {
		 	case 1:
		 		setState(5315)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5319)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,816,_ctx)) {
		 	case 1:
		 		setState(5318)
		 		try notOnOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5322)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,817,_ctx)) {
		 	case 1:
		 		setState(5321)
		 		try match(Cobol85Parser.END_STRING)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringSendingPhraseContext:ParserRuleContext {
		open func stringDelimitedByPhrase() -> StringDelimitedByPhraseContext? {
			return getRuleContext(StringDelimitedByPhraseContext.self,0)
		}
		open func stringForPhrase() -> StringForPhraseContext? {
			return getRuleContext(StringForPhraseContext.self,0)
		}
		open func stringSending() -> Array<StringSendingContext> {
			return getRuleContexts(StringSendingContext.self)
		}
		open func stringSending(_ i: Int) -> StringSendingContext? {
			return getRuleContext(StringSendingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringSendingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringSendingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringSendingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringSendingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringSendingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringSendingPhrase() throws -> StringSendingPhraseContext {
		var _localctx: StringSendingPhraseContext = StringSendingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 914, Cobol85Parser.RULE_stringSendingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5325) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5324)
		 		try stringSending()


		 		setState(5327); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5331)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.DELIMITED:
		 		setState(5329)
		 		try stringDelimitedByPhrase()

		 		break

		 	case Cobol85Parser.FOR:
		 		setState(5330)
		 		try stringForPhrase()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringSendingContext:ParserRuleContext {
		open func tableCall() -> TableCallContext? {
			return getRuleContext(TableCallContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringSending }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringSending(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringSending(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringSending(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringSending(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringSending() throws -> StringSendingContext {
		var _localctx: StringSendingContext = StringSendingContext(_ctx, getState())
		try enterRule(_localctx, 916, Cobol85Parser.RULE_stringSending)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5335)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,820, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5333)
		 		try tableCall()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5334)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringDelimitedByPhraseContext:ParserRuleContext {
		open func DELIMITED() -> TerminalNode? { return getToken(Cobol85Parser.DELIMITED, 0) }
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringDelimitedByPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringDelimitedByPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringDelimitedByPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringDelimitedByPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringDelimitedByPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringDelimitedByPhrase() throws -> StringDelimitedByPhraseContext {
		var _localctx: StringDelimitedByPhraseContext = StringDelimitedByPhraseContext(_ctx, getState())
		try enterRule(_localctx, 918, Cobol85Parser.RULE_stringDelimitedByPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5337)
		 	try match(Cobol85Parser.DELIMITED)
		 	setState(5339)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BY
		 	      return testSet
		 	 }()) {
		 		setState(5338)
		 		try match(Cobol85Parser.BY)

		 	}

		 	setState(5344)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,822, _ctx)) {
		 	case 1:
		 		setState(5341)
		 		try match(Cobol85Parser.SIZE)

		 		break
		 	case 2:
		 		setState(5342)
		 		try identifier()

		 		break
		 	case 3:
		 		setState(5343)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringForPhraseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringForPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringForPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringForPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringForPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringForPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringForPhrase() throws -> StringForPhraseContext {
		var _localctx: StringForPhraseContext = StringForPhraseContext(_ctx, getState())
		try enterRule(_localctx, 920, Cobol85Parser.RULE_stringForPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5346)
		 	try match(Cobol85Parser.FOR)
		 	setState(5349)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,823, _ctx)) {
		 	case 1:
		 		setState(5347)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5348)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringIntoPhraseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringIntoPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringIntoPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringIntoPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringIntoPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringIntoPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringIntoPhrase() throws -> StringIntoPhraseContext {
		var _localctx: StringIntoPhraseContext = StringIntoPhraseContext(_ctx, getState())
		try enterRule(_localctx, 922, Cobol85Parser.RULE_stringIntoPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5351)
		 	try match(Cobol85Parser.INTO)
		 	setState(5352)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StringWithPointerPhraseContext:ParserRuleContext {
		open func POINTER() -> TerminalNode? { return getToken(Cobol85Parser.POINTER, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_stringWithPointerPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterStringWithPointerPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitStringWithPointerPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitStringWithPointerPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitStringWithPointerPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func stringWithPointerPhrase() throws -> StringWithPointerPhraseContext {
		var _localctx: StringWithPointerPhraseContext = StringWithPointerPhraseContext(_ctx, getState())
		try enterRule(_localctx, 924, Cobol85Parser.RULE_stringWithPointerPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5355)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(5354)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(5357)
		 	try match(Cobol85Parser.POINTER)
		 	setState(5358)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractStatementContext:ParserRuleContext {
		open func SUBTRACT() -> TerminalNode? { return getToken(Cobol85Parser.SUBTRACT, 0) }
		open func subtractFromStatement() -> SubtractFromStatementContext? {
			return getRuleContext(SubtractFromStatementContext.self,0)
		}
		open func subtractFromGivingStatement() -> SubtractFromGivingStatementContext? {
			return getRuleContext(SubtractFromGivingStatementContext.self,0)
		}
		open func subtractCorrespondingStatement() -> SubtractCorrespondingStatementContext? {
			return getRuleContext(SubtractCorrespondingStatementContext.self,0)
		}
		open func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
			return getRuleContext(OnSizeErrorPhraseContext.self,0)
		}
		open func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
			return getRuleContext(NotOnSizeErrorPhraseContext.self,0)
		}
		open func END_SUBTRACT() -> TerminalNode? { return getToken(Cobol85Parser.END_SUBTRACT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractStatement() throws -> SubtractStatementContext {
		var _localctx: SubtractStatementContext = SubtractStatementContext(_ctx, getState())
		try enterRule(_localctx, 926, Cobol85Parser.RULE_subtractStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5360)
		 	try match(Cobol85Parser.SUBTRACT)
		 	setState(5364)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,825, _ctx)) {
		 	case 1:
		 		setState(5361)
		 		try subtractFromStatement()

		 		break
		 	case 2:
		 		setState(5362)
		 		try subtractFromGivingStatement()

		 		break
		 	case 3:
		 		setState(5363)
		 		try subtractCorrespondingStatement()

		 		break
		 	default: break
		 	}
		 	setState(5367)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,826,_ctx)) {
		 	case 1:
		 		setState(5366)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5370)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,827,_ctx)) {
		 	case 1:
		 		setState(5369)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5373)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,828,_ctx)) {
		 	case 1:
		 		setState(5372)
		 		try match(Cobol85Parser.END_SUBTRACT)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractFromStatementContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func subtractSubtrahend() -> Array<SubtractSubtrahendContext> {
			return getRuleContexts(SubtractSubtrahendContext.self)
		}
		open func subtractSubtrahend(_ i: Int) -> SubtractSubtrahendContext? {
			return getRuleContext(SubtractSubtrahendContext.self,i)
		}
		open func subtractMinuend() -> Array<SubtractMinuendContext> {
			return getRuleContexts(SubtractMinuendContext.self)
		}
		open func subtractMinuend(_ i: Int) -> SubtractMinuendContext? {
			return getRuleContext(SubtractMinuendContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractFromStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractFromStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractFromStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractFromStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractFromStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractFromStatement() throws -> SubtractFromStatementContext {
		var _localctx: SubtractFromStatementContext = SubtractFromStatementContext(_ctx, getState())
		try enterRule(_localctx, 928, Cobol85Parser.RULE_subtractFromStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5376) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5375)
		 		try subtractSubtrahend()


		 		setState(5378); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5380)
		 	try match(Cobol85Parser.FROM)
		 	setState(5382) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5381)
		 		try subtractMinuend()


		 		setState(5384); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractFromGivingStatementContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func subtractMinuendGiving() -> SubtractMinuendGivingContext? {
			return getRuleContext(SubtractMinuendGivingContext.self,0)
		}
		open func GIVING() -> TerminalNode? { return getToken(Cobol85Parser.GIVING, 0) }
		open func subtractSubtrahend() -> Array<SubtractSubtrahendContext> {
			return getRuleContexts(SubtractSubtrahendContext.self)
		}
		open func subtractSubtrahend(_ i: Int) -> SubtractSubtrahendContext? {
			return getRuleContext(SubtractSubtrahendContext.self,i)
		}
		open func subtractGiving() -> Array<SubtractGivingContext> {
			return getRuleContexts(SubtractGivingContext.self)
		}
		open func subtractGiving(_ i: Int) -> SubtractGivingContext? {
			return getRuleContext(SubtractGivingContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractFromGivingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractFromGivingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractFromGivingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractFromGivingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractFromGivingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractFromGivingStatement() throws -> SubtractFromGivingStatementContext {
		var _localctx: SubtractFromGivingStatementContext = SubtractFromGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 930, Cobol85Parser.RULE_subtractFromGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5387) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5386)
		 		try subtractSubtrahend()


		 		setState(5389); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 555)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5391)
		 	try match(Cobol85Parser.FROM)
		 	setState(5392)
		 	try subtractMinuendGiving()
		 	setState(5393)
		 	try match(Cobol85Parser.GIVING)
		 	setState(5395) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5394)
		 		try subtractGiving()


		 		setState(5397); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractCorrespondingStatementContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func subtractMinuendCorresponding() -> SubtractMinuendCorrespondingContext? {
			return getRuleContext(SubtractMinuendCorrespondingContext.self,0)
		}
		open func CORRESPONDING() -> TerminalNode? { return getToken(Cobol85Parser.CORRESPONDING, 0) }
		open func CORR() -> TerminalNode? { return getToken(Cobol85Parser.CORR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractCorrespondingStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractCorrespondingStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractCorrespondingStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractCorrespondingStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractCorrespondingStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractCorrespondingStatement() throws -> SubtractCorrespondingStatementContext {
		var _localctx: SubtractCorrespondingStatementContext = SubtractCorrespondingStatementContext(_ctx, getState())
		try enterRule(_localctx, 932, Cobol85Parser.RULE_subtractCorrespondingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5399)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.CORR || _la == Cobol85Parser.CORRESPONDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5400)
		 	try qualifiedDataName()
		 	setState(5401)
		 	try match(Cobol85Parser.FROM)
		 	setState(5402)
		 	try subtractMinuendCorresponding()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractSubtrahendContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractSubtrahend }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractSubtrahend(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractSubtrahend(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractSubtrahend(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractSubtrahend(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractSubtrahend() throws -> SubtractSubtrahendContext {
		var _localctx: SubtractSubtrahendContext = SubtractSubtrahendContext(_ctx, getState())
		try enterRule(_localctx, 934, Cobol85Parser.RULE_subtractSubtrahend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5406)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,833, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5404)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5405)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractMinuendContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractMinuend }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractMinuend(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractMinuend(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractMinuend(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractMinuend(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractMinuend() throws -> SubtractMinuendContext {
		var _localctx: SubtractMinuendContext = SubtractMinuendContext(_ctx, getState())
		try enterRule(_localctx, 936, Cobol85Parser.RULE_subtractMinuend)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5408)
		 	try identifier()
		 	setState(5410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(5409)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractMinuendGivingContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractMinuendGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractMinuendGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractMinuendGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractMinuendGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractMinuendGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractMinuendGiving() throws -> SubtractMinuendGivingContext {
		var _localctx: SubtractMinuendGivingContext = SubtractMinuendGivingContext(_ctx, getState())
		try enterRule(_localctx, 938, Cobol85Parser.RULE_subtractMinuendGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5414)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,835, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5412)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5413)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractGivingContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractGiving }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractGiving(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractGiving(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractGiving(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractGiving(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractGiving() throws -> SubtractGivingContext {
		var _localctx: SubtractGivingContext = SubtractGivingContext(_ctx, getState())
		try enterRule(_localctx, 940, Cobol85Parser.RULE_subtractGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5416)
		 	try identifier()
		 	setState(5418)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(5417)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubtractMinuendCorrespondingContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func ROUNDED() -> TerminalNode? { return getToken(Cobol85Parser.ROUNDED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subtractMinuendCorresponding }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubtractMinuendCorresponding(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubtractMinuendCorresponding(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubtractMinuendCorresponding(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubtractMinuendCorresponding(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtractMinuendCorresponding() throws -> SubtractMinuendCorrespondingContext {
		var _localctx: SubtractMinuendCorrespondingContext = SubtractMinuendCorrespondingContext(_ctx, getState())
		try enterRule(_localctx, 942, Cobol85Parser.RULE_subtractMinuendCorresponding)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5420)
		 	try qualifiedDataName()
		 	setState(5422)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ROUNDED
		 	      return testSet
		 	 }()) {
		 		setState(5421)
		 		try match(Cobol85Parser.ROUNDED)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TerminateStatementContext:ParserRuleContext {
		open func TERMINATE() -> TerminalNode? { return getToken(Cobol85Parser.TERMINATE, 0) }
		open func reportName() -> ReportNameContext? {
			return getRuleContext(ReportNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_terminateStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterTerminateStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitTerminateStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitTerminateStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitTerminateStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func terminateStatement() throws -> TerminateStatementContext {
		var _localctx: TerminateStatementContext = TerminateStatementContext(_ctx, getState())
		try enterRule(_localctx, 944, Cobol85Parser.RULE_terminateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5424)
		 	try match(Cobol85Parser.TERMINATE)
		 	setState(5425)
		 	try reportName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringStatementContext:ParserRuleContext {
		open func UNSTRING() -> TerminalNode? { return getToken(Cobol85Parser.UNSTRING, 0) }
		open func unstringSendingPhrase() -> UnstringSendingPhraseContext? {
			return getRuleContext(UnstringSendingPhraseContext.self,0)
		}
		open func unstringIntoPhrase() -> UnstringIntoPhraseContext? {
			return getRuleContext(UnstringIntoPhraseContext.self,0)
		}
		open func unstringWithPointerPhrase() -> UnstringWithPointerPhraseContext? {
			return getRuleContext(UnstringWithPointerPhraseContext.self,0)
		}
		open func unstringTallyingPhrase() -> UnstringTallyingPhraseContext? {
			return getRuleContext(UnstringTallyingPhraseContext.self,0)
		}
		open func onOverflowPhrase() -> OnOverflowPhraseContext? {
			return getRuleContext(OnOverflowPhraseContext.self,0)
		}
		open func notOnOverflowPhrase() -> NotOnOverflowPhraseContext? {
			return getRuleContext(NotOnOverflowPhraseContext.self,0)
		}
		open func END_UNSTRING() -> TerminalNode? { return getToken(Cobol85Parser.END_UNSTRING, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringStatement() throws -> UnstringStatementContext {
		var _localctx: UnstringStatementContext = UnstringStatementContext(_ctx, getState())
		try enterRule(_localctx, 946, Cobol85Parser.RULE_unstringStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5427)
		 	try match(Cobol85Parser.UNSTRING)
		 	setState(5428)
		 	try unstringSendingPhrase()
		 	setState(5429)
		 	try unstringIntoPhrase()
		 	setState(5431)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,838,_ctx)) {
		 	case 1:
		 		setState(5430)
		 		try unstringWithPointerPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5434)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.TALLYING
		 	      return testSet
		 	 }()) {
		 		setState(5433)
		 		try unstringTallyingPhrase()

		 	}

		 	setState(5437)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,840,_ctx)) {
		 	case 1:
		 		setState(5436)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5440)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,841,_ctx)) {
		 	case 1:
		 		setState(5439)
		 		try notOnOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5443)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,842,_ctx)) {
		 	case 1:
		 		setState(5442)
		 		try match(Cobol85Parser.END_UNSTRING)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringSendingPhraseContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func unstringDelimitedByPhrase() -> UnstringDelimitedByPhraseContext? {
			return getRuleContext(UnstringDelimitedByPhraseContext.self,0)
		}
		open func unstringOrAllPhrase() -> Array<UnstringOrAllPhraseContext> {
			return getRuleContexts(UnstringOrAllPhraseContext.self)
		}
		open func unstringOrAllPhrase(_ i: Int) -> UnstringOrAllPhraseContext? {
			return getRuleContext(UnstringOrAllPhraseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringSendingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringSendingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringSendingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringSendingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringSendingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringSendingPhrase() throws -> UnstringSendingPhraseContext {
		var _localctx: UnstringSendingPhraseContext = UnstringSendingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 948, Cobol85Parser.RULE_unstringSendingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5445)
		 	try qualifiedDataName()
		 	setState(5453)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DELIMITED
		 	      return testSet
		 	 }()) {
		 		setState(5446)
		 		try unstringDelimitedByPhrase()
		 		setState(5450)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.OR
		 		      return testSet
		 		 }()) {
		 			setState(5447)
		 			try unstringOrAllPhrase()


		 			setState(5452)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringDelimitedByPhraseContext:ParserRuleContext {
		open func DELIMITED() -> TerminalNode? { return getToken(Cobol85Parser.DELIMITED, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(Cobol85Parser.BY, 0) }
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringDelimitedByPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringDelimitedByPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringDelimitedByPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringDelimitedByPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringDelimitedByPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringDelimitedByPhrase() throws -> UnstringDelimitedByPhraseContext {
		var _localctx: UnstringDelimitedByPhraseContext = UnstringDelimitedByPhraseContext(_ctx, getState())
		try enterRule(_localctx, 950, Cobol85Parser.RULE_unstringDelimitedByPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5455)
		 	try match(Cobol85Parser.DELIMITED)
		 	setState(5457)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.BY
		 	      return testSet
		 	 }()) {
		 		setState(5456)
		 		try match(Cobol85Parser.BY)

		 	}

		 	setState(5460)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,846,_ctx)) {
		 	case 1:
		 		setState(5459)
		 		try match(Cobol85Parser.ALL)

		 		break
		 	default: break
		 	}
		 	setState(5464)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,847, _ctx)) {
		 	case 1:
		 		setState(5462)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5463)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringOrAllPhraseContext:ParserRuleContext {
		open func OR() -> TerminalNode? { return getToken(Cobol85Parser.OR, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringOrAllPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringOrAllPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringOrAllPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringOrAllPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringOrAllPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringOrAllPhrase() throws -> UnstringOrAllPhraseContext {
		var _localctx: UnstringOrAllPhraseContext = UnstringOrAllPhraseContext(_ctx, getState())
		try enterRule(_localctx, 952, Cobol85Parser.RULE_unstringOrAllPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5466)
		 	try match(Cobol85Parser.OR)
		 	setState(5468)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,848,_ctx)) {
		 	case 1:
		 		setState(5467)
		 		try match(Cobol85Parser.ALL)

		 		break
		 	default: break
		 	}
		 	setState(5472)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,849, _ctx)) {
		 	case 1:
		 		setState(5470)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5471)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringIntoPhraseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(Cobol85Parser.INTO, 0) }
		open func unstringInto() -> Array<UnstringIntoContext> {
			return getRuleContexts(UnstringIntoContext.self)
		}
		open func unstringInto(_ i: Int) -> UnstringIntoContext? {
			return getRuleContext(UnstringIntoContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringIntoPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringIntoPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringIntoPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringIntoPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringIntoPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringIntoPhrase() throws -> UnstringIntoPhraseContext {
		var _localctx: UnstringIntoPhraseContext = UnstringIntoPhraseContext(_ctx, getState())
		try enterRule(_localctx, 954, Cobol85Parser.RULE_unstringIntoPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5474)
		 	try match(Cobol85Parser.INTO)
		 	setState(5476) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5475)
		 		try unstringInto()


		 		setState(5478); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringIntoContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func unstringDelimiterIn() -> UnstringDelimiterInContext? {
			return getRuleContext(UnstringDelimiterInContext.self,0)
		}
		open func unstringCountIn() -> UnstringCountInContext? {
			return getRuleContext(UnstringCountInContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringInto }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringInto(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringInto(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringInto(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringInto(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringInto() throws -> UnstringIntoContext {
		var _localctx: UnstringIntoContext = UnstringIntoContext(_ctx, getState())
		try enterRule(_localctx, 956, Cobol85Parser.RULE_unstringInto)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5480)
		 	try identifier()
		 	setState(5482)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DELIMITER
		 	      return testSet
		 	 }()) {
		 		setState(5481)
		 		try unstringDelimiterIn()

		 	}

		 	setState(5485)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COUNT
		 	      return testSet
		 	 }()) {
		 		setState(5484)
		 		try unstringCountIn()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringDelimiterInContext:ParserRuleContext {
		open func DELIMITER() -> TerminalNode? { return getToken(Cobol85Parser.DELIMITER, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringDelimiterIn }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringDelimiterIn(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringDelimiterIn(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringDelimiterIn(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringDelimiterIn(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringDelimiterIn() throws -> UnstringDelimiterInContext {
		var _localctx: UnstringDelimiterInContext = UnstringDelimiterInContext(_ctx, getState())
		try enterRule(_localctx, 958, Cobol85Parser.RULE_unstringDelimiterIn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5487)
		 	try match(Cobol85Parser.DELIMITER)
		 	setState(5489)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(5488)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(5491)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringCountInContext:ParserRuleContext {
		open func COUNT() -> TerminalNode? { return getToken(Cobol85Parser.COUNT, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringCountIn }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringCountIn(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringCountIn(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringCountIn(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringCountIn(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringCountIn() throws -> UnstringCountInContext {
		var _localctx: UnstringCountInContext = UnstringCountInContext(_ctx, getState())
		try enterRule(_localctx, 960, Cobol85Parser.RULE_unstringCountIn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5493)
		 	try match(Cobol85Parser.COUNT)
		 	setState(5495)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(5494)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(5497)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringWithPointerPhraseContext:ParserRuleContext {
		open func POINTER() -> TerminalNode? { return getToken(Cobol85Parser.POINTER, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(Cobol85Parser.WITH, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringWithPointerPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringWithPointerPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringWithPointerPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringWithPointerPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringWithPointerPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringWithPointerPhrase() throws -> UnstringWithPointerPhraseContext {
		var _localctx: UnstringWithPointerPhraseContext = UnstringWithPointerPhraseContext(_ctx, getState())
		try enterRule(_localctx, 962, Cobol85Parser.RULE_unstringWithPointerPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(5499)
		 		try match(Cobol85Parser.WITH)

		 	}

		 	setState(5502)
		 	try match(Cobol85Parser.POINTER)
		 	setState(5503)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnstringTallyingPhraseContext:ParserRuleContext {
		open func TALLYING() -> TerminalNode? { return getToken(Cobol85Parser.TALLYING, 0) }
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_unstringTallyingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUnstringTallyingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUnstringTallyingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUnstringTallyingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUnstringTallyingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unstringTallyingPhrase() throws -> UnstringTallyingPhraseContext {
		var _localctx: UnstringTallyingPhraseContext = UnstringTallyingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 964, Cobol85Parser.RULE_unstringTallyingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5505)
		 	try match(Cobol85Parser.TALLYING)
		 	setState(5507)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IN
		 	      return testSet
		 	 }()) {
		 		setState(5506)
		 		try match(Cobol85Parser.IN)

		 	}

		 	setState(5509)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UseStatementContext:ParserRuleContext {
		open func USE() -> TerminalNode? { return getToken(Cobol85Parser.USE, 0) }
		open func useAfterClause() -> UseAfterClauseContext? {
			return getRuleContext(UseAfterClauseContext.self,0)
		}
		open func useDebugClause() -> UseDebugClauseContext? {
			return getRuleContext(UseDebugClauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_useStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUseStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUseStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUseStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUseStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func useStatement() throws -> UseStatementContext {
		var _localctx: UseStatementContext = UseStatementContext(_ctx, getState())
		try enterRule(_localctx, 966, Cobol85Parser.RULE_useStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5511)
		 	try match(Cobol85Parser.USE)
		 	setState(5514)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.AFTER:fallthrough
		 	case Cobol85Parser.GLOBAL:
		 		setState(5512)
		 		try useAfterClause()

		 		break
		 	case Cobol85Parser.DEBUGGING:fallthrough
		 	case Cobol85Parser.FOR:
		 		setState(5513)
		 		try useDebugClause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UseAfterClauseContext:ParserRuleContext {
		open func AFTER() -> TerminalNode? { return getToken(Cobol85Parser.AFTER, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURE, 0) }
		open func useAfterOn() -> UseAfterOnContext? {
			return getRuleContext(UseAfterOnContext.self,0)
		}
		open func EXCEPTION() -> TerminalNode? { return getToken(Cobol85Parser.EXCEPTION, 0) }
		open func ERROR() -> TerminalNode? { return getToken(Cobol85Parser.ERROR, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(Cobol85Parser.GLOBAL, 0) }
		open func STANDARD() -> TerminalNode? { return getToken(Cobol85Parser.STANDARD, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_useAfterClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUseAfterClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUseAfterClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUseAfterClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUseAfterClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func useAfterClause() throws -> UseAfterClauseContext {
		var _localctx: UseAfterClauseContext = UseAfterClauseContext(_ctx, getState())
		try enterRule(_localctx, 968, Cobol85Parser.RULE_useAfterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5517)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.GLOBAL
		 	      return testSet
		 	 }()) {
		 		setState(5516)
		 		try match(Cobol85Parser.GLOBAL)

		 	}

		 	setState(5519)
		 	try match(Cobol85Parser.AFTER)
		 	setState(5521)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.STANDARD
		 	      return testSet
		 	 }()) {
		 		setState(5520)
		 		try match(Cobol85Parser.STANDARD)

		 	}

		 	setState(5523)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ERROR || _la == Cobol85Parser.EXCEPTION
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5524)
		 	try match(Cobol85Parser.PROCEDURE)
		 	setState(5526)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5525)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5528)
		 	try useAfterOn()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UseAfterOnContext:ParserRuleContext {
		open func INPUT() -> TerminalNode? { return getToken(Cobol85Parser.INPUT, 0) }
		open func OUTPUT() -> TerminalNode? { return getToken(Cobol85Parser.OUTPUT, 0) }
		open func I_O() -> TerminalNode? { return getToken(Cobol85Parser.I_O, 0) }
		open func EXTEND() -> TerminalNode? { return getToken(Cobol85Parser.EXTEND, 0) }
		open func fileName() -> Array<FileNameContext> {
			return getRuleContexts(FileNameContext.self)
		}
		open func fileName(_ i: Int) -> FileNameContext? {
			return getRuleContext(FileNameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_useAfterOn }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUseAfterOn(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUseAfterOn(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUseAfterOn(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUseAfterOn(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func useAfterOn() throws -> UseAfterOnContext {
		var _localctx: UseAfterOnContext = UseAfterOnContext(_ctx, getState())
		try enterRule(_localctx, 970, Cobol85Parser.RULE_useAfterOn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5539)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.INPUT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5530)
		 		try match(Cobol85Parser.INPUT)

		 		break

		 	case Cobol85Parser.OUTPUT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5531)
		 		try match(Cobol85Parser.OUTPUT)

		 		break

		 	case Cobol85Parser.I_O:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5532)
		 		try match(Cobol85Parser.I_O)

		 		break

		 	case Cobol85Parser.EXTEND:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5533)
		 		try match(Cobol85Parser.EXTEND)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5535) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(5534)
		 			try fileName()


		 			setState(5537); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 		              return  Utils.testBitLeftShiftArray(testArray, 70)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 141)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 		              return  Utils.testBitLeftShiftArray(testArray, 205)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 270)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 		              return  Utils.testBitLeftShiftArray(testArray, 402)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 		              return  Utils.testBitLeftShiftArray(testArray, 470)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 		      return testSet
		 		 }())

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UseDebugClauseContext:ParserRuleContext {
		open func DEBUGGING() -> TerminalNode? { return getToken(Cobol85Parser.DEBUGGING, 0) }
		open func FOR() -> TerminalNode? { return getToken(Cobol85Parser.FOR, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func useDebugOn() -> Array<UseDebugOnContext> {
			return getRuleContexts(UseDebugOnContext.self)
		}
		open func useDebugOn(_ i: Int) -> UseDebugOnContext? {
			return getRuleContext(UseDebugOnContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_useDebugClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUseDebugClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUseDebugClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUseDebugClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUseDebugClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func useDebugClause() throws -> UseDebugClauseContext {
		var _localctx: UseDebugClauseContext = UseDebugClauseContext(_ctx, getState())
		try enterRule(_localctx, 972, Cobol85Parser.RULE_useDebugClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5542)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(5541)
		 		try match(Cobol85Parser.FOR)

		 	}

		 	setState(5544)
		 	try match(Cobol85Parser.DEBUGGING)
		 	setState(5546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5545)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5549) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5548)
		 		try useDebugOn()


		 		setState(5551); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UseDebugOnContext:ParserRuleContext {
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func PROCEDURES() -> TerminalNode? { return getToken(Cobol85Parser.PROCEDURES, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func REFERENCES() -> TerminalNode? { return getToken(Cobol85Parser.REFERENCES, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open func procedureName() -> ProcedureNameContext? {
			return getRuleContext(ProcedureNameContext.self,0)
		}
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_useDebugOn }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterUseDebugOn(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitUseDebugOn(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitUseDebugOn(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitUseDebugOn(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func useDebugOn() throws -> UseDebugOnContext {
		var _localctx: UseDebugOnContext = UseDebugOnContext(_ctx, getState())
		try enterRule(_localctx, 974, Cobol85Parser.RULE_useDebugOn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5565)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,868, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5553)
		 		try match(Cobol85Parser.ALL)
		 		setState(5554)
		 		try match(Cobol85Parser.PROCEDURES)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5555)
		 		try match(Cobol85Parser.ALL)
		 		setState(5557)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.REFERENCES
		 		      return testSet
		 		 }()) {
		 			setState(5556)
		 			try match(Cobol85Parser.REFERENCES)

		 		}

		 		setState(5560)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.OF
		 		      return testSet
		 		 }()) {
		 			setState(5559)
		 			try match(Cobol85Parser.OF)

		 		}

		 		setState(5562)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5563)
		 		try procedureName()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5564)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteStatementContext:ParserRuleContext {
		open func WRITE() -> TerminalNode? { return getToken(Cobol85Parser.WRITE, 0) }
		open func recordName() -> RecordNameContext? {
			return getRuleContext(RecordNameContext.self,0)
		}
		open func writeFromPhrase() -> WriteFromPhraseContext? {
			return getRuleContext(WriteFromPhraseContext.self,0)
		}
		open func writeAdvancingPhrase() -> WriteAdvancingPhraseContext? {
			return getRuleContext(WriteAdvancingPhraseContext.self,0)
		}
		open func writeAtEndOfPagePhrase() -> WriteAtEndOfPagePhraseContext? {
			return getRuleContext(WriteAtEndOfPagePhraseContext.self,0)
		}
		open func writeNotAtEndOfPagePhrase() -> WriteNotAtEndOfPagePhraseContext? {
			return getRuleContext(WriteNotAtEndOfPagePhraseContext.self,0)
		}
		open func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
			return getRuleContext(InvalidKeyPhraseContext.self,0)
		}
		open func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
			return getRuleContext(NotInvalidKeyPhraseContext.self,0)
		}
		open func END_WRITE() -> TerminalNode? { return getToken(Cobol85Parser.END_WRITE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeStatement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteStatement(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeStatement() throws -> WriteStatementContext {
		var _localctx: WriteStatementContext = WriteStatementContext(_ctx, getState())
		try enterRule(_localctx, 976, Cobol85Parser.RULE_writeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5567)
		 	try match(Cobol85Parser.WRITE)
		 	setState(5568)
		 	try recordName()
		 	setState(5570)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.FROM
		 	      return testSet
		 	 }()) {
		 		setState(5569)
		 		try writeFromPhrase()

		 	}

		 	setState(5573)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }()) {
		 		setState(5572)
		 		try writeAdvancingPhrase()

		 	}

		 	setState(5576)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,871,_ctx)) {
		 	case 1:
		 		setState(5575)
		 		try writeAtEndOfPagePhrase()

		 		break
		 	default: break
		 	}
		 	setState(5579)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,872,_ctx)) {
		 	case 1:
		 		setState(5578)
		 		try writeNotAtEndOfPagePhrase()

		 		break
		 	default: break
		 	}
		 	setState(5582)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,873,_ctx)) {
		 	case 1:
		 		setState(5581)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5585)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,874,_ctx)) {
		 	case 1:
		 		setState(5584)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5588)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,875,_ctx)) {
		 	case 1:
		 		setState(5587)
		 		try match(Cobol85Parser.END_WRITE)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteFromPhraseContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(Cobol85Parser.FROM, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeFromPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteFromPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteFromPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteFromPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteFromPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeFromPhrase() throws -> WriteFromPhraseContext {
		var _localctx: WriteFromPhraseContext = WriteFromPhraseContext(_ctx, getState())
		try enterRule(_localctx, 978, Cobol85Parser.RULE_writeFromPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5590)
		 	try match(Cobol85Parser.FROM)
		 	setState(5593)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,876, _ctx)) {
		 	case 1:
		 		setState(5591)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5592)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteAdvancingPhraseContext:ParserRuleContext {
		open func BEFORE() -> TerminalNode? { return getToken(Cobol85Parser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(Cobol85Parser.AFTER, 0) }
		open func writeAdvancingPage() -> WriteAdvancingPageContext? {
			return getRuleContext(WriteAdvancingPageContext.self,0)
		}
		open func writeAdvancingLines() -> WriteAdvancingLinesContext? {
			return getRuleContext(WriteAdvancingLinesContext.self,0)
		}
		open func writeAdvancingMnemonic() -> WriteAdvancingMnemonicContext? {
			return getRuleContext(WriteAdvancingMnemonicContext.self,0)
		}
		open func ADVANCING() -> TerminalNode? { return getToken(Cobol85Parser.ADVANCING, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeAdvancingPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteAdvancingPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteAdvancingPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteAdvancingPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteAdvancingPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeAdvancingPhrase() throws -> WriteAdvancingPhraseContext {
		var _localctx: WriteAdvancingPhraseContext = WriteAdvancingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 980, Cobol85Parser.RULE_writeAdvancingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5595)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AFTER || _la == Cobol85Parser.BEFORE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5597)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ADVANCING
		 	      return testSet
		 	 }()) {
		 		setState(5596)
		 		try match(Cobol85Parser.ADVANCING)

		 	}

		 	setState(5602)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,878, _ctx)) {
		 	case 1:
		 		setState(5599)
		 		try writeAdvancingPage()

		 		break
		 	case 2:
		 		setState(5600)
		 		try writeAdvancingLines()

		 		break
		 	case 3:
		 		setState(5601)
		 		try writeAdvancingMnemonic()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteAdvancingPageContext:ParserRuleContext {
		open func PAGE() -> TerminalNode? { return getToken(Cobol85Parser.PAGE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeAdvancingPage }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteAdvancingPage(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteAdvancingPage(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteAdvancingPage(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteAdvancingPage(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeAdvancingPage() throws -> WriteAdvancingPageContext {
		var _localctx: WriteAdvancingPageContext = WriteAdvancingPageContext(_ctx, getState())
		try enterRule(_localctx, 982, Cobol85Parser.RULE_writeAdvancingPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5604)
		 	try match(Cobol85Parser.PAGE)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteAdvancingLinesContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func LINE() -> TerminalNode? { return getToken(Cobol85Parser.LINE, 0) }
		open func LINES() -> TerminalNode? { return getToken(Cobol85Parser.LINES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeAdvancingLines }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteAdvancingLines(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteAdvancingLines(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteAdvancingLines(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteAdvancingLines(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeAdvancingLines() throws -> WriteAdvancingLinesContext {
		var _localctx: WriteAdvancingLinesContext = WriteAdvancingLinesContext(_ctx, getState())
		try enterRule(_localctx, 984, Cobol85Parser.RULE_writeAdvancingLines)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5608)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,879, _ctx)) {
		 	case 1:
		 		setState(5606)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5607)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5611)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 	      return testSet
		 	 }()) {
		 		setState(5610)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.LINE || _la == Cobol85Parser.LINES
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteAdvancingMnemonicContext:ParserRuleContext {
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeAdvancingMnemonic }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteAdvancingMnemonic(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteAdvancingMnemonic(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteAdvancingMnemonic(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteAdvancingMnemonic(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeAdvancingMnemonic() throws -> WriteAdvancingMnemonicContext {
		var _localctx: WriteAdvancingMnemonicContext = WriteAdvancingMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 986, Cobol85Parser.RULE_writeAdvancingMnemonic)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5613)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteAtEndOfPagePhraseContext:ParserRuleContext {
		open func END_OF_PAGE() -> TerminalNode? { return getToken(Cobol85Parser.END_OF_PAGE, 0) }
		open func EOP() -> TerminalNode? { return getToken(Cobol85Parser.EOP, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeAtEndOfPagePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteAtEndOfPagePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteAtEndOfPagePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteAtEndOfPagePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteAtEndOfPagePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeAtEndOfPagePhrase() throws -> WriteAtEndOfPagePhraseContext {
		var _localctx: WriteAtEndOfPagePhraseContext = WriteAtEndOfPagePhraseContext(_ctx, getState())
		try enterRule(_localctx, 988, Cobol85Parser.RULE_writeAtEndOfPagePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5616)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(5615)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(5618)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.END_OF_PAGE || _la == Cobol85Parser.EOP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5622)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,882,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5619)
		 			try statement()

		 	 
		 		}
		 		setState(5624)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,882,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class WriteNotAtEndOfPagePhraseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func END_OF_PAGE() -> TerminalNode? { return getToken(Cobol85Parser.END_OF_PAGE, 0) }
		open func EOP() -> TerminalNode? { return getToken(Cobol85Parser.EOP, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_writeNotAtEndOfPagePhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterWriteNotAtEndOfPagePhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitWriteNotAtEndOfPagePhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitWriteNotAtEndOfPagePhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitWriteNotAtEndOfPagePhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func writeNotAtEndOfPagePhrase() throws -> WriteNotAtEndOfPagePhraseContext {
		var _localctx: WriteNotAtEndOfPagePhraseContext = WriteNotAtEndOfPagePhraseContext(_ctx, getState())
		try enterRule(_localctx, 990, Cobol85Parser.RULE_writeNotAtEndOfPagePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5625)
		 	try match(Cobol85Parser.NOT)
		 	setState(5627)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(5626)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(5629)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.END_OF_PAGE || _la == Cobol85Parser.EOP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5633)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,884,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5630)
		 			try statement()

		 	 
		 		}
		 		setState(5635)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,884,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AtEndPhraseContext:ParserRuleContext {
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_atEndPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAtEndPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAtEndPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAtEndPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAtEndPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func atEndPhrase() throws -> AtEndPhraseContext {
		var _localctx: AtEndPhraseContext = AtEndPhraseContext(_ctx, getState())
		try enterRule(_localctx, 992, Cobol85Parser.RULE_atEndPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5637)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(5636)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(5639)
		 	try match(Cobol85Parser.END)
		 	setState(5643)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,886,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5640)
		 			try statement()

		 	 
		 		}
		 		setState(5645)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,886,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NotAtEndPhraseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func END() -> TerminalNode? { return getToken(Cobol85Parser.END, 0) }
		open func AT() -> TerminalNode? { return getToken(Cobol85Parser.AT, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_notAtEndPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNotAtEndPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNotAtEndPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNotAtEndPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNotAtEndPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func notAtEndPhrase() throws -> NotAtEndPhraseContext {
		var _localctx: NotAtEndPhraseContext = NotAtEndPhraseContext(_ctx, getState())
		try enterRule(_localctx, 994, Cobol85Parser.RULE_notAtEndPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5646)
		 	try match(Cobol85Parser.NOT)
		 	setState(5648)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.AT
		 	      return testSet
		 	 }()) {
		 		setState(5647)
		 		try match(Cobol85Parser.AT)

		 	}

		 	setState(5650)
		 	try match(Cobol85Parser.END)
		 	setState(5654)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,888,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5651)
		 			try statement()

		 	 
		 		}
		 		setState(5656)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,888,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InvalidKeyPhraseContext:ParserRuleContext {
		open func INVALID() -> TerminalNode? { return getToken(Cobol85Parser.INVALID, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_invalidKeyPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInvalidKeyPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInvalidKeyPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInvalidKeyPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInvalidKeyPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func invalidKeyPhrase() throws -> InvalidKeyPhraseContext {
		var _localctx: InvalidKeyPhraseContext = InvalidKeyPhraseContext(_ctx, getState())
		try enterRule(_localctx, 996, Cobol85Parser.RULE_invalidKeyPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5657)
		 	try match(Cobol85Parser.INVALID)
		 	setState(5659)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(5658)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(5664)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,890,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5661)
		 			try statement()

		 	 
		 		}
		 		setState(5666)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,890,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NotInvalidKeyPhraseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func INVALID() -> TerminalNode? { return getToken(Cobol85Parser.INVALID, 0) }
		open func KEY() -> TerminalNode? { return getToken(Cobol85Parser.KEY, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_notInvalidKeyPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNotInvalidKeyPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNotInvalidKeyPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNotInvalidKeyPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNotInvalidKeyPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func notInvalidKeyPhrase() throws -> NotInvalidKeyPhraseContext {
		var _localctx: NotInvalidKeyPhraseContext = NotInvalidKeyPhraseContext(_ctx, getState())
		try enterRule(_localctx, 998, Cobol85Parser.RULE_notInvalidKeyPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5667)
		 	try match(Cobol85Parser.NOT)
		 	setState(5668)
		 	try match(Cobol85Parser.INVALID)
		 	setState(5670)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.KEY
		 	      return testSet
		 	 }()) {
		 		setState(5669)
		 		try match(Cobol85Parser.KEY)

		 	}

		 	setState(5675)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,892,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5672)
		 			try statement()

		 	 
		 		}
		 		setState(5677)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,892,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OnOverflowPhraseContext:ParserRuleContext {
		open func OVERFLOW() -> TerminalNode? { return getToken(Cobol85Parser.OVERFLOW, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_onOverflowPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOnOverflowPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOnOverflowPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOnOverflowPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOnOverflowPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func onOverflowPhrase() throws -> OnOverflowPhraseContext {
		var _localctx: OnOverflowPhraseContext = OnOverflowPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1000, Cobol85Parser.RULE_onOverflowPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5679)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5678)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5681)
		 	try match(Cobol85Parser.OVERFLOW)
		 	setState(5685)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,894,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5682)
		 			try statement()

		 	 
		 		}
		 		setState(5687)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,894,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NotOnOverflowPhraseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func OVERFLOW() -> TerminalNode? { return getToken(Cobol85Parser.OVERFLOW, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_notOnOverflowPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNotOnOverflowPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNotOnOverflowPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNotOnOverflowPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNotOnOverflowPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func notOnOverflowPhrase() throws -> NotOnOverflowPhraseContext {
		var _localctx: NotOnOverflowPhraseContext = NotOnOverflowPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1002, Cobol85Parser.RULE_notOnOverflowPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5688)
		 	try match(Cobol85Parser.NOT)
		 	setState(5690)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5689)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5692)
		 	try match(Cobol85Parser.OVERFLOW)
		 	setState(5696)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,896,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5693)
		 			try statement()

		 	 
		 		}
		 		setState(5698)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,896,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OnSizeErrorPhraseContext:ParserRuleContext {
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func ERROR() -> TerminalNode? { return getToken(Cobol85Parser.ERROR, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_onSizeErrorPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOnSizeErrorPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOnSizeErrorPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOnSizeErrorPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOnSizeErrorPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func onSizeErrorPhrase() throws -> OnSizeErrorPhraseContext {
		var _localctx: OnSizeErrorPhraseContext = OnSizeErrorPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1004, Cobol85Parser.RULE_onSizeErrorPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5700)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5699)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5702)
		 	try match(Cobol85Parser.SIZE)
		 	setState(5703)
		 	try match(Cobol85Parser.ERROR)
		 	setState(5707)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,898,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5704)
		 			try statement()

		 	 
		 		}
		 		setState(5709)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,898,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NotOnSizeErrorPhraseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SIZE, 0) }
		open func ERROR() -> TerminalNode? { return getToken(Cobol85Parser.ERROR, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_notOnSizeErrorPhrase }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNotOnSizeErrorPhrase(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNotOnSizeErrorPhrase(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNotOnSizeErrorPhrase(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNotOnSizeErrorPhrase(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func notOnSizeErrorPhrase() throws -> NotOnSizeErrorPhraseContext {
		var _localctx: NotOnSizeErrorPhraseContext = NotOnSizeErrorPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1006, Cobol85Parser.RULE_notOnSizeErrorPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5710)
		 	try match(Cobol85Parser.NOT)
		 	setState(5712)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5711)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5714)
		 	try match(Cobol85Parser.SIZE)
		 	setState(5715)
		 	try match(Cobol85Parser.ERROR)
		 	setState(5719)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,900,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5716)
		 			try statement()

		 	 
		 		}
		 		setState(5721)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,900,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OnExceptionClauseContext:ParserRuleContext {
		open func EXCEPTION() -> TerminalNode? { return getToken(Cobol85Parser.EXCEPTION, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_onExceptionClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterOnExceptionClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitOnExceptionClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitOnExceptionClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitOnExceptionClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func onExceptionClause() throws -> OnExceptionClauseContext {
		var _localctx: OnExceptionClauseContext = OnExceptionClauseContext(_ctx, getState())
		try enterRule(_localctx, 1008, Cobol85Parser.RULE_onExceptionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5723)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5722)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5725)
		 	try match(Cobol85Parser.EXCEPTION)
		 	setState(5729)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,902,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5726)
		 			try statement()

		 	 
		 		}
		 		setState(5731)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,902,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NotOnExceptionClauseContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func EXCEPTION() -> TerminalNode? { return getToken(Cobol85Parser.EXCEPTION, 0) }
		open func ON() -> TerminalNode? { return getToken(Cobol85Parser.ON, 0) }
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_notOnExceptionClause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNotOnExceptionClause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNotOnExceptionClause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNotOnExceptionClause(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNotOnExceptionClause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func notOnExceptionClause() throws -> NotOnExceptionClauseContext {
		var _localctx: NotOnExceptionClauseContext = NotOnExceptionClauseContext(_ctx, getState())
		try enterRule(_localctx, 1010, Cobol85Parser.RULE_notOnExceptionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5732)
		 	try match(Cobol85Parser.NOT)
		 	setState(5734)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ON
		 	      return testSet
		 	 }()) {
		 		setState(5733)
		 		try match(Cobol85Parser.ON)

		 	}

		 	setState(5736)
		 	try match(Cobol85Parser.EXCEPTION)
		 	setState(5740)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,904,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5737)
		 			try statement()

		 	 
		 		}
		 		setState(5742)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,904,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ArithmeticExpressionContext:ParserRuleContext {
		open func multDivs() -> MultDivsContext? {
			return getRuleContext(MultDivsContext.self,0)
		}
		open func plusMinus() -> Array<PlusMinusContext> {
			return getRuleContexts(PlusMinusContext.self)
		}
		open func plusMinus(_ i: Int) -> PlusMinusContext? {
			return getRuleContext(PlusMinusContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_arithmeticExpression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterArithmeticExpression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitArithmeticExpression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitArithmeticExpression(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitArithmeticExpression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func arithmeticExpression() throws -> ArithmeticExpressionContext {
		var _localctx: ArithmeticExpressionContext = ArithmeticExpressionContext(_ctx, getState())
		try enterRule(_localctx, 1012, Cobol85Parser.RULE_arithmeticExpression)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5743)
		 	try multDivs()
		 	setState(5747)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,905,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5744)
		 			try plusMinus()

		 	 
		 		}
		 		setState(5749)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,905,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PlusMinusContext:ParserRuleContext {
		open func multDivs() -> MultDivsContext? {
			return getRuleContext(MultDivsContext.self,0)
		}
		open func PLUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.PLUSCHAR, 0) }
		open func MINUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MINUSCHAR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_plusMinus }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPlusMinus(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPlusMinus(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPlusMinus(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPlusMinus(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func plusMinus() throws -> PlusMinusContext {
		var _localctx: PlusMinusContext = PlusMinusContext(_ctx, getState())
		try enterRule(_localctx, 1014, Cobol85Parser.RULE_plusMinus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5750)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5751)
		 	try multDivs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultDivsContext:ParserRuleContext {
		open func powers() -> PowersContext? {
			return getRuleContext(PowersContext.self,0)
		}
		open func multDiv() -> Array<MultDivContext> {
			return getRuleContexts(MultDivContext.self)
		}
		open func multDiv(_ i: Int) -> MultDivContext? {
			return getRuleContext(MultDivContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multDivs }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultDivs(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultDivs(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultDivs(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultDivs(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multDivs() throws -> MultDivsContext {
		var _localctx: MultDivsContext = MultDivsContext(_ctx, getState())
		try enterRule(_localctx, 1016, Cobol85Parser.RULE_multDivs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5753)
		 	try powers()
		 	setState(5757)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ASTERISKCHAR || _la == Cobol85Parser.SLASHCHAR
		 	      return testSet
		 	 }()) {
		 		setState(5754)
		 		try multDiv()


		 		setState(5759)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MultDivContext:ParserRuleContext {
		open func powers() -> PowersContext? {
			return getRuleContext(PowersContext.self,0)
		}
		open func ASTERISKCHAR() -> TerminalNode? { return getToken(Cobol85Parser.ASTERISKCHAR, 0) }
		open func SLASHCHAR() -> TerminalNode? { return getToken(Cobol85Parser.SLASHCHAR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_multDiv }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMultDiv(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMultDiv(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMultDiv(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMultDiv(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multDiv() throws -> MultDivContext {
		var _localctx: MultDivContext = MultDivContext(_ctx, getState())
		try enterRule(_localctx, 1018, Cobol85Parser.RULE_multDiv)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5760)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.ASTERISKCHAR || _la == Cobol85Parser.SLASHCHAR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5761)
		 	try powers()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PowersContext:ParserRuleContext {
		open func basis() -> BasisContext? {
			return getRuleContext(BasisContext.self,0)
		}
		open func power() -> Array<PowerContext> {
			return getRuleContexts(PowerContext.self)
		}
		open func power(_ i: Int) -> PowerContext? {
			return getRuleContext(PowerContext.self,i)
		}
		open func PLUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.PLUSCHAR, 0) }
		open func MINUSCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MINUSCHAR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_powers }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPowers(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPowers(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPowers(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPowers(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func powers() throws -> PowersContext {
		var _localctx: PowersContext = PowersContext(_ctx, getState())
		try enterRule(_localctx, 1020, Cobol85Parser.RULE_powers)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5764)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 	      return testSet
		 	 }()) {
		 		setState(5763)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.MINUSCHAR || _la == Cobol85Parser.PLUSCHAR
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(5766)
		 	try basis()
		 	setState(5770)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.DOUBLEASTERISKCHAR
		 	      return testSet
		 	 }()) {
		 		setState(5767)
		 		try power()


		 		setState(5772)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PowerContext:ParserRuleContext {
		open func DOUBLEASTERISKCHAR() -> TerminalNode? { return getToken(Cobol85Parser.DOUBLEASTERISKCHAR, 0) }
		open func basis() -> BasisContext? {
			return getRuleContext(BasisContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_power }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterPower(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitPower(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitPower(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitPower(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func power() throws -> PowerContext {
		var _localctx: PowerContext = PowerContext(_ctx, getState())
		try enterRule(_localctx, 1022, Cobol85Parser.RULE_power)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5773)
		 	try match(Cobol85Parser.DOUBLEASTERISKCHAR)
		 	setState(5774)
		 	try basis()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BasisContext:ParserRuleContext {
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_basis }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterBasis(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitBasis(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitBasis(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitBasis(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func basis() throws -> BasisContext {
		var _localctx: BasisContext = BasisContext(_ctx, getState())
		try enterRule(_localctx, 1024, Cobol85Parser.RULE_basis)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5782)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,909, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5776)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(5777)
		 		try arithmeticExpression()
		 		setState(5778)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5780)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5781)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionContext:ParserRuleContext {
		open func combinableCondition() -> CombinableConditionContext? {
			return getRuleContext(CombinableConditionContext.self,0)
		}
		open func andOrCondition() -> Array<AndOrConditionContext> {
			return getRuleContexts(AndOrConditionContext.self)
		}
		open func andOrCondition(_ i: Int) -> AndOrConditionContext? {
			return getRuleContext(AndOrConditionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_condition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func condition() throws -> ConditionContext {
		var _localctx: ConditionContext = ConditionContext(_ctx, getState())
		try enterRule(_localctx, 1026, Cobol85Parser.RULE_condition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5784)
		 	try combinableCondition()
		 	setState(5788)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.AND
		 	          testSet = testSet || _la == Cobol85Parser.OR
		 	      return testSet
		 	 }()) {
		 		setState(5785)
		 		try andOrCondition()


		 		setState(5790)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AndOrConditionContext:ParserRuleContext {
		open func AND() -> TerminalNode? { return getToken(Cobol85Parser.AND, 0) }
		open func OR() -> TerminalNode? { return getToken(Cobol85Parser.OR, 0) }
		open func combinableCondition() -> CombinableConditionContext? {
			return getRuleContext(CombinableConditionContext.self,0)
		}
		open func abbreviation() -> Array<AbbreviationContext> {
			return getRuleContexts(AbbreviationContext.self)
		}
		open func abbreviation(_ i: Int) -> AbbreviationContext? {
			return getRuleContext(AbbreviationContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_andOrCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAndOrCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAndOrCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAndOrCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAndOrCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func andOrCondition() throws -> AndOrConditionContext {
		var _localctx: AndOrConditionContext = AndOrConditionContext(_ctx, getState())
		try enterRule(_localctx, 1028, Cobol85Parser.RULE_andOrCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5791)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.AND
		 	          testSet = testSet || _la == Cobol85Parser.OR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(5798)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,912, _ctx)) {
		 	case 1:
		 		setState(5792)
		 		try combinableCondition()

		 		break
		 	case 2:
		 		setState(5794); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(5793)
		 				try abbreviation()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(5796); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,911,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CombinableConditionContext:ParserRuleContext {
		open func simpleCondition() -> SimpleConditionContext? {
			return getRuleContext(SimpleConditionContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_combinableCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCombinableCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCombinableCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCombinableCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCombinableCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func combinableCondition() throws -> CombinableConditionContext {
		var _localctx: CombinableConditionContext = CombinableConditionContext(_ctx, getState())
		try enterRule(_localctx, 1030, Cobol85Parser.RULE_combinableCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5801)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(5800)
		 		try match(Cobol85Parser.NOT)

		 	}

		 	setState(5803)
		 	try simpleCondition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SimpleConditionContext:ParserRuleContext {
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func relationCondition() -> RelationConditionContext? {
			return getRuleContext(RelationConditionContext.self,0)
		}
		open func classCondition() -> ClassConditionContext? {
			return getRuleContext(ClassConditionContext.self,0)
		}
		open func conditionNameReference() -> ConditionNameReferenceContext? {
			return getRuleContext(ConditionNameReferenceContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_simpleCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSimpleCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSimpleCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSimpleCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSimpleCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simpleCondition() throws -> SimpleConditionContext {
		var _localctx: SimpleConditionContext = SimpleConditionContext(_ctx, getState())
		try enterRule(_localctx, 1032, Cobol85Parser.RULE_simpleCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5812)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,914, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5805)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(5806)
		 		try condition()
		 		setState(5807)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5809)
		 		try relationCondition()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5810)
		 		try classCondition()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5811)
		 		try conditionNameReference()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassConditionContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func NUMERIC() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC, 0) }
		open func ALPHABETIC() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABETIC, 0) }
		open func ALPHABETIC_LOWER() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABETIC_LOWER, 0) }
		open func ALPHABETIC_UPPER() -> TerminalNode? { return getToken(Cobol85Parser.ALPHABETIC_UPPER, 0) }
		open func DBCS() -> TerminalNode? { return getToken(Cobol85Parser.DBCS, 0) }
		open func KANJI() -> TerminalNode? { return getToken(Cobol85Parser.KANJI, 0) }
		open func className() -> ClassNameContext? {
			return getRuleContext(ClassNameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_classCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func classCondition() throws -> ClassConditionContext {
		var _localctx: ClassConditionContext = ClassConditionContext(_ctx, getState())
		try enterRule(_localctx, 1034, Cobol85Parser.RULE_classCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5814)
		 	try identifier()
		 	setState(5816)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5815)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5819)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(5818)
		 		try match(Cobol85Parser.NOT)

		 	}

		 	setState(5828)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NUMERIC:
		 		setState(5821)
		 		try match(Cobol85Parser.NUMERIC)

		 		break

		 	case Cobol85Parser.ALPHABETIC:
		 		setState(5822)
		 		try match(Cobol85Parser.ALPHABETIC)

		 		break

		 	case Cobol85Parser.ALPHABETIC_LOWER:
		 		setState(5823)
		 		try match(Cobol85Parser.ALPHABETIC_LOWER)

		 		break

		 	case Cobol85Parser.ALPHABETIC_UPPER:
		 		setState(5824)
		 		try match(Cobol85Parser.ALPHABETIC_UPPER)

		 		break

		 	case Cobol85Parser.DBCS:
		 		setState(5825)
		 		try match(Cobol85Parser.DBCS)

		 		break

		 	case Cobol85Parser.KANJI:
		 		setState(5826)
		 		try match(Cobol85Parser.KANJI)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		setState(5827)
		 		try className()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionNameReferenceContext:ParserRuleContext {
		open func conditionName() -> ConditionNameContext? {
			return getRuleContext(ConditionNameContext.self,0)
		}
		open func inData() -> Array<InDataContext> {
			return getRuleContexts(InDataContext.self)
		}
		open func inData(_ i: Int) -> InDataContext? {
			return getRuleContext(InDataContext.self,i)
		}
		open func inFile() -> InFileContext? {
			return getRuleContext(InFileContext.self,0)
		}
		open func conditionNameSubscriptReference() -> Array<ConditionNameSubscriptReferenceContext> {
			return getRuleContexts(ConditionNameSubscriptReferenceContext.self)
		}
		open func conditionNameSubscriptReference(_ i: Int) -> ConditionNameSubscriptReferenceContext? {
			return getRuleContext(ConditionNameSubscriptReferenceContext.self,i)
		}
		open func inMnemonic() -> Array<InMnemonicContext> {
			return getRuleContexts(InMnemonicContext.self)
		}
		open func inMnemonic(_ i: Int) -> InMnemonicContext? {
			return getRuleContext(InMnemonicContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_conditionNameReference }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterConditionNameReference(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitConditionNameReference(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitConditionNameReference(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitConditionNameReference(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditionNameReference() throws -> ConditionNameReferenceContext {
		var _localctx: ConditionNameReferenceContext = ConditionNameReferenceContext(_ctx, getState())
		try enterRule(_localctx, 1036, Cobol85Parser.RULE_conditionNameReference)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5830)
		 	try conditionName()
		 	setState(5852)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,922, _ctx)) {
		 	case 1:
		 		setState(5834)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,918,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(5831)
		 				try inData()

		 		 
		 			}
		 			setState(5836)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,918,_ctx)
		 		}
		 		setState(5838)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.IN
		 		          testSet = testSet || _la == Cobol85Parser.OF
		 		      return testSet
		 		 }()) {
		 			setState(5837)
		 			try inFile()

		 		}

		 		setState(5843)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.LPARENCHAR
		 		      return testSet
		 		 }()) {
		 			setState(5840)
		 			try conditionNameSubscriptReference()


		 			setState(5845)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		setState(5849)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.IN
		 		          testSet = testSet || _la == Cobol85Parser.OF
		 		      return testSet
		 		 }()) {
		 			setState(5846)
		 			try inMnemonic()


		 			setState(5851)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionNameSubscriptReferenceContext:ParserRuleContext {
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func subscript() -> Array<SubscriptContext> {
			return getRuleContexts(SubscriptContext.self)
		}
		open func subscript(_ i: Int) -> SubscriptContext? {
			return getRuleContext(SubscriptContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_conditionNameSubscriptReference }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterConditionNameSubscriptReference(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitConditionNameSubscriptReference(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitConditionNameSubscriptReference(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitConditionNameSubscriptReference(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditionNameSubscriptReference() throws -> ConditionNameSubscriptReferenceContext {
		var _localctx: ConditionNameSubscriptReferenceContext = ConditionNameSubscriptReferenceContext(_ctx, getState())
		try enterRule(_localctx, 1038, Cobol85Parser.RULE_conditionNameSubscriptReference)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5854)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(5856) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5855)
		 		try subscript()


		 		setState(5858); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LPARENCHAR,Cobol85Parser.MINUSCHAR,Cobol85Parser.PLUSCHAR,Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 547)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5860)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationConditionContext:ParserRuleContext {
		open func relationSignCondition() -> RelationSignConditionContext? {
			return getRuleContext(RelationSignConditionContext.self,0)
		}
		open func relationArithmeticComparison() -> RelationArithmeticComparisonContext? {
			return getRuleContext(RelationArithmeticComparisonContext.self,0)
		}
		open func relationCombinedComparison() -> RelationCombinedComparisonContext? {
			return getRuleContext(RelationCombinedComparisonContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationCondition() throws -> RelationConditionContext {
		var _localctx: RelationConditionContext = RelationConditionContext(_ctx, getState())
		try enterRule(_localctx, 1040, Cobol85Parser.RULE_relationCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5865)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,924, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5862)
		 		try relationSignCondition()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5863)
		 		try relationArithmeticComparison()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5864)
		 		try relationCombinedComparison()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationSignConditionContext:ParserRuleContext {
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func POSITIVE() -> TerminalNode? { return getToken(Cobol85Parser.POSITIVE, 0) }
		open func NEGATIVE() -> TerminalNode? { return getToken(Cobol85Parser.NEGATIVE, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationSignCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationSignCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationSignCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationSignCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationSignCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationSignCondition() throws -> RelationSignConditionContext {
		var _localctx: RelationSignConditionContext = RelationSignConditionContext(_ctx, getState())
		try enterRule(_localctx, 1042, Cobol85Parser.RULE_relationSignCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5867)
		 	try arithmeticExpression()
		 	setState(5869)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5868)
		 		try match(Cobol85Parser.IS)

		 	}

		 	setState(5872)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(5871)
		 		try match(Cobol85Parser.NOT)

		 	}

		 	setState(5874)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.NEGATIVE || _la == Cobol85Parser.POSITIVE
		 	          testSet = testSet || _la == Cobol85Parser.ZERO
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationArithmeticComparisonContext:ParserRuleContext {
		open func arithmeticExpression() -> Array<ArithmeticExpressionContext> {
			return getRuleContexts(ArithmeticExpressionContext.self)
		}
		open func arithmeticExpression(_ i: Int) -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,i)
		}
		open func relationalOperator() -> RelationalOperatorContext? {
			return getRuleContext(RelationalOperatorContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationArithmeticComparison }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationArithmeticComparison(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationArithmeticComparison(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationArithmeticComparison(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationArithmeticComparison(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationArithmeticComparison() throws -> RelationArithmeticComparisonContext {
		var _localctx: RelationArithmeticComparisonContext = RelationArithmeticComparisonContext(_ctx, getState())
		try enterRule(_localctx, 1044, Cobol85Parser.RULE_relationArithmeticComparison)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5876)
		 	try arithmeticExpression()
		 	setState(5877)
		 	try relationalOperator()
		 	setState(5878)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationCombinedComparisonContext:ParserRuleContext {
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func relationalOperator() -> RelationalOperatorContext? {
			return getRuleContext(RelationalOperatorContext.self,0)
		}
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func relationCombinedCondition() -> RelationCombinedConditionContext? {
			return getRuleContext(RelationCombinedConditionContext.self,0)
		}
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationCombinedComparison }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationCombinedComparison(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationCombinedComparison(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationCombinedComparison(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationCombinedComparison(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationCombinedComparison() throws -> RelationCombinedComparisonContext {
		var _localctx: RelationCombinedComparisonContext = RelationCombinedComparisonContext(_ctx, getState())
		try enterRule(_localctx, 1046, Cobol85Parser.RULE_relationCombinedComparison)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5880)
		 	try arithmeticExpression()
		 	setState(5881)
		 	try relationalOperator()
		 	setState(5882)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(5883)
		 	try relationCombinedCondition()
		 	setState(5884)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationCombinedConditionContext:ParserRuleContext {
		open func arithmeticExpression() -> Array<ArithmeticExpressionContext> {
			return getRuleContexts(ArithmeticExpressionContext.self)
		}
		open func arithmeticExpression(_ i: Int) -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,i)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.OR) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.OR, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationCombinedCondition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationCombinedCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationCombinedCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationCombinedCondition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationCombinedCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationCombinedCondition() throws -> RelationCombinedConditionContext {
		var _localctx: RelationCombinedConditionContext = RelationCombinedConditionContext(_ctx, getState())
		try enterRule(_localctx, 1048, Cobol85Parser.RULE_relationCombinedCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5886)
		 	try arithmeticExpression()
		 	setState(5889) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5887)
		 		try match(Cobol85Parser.OR)
		 		setState(5888)
		 		try arithmeticExpression()


		 		setState(5891); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.OR
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RelationalOperatorContext:ParserRuleContext {
		open func GREATER() -> TerminalNode? { return getToken(Cobol85Parser.GREATER, 0) }
		open func OR() -> TerminalNode? { return getToken(Cobol85Parser.OR, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(Cobol85Parser.EQUAL, 0) }
		open func MORETHANOREQUAL() -> TerminalNode? { return getToken(Cobol85Parser.MORETHANOREQUAL, 0) }
		open func LESS() -> TerminalNode? { return getToken(Cobol85Parser.LESS, 0) }
		open func LESSTHANOREQUAL() -> TerminalNode? { return getToken(Cobol85Parser.LESSTHANOREQUAL, 0) }
		open func IS() -> TerminalNode? { return getToken(Cobol85Parser.IS, 0) }
		open func ARE() -> TerminalNode? { return getToken(Cobol85Parser.ARE, 0) }
		open func MORETHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.MORETHANCHAR, 0) }
		open func LESSTHANCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LESSTHANCHAR, 0) }
		open func EQUALCHAR() -> TerminalNode? { return getToken(Cobol85Parser.EQUALCHAR, 0) }
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func THAN() -> TerminalNode? { return getToken(Cobol85Parser.THAN, 0) }
		open func TO() -> TerminalNode? { return getToken(Cobol85Parser.TO, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_relationalOperator }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRelationalOperator(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRelationalOperator(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRelationalOperator(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRelationalOperator(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relationalOperator() throws -> RelationalOperatorContext {
		var _localctx: RelationalOperatorContext = RelationalOperatorContext(_ctx, getState())
		try enterRule(_localctx, 1050, Cobol85Parser.RULE_relationalOperator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5894)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ARE
		 	          testSet = testSet || _la == Cobol85Parser.IS
		 	      return testSet
		 	 }()) {
		 		setState(5893)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.ARE
		 		          testSet = testSet || _la == Cobol85Parser.IS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(5936)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,938, _ctx)) {
		 	case 1:
		 		setState(5897)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.NOT
		 		      return testSet
		 		 }()) {
		 			setState(5896)
		 			try match(Cobol85Parser.NOT)

		 		}

		 		setState(5914)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case Cobol85Parser.GREATER:
		 			setState(5899)
		 			try match(Cobol85Parser.GREATER)
		 			setState(5901)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.THAN
		 			      return testSet
		 			 }()) {
		 				setState(5900)
		 				try match(Cobol85Parser.THAN)

		 			}


		 			break

		 		case Cobol85Parser.MORETHANCHAR:
		 			setState(5903)
		 			try match(Cobol85Parser.MORETHANCHAR)

		 			break

		 		case Cobol85Parser.LESS:
		 			setState(5904)
		 			try match(Cobol85Parser.LESS)
		 			setState(5906)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.THAN
		 			      return testSet
		 			 }()) {
		 				setState(5905)
		 				try match(Cobol85Parser.THAN)

		 			}


		 			break

		 		case Cobol85Parser.LESSTHANCHAR:
		 			setState(5908)
		 			try match(Cobol85Parser.LESSTHANCHAR)

		 			break

		 		case Cobol85Parser.EQUAL:
		 			setState(5909)
		 			try match(Cobol85Parser.EQUAL)
		 			setState(5911)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.TO
		 			      return testSet
		 			 }()) {
		 				setState(5910)
		 				try match(Cobol85Parser.TO)

		 			}


		 			break

		 		case Cobol85Parser.EQUALCHAR:
		 			setState(5913)
		 			try match(Cobol85Parser.EQUALCHAR)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		setState(5916)
		 		try match(Cobol85Parser.GREATER)
		 		setState(5918)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THAN
		 		      return testSet
		 		 }()) {
		 			setState(5917)
		 			try match(Cobol85Parser.THAN)

		 		}

		 		setState(5920)
		 		try match(Cobol85Parser.OR)
		 		setState(5921)
		 		try match(Cobol85Parser.EQUAL)
		 		setState(5923)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TO
		 		      return testSet
		 		 }()) {
		 			setState(5922)
		 			try match(Cobol85Parser.TO)

		 		}


		 		break
		 	case 3:
		 		setState(5925)
		 		try match(Cobol85Parser.MORETHANOREQUAL)

		 		break
		 	case 4:
		 		setState(5926)
		 		try match(Cobol85Parser.LESS)
		 		setState(5928)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.THAN
		 		      return testSet
		 		 }()) {
		 			setState(5927)
		 			try match(Cobol85Parser.THAN)

		 		}

		 		setState(5930)
		 		try match(Cobol85Parser.OR)
		 		setState(5931)
		 		try match(Cobol85Parser.EQUAL)
		 		setState(5933)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.TO
		 		      return testSet
		 		 }()) {
		 			setState(5932)
		 			try match(Cobol85Parser.TO)

		 		}


		 		break
		 	case 5:
		 		setState(5935)
		 		try match(Cobol85Parser.LESSTHANOREQUAL)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AbbreviationContext:ParserRuleContext {
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func abbreviation() -> AbbreviationContext? {
			return getRuleContext(AbbreviationContext.self,0)
		}
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func NOT() -> TerminalNode? { return getToken(Cobol85Parser.NOT, 0) }
		open func relationalOperator() -> RelationalOperatorContext? {
			return getRuleContext(RelationalOperatorContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_abbreviation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAbbreviation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAbbreviation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAbbreviation(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAbbreviation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func abbreviation() throws -> AbbreviationContext {
		var _localctx: AbbreviationContext = AbbreviationContext(_ctx, getState())
		try enterRule(_localctx, 1052, Cobol85Parser.RULE_abbreviation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5939)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,939,_ctx)) {
		 	case 1:
		 		setState(5938)
		 		try match(Cobol85Parser.NOT)

		 		break
		 	default: break
		 	}
		 	setState(5942)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.ARE
		 	          testSet = testSet || _la == Cobol85Parser.EQUAL || _la == Cobol85Parser.GREATER
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.IS,Cobol85Parser.LESS,Cobol85Parser.NOT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EQUALCHAR,Cobol85Parser.LESSTHANCHAR,Cobol85Parser.LESSTHANOREQUAL,Cobol85Parser.MORETHANCHAR,Cobol85Parser.MORETHANOREQUAL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 541)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5941)
		 		try relationalOperator()

		 	}

		 	setState(5950)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,941, _ctx)) {
		 	case 1:
		 		setState(5944)
		 		try arithmeticExpression()

		 		break
		 	case 2:
		 		setState(5945)
		 		try match(Cobol85Parser.LPARENCHAR)
		 		setState(5946)
		 		try arithmeticExpression()
		 		setState(5947)
		 		try abbreviation()
		 		setState(5948)
		 		try match(Cobol85Parser.RPARENCHAR)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdentifierContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func tableCall() -> TableCallContext? {
			return getRuleContext(TableCallContext.self,0)
		}
		open func functionCall() -> FunctionCallContext? {
			return getRuleContext(FunctionCallContext.self,0)
		}
		open func specialRegister() -> SpecialRegisterContext? {
			return getRuleContext(SpecialRegisterContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_identifier }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIdentifier(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIdentifier(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIdentifier(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIdentifier(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func identifier() throws -> IdentifierContext {
		var _localctx: IdentifierContext = IdentifierContext(_ctx, getState())
		try enterRule(_localctx, 1054, Cobol85Parser.RULE_identifier)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5956)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,942, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5952)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5953)
		 		try tableCall()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5954)
		 		try functionCall()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5955)
		 		try specialRegister()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TableCallContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func LPARENCHAR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.LPARENCHAR) }
		open func LPARENCHAR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.LPARENCHAR, i)
		}
		open func RPARENCHAR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.RPARENCHAR) }
		open func RPARENCHAR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.RPARENCHAR, i)
		}
		open func referenceModifier() -> ReferenceModifierContext? {
			return getRuleContext(ReferenceModifierContext.self,0)
		}
		open func subscript() -> Array<SubscriptContext> {
			return getRuleContexts(SubscriptContext.self)
		}
		open func subscript(_ i: Int) -> SubscriptContext? {
			return getRuleContext(SubscriptContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_tableCall }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterTableCall(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitTableCall(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitTableCall(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitTableCall(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func tableCall() throws -> TableCallContext {
		var _localctx: TableCallContext = TableCallContext(_ctx, getState())
		try enterRule(_localctx, 1056, Cobol85Parser.RULE_tableCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5958)
		 	try qualifiedDataName()
		 	setState(5969)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,944,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5959)
		 			try match(Cobol85Parser.LPARENCHAR)
		 			setState(5961) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(5960)
		 				try subscript()


		 				setState(5963); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 			              return  Utils.testBitLeftShiftArray(testArray, 70)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 141)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 			              return  Utils.testBitLeftShiftArray(testArray, 205)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 270)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 336)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 			              return  Utils.testBitLeftShiftArray(testArray, 402)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 			              return  Utils.testBitLeftShiftArray(testArray, 470)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.LPARENCHAR,Cobol85Parser.MINUSCHAR,Cobol85Parser.PLUSCHAR,Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 			              return  Utils.testBitLeftShiftArray(testArray, 547)
		 			          }()
		 			      return testSet
		 			 }())
		 			setState(5965)
		 			try match(Cobol85Parser.RPARENCHAR)

		 	 
		 		}
		 		setState(5971)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,944,_ctx)
		 	}
		 	setState(5973)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,945,_ctx)) {
		 	case 1:
		 		setState(5972)
		 		try referenceModifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FunctionCallContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(Cobol85Parser.FUNCTION, 0) }
		open func functionName() -> FunctionNameContext? {
			return getRuleContext(FunctionNameContext.self,0)
		}
		open func LPARENCHAR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.LPARENCHAR) }
		open func LPARENCHAR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.LPARENCHAR, i)
		}
		open func RPARENCHAR() -> Array<TerminalNode> { return getTokens(Cobol85Parser.RPARENCHAR) }
		open func RPARENCHAR(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.RPARENCHAR, i)
		}
		open func referenceModifier() -> ReferenceModifierContext? {
			return getRuleContext(ReferenceModifierContext.self,0)
		}
		open func argument() -> Array<ArgumentContext> {
			return getRuleContexts(ArgumentContext.self)
		}
		open func argument(_ i: Int) -> ArgumentContext? {
			return getRuleContext(ArgumentContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_functionCall }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFunctionCall(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFunctionCall(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFunctionCall(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFunctionCall(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func functionCall() throws -> FunctionCallContext {
		var _localctx: FunctionCallContext = FunctionCallContext(_ctx, getState())
		try enterRule(_localctx, 1058, Cobol85Parser.RULE_functionCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5975)
		 	try match(Cobol85Parser.FUNCTION)
		 	setState(5976)
		 	try functionName()
		 	setState(5987)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,947,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5977)
		 			try match(Cobol85Parser.LPARENCHAR)
		 			setState(5979) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(5978)
		 				try argument()


		 				setState(5981); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 			              return  Utils.testBitLeftShiftArray(testArray, 70)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 141)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 			              return  Utils.testBitLeftShiftArray(testArray, 205)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 270)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 336)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 			              return  Utils.testBitLeftShiftArray(testArray, 402)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 			              return  Utils.testBitLeftShiftArray(testArray, 470)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.LPARENCHAR,Cobol85Parser.MINUSCHAR,Cobol85Parser.PLUSCHAR,Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 			              return  Utils.testBitLeftShiftArray(testArray, 547)
		 			          }()
		 			      return testSet
		 			 }())
		 			setState(5983)
		 			try match(Cobol85Parser.RPARENCHAR)

		 	 
		 		}
		 		setState(5989)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,947,_ctx)
		 	}
		 	setState(5991)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,948,_ctx)) {
		 	case 1:
		 		setState(5990)
		 		try referenceModifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReferenceModifierContext:ParserRuleContext {
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func characterPosition() -> CharacterPositionContext? {
			return getRuleContext(CharacterPositionContext.self,0)
		}
		open func COLONCHAR() -> TerminalNode? { return getToken(Cobol85Parser.COLONCHAR, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func length() -> LengthContext? {
			return getRuleContext(LengthContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_referenceModifier }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReferenceModifier(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReferenceModifier(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReferenceModifier(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReferenceModifier(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func referenceModifier() throws -> ReferenceModifierContext {
		var _localctx: ReferenceModifierContext = ReferenceModifierContext(_ctx, getState())
		try enterRule(_localctx, 1060, Cobol85Parser.RULE_referenceModifier)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5993)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(5994)
		 	try characterPosition()
		 	setState(5995)
		 	try match(Cobol85Parser.COLONCHAR)
		 	setState(5997)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.ADDRESS,Cobol85Parser.ALL,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DATE,Cobol85Parser.DAY,Cobol85Parser.DAY_OF_WEEK,Cobol85Parser.DEBUG_CONTENTS,Cobol85Parser.DEBUG_ITEM,Cobol85Parser.DEBUG_LINE,Cobol85Parser.DEBUG_NAME,Cobol85Parser.DEBUG_SUB_1,Cobol85Parser.DEBUG_SUB_2,Cobol85Parser.DEBUG_SUB_3,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FALSE,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTION,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.HIGH_VALUE,Cobol85Parser.HIGH_VALUES,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LINAGE_COUNTER,Cobol85Parser.LINE_COUNTER,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.LOW_VALUE,Cobol85Parser.LOW_VALUES,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NULL,Cobol85Parser.NULLS,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PAGE_COUNTER,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.QUOTE,Cobol85Parser.QUOTES,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.RETURN_CODE,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHIFT_IN,Cobol85Parser.SHIFT_OUT,Cobol85Parser.SHORT_DATE,Cobol85Parser.SORT_CONTROL,Cobol85Parser.SORT_CORE_SIZE,Cobol85Parser.SORT_FILE_SIZE,Cobol85Parser.SORT_MESSAGE,Cobol85Parser.SORT_MODE_SIZE,Cobol85Parser.SORT_RETURN,Cobol85Parser.SP,Cobol85Parser.SPACE,Cobol85Parser.SPACES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TALLY,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIME,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUE,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.WHEN_COMPILED,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO,Cobol85Parser.ZERO_FILL,Cobol85Parser.ZEROS,Cobol85Parser.ZEROES]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LPARENCHAR,Cobol85Parser.MINUSCHAR,Cobol85Parser.PLUSCHAR,Cobol85Parser.NONNUMERICLITERAL,Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL,Cobol85Parser.NUMERICLITERAL,Cobol85Parser.IDENTIFIER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 547)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5996)
		 		try length()

		 	}

		 	setState(5999)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CharacterPositionContext:ParserRuleContext {
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_characterPosition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCharacterPosition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCharacterPosition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCharacterPosition(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCharacterPosition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func characterPosition() throws -> CharacterPositionContext {
		var _localctx: CharacterPositionContext = CharacterPositionContext(_ctx, getState())
		try enterRule(_localctx, 1062, Cobol85Parser.RULE_characterPosition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6001)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LengthContext:ParserRuleContext {
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_length }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLength(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLength(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLength(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLength(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func length() throws -> LengthContext {
		var _localctx: LengthContext = LengthContext(_ctx, getState())
		try enterRule(_localctx, 1064, Cobol85Parser.RULE_length)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6003)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubscriptContext:ParserRuleContext {
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func indexName() -> IndexNameContext? {
			return getRuleContext(IndexNameContext.self,0)
		}
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_subscript }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSubscript(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSubscript(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSubscript(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSubscript(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subscript() throws -> SubscriptContext {
		var _localctx: SubscriptContext = SubscriptContext(_ctx, getState())
		try enterRule(_localctx, 1066, Cobol85Parser.RULE_subscript)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6016)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,952, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6005)
		 		try match(Cobol85Parser.ALL)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6006)
		 		try integerLiteral()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6007)
		 		try qualifiedDataName()
		 		setState(6009)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,950,_ctx)) {
		 		case 1:
		 			setState(6008)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6011)
		 		try indexName()
		 		setState(6013)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,951,_ctx)) {
		 		case 1:
		 			setState(6012)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6015)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ArgumentContext:ParserRuleContext {
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open func indexName() -> IndexNameContext? {
			return getRuleContext(IndexNameContext.self,0)
		}
		open func arithmeticExpression() -> ArithmeticExpressionContext? {
			return getRuleContext(ArithmeticExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_argument }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterArgument(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitArgument(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitArgument(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitArgument(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func argument() throws -> ArgumentContext {
		var _localctx: ArgumentContext = ArgumentContext(_ctx, getState())
		try enterRule(_localctx, 1068, Cobol85Parser.RULE_argument)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6029)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,955, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6018)
		 		try literal()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6019)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6020)
		 		try qualifiedDataName()
		 		setState(6022)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,953,_ctx)) {
		 		case 1:
		 			setState(6021)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6024)
		 		try indexName()
		 		setState(6026)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,954,_ctx)) {
		 		case 1:
		 			setState(6025)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6028)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedDataNameContext:ParserRuleContext {
		open func qualifiedDataNameFormat1() -> QualifiedDataNameFormat1Context? {
			return getRuleContext(QualifiedDataNameFormat1Context.self,0)
		}
		open func qualifiedDataNameFormat2() -> QualifiedDataNameFormat2Context? {
			return getRuleContext(QualifiedDataNameFormat2Context.self,0)
		}
		open func qualifiedDataNameFormat3() -> QualifiedDataNameFormat3Context? {
			return getRuleContext(QualifiedDataNameFormat3Context.self,0)
		}
		open func qualifiedDataNameFormat4() -> QualifiedDataNameFormat4Context? {
			return getRuleContext(QualifiedDataNameFormat4Context.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedDataName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedDataName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedDataName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedDataName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedDataName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedDataName() throws -> QualifiedDataNameContext {
		var _localctx: QualifiedDataNameContext = QualifiedDataNameContext(_ctx, getState())
		try enterRule(_localctx, 1070, Cobol85Parser.RULE_qualifiedDataName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6035)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,956, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6031)
		 		try qualifiedDataNameFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6032)
		 		try qualifiedDataNameFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6033)
		 		try qualifiedDataNameFormat3()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6034)
		 		try qualifiedDataNameFormat4()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedDataNameFormat1Context:ParserRuleContext {
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func conditionName() -> ConditionNameContext? {
			return getRuleContext(ConditionNameContext.self,0)
		}
		open func inFile() -> InFileContext? {
			return getRuleContext(InFileContext.self,0)
		}
		open func qualifiedInData() -> Array<QualifiedInDataContext> {
			return getRuleContexts(QualifiedInDataContext.self)
		}
		open func qualifiedInData(_ i: Int) -> QualifiedInDataContext? {
			return getRuleContext(QualifiedInDataContext.self,i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedDataNameFormat1 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedDataNameFormat1(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedDataNameFormat1(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedDataNameFormat1(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedDataNameFormat1(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedDataNameFormat1() throws -> QualifiedDataNameFormat1Context {
		var _localctx: QualifiedDataNameFormat1Context = QualifiedDataNameFormat1Context(_ctx, getState())
		try enterRule(_localctx, 1072, Cobol85Parser.RULE_qualifiedDataNameFormat1)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6039)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,957, _ctx)) {
		 	case 1:
		 		setState(6037)
		 		try dataName()

		 		break
		 	case 2:
		 		setState(6038)
		 		try conditionName()

		 		break
		 	default: break
		 	}
		 	setState(6050)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,960,_ctx)) {
		 	case 1:
		 		setState(6042); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(6041)
		 				try qualifiedInData()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(6044); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,958,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 		setState(6047)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,959,_ctx)) {
		 		case 1:
		 			setState(6046)
		 			try inFile()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(6049)
		 		try inFile()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedDataNameFormat2Context:ParserRuleContext {
		open func paragraphName() -> ParagraphNameContext? {
			return getRuleContext(ParagraphNameContext.self,0)
		}
		open func inSection() -> InSectionContext? {
			return getRuleContext(InSectionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedDataNameFormat2 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedDataNameFormat2(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedDataNameFormat2(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedDataNameFormat2(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedDataNameFormat2(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedDataNameFormat2() throws -> QualifiedDataNameFormat2Context {
		var _localctx: QualifiedDataNameFormat2Context = QualifiedDataNameFormat2Context(_ctx, getState())
		try enterRule(_localctx, 1074, Cobol85Parser.RULE_qualifiedDataNameFormat2)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6052)
		 	try paragraphName()
		 	setState(6053)
		 	try inSection()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedDataNameFormat3Context:ParserRuleContext {
		open func textName() -> TextNameContext? {
			return getRuleContext(TextNameContext.self,0)
		}
		open func inLibrary() -> InLibraryContext? {
			return getRuleContext(InLibraryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedDataNameFormat3 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedDataNameFormat3(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedDataNameFormat3(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedDataNameFormat3(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedDataNameFormat3(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedDataNameFormat3() throws -> QualifiedDataNameFormat3Context {
		var _localctx: QualifiedDataNameFormat3Context = QualifiedDataNameFormat3Context(_ctx, getState())
		try enterRule(_localctx, 1076, Cobol85Parser.RULE_qualifiedDataNameFormat3)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6055)
		 	try textName()
		 	setState(6056)
		 	try inLibrary()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedDataNameFormat4Context:ParserRuleContext {
		open func LINAGE_COUNTER() -> TerminalNode? { return getToken(Cobol85Parser.LINAGE_COUNTER, 0) }
		open func inFile() -> InFileContext? {
			return getRuleContext(InFileContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedDataNameFormat4 }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedDataNameFormat4(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedDataNameFormat4(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedDataNameFormat4(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedDataNameFormat4(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedDataNameFormat4() throws -> QualifiedDataNameFormat4Context {
		var _localctx: QualifiedDataNameFormat4Context = QualifiedDataNameFormat4Context(_ctx, getState())
		try enterRule(_localctx, 1078, Cobol85Parser.RULE_qualifiedDataNameFormat4)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6058)
		 	try match(Cobol85Parser.LINAGE_COUNTER)
		 	setState(6059)
		 	try inFile()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class QualifiedInDataContext:ParserRuleContext {
		open func inData() -> InDataContext? {
			return getRuleContext(InDataContext.self,0)
		}
		open func inTable() -> InTableContext? {
			return getRuleContext(InTableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_qualifiedInData }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterQualifiedInData(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitQualifiedInData(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitQualifiedInData(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitQualifiedInData(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func qualifiedInData() throws -> QualifiedInDataContext {
		var _localctx: QualifiedInDataContext = QualifiedInDataContext(_ctx, getState())
		try enterRule(_localctx, 1080, Cobol85Parser.RULE_qualifiedInData)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6063)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,961, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6061)
		 		try inData()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6062)
		 		try inTable()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InDataContext:ParserRuleContext {
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inData }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInData(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInData(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInData(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInData(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inData() throws -> InDataContext {
		var _localctx: InDataContext = InDataContext(_ctx, getState())
		try enterRule(_localctx, 1082, Cobol85Parser.RULE_inData)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6065)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6066)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InFileContext:ParserRuleContext {
		open func fileName() -> FileNameContext? {
			return getRuleContext(FileNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inFile }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInFile(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInFile(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInFile(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInFile(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inFile() throws -> InFileContext {
		var _localctx: InFileContext = InFileContext(_ctx, getState())
		try enterRule(_localctx, 1084, Cobol85Parser.RULE_inFile)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6068)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6069)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InMnemonicContext:ParserRuleContext {
		open func mnemonicName() -> MnemonicNameContext? {
			return getRuleContext(MnemonicNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inMnemonic }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInMnemonic(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInMnemonic(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInMnemonic(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInMnemonic(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inMnemonic() throws -> InMnemonicContext {
		var _localctx: InMnemonicContext = InMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 1086, Cobol85Parser.RULE_inMnemonic)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6071)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6072)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InSectionContext:ParserRuleContext {
		open func sectionName() -> SectionNameContext? {
			return getRuleContext(SectionNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inSection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInSection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInSection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInSection(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInSection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inSection() throws -> InSectionContext {
		var _localctx: InSectionContext = InSectionContext(_ctx, getState())
		try enterRule(_localctx, 1088, Cobol85Parser.RULE_inSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6074)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6075)
		 	try sectionName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InLibraryContext:ParserRuleContext {
		open func libraryName() -> LibraryNameContext? {
			return getRuleContext(LibraryNameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inLibrary }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInLibrary(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInLibrary(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInLibrary(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInLibrary(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inLibrary() throws -> InLibraryContext {
		var _localctx: InLibraryContext = InLibraryContext(_ctx, getState())
		try enterRule(_localctx, 1090, Cobol85Parser.RULE_inLibrary)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6077)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6078)
		 	try libraryName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class InTableContext:ParserRuleContext {
		open func tableCall() -> TableCallContext? {
			return getRuleContext(TableCallContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(Cobol85Parser.IN, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_inTable }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterInTable(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitInTable(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitInTable(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitInTable(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func inTable() throws -> InTableContext {
		var _localctx: InTableContext = InTableContext(_ctx, getState())
		try enterRule(_localctx, 1092, Cobol85Parser.RULE_inTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6080)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.IN
		 	          testSet = testSet || _la == Cobol85Parser.OF
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(6081)
		 	try tableCall()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlphabetNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_alphabetName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAlphabetName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAlphabetName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAlphabetName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAlphabetName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alphabetName() throws -> AlphabetNameContext {
		var _localctx: AlphabetNameContext = AlphabetNameContext(_ctx, getState())
		try enterRule(_localctx, 1094, Cobol85Parser.RULE_alphabetName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6083)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AssignmentNameContext:ParserRuleContext {
		open func systemName() -> SystemNameContext? {
			return getRuleContext(SystemNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_assignmentName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterAssignmentName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitAssignmentName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitAssignmentName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitAssignmentName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func assignmentName() throws -> AssignmentNameContext {
		var _localctx: AssignmentNameContext = AssignmentNameContext(_ctx, getState())
		try enterRule(_localctx, 1096, Cobol85Parser.RULE_assignmentName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6085)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BasisNameContext:ParserRuleContext {
		open func programName() -> ProgramNameContext? {
			return getRuleContext(ProgramNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_basisName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterBasisName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitBasisName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitBasisName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitBasisName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func basisName() throws -> BasisNameContext {
		var _localctx: BasisNameContext = BasisNameContext(_ctx, getState())
		try enterRule(_localctx, 1098, Cobol85Parser.RULE_basisName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6087)
		 	try programName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CdNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cdName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCdName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCdName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCdName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCdName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cdName() throws -> CdNameContext {
		var _localctx: CdNameContext = CdNameContext(_ctx, getState())
		try enterRule(_localctx, 1100, Cobol85Parser.RULE_cdName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6089)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClassNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_className }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterClassName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitClassName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitClassName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitClassName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func className() throws -> ClassNameContext {
		var _localctx: ClassNameContext = ClassNameContext(_ctx, getState())
		try enterRule(_localctx, 1102, Cobol85Parser.RULE_className)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6091)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ComputerNameContext:ParserRuleContext {
		open func systemName() -> SystemNameContext? {
			return getRuleContext(SystemNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_computerName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterComputerName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitComputerName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitComputerName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitComputerName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func computerName() throws -> ComputerNameContext {
		var _localctx: ComputerNameContext = ComputerNameContext(_ctx, getState())
		try enterRule(_localctx, 1104, Cobol85Parser.RULE_computerName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6093)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_conditionName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterConditionName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitConditionName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitConditionName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitConditionName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditionName() throws -> ConditionNameContext {
		var _localctx: ConditionNameContext = ConditionNameContext(_ctx, getState())
		try enterRule(_localctx, 1106, Cobol85Parser.RULE_conditionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6095)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataName() throws -> DataNameContext {
		var _localctx: DataNameContext = DataNameContext(_ctx, getState())
		try enterRule(_localctx, 1108, Cobol85Parser.RULE_dataName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6097)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DataDescNameContext:ParserRuleContext {
		open func FILLER() -> TerminalNode? { return getToken(Cobol85Parser.FILLER, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(Cobol85Parser.CURSOR, 0) }
		open func dataName() -> DataNameContext? {
			return getRuleContext(DataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_dataDescName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterDataDescName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitDataDescName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitDataDescName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitDataDescName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dataDescName() throws -> DataDescNameContext {
		var _localctx: DataDescNameContext = DataDescNameContext(_ctx, getState())
		try enterRule(_localctx, 1110, Cobol85Parser.RULE_dataDescName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6102)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,962, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6099)
		 		try match(Cobol85Parser.FILLER)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6100)
		 		try match(Cobol85Parser.CURSOR)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6101)
		 		try dataName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class EnvironmentNameContext:ParserRuleContext {
		open func systemName() -> SystemNameContext? {
			return getRuleContext(SystemNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_environmentName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterEnvironmentName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitEnvironmentName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitEnvironmentName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitEnvironmentName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func environmentName() throws -> EnvironmentNameContext {
		var _localctx: EnvironmentNameContext = EnvironmentNameContext(_ctx, getState())
		try enterRule(_localctx, 1112, Cobol85Parser.RULE_environmentName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6104)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FileNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_fileName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFileName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFileName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFileName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFileName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fileName() throws -> FileNameContext {
		var _localctx: FileNameContext = FileNameContext(_ctx, getState())
		try enterRule(_localctx, 1114, Cobol85Parser.RULE_fileName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6106)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FunctionNameContext:ParserRuleContext {
		open func INTEGER() -> TerminalNode? { return getToken(Cobol85Parser.INTEGER, 0) }
		open func LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH, 0) }
		open func RANDOM() -> TerminalNode? { return getToken(Cobol85Parser.RANDOM, 0) }
		open func SUM() -> TerminalNode? { return getToken(Cobol85Parser.SUM, 0) }
		open func WHEN_COMPILED() -> TerminalNode? { return getToken(Cobol85Parser.WHEN_COMPILED, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_functionName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFunctionName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFunctionName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFunctionName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFunctionName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func functionName() throws -> FunctionNameContext {
		var _localctx: FunctionNameContext = FunctionNameContext(_ctx, getState())
		try enterRule(_localctx, 1116, Cobol85Parser.RULE_functionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6114)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,963, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6108)
		 		try match(Cobol85Parser.INTEGER)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6109)
		 		try match(Cobol85Parser.LENGTH)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6110)
		 		try match(Cobol85Parser.RANDOM)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6111)
		 		try match(Cobol85Parser.SUM)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6112)
		 		try match(Cobol85Parser.WHEN_COMPILED)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6113)
		 		try cobolWord()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IndexNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_indexName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIndexName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIndexName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIndexName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIndexName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func indexName() throws -> IndexNameContext {
		var _localctx: IndexNameContext = IndexNameContext(_ctx, getState())
		try enterRule(_localctx, 1118, Cobol85Parser.RULE_indexName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6116)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LanguageNameContext:ParserRuleContext {
		open func systemName() -> SystemNameContext? {
			return getRuleContext(SystemNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_languageName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLanguageName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLanguageName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLanguageName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLanguageName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func languageName() throws -> LanguageNameContext {
		var _localctx: LanguageNameContext = LanguageNameContext(_ctx, getState())
		try enterRule(_localctx, 1120, Cobol85Parser.RULE_languageName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6118)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LibraryNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_libraryName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLibraryName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLibraryName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLibraryName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLibraryName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func libraryName() throws -> LibraryNameContext {
		var _localctx: LibraryNameContext = LibraryNameContext(_ctx, getState())
		try enterRule(_localctx, 1122, Cobol85Parser.RULE_libraryName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6120)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LocalNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_localName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLocalName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLocalName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLocalName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLocalName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func localName() throws -> LocalNameContext {
		var _localctx: LocalNameContext = LocalNameContext(_ctx, getState())
		try enterRule(_localctx, 1124, Cobol85Parser.RULE_localName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6122)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class MnemonicNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_mnemonicName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterMnemonicName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitMnemonicName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitMnemonicName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitMnemonicName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mnemonicName() throws -> MnemonicNameContext {
		var _localctx: MnemonicNameContext = MnemonicNameContext(_ctx, getState())
		try enterRule(_localctx, 1126, Cobol85Parser.RULE_mnemonicName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6124)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ParagraphNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_paragraphName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterParagraphName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitParagraphName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitParagraphName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitParagraphName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func paragraphName() throws -> ParagraphNameContext {
		var _localctx: ParagraphNameContext = ParagraphNameContext(_ctx, getState())
		try enterRule(_localctx, 1128, Cobol85Parser.RULE_paragraphName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6128)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6126)
		 		try cobolWord()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6127)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProcedureNameContext:ParserRuleContext {
		open func paragraphName() -> ParagraphNameContext? {
			return getRuleContext(ParagraphNameContext.self,0)
		}
		open func inSection() -> InSectionContext? {
			return getRuleContext(InSectionContext.self,0)
		}
		open func sectionName() -> SectionNameContext? {
			return getRuleContext(SectionNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_procedureName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProcedureName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProcedureName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProcedureName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProcedureName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedureName() throws -> ProcedureNameContext {
		var _localctx: ProcedureNameContext = ProcedureNameContext(_ctx, getState())
		try enterRule(_localctx, 1130, Cobol85Parser.RULE_procedureName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6135)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,966, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6130)
		 		try paragraphName()
		 		setState(6132)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.IN
		 		          testSet = testSet || _la == Cobol85Parser.OF
		 		      return testSet
		 		 }()) {
		 			setState(6131)
		 			try inSection()

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6134)
		 		try sectionName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ProgramNameContext:ParserRuleContext {
		open func NONNUMERICLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.NONNUMERICLITERAL, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_programName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterProgramName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitProgramName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitProgramName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitProgramName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func programName() throws -> ProgramNameContext {
		var _localctx: ProgramNameContext = ProgramNameContext(_ctx, getState())
		try enterRule(_localctx, 1132, Cobol85Parser.RULE_programName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6139)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NONNUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6137)
		 		try match(Cobol85Parser.NONNUMERICLITERAL)

		 		break
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6138)
		 		try cobolWord()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RecordNameContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_recordName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRecordName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRecordName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRecordName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRecordName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recordName() throws -> RecordNameContext {
		var _localctx: RecordNameContext = RecordNameContext(_ctx, getState())
		try enterRule(_localctx, 1134, Cobol85Parser.RULE_recordName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6141)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ReportNameContext:ParserRuleContext {
		open func qualifiedDataName() -> QualifiedDataNameContext? {
			return getRuleContext(QualifiedDataNameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_reportName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterReportName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitReportName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitReportName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitReportName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reportName() throws -> ReportNameContext {
		var _localctx: ReportNameContext = ReportNameContext(_ctx, getState())
		try enterRule(_localctx, 1136, Cobol85Parser.RULE_reportName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6143)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class RoutineNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_routineName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterRoutineName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitRoutineName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitRoutineName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitRoutineName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func routineName() throws -> RoutineNameContext {
		var _localctx: RoutineNameContext = RoutineNameContext(_ctx, getState())
		try enterRule(_localctx, 1138, Cobol85Parser.RULE_routineName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6145)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ScreenNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_screenName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterScreenName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitScreenName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitScreenName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitScreenName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func screenName() throws -> ScreenNameContext {
		var _localctx: ScreenNameContext = ScreenNameContext(_ctx, getState())
		try enterRule(_localctx, 1140, Cobol85Parser.RULE_screenName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6147)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SectionNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_sectionName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSectionName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSectionName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSectionName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSectionName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sectionName() throws -> SectionNameContext {
		var _localctx: SectionNameContext = SectionNameContext(_ctx, getState())
		try enterRule(_localctx, 1142, Cobol85Parser.RULE_sectionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6151)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ABORT:fallthrough
		 	case Cobol85Parser.APOST:fallthrough
		 	case Cobol85Parser.ARITH:fallthrough
		 	case Cobol85Parser.AS:fallthrough
		 	case Cobol85Parser.ASCII:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA:fallthrough
		 	case Cobol85Parser.ASSOCIATED_DATA_LENGTH:fallthrough
		 	case Cobol85Parser.ATTRIBUTE:fallthrough
		 	case Cobol85Parser.AUTO:fallthrough
		 	case Cobol85Parser.AUTO_SKIP:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOR:fallthrough
		 	case Cobol85Parser.BACKGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.BEEP:fallthrough
		 	case Cobol85Parser.BELL:fallthrough
		 	case Cobol85Parser.BIT:fallthrough
		 	case Cobol85Parser.BLINK:fallthrough
		 	case Cobol85Parser.BOUNDS:fallthrough
		 	case Cobol85Parser.CAPABLE:fallthrough
		 	case Cobol85Parser.CCSVERSION:fallthrough
		 	case Cobol85Parser.CHANGED:fallthrough
		 	case Cobol85Parser.CHANNEL:fallthrough
		 	case Cobol85Parser.CLOSE_DISPOSITION:fallthrough
		 	case Cobol85Parser.COBOL:fallthrough
		 	case Cobol85Parser.CODEPAGE:fallthrough
		 	case Cobol85Parser.COMMITMENT:fallthrough
		 	case Cobol85Parser.CONTROL_POINT:fallthrough
		 	case Cobol85Parser.CONVENTION:fallthrough
		 	case Cobol85Parser.CRUNCH:fallthrough
		 	case Cobol85Parser.CURSOR:fallthrough
		 	case Cobol85Parser.DEFAULT:fallthrough
		 	case Cobol85Parser.DEFAULT_DISPLAY:fallthrough
		 	case Cobol85Parser.DEFINITION:fallthrough
		 	case Cobol85Parser.DFHRESP:fallthrough
		 	case Cobol85Parser.DFHVALUE:fallthrough
		 	case Cobol85Parser.DISK:fallthrough
		 	case Cobol85Parser.DONTCARE:fallthrough
		 	case Cobol85Parser.DOUBLE:fallthrough
		 	case Cobol85Parser.EBCDIC:fallthrough
		 	case Cobol85Parser.EMPTY_CHECK:fallthrough
		 	case Cobol85Parser.ENTER:fallthrough
		 	case Cobol85Parser.ENTRY_PROCEDURE:fallthrough
		 	case Cobol85Parser.ERASE:fallthrough
		 	case Cobol85Parser.EOL:fallthrough
		 	case Cobol85Parser.EOS:fallthrough
		 	case Cobol85Parser.ESCAPE:fallthrough
		 	case Cobol85Parser.EVENT:fallthrough
		 	case Cobol85Parser.EXCLUSIVE:fallthrough
		 	case Cobol85Parser.EXPORT:fallthrough
		 	case Cobol85Parser.EXTENDED:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOR:fallthrough
		 	case Cobol85Parser.FOREGROUND_COLOUR:fallthrough
		 	case Cobol85Parser.FULL:fallthrough
		 	case Cobol85Parser.FUNCTIONNAME:fallthrough
		 	case Cobol85Parser.FUNCTION_POINTER:fallthrough
		 	case Cobol85Parser.GRID:fallthrough
		 	case Cobol85Parser.HIGHLIGHT:fallthrough
		 	case Cobol85Parser.IMPLICIT:fallthrough
		 	case Cobol85Parser.IMPORT:fallthrough
		 	case Cobol85Parser.INTEGER:fallthrough
		 	case Cobol85Parser.KEPT:fallthrough
		 	case Cobol85Parser.LANGUAGE:fallthrough
		 	case Cobol85Parser.LB:fallthrough
		 	case Cobol85Parser.LD:fallthrough
		 	case Cobol85Parser.LEFTLINE:fallthrough
		 	case Cobol85Parser.LENGTH_CHECK:fallthrough
		 	case Cobol85Parser.LIB:fallthrough
		 	case Cobol85Parser.LIBACCESS:fallthrough
		 	case Cobol85Parser.LIBPARAMETER:fallthrough
		 	case Cobol85Parser.LIBRARY:fallthrough
		 	case Cobol85Parser.LIST:fallthrough
		 	case Cobol85Parser.LOCAL:fallthrough
		 	case Cobol85Parser.LONG_DATE:fallthrough
		 	case Cobol85Parser.LONG_TIME:fallthrough
		 	case Cobol85Parser.LOWER:fallthrough
		 	case Cobol85Parser.LOWLIGHT:fallthrough
		 	case Cobol85Parser.MMDDYYYY:fallthrough
		 	case Cobol85Parser.NAMED:fallthrough
		 	case Cobol85Parser.NATIONAL:fallthrough
		 	case Cobol85Parser.NETWORK:fallthrough
		 	case Cobol85Parser.NO_ECHO:fallthrough
		 	case Cobol85Parser.NOSEQ:fallthrough
		 	case Cobol85Parser.NUMERIC_DATE:fallthrough
		 	case Cobol85Parser.NUMERIC_TIME:fallthrough
		 	case Cobol85Parser.ODT:fallthrough
		 	case Cobol85Parser.OPTIMIZE:fallthrough
		 	case Cobol85Parser.ORDERLY:fallthrough
		 	case Cobol85Parser.OVERLINE:fallthrough
		 	case Cobol85Parser.OWN:fallthrough
		 	case Cobol85Parser.PASSWORD:fallthrough
		 	case Cobol85Parser.PORT:fallthrough
		 	case Cobol85Parser.PRINTER:fallthrough
		 	case Cobol85Parser.PRIVATE:fallthrough
		 	case Cobol85Parser.PROCESS:fallthrough
		 	case Cobol85Parser.PROGRAM:fallthrough
		 	case Cobol85Parser.PROMPT:fallthrough
		 	case Cobol85Parser.READER:fallthrough
		 	case Cobol85Parser.REMOTE:fallthrough
		 	case Cobol85Parser.REAL:fallthrough
		 	case Cobol85Parser.RECEIVED:fallthrough
		 	case Cobol85Parser.REF:fallthrough
		 	case Cobol85Parser.REMOVE:fallthrough
		 	case Cobol85Parser.REQUIRED:fallthrough
		 	case Cobol85Parser.REVERSE_VIDEO:fallthrough
		 	case Cobol85Parser.SAVE:fallthrough
		 	case Cobol85Parser.SECURE:fallthrough
		 	case Cobol85Parser.SHARED:fallthrough
		 	case Cobol85Parser.SHAREDBYALL:fallthrough
		 	case Cobol85Parser.SHAREDBYRUNUNIT:fallthrough
		 	case Cobol85Parser.SHARING:fallthrough
		 	case Cobol85Parser.SHORT_DATE:fallthrough
		 	case Cobol85Parser.SP:fallthrough
		 	case Cobol85Parser.SYMBOL:fallthrough
		 	case Cobol85Parser.TASK:fallthrough
		 	case Cobol85Parser.THREAD:fallthrough
		 	case Cobol85Parser.THREAD_LOCAL:fallthrough
		 	case Cobol85Parser.TIMER:fallthrough
		 	case Cobol85Parser.TODAYS_DATE:fallthrough
		 	case Cobol85Parser.TODAYS_NAME:fallthrough
		 	case Cobol85Parser.TRUNCATED:fallthrough
		 	case Cobol85Parser.TYPEDEF:fallthrough
		 	case Cobol85Parser.UNDERLINE:fallthrough
		 	case Cobol85Parser.VIRTUAL:fallthrough
		 	case Cobol85Parser.WAIT:fallthrough
		 	case Cobol85Parser.XOPTS:fallthrough
		 	case Cobol85Parser.YEAR:fallthrough
		 	case Cobol85Parser.YYYYMMDD:fallthrough
		 	case Cobol85Parser.YYYYDDD:fallthrough
		 	case Cobol85Parser.ZERO_FILL:fallthrough
		 	case Cobol85Parser.IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6149)
		 		try cobolWord()

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6150)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SystemNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_systemName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSystemName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSystemName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSystemName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSystemName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func systemName() throws -> SystemNameContext {
		var _localctx: SystemNameContext = SystemNameContext(_ctx, getState())
		try enterRule(_localctx, 1144, Cobol85Parser.RULE_systemName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6153)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SymbolicCharacterContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_symbolicCharacter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSymbolicCharacter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSymbolicCharacter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSymbolicCharacter(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSymbolicCharacter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func symbolicCharacter() throws -> SymbolicCharacterContext {
		var _localctx: SymbolicCharacterContext = SymbolicCharacterContext(_ctx, getState())
		try enterRule(_localctx, 1146, Cobol85Parser.RULE_symbolicCharacter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6155)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TextNameContext:ParserRuleContext {
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_textName }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterTextName(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitTextName(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitTextName(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitTextName(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func textName() throws -> TextNameContext {
		var _localctx: TextNameContext = TextNameContext(_ctx, getState())
		try enterRule(_localctx, 1148, Cobol85Parser.RULE_textName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6157)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CobolWordContext:ParserRuleContext {
		open func IDENTIFIER() -> TerminalNode? { return getToken(Cobol85Parser.IDENTIFIER, 0) }
		open func COBOL() -> TerminalNode? { return getToken(Cobol85Parser.COBOL, 0) }
		open func PROGRAM() -> TerminalNode? { return getToken(Cobol85Parser.PROGRAM, 0) }
		open func ABORT() -> TerminalNode? { return getToken(Cobol85Parser.ABORT, 0) }
		open func APOST() -> TerminalNode? { return getToken(Cobol85Parser.APOST, 0) }
		open func ARITH() -> TerminalNode? { return getToken(Cobol85Parser.ARITH, 0) }
		open func AS() -> TerminalNode? { return getToken(Cobol85Parser.AS, 0) }
		open func ASCII() -> TerminalNode? { return getToken(Cobol85Parser.ASCII, 0) }
		open func ASSOCIATED_DATA() -> TerminalNode? { return getToken(Cobol85Parser.ASSOCIATED_DATA, 0) }
		open func ASSOCIATED_DATA_LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.ASSOCIATED_DATA_LENGTH, 0) }
		open func ATTRIBUTE() -> TerminalNode? { return getToken(Cobol85Parser.ATTRIBUTE, 0) }
		open func AUTO() -> TerminalNode? { return getToken(Cobol85Parser.AUTO, 0) }
		open func AUTO_SKIP() -> TerminalNode? { return getToken(Cobol85Parser.AUTO_SKIP, 0) }
		open func BACKGROUND_COLOR() -> TerminalNode? { return getToken(Cobol85Parser.BACKGROUND_COLOR, 0) }
		open func BACKGROUND_COLOUR() -> TerminalNode? { return getToken(Cobol85Parser.BACKGROUND_COLOUR, 0) }
		open func BEEP() -> TerminalNode? { return getToken(Cobol85Parser.BEEP, 0) }
		open func BELL() -> TerminalNode? { return getToken(Cobol85Parser.BELL, 0) }
		open func BIT() -> TerminalNode? { return getToken(Cobol85Parser.BIT, 0) }
		open func BLINK() -> TerminalNode? { return getToken(Cobol85Parser.BLINK, 0) }
		open func BOUNDS() -> TerminalNode? { return getToken(Cobol85Parser.BOUNDS, 0) }
		open func CAPABLE() -> TerminalNode? { return getToken(Cobol85Parser.CAPABLE, 0) }
		open func CCSVERSION() -> TerminalNode? { return getToken(Cobol85Parser.CCSVERSION, 0) }
		open func CHANGED() -> TerminalNode? { return getToken(Cobol85Parser.CHANGED, 0) }
		open func CHANNEL() -> TerminalNode? { return getToken(Cobol85Parser.CHANNEL, 0) }
		open func CLOSE_DISPOSITION() -> TerminalNode? { return getToken(Cobol85Parser.CLOSE_DISPOSITION, 0) }
		open func CODEPAGE() -> TerminalNode? { return getToken(Cobol85Parser.CODEPAGE, 0) }
		open func COMMITMENT() -> TerminalNode? { return getToken(Cobol85Parser.COMMITMENT, 0) }
		open func CONTROL_POINT() -> TerminalNode? { return getToken(Cobol85Parser.CONTROL_POINT, 0) }
		open func CONVENTION() -> TerminalNode? { return getToken(Cobol85Parser.CONVENTION, 0) }
		open func CRUNCH() -> TerminalNode? { return getToken(Cobol85Parser.CRUNCH, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(Cobol85Parser.CURSOR, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(Cobol85Parser.DEFAULT, 0) }
		open func DEFAULT_DISPLAY() -> TerminalNode? { return getToken(Cobol85Parser.DEFAULT_DISPLAY, 0) }
		open func DEFINITION() -> TerminalNode? { return getToken(Cobol85Parser.DEFINITION, 0) }
		open func DFHRESP() -> TerminalNode? { return getToken(Cobol85Parser.DFHRESP, 0) }
		open func DFHVALUE() -> TerminalNode? { return getToken(Cobol85Parser.DFHVALUE, 0) }
		open func DISK() -> TerminalNode? { return getToken(Cobol85Parser.DISK, 0) }
		open func DONTCARE() -> TerminalNode? { return getToken(Cobol85Parser.DONTCARE, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(Cobol85Parser.DOUBLE, 0) }
		open func EBCDIC() -> TerminalNode? { return getToken(Cobol85Parser.EBCDIC, 0) }
		open func EMPTY_CHECK() -> TerminalNode? { return getToken(Cobol85Parser.EMPTY_CHECK, 0) }
		open func ENTER() -> TerminalNode? { return getToken(Cobol85Parser.ENTER, 0) }
		open func ENTRY_PROCEDURE() -> TerminalNode? { return getToken(Cobol85Parser.ENTRY_PROCEDURE, 0) }
		open func EOL() -> TerminalNode? { return getToken(Cobol85Parser.EOL, 0) }
		open func EOS() -> TerminalNode? { return getToken(Cobol85Parser.EOS, 0) }
		open func ERASE() -> TerminalNode? { return getToken(Cobol85Parser.ERASE, 0) }
		open func ESCAPE() -> TerminalNode? { return getToken(Cobol85Parser.ESCAPE, 0) }
		open func EVENT() -> TerminalNode? { return getToken(Cobol85Parser.EVENT, 0) }
		open func EXCLUSIVE() -> TerminalNode? { return getToken(Cobol85Parser.EXCLUSIVE, 0) }
		open func EXPORT() -> TerminalNode? { return getToken(Cobol85Parser.EXPORT, 0) }
		open func EXTENDED() -> TerminalNode? { return getToken(Cobol85Parser.EXTENDED, 0) }
		open func FOREGROUND_COLOR() -> TerminalNode? { return getToken(Cobol85Parser.FOREGROUND_COLOR, 0) }
		open func FOREGROUND_COLOUR() -> TerminalNode? { return getToken(Cobol85Parser.FOREGROUND_COLOUR, 0) }
		open func FULL() -> TerminalNode? { return getToken(Cobol85Parser.FULL, 0) }
		open func FUNCTIONNAME() -> TerminalNode? { return getToken(Cobol85Parser.FUNCTIONNAME, 0) }
		open func FUNCTION_POINTER() -> TerminalNode? { return getToken(Cobol85Parser.FUNCTION_POINTER, 0) }
		open func GRID() -> TerminalNode? { return getToken(Cobol85Parser.GRID, 0) }
		open func HIGHLIGHT() -> TerminalNode? { return getToken(Cobol85Parser.HIGHLIGHT, 0) }
		open func IMPLICIT() -> TerminalNode? { return getToken(Cobol85Parser.IMPLICIT, 0) }
		open func IMPORT() -> TerminalNode? { return getToken(Cobol85Parser.IMPORT, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(Cobol85Parser.INTEGER, 0) }
		open func KEPT() -> TerminalNode? { return getToken(Cobol85Parser.KEPT, 0) }
		open func LANGUAGE() -> TerminalNode? { return getToken(Cobol85Parser.LANGUAGE, 0) }
		open func LB() -> TerminalNode? { return getToken(Cobol85Parser.LB, 0) }
		open func LD() -> TerminalNode? { return getToken(Cobol85Parser.LD, 0) }
		open func LEFTLINE() -> TerminalNode? { return getToken(Cobol85Parser.LEFTLINE, 0) }
		open func LENGTH_CHECK() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH_CHECK, 0) }
		open func LIB() -> TerminalNode? { return getToken(Cobol85Parser.LIB, 0) }
		open func LIBACCESS() -> TerminalNode? { return getToken(Cobol85Parser.LIBACCESS, 0) }
		open func LIBPARAMETER() -> TerminalNode? { return getToken(Cobol85Parser.LIBPARAMETER, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(Cobol85Parser.LIBRARY, 0) }
		open func LIST() -> TerminalNode? { return getToken(Cobol85Parser.LIST, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(Cobol85Parser.LOCAL, 0) }
		open func LONG_DATE() -> TerminalNode? { return getToken(Cobol85Parser.LONG_DATE, 0) }
		open func LONG_TIME() -> TerminalNode? { return getToken(Cobol85Parser.LONG_TIME, 0) }
		open func LOWER() -> TerminalNode? { return getToken(Cobol85Parser.LOWER, 0) }
		open func LOWLIGHT() -> TerminalNode? { return getToken(Cobol85Parser.LOWLIGHT, 0) }
		open func MMDDYYYY() -> TerminalNode? { return getToken(Cobol85Parser.MMDDYYYY, 0) }
		open func NAMED() -> TerminalNode? { return getToken(Cobol85Parser.NAMED, 0) }
		open func NATIONAL() -> TerminalNode? { return getToken(Cobol85Parser.NATIONAL, 0) }
		open func NETWORK() -> TerminalNode? { return getToken(Cobol85Parser.NETWORK, 0) }
		open func NO_ECHO() -> TerminalNode? { return getToken(Cobol85Parser.NO_ECHO, 0) }
		open func NOSEQ() -> TerminalNode? { return getToken(Cobol85Parser.NOSEQ, 0) }
		open func NUMERIC_DATE() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC_DATE, 0) }
		open func NUMERIC_TIME() -> TerminalNode? { return getToken(Cobol85Parser.NUMERIC_TIME, 0) }
		open func ODT() -> TerminalNode? { return getToken(Cobol85Parser.ODT, 0) }
		open func OPTIMIZE() -> TerminalNode? { return getToken(Cobol85Parser.OPTIMIZE, 0) }
		open func ORDERLY() -> TerminalNode? { return getToken(Cobol85Parser.ORDERLY, 0) }
		open func OVERLINE() -> TerminalNode? { return getToken(Cobol85Parser.OVERLINE, 0) }
		open func OWN() -> TerminalNode? { return getToken(Cobol85Parser.OWN, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(Cobol85Parser.PASSWORD, 0) }
		open func PORT() -> TerminalNode? { return getToken(Cobol85Parser.PORT, 0) }
		open func PRINTER() -> TerminalNode? { return getToken(Cobol85Parser.PRINTER, 0) }
		open func PRIVATE() -> TerminalNode? { return getToken(Cobol85Parser.PRIVATE, 0) }
		open func PROCESS() -> TerminalNode? { return getToken(Cobol85Parser.PROCESS, 0) }
		open func PROMPT() -> TerminalNode? { return getToken(Cobol85Parser.PROMPT, 0) }
		open func READER() -> TerminalNode? { return getToken(Cobol85Parser.READER, 0) }
		open func REAL() -> TerminalNode? { return getToken(Cobol85Parser.REAL, 0) }
		open func RECEIVED() -> TerminalNode? { return getToken(Cobol85Parser.RECEIVED, 0) }
		open func REF() -> TerminalNode? { return getToken(Cobol85Parser.REF, 0) }
		open func REMOTE() -> TerminalNode? { return getToken(Cobol85Parser.REMOTE, 0) }
		open func REMOVE() -> TerminalNode? { return getToken(Cobol85Parser.REMOVE, 0) }
		open func REQUIRED() -> TerminalNode? { return getToken(Cobol85Parser.REQUIRED, 0) }
		open func REVERSE_VIDEO() -> TerminalNode? { return getToken(Cobol85Parser.REVERSE_VIDEO, 0) }
		open func SAVE() -> TerminalNode? { return getToken(Cobol85Parser.SAVE, 0) }
		open func SECURE() -> TerminalNode? { return getToken(Cobol85Parser.SECURE, 0) }
		open func SHARED() -> TerminalNode? { return getToken(Cobol85Parser.SHARED, 0) }
		open func SHAREDBYALL() -> TerminalNode? { return getToken(Cobol85Parser.SHAREDBYALL, 0) }
		open func SHAREDBYRUNUNIT() -> TerminalNode? { return getToken(Cobol85Parser.SHAREDBYRUNUNIT, 0) }
		open func SHARING() -> TerminalNode? { return getToken(Cobol85Parser.SHARING, 0) }
		open func SHORT_DATE() -> TerminalNode? { return getToken(Cobol85Parser.SHORT_DATE, 0) }
		open func SP() -> TerminalNode? { return getToken(Cobol85Parser.SP, 0) }
		open func SYMBOL() -> TerminalNode? { return getToken(Cobol85Parser.SYMBOL, 0) }
		open func TASK() -> TerminalNode? { return getToken(Cobol85Parser.TASK, 0) }
		open func THREAD() -> TerminalNode? { return getToken(Cobol85Parser.THREAD, 0) }
		open func THREAD_LOCAL() -> TerminalNode? { return getToken(Cobol85Parser.THREAD_LOCAL, 0) }
		open func TIMER() -> TerminalNode? { return getToken(Cobol85Parser.TIMER, 0) }
		open func TODAYS_DATE() -> TerminalNode? { return getToken(Cobol85Parser.TODAYS_DATE, 0) }
		open func TODAYS_NAME() -> TerminalNode? { return getToken(Cobol85Parser.TODAYS_NAME, 0) }
		open func TRUNCATED() -> TerminalNode? { return getToken(Cobol85Parser.TRUNCATED, 0) }
		open func TYPEDEF() -> TerminalNode? { return getToken(Cobol85Parser.TYPEDEF, 0) }
		open func UNDERLINE() -> TerminalNode? { return getToken(Cobol85Parser.UNDERLINE, 0) }
		open func VIRTUAL() -> TerminalNode? { return getToken(Cobol85Parser.VIRTUAL, 0) }
		open func WAIT() -> TerminalNode? { return getToken(Cobol85Parser.WAIT, 0) }
		open func XOPTS() -> TerminalNode? { return getToken(Cobol85Parser.XOPTS, 0) }
		open func YEAR() -> TerminalNode? { return getToken(Cobol85Parser.YEAR, 0) }
		open func YYYYMMDD() -> TerminalNode? { return getToken(Cobol85Parser.YYYYMMDD, 0) }
		open func YYYYDDD() -> TerminalNode? { return getToken(Cobol85Parser.YYYYDDD, 0) }
		open func ZERO_FILL() -> TerminalNode? { return getToken(Cobol85Parser.ZERO_FILL, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cobolWord }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCobolWord(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCobolWord(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCobolWord(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCobolWord(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cobolWord() throws -> CobolWordContext {
		var _localctx: CobolWordContext = CobolWordContext(_ctx, getState())
		try enterRule(_localctx, 1150, Cobol85Parser.RULE_cobolWord)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6159)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.ABORT,Cobol85Parser.APOST,Cobol85Parser.ARITH,Cobol85Parser.AS,Cobol85Parser.ASCII,Cobol85Parser.ASSOCIATED_DATA,Cobol85Parser.ASSOCIATED_DATA_LENGTH,Cobol85Parser.ATTRIBUTE,Cobol85Parser.AUTO,Cobol85Parser.AUTO_SKIP,Cobol85Parser.BACKGROUND_COLOR,Cobol85Parser.BACKGROUND_COLOUR,Cobol85Parser.BEEP,Cobol85Parser.BELL,Cobol85Parser.BIT,Cobol85Parser.BLINK,Cobol85Parser.BOUNDS,Cobol85Parser.CAPABLE,Cobol85Parser.CCSVERSION,Cobol85Parser.CHANGED,Cobol85Parser.CHANNEL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.CLOSE_DISPOSITION,Cobol85Parser.COBOL,Cobol85Parser.CODEPAGE,Cobol85Parser.COMMITMENT,Cobol85Parser.CONTROL_POINT,Cobol85Parser.CONVENTION,Cobol85Parser.CRUNCH,Cobol85Parser.CURSOR,Cobol85Parser.DEFAULT,Cobol85Parser.DEFAULT_DISPLAY,Cobol85Parser.DEFINITION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 70)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.DFHRESP,Cobol85Parser.DFHVALUE,Cobol85Parser.DISK,Cobol85Parser.DONTCARE,Cobol85Parser.DOUBLE,Cobol85Parser.EBCDIC,Cobol85Parser.EMPTY_CHECK,Cobol85Parser.ENTER,Cobol85Parser.ENTRY_PROCEDURE,Cobol85Parser.ERASE,Cobol85Parser.EOL,Cobol85Parser.EOS,Cobol85Parser.ESCAPE,Cobol85Parser.EVENT,Cobol85Parser.EXCLUSIVE,Cobol85Parser.EXPORT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 141)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.EXTENDED,Cobol85Parser.FOREGROUND_COLOR,Cobol85Parser.FOREGROUND_COLOUR,Cobol85Parser.FULL,Cobol85Parser.FUNCTIONNAME,Cobol85Parser.FUNCTION_POINTER,Cobol85Parser.GRID,Cobol85Parser.HIGHLIGHT,Cobol85Parser.IMPLICIT,Cobol85Parser.IMPORT,Cobol85Parser.INTEGER,Cobol85Parser.KEPT,Cobol85Parser.LANGUAGE,Cobol85Parser.LB,Cobol85Parser.LD]
		 	              return  Utils.testBitLeftShiftArray(testArray, 205)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.LEFTLINE,Cobol85Parser.LENGTH_CHECK,Cobol85Parser.LIB,Cobol85Parser.LIBACCESS,Cobol85Parser.LIBPARAMETER,Cobol85Parser.LIBRARY,Cobol85Parser.LIST,Cobol85Parser.LOCAL,Cobol85Parser.LONG_DATE,Cobol85Parser.LONG_TIME,Cobol85Parser.LOWER,Cobol85Parser.LOWLIGHT,Cobol85Parser.MMDDYYYY,Cobol85Parser.NAMED,Cobol85Parser.NATIONAL,Cobol85Parser.NETWORK,Cobol85Parser.NO_ECHO,Cobol85Parser.NOSEQ,Cobol85Parser.NUMERIC_DATE,Cobol85Parser.NUMERIC_TIME,Cobol85Parser.ODT,Cobol85Parser.OPTIMIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 270)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.ORDERLY,Cobol85Parser.OVERLINE,Cobol85Parser.OWN,Cobol85Parser.PASSWORD,Cobol85Parser.PORT,Cobol85Parser.PRINTER,Cobol85Parser.PRIVATE,Cobol85Parser.PROCESS,Cobol85Parser.PROGRAM,Cobol85Parser.PROMPT,Cobol85Parser.READER,Cobol85Parser.REMOTE,Cobol85Parser.REAL,Cobol85Parser.RECEIVED,Cobol85Parser.REF,Cobol85Parser.REMOVE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.REQUIRED,Cobol85Parser.REVERSE_VIDEO,Cobol85Parser.SAVE,Cobol85Parser.SECURE,Cobol85Parser.SHARED,Cobol85Parser.SHAREDBYALL,Cobol85Parser.SHAREDBYRUNUNIT,Cobol85Parser.SHARING,Cobol85Parser.SHORT_DATE,Cobol85Parser.SP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.SYMBOL,Cobol85Parser.TASK,Cobol85Parser.THREAD,Cobol85Parser.THREAD_LOCAL,Cobol85Parser.TIMER,Cobol85Parser.TODAYS_DATE,Cobol85Parser.TODAYS_NAME,Cobol85Parser.TRUNCATED,Cobol85Parser.TYPEDEF,Cobol85Parser.UNDERLINE,Cobol85Parser.VIRTUAL,Cobol85Parser.WAIT,Cobol85Parser.XOPTS,Cobol85Parser.YEAR,Cobol85Parser.YYYYMMDD,Cobol85Parser.YYYYDDD,Cobol85Parser.ZERO_FILL]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.IDENTIFIER
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class LiteralContext:ParserRuleContext {
		open func NONNUMERICLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.NONNUMERICLITERAL, 0) }
		open func numericLiteral() -> NumericLiteralContext? {
			return getRuleContext(NumericLiteralContext.self,0)
		}
		open func booleanLiteral() -> BooleanLiteralContext? {
			return getRuleContext(BooleanLiteralContext.self,0)
		}
		open func figurativeConstant() -> FigurativeConstantContext? {
			return getRuleContext(FigurativeConstantContext.self,0)
		}
		open func cicsDfhRespLiteral() -> CicsDfhRespLiteralContext? {
			return getRuleContext(CicsDfhRespLiteralContext.self,0)
		}
		open func cicsDfhValueLiteral() -> CicsDfhValueLiteralContext? {
			return getRuleContext(CicsDfhValueLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_literal }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func literal() throws -> LiteralContext {
		var _localctx: LiteralContext = LiteralContext(_ctx, getState())
		try enterRule(_localctx, 1152, Cobol85Parser.RULE_literal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6167)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,969, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6161)
		 		try match(Cobol85Parser.NONNUMERICLITERAL)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6162)
		 		try numericLiteral()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6163)
		 		try booleanLiteral()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6164)
		 		try figurativeConstant()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6165)
		 		try cicsDfhRespLiteral()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6166)
		 		try cicsDfhValueLiteral()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BooleanLiteralContext:ParserRuleContext {
		open func TRUE() -> TerminalNode? { return getToken(Cobol85Parser.TRUE, 0) }
		open func FALSE() -> TerminalNode? { return getToken(Cobol85Parser.FALSE, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_booleanLiteral }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterBooleanLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitBooleanLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitBooleanLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitBooleanLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func booleanLiteral() throws -> BooleanLiteralContext {
		var _localctx: BooleanLiteralContext = BooleanLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1154, Cobol85Parser.RULE_booleanLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6169)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.FALSE
		 	          testSet = testSet || _la == Cobol85Parser.TRUE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NumericLiteralContext:ParserRuleContext {
		open func NUMERICLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.NUMERICLITERAL, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func integerLiteral() -> IntegerLiteralContext? {
			return getRuleContext(IntegerLiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_numericLiteral }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterNumericLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitNumericLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitNumericLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitNumericLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numericLiteral() throws -> NumericLiteralContext {
		var _localctx: NumericLiteralContext = NumericLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1156, Cobol85Parser.RULE_numericLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6174)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.NUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6171)
		 		try match(Cobol85Parser.NUMERICLITERAL)

		 		break

		 	case Cobol85Parser.ZERO:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6172)
		 		try match(Cobol85Parser.ZERO)

		 		break
		 	case Cobol85Parser.LEVEL_NUMBER_66:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_77:fallthrough
		 	case Cobol85Parser.LEVEL_NUMBER_88:fallthrough
		 	case Cobol85Parser.INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6173)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IntegerLiteralContext:ParserRuleContext {
		open func INTEGERLITERAL() -> TerminalNode? { return getToken(Cobol85Parser.INTEGERLITERAL, 0) }
		open func LEVEL_NUMBER_66() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_66, 0) }
		open func LEVEL_NUMBER_77() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_77, 0) }
		open func LEVEL_NUMBER_88() -> TerminalNode? { return getToken(Cobol85Parser.LEVEL_NUMBER_88, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_integerLiteral }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterIntegerLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitIntegerLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitIntegerLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitIntegerLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func integerLiteral() throws -> IntegerLiteralContext {
		var _localctx: IntegerLiteralContext = IntegerLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1158, Cobol85Parser.RULE_integerLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6176)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.LEVEL_NUMBER_66,Cobol85Parser.LEVEL_NUMBER_77,Cobol85Parser.LEVEL_NUMBER_88,Cobol85Parser.INTEGERLITERAL]
		 	    return  Utils.testBitLeftShiftArray(testArray, 556)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CicsDfhRespLiteralContext:ParserRuleContext {
		open func DFHRESP() -> TerminalNode? { return getToken(Cobol85Parser.DFHRESP, 0) }
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cicsDfhRespLiteral }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCicsDfhRespLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCicsDfhRespLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCicsDfhRespLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCicsDfhRespLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cicsDfhRespLiteral() throws -> CicsDfhRespLiteralContext {
		var _localctx: CicsDfhRespLiteralContext = CicsDfhRespLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1160, Cobol85Parser.RULE_cicsDfhRespLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6178)
		 	try match(Cobol85Parser.DFHRESP)
		 	setState(6179)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(6182)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,971, _ctx)) {
		 	case 1:
		 		setState(6180)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(6181)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(6184)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CicsDfhValueLiteralContext:ParserRuleContext {
		open func DFHVALUE() -> TerminalNode? { return getToken(Cobol85Parser.DFHVALUE, 0) }
		open func LPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.LPARENCHAR, 0) }
		open func RPARENCHAR() -> TerminalNode? { return getToken(Cobol85Parser.RPARENCHAR, 0) }
		open func cobolWord() -> CobolWordContext? {
			return getRuleContext(CobolWordContext.self,0)
		}
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_cicsDfhValueLiteral }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCicsDfhValueLiteral(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCicsDfhValueLiteral(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCicsDfhValueLiteral(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCicsDfhValueLiteral(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cicsDfhValueLiteral() throws -> CicsDfhValueLiteralContext {
		var _localctx: CicsDfhValueLiteralContext = CicsDfhValueLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1162, Cobol85Parser.RULE_cicsDfhValueLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6186)
		 	try match(Cobol85Parser.DFHVALUE)
		 	setState(6187)
		 	try match(Cobol85Parser.LPARENCHAR)
		 	setState(6190)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,972, _ctx)) {
		 	case 1:
		 		setState(6188)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(6189)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(6192)
		 	try match(Cobol85Parser.RPARENCHAR)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class FigurativeConstantContext:ParserRuleContext {
		open func ALL() -> TerminalNode? { return getToken(Cobol85Parser.ALL, 0) }
		open func literal() -> LiteralContext? {
			return getRuleContext(LiteralContext.self,0)
		}
		open func HIGH_VALUE() -> TerminalNode? { return getToken(Cobol85Parser.HIGH_VALUE, 0) }
		open func HIGH_VALUES() -> TerminalNode? { return getToken(Cobol85Parser.HIGH_VALUES, 0) }
		open func LOW_VALUE() -> TerminalNode? { return getToken(Cobol85Parser.LOW_VALUE, 0) }
		open func LOW_VALUES() -> TerminalNode? { return getToken(Cobol85Parser.LOW_VALUES, 0) }
		open func NULL() -> TerminalNode? { return getToken(Cobol85Parser.NULL, 0) }
		open func NULLS() -> TerminalNode? { return getToken(Cobol85Parser.NULLS, 0) }
		open func QUOTE() -> TerminalNode? { return getToken(Cobol85Parser.QUOTE, 0) }
		open func QUOTES() -> TerminalNode? { return getToken(Cobol85Parser.QUOTES, 0) }
		open func SPACE() -> TerminalNode? { return getToken(Cobol85Parser.SPACE, 0) }
		open func SPACES() -> TerminalNode? { return getToken(Cobol85Parser.SPACES, 0) }
		open func ZERO() -> TerminalNode? { return getToken(Cobol85Parser.ZERO, 0) }
		open func ZEROS() -> TerminalNode? { return getToken(Cobol85Parser.ZEROS, 0) }
		open func ZEROES() -> TerminalNode? { return getToken(Cobol85Parser.ZEROES, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_figurativeConstant }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterFigurativeConstant(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitFigurativeConstant(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitFigurativeConstant(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitFigurativeConstant(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func figurativeConstant() throws -> FigurativeConstantContext {
		var _localctx: FigurativeConstantContext = FigurativeConstantContext(_ctx, getState())
		try enterRule(_localctx, 1164, Cobol85Parser.RULE_figurativeConstant)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6209)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ALL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6194)
		 		try match(Cobol85Parser.ALL)
		 		setState(6195)
		 		try literal()

		 		break

		 	case Cobol85Parser.HIGH_VALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6196)
		 		try match(Cobol85Parser.HIGH_VALUE)

		 		break

		 	case Cobol85Parser.HIGH_VALUES:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6197)
		 		try match(Cobol85Parser.HIGH_VALUES)

		 		break

		 	case Cobol85Parser.LOW_VALUE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6198)
		 		try match(Cobol85Parser.LOW_VALUE)

		 		break

		 	case Cobol85Parser.LOW_VALUES:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6199)
		 		try match(Cobol85Parser.LOW_VALUES)

		 		break

		 	case Cobol85Parser.NULL:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6200)
		 		try match(Cobol85Parser.NULL)

		 		break

		 	case Cobol85Parser.NULLS:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6201)
		 		try match(Cobol85Parser.NULLS)

		 		break

		 	case Cobol85Parser.QUOTE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6202)
		 		try match(Cobol85Parser.QUOTE)

		 		break

		 	case Cobol85Parser.QUOTES:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6203)
		 		try match(Cobol85Parser.QUOTES)

		 		break

		 	case Cobol85Parser.SPACE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6204)
		 		try match(Cobol85Parser.SPACE)

		 		break

		 	case Cobol85Parser.SPACES:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6205)
		 		try match(Cobol85Parser.SPACES)

		 		break

		 	case Cobol85Parser.ZERO:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6206)
		 		try match(Cobol85Parser.ZERO)

		 		break

		 	case Cobol85Parser.ZEROS:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6207)
		 		try match(Cobol85Parser.ZEROS)

		 		break

		 	case Cobol85Parser.ZEROES:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6208)
		 		try match(Cobol85Parser.ZEROES)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SpecialRegisterContext:ParserRuleContext {
		open func ADDRESS() -> TerminalNode? { return getToken(Cobol85Parser.ADDRESS, 0) }
		open func OF() -> TerminalNode? { return getToken(Cobol85Parser.OF, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func DATE() -> TerminalNode? { return getToken(Cobol85Parser.DATE, 0) }
		open func DAY() -> TerminalNode? { return getToken(Cobol85Parser.DAY, 0) }
		open func DAY_OF_WEEK() -> TerminalNode? { return getToken(Cobol85Parser.DAY_OF_WEEK, 0) }
		open func DEBUG_CONTENTS() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_CONTENTS, 0) }
		open func DEBUG_ITEM() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_ITEM, 0) }
		open func DEBUG_LINE() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_LINE, 0) }
		open func DEBUG_NAME() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_NAME, 0) }
		open func DEBUG_SUB_1() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_SUB_1, 0) }
		open func DEBUG_SUB_2() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_SUB_2, 0) }
		open func DEBUG_SUB_3() -> TerminalNode? { return getToken(Cobol85Parser.DEBUG_SUB_3, 0) }
		open func LENGTH() -> TerminalNode? { return getToken(Cobol85Parser.LENGTH, 0) }
		open func LINAGE_COUNTER() -> TerminalNode? { return getToken(Cobol85Parser.LINAGE_COUNTER, 0) }
		open func LINE_COUNTER() -> TerminalNode? { return getToken(Cobol85Parser.LINE_COUNTER, 0) }
		open func PAGE_COUNTER() -> TerminalNode? { return getToken(Cobol85Parser.PAGE_COUNTER, 0) }
		open func RETURN_CODE() -> TerminalNode? { return getToken(Cobol85Parser.RETURN_CODE, 0) }
		open func SHIFT_OUT() -> TerminalNode? { return getToken(Cobol85Parser.SHIFT_OUT, 0) }
		open func SHIFT_IN() -> TerminalNode? { return getToken(Cobol85Parser.SHIFT_IN, 0) }
		open func SORT_CONTROL() -> TerminalNode? { return getToken(Cobol85Parser.SORT_CONTROL, 0) }
		open func SORT_CORE_SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SORT_CORE_SIZE, 0) }
		open func SORT_FILE_SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SORT_FILE_SIZE, 0) }
		open func SORT_MESSAGE() -> TerminalNode? { return getToken(Cobol85Parser.SORT_MESSAGE, 0) }
		open func SORT_MODE_SIZE() -> TerminalNode? { return getToken(Cobol85Parser.SORT_MODE_SIZE, 0) }
		open func SORT_RETURN() -> TerminalNode? { return getToken(Cobol85Parser.SORT_RETURN, 0) }
		open func TALLY() -> TerminalNode? { return getToken(Cobol85Parser.TALLY, 0) }
		open func TIME() -> TerminalNode? { return getToken(Cobol85Parser.TIME, 0) }
		open func WHEN_COMPILED() -> TerminalNode? { return getToken(Cobol85Parser.WHEN_COMPILED, 0) }
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_specialRegister }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterSpecialRegister(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitSpecialRegister(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitSpecialRegister(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitSpecialRegister(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func specialRegister() throws -> SpecialRegisterContext {
		var _localctx: SpecialRegisterContext = SpecialRegisterContext(_ctx, getState())
		try enterRule(_localctx, 1166, Cobol85Parser.RULE_specialRegister)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6242)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case Cobol85Parser.ADDRESS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6211)
		 		try match(Cobol85Parser.ADDRESS)
		 		setState(6212)
		 		try match(Cobol85Parser.OF)
		 		setState(6213)
		 		try identifier()

		 		break

		 	case Cobol85Parser.DATE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6214)
		 		try match(Cobol85Parser.DATE)

		 		break

		 	case Cobol85Parser.DAY:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6215)
		 		try match(Cobol85Parser.DAY)

		 		break

		 	case Cobol85Parser.DAY_OF_WEEK:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6216)
		 		try match(Cobol85Parser.DAY_OF_WEEK)

		 		break

		 	case Cobol85Parser.DEBUG_CONTENTS:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6217)
		 		try match(Cobol85Parser.DEBUG_CONTENTS)

		 		break

		 	case Cobol85Parser.DEBUG_ITEM:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6218)
		 		try match(Cobol85Parser.DEBUG_ITEM)

		 		break

		 	case Cobol85Parser.DEBUG_LINE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6219)
		 		try match(Cobol85Parser.DEBUG_LINE)

		 		break

		 	case Cobol85Parser.DEBUG_NAME:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6220)
		 		try match(Cobol85Parser.DEBUG_NAME)

		 		break

		 	case Cobol85Parser.DEBUG_SUB_1:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6221)
		 		try match(Cobol85Parser.DEBUG_SUB_1)

		 		break

		 	case Cobol85Parser.DEBUG_SUB_2:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6222)
		 		try match(Cobol85Parser.DEBUG_SUB_2)

		 		break

		 	case Cobol85Parser.DEBUG_SUB_3:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6223)
		 		try match(Cobol85Parser.DEBUG_SUB_3)

		 		break

		 	case Cobol85Parser.LENGTH:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6224)
		 		try match(Cobol85Parser.LENGTH)
		 		setState(6225)
		 		try match(Cobol85Parser.OF)
		 		setState(6226)
		 		try identifier()

		 		break

		 	case Cobol85Parser.LINAGE_COUNTER:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6227)
		 		try match(Cobol85Parser.LINAGE_COUNTER)

		 		break

		 	case Cobol85Parser.LINE_COUNTER:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6228)
		 		try match(Cobol85Parser.LINE_COUNTER)

		 		break

		 	case Cobol85Parser.PAGE_COUNTER:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(6229)
		 		try match(Cobol85Parser.PAGE_COUNTER)

		 		break

		 	case Cobol85Parser.RETURN_CODE:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(6230)
		 		try match(Cobol85Parser.RETURN_CODE)

		 		break

		 	case Cobol85Parser.SHIFT_OUT:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(6231)
		 		try match(Cobol85Parser.SHIFT_OUT)

		 		break

		 	case Cobol85Parser.SHIFT_IN:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(6232)
		 		try match(Cobol85Parser.SHIFT_IN)

		 		break

		 	case Cobol85Parser.SORT_CONTROL:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(6233)
		 		try match(Cobol85Parser.SORT_CONTROL)

		 		break

		 	case Cobol85Parser.SORT_CORE_SIZE:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(6234)
		 		try match(Cobol85Parser.SORT_CORE_SIZE)

		 		break

		 	case Cobol85Parser.SORT_FILE_SIZE:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(6235)
		 		try match(Cobol85Parser.SORT_FILE_SIZE)

		 		break

		 	case Cobol85Parser.SORT_MESSAGE:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(6236)
		 		try match(Cobol85Parser.SORT_MESSAGE)

		 		break

		 	case Cobol85Parser.SORT_MODE_SIZE:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(6237)
		 		try match(Cobol85Parser.SORT_MODE_SIZE)

		 		break

		 	case Cobol85Parser.SORT_RETURN:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(6238)
		 		try match(Cobol85Parser.SORT_RETURN)

		 		break

		 	case Cobol85Parser.TALLY:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(6239)
		 		try match(Cobol85Parser.TALLY)

		 		break

		 	case Cobol85Parser.TIME:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(6240)
		 		try match(Cobol85Parser.TIME)

		 		break

		 	case Cobol85Parser.WHEN_COMPILED:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(6241)
		 		try match(Cobol85Parser.WHEN_COMPILED)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class CommentEntryContext:ParserRuleContext {
		open func COMMENTENTRYLINE() -> Array<TerminalNode> { return getTokens(Cobol85Parser.COMMENTENTRYLINE) }
		open func COMMENTENTRYLINE(_ i:Int) -> TerminalNode?{
			return getToken(Cobol85Parser.COMMENTENTRYLINE, i)
		}
		open override func getRuleIndex() -> Int { return Cobol85Parser.RULE_commentEntry }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).enterCommentEntry(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is Cobol85Listener {
			 	(listener as! Cobol85Listener).exitCommentEntry(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is Cobol85Visitor {
			     return (visitor as! Cobol85Visitor<T>).visitCommentEntry(self)
			}else if visitor is Cobol85BaseVisitor {
		    	 return (visitor as! Cobol85BaseVisitor<T>).visitCommentEntry(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func commentEntry() throws -> CommentEntryContext {
		var _localctx: CommentEntryContext = CommentEntryContext(_ctx, getState())
		try enterRule(_localctx, 1168, Cobol85Parser.RULE_commentEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6245) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(6244)
		 		try match(Cobol85Parser.COMMENTENTRYLINE)


		 		setState(6247); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.COMMENTENTRYLINE
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

   public static let _serializedATN : String = Cobol85ParserATN().jsonString
   public static let _ATN: ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}