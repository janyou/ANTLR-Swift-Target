// Generated from ./grammars-v4/plsql/plsql.g4 by ANTLR 4.5.1
import Antlr4

open class plsqlParser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = plsqlParser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(plsqlParser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()
	internal static let _sharedContextCache: PredictionContextCache = PredictionContextCache()
	public static let T__0=1, A_LETTER=2, ADD=3, AFTER=4, AGENT=5, AGGREGATE=6, 
                   ALL=7, ALTER=8, ANALYZE=9, AND=10, ANY=11, ARRAY=12, 
                   AS=13, ASC=14, ASSOCIATE=15, AT=16, ATTRIBUTE=17, AUDIT=18, 
                   AUTHID=19, AUTO=20, AUTOMATIC=21, AUTONOMOUS_TRANSACTION=22, 
                   BATCH=23, BEFORE=24, BEGIN=25, BETWEEN=26, BFILE=27, 
                   BINARY_DOUBLE=28, BINARY_FLOAT=29, BINARY_INTEGER=30, 
                   BLOB=31, BLOCK=32, BODY=33, BOOLEAN=34, BOTH=35, BREADTH=36, 
                   BULK=37, BY=38, BYTE=39, C_LETTER=40, CACHE=41, CALL=42, 
                   CANONICAL=43, CASCADE=44, CASE=45, CAST=46, CHAR=47, 
                   CHAR_CS=48, CHARACTER=49, CHECK=50, CHR=51, CLOB=52, 
                   CLOSE=53, CLUSTER=54, COLLECT=55, COLUMNS=56, COMMENT=57, 
                   COMMIT=58, COMMITTED=59, COMPATIBILITY=60, COMPILE=61, 
                   COMPOUND=62, CONNECT=63, CONNECT_BY_ROOT=64, CONSTANT=65, 
                   CONSTRAINT=66, CONSTRAINTS=67, CONSTRUCTOR=68, CONTENT=69, 
                   CONTEXT=70, CONTINUE=71, CONVERT=72, CORRUPT_XID=73, 
                   CORRUPT_XID_ALL=74, COST=75, COUNT=76, CREATE=77, CROSS=78, 
                   CUBE=79, CURRENT=80, CURRENT_USER=81, CURSOR=82, CUSTOMDATUM=83, 
                   CYCLE=84, DATA=85, DATABASE=86, DATE=87, DAY=88, DB_ROLE_CHANGE=89, 
                   DBTIMEZONE=90, DDL=91, DEBUG=92, DEC=93, DECIMAL=94, 
                   DECLARE=95, DECOMPOSE=96, DECREMENT=97, DEFAULT=98, DEFAULTS=99, 
                   DEFERRED=100, DEFINER=101, DELETE=102, DEPTH=103, DESC=104, 
                   DETERMINISTIC=105, DIMENSION=106, DISABLE=107, DISASSOCIATE=108, 
                   DISTINCT=109, DOCUMENT=110, DOUBLE=111, DROP=112, DSINTERVAL_UNCONSTRAINED=113, 
                   EACH=114, ELEMENT=115, ELSE=116, ELSIF=117, EMPTY=118, 
                   ENABLE=119, ENCODING=120, END=121, ENTITYESCAPING=122, 
                   ERR=123, ERRORS=124, ESCAPE=125, EVALNAME=126, EXCEPTION=127, 
                   EXCEPTION_INIT=128, EXCEPTIONS=129, EXCLUDE=130, EXCLUSIVE=131, 
                   EXECUTE=132, EXISTS=133, EXIT=134, EXPLAIN=135, EXTERNAL=136, 
                   EXTRACT=137, FAILURE=138, FALSE=139, FETCH=140, FINAL=141, 
                   FIRST=142, FIRST_VALUE=143, FLOAT=144, FOLLOWING=145, 
                   FOLLOWS=146, FOR=147, FORALL=148, FORCE=149, FROM=150, 
                   FULL=151, FUNCTION=152, GOTO=153, GRANT=154, GROUP=155, 
                   GROUPING=156, HASH=157, HAVING=158, HIDE=159, HOUR=160, 
                   IF=161, IGNORE=162, IMMEDIATE=163, IN=164, INCLUDE=165, 
                   INCLUDING=166, INCREMENT=167, INDENT=168, INDEX=169, 
                   INDEXED=170, INDICATOR=171, INDICES=172, INFINITE=173, 
                   INLINE=174, INNER=175, INOUT=176, INSERT=177, INSTANTIABLE=178, 
                   INSTEAD=179, INT=180, INTEGER=181, INTERSECT=182, INTERVAL=183, 
                   INTO=184, INVALIDATE=185, IS=186, ISOLATION=187, ITERATE=188, 
                   JAVA=189, JOIN=190, KEEP=191, LANGUAGE=192, LAST=193, 
                   LAST_VALUE=194, LEADING=195, LEFT=196, LEVEL=197, LIBRARY=198, 
                   LIKE=199, LIKE2=200, LIKE4=201, LIKEC=202, LIMIT=203, 
                   LOCAL=204, LOCK=205, LOCKED=206, LOG=207, LOGOFF=208, 
                   LOGON=209, LONG=210, LOOP=211, MAIN=212, MAP=213, MATCHED=214, 
                   MAXVALUE=215, MEASURES=216, MEMBER=217, MERGE=218, MINUS=219, 
                   MINUTE=220, MINVALUE=221, MLSLABEL=222, MODE=223, MODEL=224, 
                   MODIFY=225, MONTH=226, MULTISET=227, NAME=228, NAN=229, 
                   NATURAL=230, NATURALN=231, NAV=232, NCHAR=233, NCHAR_CS=234, 
                   NCLOB=235, NESTED=236, NEW=237, NO=238, NOAUDIT=239, 
                   NOCACHE=240, NOCOPY=241, NOCYCLE=242, NOENTITYESCAPING=243, 
                   NOMAXVALUE=244, NOMINVALUE=245, NONE=246, NOORDER=247, 
                   NOSCHEMACHECK=248, NOT=249, NOWAIT=250, NULL=251, NULLS=252, 
                   NUMBER=253, NUMERIC=254, NVARCHAR2=255, OBJECT=256, OF=257, 
                   OFF=258, OID=259, OLD=260, ON=261, ONLY=262, OPEN=263, 
                   OPTION=264, OR=265, ORADATA=266, ORDER=267, ORDINALITY=268, 
                   OSERROR=269, OUT=270, OUTER=271, OVER=272, OVERRIDING=273, 
                   PACKAGE=274, PARALLEL_ENABLE=275, PARAMETERS=276, PARENT=277, 
                   PARTITION=278, PASSING=279, PATH=280, PERCENT_ISOPEN=281, 
                   PERCENT_FOUND=282, PERCENT_NOTFOUND=283, PERCENT_ROWCOUNT=284, 
                   PERCENT_ROWTYPE=285, PERCENT_TYPE=286, PIPELINED=287, 
                   PIVOT=288, PLAN=289, PLS_INTEGER=290, POSITIVE=291, POSITIVEN=292, 
                   PRAGMA=293, PRECEDING=294, PRECISION=295, PRESENT=296, 
                   PRIOR=297, PROCEDURE=298, RAISE=299, RANGE=300, RAW=301, 
                   READ=302, REAL=303, RECORD=304, REF=305, REFERENCE=306, 
                   REFERENCING=307, REJECT=308, RELIES_ON=309, RENAME=310, 
                   REPLACE=311, RESPECT=312, RESTRICT_REFERENCES=313, RESULT=314, 
                   RESULT_CACHE=315, RETURN=316, RETURNING=317, REUSE=318, 
                   REVERSE=319, REVOKE=320, RIGHT=321, ROLLBACK=322, ROLLUP=323, 
                   ROW=324, ROWID=325, ROWS=326, RULES=327, SAMPLE=328, 
                   SAVE=329, SAVEPOINT=330, SCHEMA=331, SCHEMACHECK=332, 
                   SCN=333, SEARCH=334, SECOND=335, SEED=336, SEGMENT=337, 
                   SELECT=338, SELF=339, SEQUENCE=340, SEQUENTIAL=341, SERIALIZABLE=342, 
                   SERIALLY_REUSABLE=343, SERVERERROR=344, SESSIONTIMEZONE=345, 
                   SET=346, SETS=347, SETTINGS=348, SHARE=349, SHOW=350, 
                   SHUTDOWN=351, SIBLINGS=352, SIGNTYPE=353, SIMPLE_INTEGER=354, 
                   SINGLE=355, SIZE=356, SKIP_=357, SMALLINT=358, SNAPSHOT=359, 
                   SOME=360, SPECIFICATION=361, SQLDATA=362, SQLERROR=363, 
                   STANDALONE=364, START=365, STARTUP=366, STATEMENT=367, 
                   STATEMENT_ID=368, STATIC=369, STATISTICS=370, STRING=371, 
                   SUBMULTISET=372, SUBPARTITION=373, SUBSTITUTABLE=374, 
                   SUBTYPE=375, SUCCESS=376, SUSPEND=377, TABLE=378, THE=379, 
                   THEN=380, TIME=381, TIMESTAMP=382, TIMESTAMP_LTZ_UNCONSTRAINED=383, 
                   TIMESTAMP_TZ_UNCONSTRAINED=384, TIMESTAMP_UNCONSTRAINED=385, 
                   TIMEZONE_ABBR=386, TIMEZONE_HOUR=387, TIMEZONE_MINUTE=388, 
                   TIMEZONE_REGION=389, TO=390, TRAILING=391, TRANSACTION=392, 
                   TRANSLATE=393, TREAT=394, TRIGGER=395, TRIM=396, TRUE=397, 
                   TRUNCATE=398, TYPE=399, UNBOUNDED=400, UNDER=401, UNION=402, 
                   UNIQUE=403, UNLIMITED=404, UNPIVOT=405, UNTIL=406, UPDATE=407, 
                   UPDATED=408, UPSERT=409, UROWID=410, USE=411, USING=412, 
                   VALIDATE=413, VALUE=414, VALUES=415, VARCHAR=416, VARCHAR2=417, 
                   VARIABLE=418, VARRAY=419, VARYING=420, VERSION=421, VERSIONS=422, 
                   WAIT=423, WARNING=424, WELLFORMED=425, WHEN=426, WHENEVER=427, 
                   WHERE=428, WHILE=429, WITH=430, WITHIN=431, WORK=432, 
                   WRITE=433, XML=434, XMLAGG=435, XMLATTRIBUTES=436, XMLCAST=437, 
                   XMLCOLATTVAL=438, XMLELEMENT=439, XMLEXISTS=440, XMLFOREST=441, 
                   XMLNAMESPACES=442, XMLPARSE=443, XMLPI=444, XMLQUERY=445, 
                   XMLROOT=446, XMLSERIALIZE=447, XMLTABLE=448, YEAR=449, 
                   YES=450, YMINTERVAL_UNCONSTRAINED=451, ZONE=452, PREDICTION=453, 
                   PREDICTION_BOUNDS=454, PREDICTION_COST=455, PREDICTION_DETAILS=456, 
                   PREDICTION_PROBABILITY=457, PREDICTION_SET=458, CUME_DIST=459, 
                   DENSE_RANK=460, LISTAGG=461, PERCENT_RANK=462, PERCENTILE_CONT=463, 
                   PERCENTILE_DISC=464, RANK=465, AVG=466, CORR=467, LAG=468, 
                   LEAD=469, MAX=470, MEDIAN=471, MIN=472, NTILE=473, RATIO_TO_REPORT=474, 
                   ROW_NUMBER=475, SUM=476, VARIANCE=477, REGR_=478, STDDEV=479, 
                   VAR_=480, COVAR_=481, NATIONAL_CHAR_STRING_LIT=482, BIT_STRING_LIT=483, 
                   HEX_STRING_LIT=484, DOUBLE_PERIOD=485, PERIOD=486, UNSIGNED_INTEGER=487, 
                   APPROXIMATE_NUM_LIT=488, CHAR_STRING=489, DELIMITED_ID=490, 
                   PERCENT=491, AMPERSAND=492, LEFT_PAREN=493, RIGHT_PAREN=494, 
                   DOUBLE_ASTERISK=495, ASTERISK=496, PLUS_SIGN=497, MINUS_SIGN=498, 
                   COMMA=499, SOLIDUS=500, AT_SIGN=501, ASSIGN_OP=502, BINDVAR=503, 
                   COLON=504, SEMICOLON=505, LESS_THAN_OR_EQUALS_OP=506, 
                   LESS_THAN_OP=507, GREATER_THAN_OR_EQUALS_OP=508, NOT_EQUAL_OP=509, 
                   CARRET_OPERATOR_PART=510, TILDE_OPERATOR_PART=511, EXCLAMATION_OPERATOR_PART=512, 
                   GREATER_THAN_OP=513, CONCATENATION_OP=514, VERTICAL_BAR=515, 
                   EQUALS_OP=516, LEFT_BRACKET=517, RIGHT_BRACKET=518, INTRODUCER=519, 
                   SPACES=520, SINGLE_LINE_COMMENT=521, MULTI_LINE_COMMENT=522, 
                   PROMPT=523, REGULAR_ID=524, ZV=525
	public static let RULE_swallow_to_semi = 0, RULE_compilation_unit = 1, 
                   RULE_sql_script = 2, RULE_unit_statement = 3, RULE_drop_function = 4, 
                   RULE_alter_function = 5, RULE_create_function_body = 6, 
                   RULE_parallel_enable_clause = 7, RULE_partition_by_clause = 8, 
                   RULE_result_cache_clause = 9, RULE_relies_on_part = 10, 
                   RULE_streaming_clause = 11, RULE_drop_package = 12, RULE_alter_package = 13, 
                   RULE_create_package = 14, RULE_package_body = 15, RULE_package_spec = 16, 
                   RULE_package_obj_spec = 17, RULE_procedure_spec = 18, 
                   RULE_function_spec = 19, RULE_package_obj_body = 20, 
                   RULE_drop_procedure = 21, RULE_alter_procedure = 22, 
                   RULE_create_procedure_body = 23, RULE_drop_trigger = 24, 
                   RULE_alter_trigger = 25, RULE_create_trigger = 26, RULE_trigger_follows_clause = 27, 
                   RULE_trigger_when_clause = 28, RULE_simple_dml_trigger = 29, 
                   RULE_for_each_row = 30, RULE_compound_dml_trigger = 31, 
                   RULE_non_dml_trigger = 32, RULE_trigger_body = 33, RULE_routine_clause = 34, 
                   RULE_compound_trigger_block = 35, RULE_timing_point_section = 36, 
                   RULE_non_dml_event = 37, RULE_dml_event_clause = 38, 
                   RULE_dml_event_element = 39, RULE_dml_event_nested_clause = 40, 
                   RULE_referencing_clause = 41, RULE_referencing_element = 42, 
                   RULE_drop_type = 43, RULE_alter_type = 44, RULE_compile_type_clause = 45, 
                   RULE_replace_type_clause = 46, RULE_alter_method_spec = 47, 
                   RULE_alter_method_element = 48, RULE_alter_attribute_definition = 49, 
                   RULE_attribute_definition = 50, RULE_alter_collection_clauses = 51, 
                   RULE_dependent_handling_clause = 52, RULE_dependent_exceptions_part = 53, 
                   RULE_create_type = 54, RULE_type_definition = 55, RULE_object_type_def = 56, 
                   RULE_object_as_part = 57, RULE_object_under_part = 58, 
                   RULE_nested_table_type_def = 59, RULE_sqlj_object_type = 60, 
                   RULE_type_body = 61, RULE_type_body_elements = 62, RULE_map_order_func_declaration = 63, 
                   RULE_subprog_decl_in_type = 64, RULE_proc_decl_in_type = 65, 
                   RULE_func_decl_in_type = 66, RULE_constructor_declaration = 67, 
                   RULE_modifier_clause = 68, RULE_object_member_spec = 69, 
                   RULE_sqlj_object_type_attr = 70, RULE_element_spec = 71, 
                   RULE_element_spec_options = 72, RULE_subprogram_spec = 73, 
                   RULE_type_procedure_spec = 74, RULE_type_function_spec = 75, 
                   RULE_constructor_spec = 76, RULE_map_order_function_spec = 77, 
                   RULE_pragma_clause = 78, RULE_pragma_elements = 79, RULE_type_elements_parameter = 80, 
                   RULE_drop_sequence = 81, RULE_alter_sequence = 82, RULE_create_sequence = 83, 
                   RULE_sequence_spec = 84, RULE_sequence_start_clause = 85, 
                   RULE_invoker_rights_clause = 86, RULE_compiler_parameters_clause = 87, 
                   RULE_call_spec = 88, RULE_java_spec = 89, RULE_c_spec = 90, 
                   RULE_c_agent_in_clause = 91, RULE_c_parameters_clause = 92, 
                   RULE_parameter = 93, RULE_default_value_part = 94, RULE_declare_spec = 95, 
                   RULE_variable_declaration = 96, RULE_subtype_declaration = 97, 
                   RULE_cursor_declaration = 98, RULE_parameter_spec = 99, 
                   RULE_exception_declaration = 100, RULE_pragma_declaration = 101, 
                   RULE_record_declaration = 102, RULE_record_type_dec = 103, 
                   RULE_field_spec = 104, RULE_record_var_dec = 105, RULE_table_declaration = 106, 
                   RULE_table_type_dec = 107, RULE_table_indexed_by_part = 108, 
                   RULE_varray_type_def = 109, RULE_table_var_dec = 110, 
                   RULE_seq_of_statements = 111, RULE_label_declaration = 112, 
                   RULE_statement = 113, RULE_assignment_statement = 114, 
                   RULE_continue_statement = 115, RULE_exit_statement = 116, 
                   RULE_goto_statement = 117, RULE_if_statement = 118, RULE_elsif_part = 119, 
                   RULE_else_part = 120, RULE_loop_statement = 121, RULE_cursor_loop_param = 122, 
                   RULE_forall_statement = 123, RULE_bounds_clause = 124, 
                   RULE_between_bound = 125, RULE_lower_bound = 126, RULE_upper_bound = 127, 
                   RULE_null_statement = 128, RULE_raise_statement = 129, 
                   RULE_return_statement = 130, RULE_function_call = 131, 
                   RULE_body = 132, RULE_exception_handler = 133, RULE_trigger_block = 134, 
                   RULE_block = 135, RULE_sql_statement = 136, RULE_execute_immediate = 137, 
                   RULE_dynamic_returning_clause = 138, RULE_data_manipulation_language_statements = 139, 
                   RULE_cursor_manipulation_statements = 140, RULE_close_statement = 141, 
                   RULE_open_statement = 142, RULE_fetch_statement = 143, 
                   RULE_open_for_statement = 144, RULE_transaction_control_statements = 145, 
                   RULE_set_transaction_command = 146, RULE_set_constraint_command = 147, 
                   RULE_commit_statement = 148, RULE_write_clause = 149, 
                   RULE_rollback_statement = 150, RULE_savepoint_statement = 151, 
                   RULE_explain_statement = 152, RULE_select_statement = 153, 
                   RULE_subquery_factoring_clause = 154, RULE_factoring_element = 155, 
                   RULE_search_clause = 156, RULE_cycle_clause = 157, RULE_subquery = 158, 
                   RULE_subquery_operation_part = 159, RULE_subquery_basic_elements = 160, 
                   RULE_query_block = 161, RULE_selected_element = 162, 
                   RULE_from_clause = 163, RULE_select_list_elements = 164, 
                   RULE_table_ref_list = 165, RULE_table_ref = 166, RULE_table_ref_aux = 167, 
                   RULE_join_clause = 168, RULE_join_on_part = 169, RULE_join_using_part = 170, 
                   RULE_outer_join_type = 171, RULE_query_partition_clause = 172, 
                   RULE_flashback_query_clause = 173, RULE_pivot_clause = 174, 
                   RULE_pivot_element = 175, RULE_pivot_for_clause = 176, 
                   RULE_pivot_in_clause = 177, RULE_pivot_in_clause_element = 178, 
                   RULE_pivot_in_clause_elements = 179, RULE_unpivot_clause = 180, 
                   RULE_unpivot_in_clause = 181, RULE_unpivot_in_elements = 182, 
                   RULE_hierarchical_query_clause = 183, RULE_start_part = 184, 
                   RULE_group_by_clause = 185, RULE_group_by_elements = 186, 
                   RULE_rollup_cube_clause = 187, RULE_grouping_sets_clause = 188, 
                   RULE_grouping_sets_elements = 189, RULE_having_clause = 190, 
                   RULE_model_clause = 191, RULE_cell_reference_options = 192, 
                   RULE_return_rows_clause = 193, RULE_reference_model = 194, 
                   RULE_main_model = 195, RULE_model_column_clauses = 196, 
                   RULE_model_column_partition_part = 197, RULE_model_column_list = 198, 
                   RULE_model_column = 199, RULE_model_rules_clause = 200, 
                   RULE_model_rules_part = 201, RULE_model_rules_element = 202, 
                   RULE_cell_assignment = 203, RULE_model_iterate_clause = 204, 
                   RULE_until_part = 205, RULE_order_by_clause = 206, RULE_order_by_elements = 207, 
                   RULE_for_update_clause = 208, RULE_for_update_of_part = 209, 
                   RULE_for_update_options = 210, RULE_update_statement = 211, 
                   RULE_update_set_clause = 212, RULE_column_based_update_set_clause = 213, 
                   RULE_delete_statement = 214, RULE_insert_statement = 215, 
                   RULE_single_table_insert = 216, RULE_multi_table_insert = 217, 
                   RULE_multi_table_element = 218, RULE_conditional_insert_clause = 219, 
                   RULE_conditional_insert_when_part = 220, RULE_conditional_insert_else_part = 221, 
                   RULE_insert_into_clause = 222, RULE_values_clause = 223, 
                   RULE_merge_statement = 224, RULE_merge_update_clause = 225, 
                   RULE_merge_element = 226, RULE_merge_update_delete_part = 227, 
                   RULE_merge_insert_clause = 228, RULE_selected_tableview = 229, 
                   RULE_lock_table_statement = 230, RULE_wait_nowait_part = 231, 
                   RULE_lock_table_element = 232, RULE_lock_mode = 233, 
                   RULE_general_table_ref = 234, RULE_static_returning_clause = 235, 
                   RULE_error_logging_clause = 236, RULE_error_logging_into_part = 237, 
                   RULE_error_logging_reject_part = 238, RULE_dml_table_expression_clause = 239, 
                   RULE_table_collection_expression = 240, RULE_subquery_restriction_clause = 241, 
                   RULE_sample_clause = 242, RULE_seed_part = 243, RULE_cursor_expression = 244, 
                   RULE_expression_list = 245, RULE_condition = 246, RULE_expression = 247, 
                   RULE_logical_or_expression = 248, RULE_logical_and_expression = 249, 
                   RULE_negated_expression = 250, RULE_equality_expression = 251, 
                   RULE_multiset_expression = 252, RULE_multiset_type = 253, 
                   RULE_relational_expression = 254, RULE_compound_expression = 255, 
                   RULE_relational_operator = 256, RULE_like_type = 257, 
                   RULE_like_escape_part = 258, RULE_in_elements = 259, 
                   RULE_between_elements = 260, RULE_concatenation = 261, 
                   RULE_additive_expression = 262, RULE_multiply_expression = 263, 
                   RULE_datetime_expression = 264, RULE_interval_expression = 265, 
                   RULE_model_expression = 266, RULE_model_expression_element = 267, 
                   RULE_single_column_for_loop = 268, RULE_for_like_part = 269, 
                   RULE_for_increment_decrement_type = 270, RULE_multi_column_for_loop = 271, 
                   RULE_unary_expression = 272, RULE_case_statement = 273, 
                   RULE_simple_case_statement = 274, RULE_simple_case_when_part = 275, 
                   RULE_searched_case_statement = 276, RULE_searched_case_when_part = 277, 
                   RULE_case_else_part = 278, RULE_atom = 279, RULE_expression_or_vector = 280, 
                   RULE_vector_expr = 281, RULE_quantified_expression = 282, 
                   RULE_standard_function = 283, RULE_over_clause_keyword = 284, 
                   RULE_within_or_over_clause_keyword = 285, RULE_standard_prediction_function_keyword = 286, 
                   RULE_over_clause = 287, RULE_windowing_clause = 288, 
                   RULE_windowing_type = 289, RULE_windowing_elements = 290, 
                   RULE_using_clause = 291, RULE_using_element = 292, RULE_collect_order_by_part = 293, 
                   RULE_within_or_over_part = 294, RULE_cost_matrix_clause = 295, 
                   RULE_xml_passing_clause = 296, RULE_xml_attributes_clause = 297, 
                   RULE_xml_namespaces_clause = 298, RULE_xml_table_column = 299, 
                   RULE_xml_general_default_part = 300, RULE_xml_multiuse_expression_element = 301, 
                   RULE_xmlroot_param_version_part = 302, RULE_xmlroot_param_standalone_part = 303, 
                   RULE_xmlserialize_param_enconding_part = 304, RULE_xmlserialize_param_version_part = 305, 
                   RULE_xmlserialize_param_ident_part = 306, RULE_sql_plus_command = 307, 
                   RULE_whenever_command = 308, RULE_set_command = 309, 
                   RULE_exit_command = 310, RULE_prompt_command = 311, RULE_show_errors_command = 312, 
                   RULE_partition_extension_clause = 313, RULE_column_alias = 314, 
                   RULE_table_alias = 315, RULE_alias_quoted_string = 316, 
                   RULE_where_clause = 317, RULE_current_of_clause = 318, 
                   RULE_into_clause = 319, RULE_xml_column_name = 320, RULE_cost_class_name = 321, 
                   RULE_attribute_name = 322, RULE_savepoint_name = 323, 
                   RULE_rollback_segment_name = 324, RULE_table_var_name = 325, 
                   RULE_schema_name = 326, RULE_routine_name = 327, RULE_package_name = 328, 
                   RULE_implementation_type_name = 329, RULE_parameter_name = 330, 
                   RULE_reference_model_name = 331, RULE_main_model_name = 332, 
                   RULE_aggregate_function_name = 333, RULE_query_name = 334, 
                   RULE_constraint_name = 335, RULE_label_name = 336, RULE_type_name = 337, 
                   RULE_sequence_name = 338, RULE_exception_name = 339, 
                   RULE_function_name = 340, RULE_procedure_name = 341, 
                   RULE_trigger_name = 342, RULE_variable_name = 343, RULE_index_name = 344, 
                   RULE_cursor_name = 345, RULE_record_name = 346, RULE_collection_name = 347, 
                   RULE_link_name = 348, RULE_column_name = 349, RULE_tableview_name = 350, 
                   RULE_char_set_name = 351, RULE_keep_clause = 352, RULE_function_argument = 353, 
                   RULE_function_argument_analytic = 354, RULE_function_argument_modeling = 355, 
                   RULE_respect_or_ignore_nulls = 356, RULE_argument = 357, 
                   RULE_type_spec = 358, RULE_datatype = 359, RULE_precision_part = 360, 
                   RULE_native_datatype_element = 361, RULE_bind_variable = 362, 
                   RULE_general_element = 363, RULE_general_element_part = 364, 
                   RULE_table_element = 365, RULE_constant = 366, RULE_numeric = 367, 
                   RULE_numeric_negative = 368, RULE_quoted_string = 369, 
                   RULE_id = 370, RULE_id_expression = 371, RULE_not_equal_op = 372, 
                   RULE_greater_than_or_equals_op = 373, RULE_less_than_or_equals_op = 374, 
                   RULE_concatenation_op = 375, RULE_outer_join_sign = 376, 
                   RULE_regular_id = 377
	public static let ruleNames: [String] = [
		"swallow_to_semi", "compilation_unit", "sql_script", "unit_statement", 
		"drop_function", "alter_function", "create_function_body", "parallel_enable_clause", 
		"partition_by_clause", "result_cache_clause", "relies_on_part", "streaming_clause", 
		"drop_package", "alter_package", "create_package", "package_body", "package_spec", 
		"package_obj_spec", "procedure_spec", "function_spec", "package_obj_body", 
		"drop_procedure", "alter_procedure", "create_procedure_body", "drop_trigger", 
		"alter_trigger", "create_trigger", "trigger_follows_clause", "trigger_when_clause", 
		"simple_dml_trigger", "for_each_row", "compound_dml_trigger", "non_dml_trigger", 
		"trigger_body", "routine_clause", "compound_trigger_block", "timing_point_section", 
		"non_dml_event", "dml_event_clause", "dml_event_element", "dml_event_nested_clause", 
		"referencing_clause", "referencing_element", "drop_type", "alter_type", 
		"compile_type_clause", "replace_type_clause", "alter_method_spec", "alter_method_element", 
		"alter_attribute_definition", "attribute_definition", "alter_collection_clauses", 
		"dependent_handling_clause", "dependent_exceptions_part", "create_type", 
		"type_definition", "object_type_def", "object_as_part", "object_under_part", 
		"nested_table_type_def", "sqlj_object_type", "type_body", "type_body_elements", 
		"map_order_func_declaration", "subprog_decl_in_type", "proc_decl_in_type", 
		"func_decl_in_type", "constructor_declaration", "modifier_clause", "object_member_spec", 
		"sqlj_object_type_attr", "element_spec", "element_spec_options", "subprogram_spec", 
		"type_procedure_spec", "type_function_spec", "constructor_spec", "map_order_function_spec", 
		"pragma_clause", "pragma_elements", "type_elements_parameter", "drop_sequence", 
		"alter_sequence", "create_sequence", "sequence_spec", "sequence_start_clause", 
		"invoker_rights_clause", "compiler_parameters_clause", "call_spec", "java_spec", 
		"c_spec", "c_agent_in_clause", "c_parameters_clause", "parameter", "default_value_part", 
		"declare_spec", "variable_declaration", "subtype_declaration", "cursor_declaration", 
		"parameter_spec", "exception_declaration", "pragma_declaration", "record_declaration", 
		"record_type_dec", "field_spec", "record_var_dec", "table_declaration", 
		"table_type_dec", "table_indexed_by_part", "varray_type_def", "table_var_dec", 
		"seq_of_statements", "label_declaration", "statement", "assignment_statement", 
		"continue_statement", "exit_statement", "goto_statement", "if_statement", 
		"elsif_part", "else_part", "loop_statement", "cursor_loop_param", "forall_statement", 
		"bounds_clause", "between_bound", "lower_bound", "upper_bound", "null_statement", 
		"raise_statement", "return_statement", "function_call", "body", "exception_handler", 
		"trigger_block", "block", "sql_statement", "execute_immediate", "dynamic_returning_clause", 
		"data_manipulation_language_statements", "cursor_manipulation_statements", 
		"close_statement", "open_statement", "fetch_statement", "open_for_statement", 
		"transaction_control_statements", "set_transaction_command", "set_constraint_command", 
		"commit_statement", "write_clause", "rollback_statement", "savepoint_statement", 
		"explain_statement", "select_statement", "subquery_factoring_clause", 
		"factoring_element", "search_clause", "cycle_clause", "subquery", "subquery_operation_part", 
		"subquery_basic_elements", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"join_clause", "join_on_part", "join_using_part", "outer_join_type", "query_partition_clause", 
		"flashback_query_clause", "pivot_clause", "pivot_element", "pivot_for_clause", 
		"pivot_in_clause", "pivot_in_clause_element", "pivot_in_clause_elements", 
		"unpivot_clause", "unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "cursor_expression", "expression_list", 
		"condition", "expression", "logical_or_expression", "logical_and_expression", 
		"negated_expression", "equality_expression", "multiset_expression", "multiset_type", 
		"relational_expression", "compound_expression", "relational_operator", 
		"like_type", "like_escape_part", "in_elements", "between_elements", "concatenation", 
		"additive_expression", "multiply_expression", "datetime_expression", "interval_expression", 
		"model_expression", "model_expression_element", "single_column_for_loop", 
		"for_like_part", "for_increment_decrement_type", "multi_column_for_loop", 
		"unary_expression", "case_statement", "simple_case_statement", "simple_case_when_part", 
		"searched_case_statement", "searched_case_when_part", "case_else_part", 
		"atom", "expression_or_vector", "vector_expr", "quantified_expression", 
		"standard_function", "over_clause_keyword", "within_or_over_clause_keyword", 
		"standard_prediction_function_keyword", "over_clause", "windowing_clause", 
		"windowing_type", "windowing_elements", "using_clause", "using_element", 
		"collect_order_by_part", "within_or_over_part", "cost_matrix_clause", 
		"xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "sql_plus_command", 
		"whenever_command", "set_command", "exit_command", "prompt_command", "show_errors_command", 
		"partition_extension_clause", "column_alias", "table_alias", "alias_quoted_string", 
		"where_clause", "current_of_clause", "into_clause", "xml_column_name", 
		"cost_class_name", "attribute_name", "savepoint_name", "rollback_segment_name", 
		"table_var_name", "schema_name", "routine_name", "package_name", "implementation_type_name", 
		"parameter_name", "reference_model_name", "main_model_name", "aggregate_function_name", 
		"query_name", "constraint_name", "label_name", "type_name", "sequence_name", 
		"exception_name", "function_name", "procedure_name", "trigger_name", "variable_name", 
		"index_name", "cursor_name", "record_name", "collection_name", "link_name", 
		"column_name", "tableview_name", "char_set_name", "keep_clause", "function_argument", 
		"function_argument_analytic", "function_argument_modeling", "respect_or_ignore_nulls", 
		"argument", "type_spec", "datatype", "precision_part", "native_datatype_element", 
		"bind_variable", "general_element", "general_element_part", "table_element", 
		"constant", "numeric", "numeric_negative", "quoted_string", "id", "id_expression", 
		"not_equal_op", "greater_than_or_equals_op", "less_than_or_equals_op", 
		"concatenation_op", "outer_join_sign", "regular_id"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, "'..'", nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, "'.'", nil, nil, nil, 
		nil, "'%'", "'&'", "'('", "')'", "'**'", "'*'", "'+'", "'-'", "','", "'/'", 
		"'@'", "':='", nil, "':'", "';'", "'<='", "'<'", "'>='", nil, "'^'", "'~'", 
		"'!'", "'>'", "'||'", "'|'", "'='", "'['", "']'", "'_'", nil, nil, nil, 
		nil, nil, "'@!'"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, nil, "A_LETTER", "ADD", "AFTER", "AGENT", "AGGREGATE", "ALL", "ALTER", 
		"ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", 
		"AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", "BATCH", 
		"BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT", 
		"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH", 
		"BULK", "BY", "BYTE", "C_LETTER", "CACHE", "CALL", "CANONICAL", "CASCADE", 
		"CASE", "CAST", "CHAR", "CHAR_CS", "CHARACTER", "CHECK", "CHR", "CLOB", 
		"CLOSE", "CLUSTER", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", 
		"COMPATIBILITY", "COMPILE", "COMPOUND", "CONNECT", "CONNECT_BY_ROOT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", 
		"CONTINUE", "CONVERT", "CORRUPT_XID", "CORRUPT_XID_ALL", "COST", "COUNT", 
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", 
		"CYCLE", "DATA", "DATABASE", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", 
		"DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", 
		"DEFAULT", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", 
		"DETERMINISTIC", "DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", 
		"DOUBLE", "DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", 
		"ELSIF", "EMPTY", "ENABLE", "ENCODING", "END", "ENTITYESCAPING", "ERR", 
		"ERRORS", "ESCAPE", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS", 
		"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL", 
		"EXTRACT", "FAILURE", "FALSE", "FETCH", "FINAL", "FIRST", "FIRST_VALUE", 
		"FLOAT", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORCE", "FROM", "FULL", 
		"FUNCTION", "GOTO", "GRANT", "GROUP", "GROUPING", "HASH", "HAVING", "HIDE", 
		"HOUR", "IF", "IGNORE", "IMMEDIATE", "IN", "INCLUDE", "INCLUDING", "INCREMENT", 
		"INDENT", "INDEX", "INDEXED", "INDICATOR", "INDICES", "INFINITE", "INLINE", 
		"INNER", "INOUT", "INSERT", "INSTANTIABLE", "INSTEAD", "INT", "INTEGER", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "ITERATE", 
		"JAVA", "JOIN", "KEEP", "LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", 
		"LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LOCAL", 
		"LOCK", "LOCKED", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "MAIN", "MAP", 
		"MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINUS", "MINUTE", 
		"MINVALUE", "MLSLABEL", "MODE", "MODEL", "MODIFY", "MONTH", "MULTISET", 
		"NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR", "NCHAR_CS", "NCLOB", 
		"NESTED", "NEW", "NO", "NOAUDIT", "NOCACHE", "NOCOPY", "NOCYCLE", "NOENTITYESCAPING", 
		"NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NOSCHEMACHECK", "NOT", 
		"NOWAIT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", 
		"OF", "OFF", "OID", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OR", "ORADATA", 
		"ORDER", "ORDINALITY", "OSERROR", "OUT", "OUTER", "OVER", "OVERRIDING", 
		"PACKAGE", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", 
		"PATH", "PERCENT_ISOPEN", "PERCENT_FOUND", "PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", 
		"PERCENT_ROWTYPE", "PERCENT_TYPE", "PIPELINED", "PIVOT", "PLAN", "PLS_INTEGER", 
		"POSITIVE", "POSITIVEN", "PRAGMA", "PRECEDING", "PRECISION", "PRESENT", 
		"PRIOR", "PROCEDURE", "RAISE", "RANGE", "RAW", "READ", "REAL", "RECORD", 
		"REF", "REFERENCE", "REFERENCING", "REJECT", "RELIES_ON", "RENAME", "REPLACE", 
		"RESPECT", "RESTRICT_REFERENCES", "RESULT", "RESULT_CACHE", "RETURN", 
		"RETURNING", "REUSE", "REVERSE", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", 
		"ROW", "ROWID", "ROWS", "RULES", "SAMPLE", "SAVE", "SAVEPOINT", "SCHEMA", 
		"SCHEMACHECK", "SCN", "SEARCH", "SECOND", "SEED", "SEGMENT", "SELECT", 
		"SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", "SHARE", 
		"SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", "SINGLE", 
		"SIZE", "SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", "SQLDATA", 
		"SQLERROR", "STANDALONE", "START", "STARTUP", "STATEMENT", "STATEMENT_ID", 
		"STATIC", "STATISTICS", "STRING", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", 
		"SUBTYPE", "SUCCESS", "SUSPEND", "TABLE", "THE", "THEN", "TIME", "TIMESTAMP", 
		"TIMESTAMP_LTZ_UNCONSTRAINED", "TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", 
		"TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", 
		"TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", "TRIGGER", "TRIM", 
		"TRUE", "TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNLIMITED", 
		"UNPIVOT", "UNTIL", "UPDATE", "UPDATED", "UPSERT", "UROWID", "USE", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARIABLE", "VARRAY", 
		"VARYING", "VERSION", "VERSIONS", "WAIT", "WARNING", "WELLFORMED", "WHEN", 
		"WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", "WORK", "WRITE", "XML", 
		"XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS", 
		"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", 
		"XMLSERIALIZE", "XMLTABLE", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED", 
		"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS", 
		"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK", 
		"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", 
		"AVG", "CORR", "LAG", "LEAD", "MAX", "MEDIAN", "MIN", "NTILE", "RATIO_TO_REPORT", 
		"ROW_NUMBER", "SUM", "VARIANCE", "REGR_", "STDDEV", "VAR_", "COVAR_", 
		"NATIONAL_CHAR_STRING_LIT", "BIT_STRING_LIT", "HEX_STRING_LIT", "DOUBLE_PERIOD", 
		"PERIOD", "UNSIGNED_INTEGER", "APPROXIMATE_NUM_LIT", "CHAR_STRING", "DELIMITED_ID", 
		"PERCENT", "AMPERSAND", "LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK", 
		"ASTERISK", "PLUS_SIGN", "MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", 
		"ASSIGN_OP", "BINDVAR", "COLON", "SEMICOLON", "LESS_THAN_OR_EQUALS_OP", 
		"LESS_THAN_OP", "GREATER_THAN_OR_EQUALS_OP", "NOT_EQUAL_OP", "CARRET_OPERATOR_PART", 
		"TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", "GREATER_THAN_OP", 
		"CONCATENATION_OP", "VERTICAL_BAR", "EQUALS_OP", "LEFT_BRACKET", "RIGHT_BRACKET", 
		"INTRODUCER", "SPACES", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", "PROMPT", 
		"REGULAR_ID", "ZV"
	]
	public static let VOCABULARY: Vocabulary = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	//@Deprecated
	public let tokenNames: [String?]? = {
	    let length = _SYMBOLIC_NAMES.count
	    var tokenNames = [String?](repeating: nil, count: length)
		for i in 0..<length {
			var name = VOCABULARY.getLiteralName(i)
			if name == nil {
				name = VOCABULARY.getSymbolicName(i)
			}
			if name == nil {
				name = "<INVALID>"
			}
			tokenNames[i] = name
		}
		return tokenNames
	}()

	override
	open func getTokenNames() -> [String?]? {
		return tokenNames
	}

	override
	open func getGrammarFileName() -> String { return "plsql.g4" }

	override
	open func getRuleNames() -> [String] { return plsqlParser.ruleNames }

	override
	open func getSerializedATN() -> String { return plsqlParser._serializedATN }

	override
	open func getATN() -> ATN { return plsqlParser._ATN }

	open override func getVocabulary() -> Vocabulary {
	    return plsqlParser.VOCABULARY
	}

	public override init(_ input:TokenStream)throws {
	    RuntimeMetaData.checkVersion("4.5.3", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,plsqlParser._ATN,plsqlParser._decisionToDFA, plsqlParser._sharedContextCache)
	}
	open class Swallow_to_semiContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_swallow_to_semi }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSwallow_to_semi(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSwallow_to_semi(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSwallow_to_semi(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSwallow_to_semi(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func swallow_to_semi() throws -> Swallow_to_semiContext {
		var _localctx: Swallow_to_semiContext = Swallow_to_semiContext(_ctx, getState())
		try enterRule(_localctx, 0, plsqlParser.RULE_swallow_to_semi)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(757) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(756)
		 		_la = try _input.LA(1)
		 		if (_la <= 0 || (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.SEMICOLON
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}


		 		setState(759); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.T__0,plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ALL,plsqlParser.ALTER,plsqlParser.ANALYZE,plsqlParser.AND,plsqlParser.ANY,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASC,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BEGIN,plsqlParser.BETWEEN,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BREADTH,plsqlParser.BULK,plsqlParser.BY,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CACHE,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CASE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHECK,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND,plsqlParser.CONNECT]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONNECT_BY_ROOT,plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECLARE,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DELETE,plsqlParser.DEPTH,plsqlParser.DESC,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DISTINCT,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DROP,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.ELSE,plsqlParser.ELSIF,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.END,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTION_INIT,plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXCLUSIVE,plsqlParser.EXECUTE,plsqlParser.EXISTS,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FALSE,plsqlParser.FETCH,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FOR,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FROM,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GOTO,plsqlParser.GRANT,plsqlParser.GROUP,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HAVING,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IF,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.IN,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEX,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSERT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERSECT,plsqlParser.INTERVAL,plsqlParser.INTO,plsqlParser.INVALIDATE,plsqlParser.IS,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LANGUAGE,plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCK,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUS,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODE,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCACHE,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NOMAXVALUE,plsqlParser.NOMINVALUE,plsqlParser.NONE,plsqlParser.NOORDER,plsqlParser.NOSCHEMACHECK,plsqlParser.NOT,plsqlParser.NOWAIT,plsqlParser.NULL,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OBJECT,plsqlParser.OF,plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ON,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.OPTION,plsqlParser.OR,plsqlParser.ORADATA,plsqlParser.ORDER,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PERCENT_ISOPEN,plsqlParser.PERCENT_FOUND,plsqlParser.PERCENT_NOTFOUND,plsqlParser.PERCENT_ROWCOUNT,plsqlParser.PERCENT_ROWTYPE,plsqlParser.PERCENT_TYPE,plsqlParser.PIPELINED,plsqlParser.PIVOT,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PRIOR,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.REVOKE,plsqlParser.RIGHT,plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SEARCH,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELECT,plsqlParser.SELF,plsqlParser.SEQUENCE,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHARE,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SIZE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.START,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TABLE,plsqlParser.THE,plsqlParser.THEN,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 320)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED,plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TO,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUE,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNION,plsqlParser.UNIQUE,plsqlParser.UNLIMITED,plsqlParser.UNPIVOT,plsqlParser.UNTIL,plsqlParser.UPDATE,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.USING,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VALUES,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHEN,plsqlParser.WHENEVER,plsqlParser.WHERE,plsqlParser.WHILE,plsqlParser.WITH,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 384)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.XMLTABLE,plsqlParser.YEAR,plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.BIT_STRING_LIT,plsqlParser.HEX_STRING_LIT,plsqlParser.DOUBLE_PERIOD,plsqlParser.PERIOD,plsqlParser.UNSIGNED_INTEGER,plsqlParser.APPROXIMATE_NUM_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID,plsqlParser.PERCENT,plsqlParser.AMPERSAND,plsqlParser.LEFT_PAREN,plsqlParser.RIGHT_PAREN,plsqlParser.DOUBLE_ASTERISK,plsqlParser.ASTERISK,plsqlParser.PLUS_SIGN,plsqlParser.MINUS_SIGN,plsqlParser.COMMA,plsqlParser.SOLIDUS,plsqlParser.AT_SIGN,plsqlParser.ASSIGN_OP,plsqlParser.BINDVAR,plsqlParser.COLON,plsqlParser.LESS_THAN_OR_EQUALS_OP,plsqlParser.LESS_THAN_OP,plsqlParser.GREATER_THAN_OR_EQUALS_OP,plsqlParser.NOT_EQUAL_OP,plsqlParser.CARRET_OPERATOR_PART,plsqlParser.TILDE_OPERATOR_PART]
		 	              return  Utils.testBitLeftShiftArray(testArray, 448)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCLAMATION_OPERATOR_PART,plsqlParser.GREATER_THAN_OP,plsqlParser.CONCATENATION_OP,plsqlParser.VERTICAL_BAR,plsqlParser.EQUALS_OP,plsqlParser.LEFT_BRACKET,plsqlParser.RIGHT_BRACKET,plsqlParser.INTRODUCER,plsqlParser.SPACES,plsqlParser.SINGLE_LINE_COMMENT,plsqlParser.MULTI_LINE_COMMENT,plsqlParser.PROMPT,plsqlParser.REGULAR_ID,plsqlParser.ZV]
		 	              return  Utils.testBitLeftShiftArray(testArray, 512)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compilation_unitContext:ParserRuleContext {
		open func EOF() -> TerminalNode? { return getToken(plsqlParser.EOF, 0) }
		open func unit_statement() -> Array<Unit_statementContext> {
			return getRuleContexts(Unit_statementContext.self)
		}
		open func unit_statement(_ i: Int) -> Unit_statementContext? {
			return getRuleContext(Unit_statementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compilation_unit }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompilation_unit(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompilation_unit(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompilation_unit(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompilation_unit(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilation_unit() throws -> Compilation_unitContext {
		var _localctx: Compilation_unitContext = Compilation_unitContext(_ctx, getState())
		try enterRule(_localctx, 2, plsqlParser.RULE_compilation_unit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(764)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ALTER
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CREATE,plsqlParser.DELETE,plsqlParser.DROP,plsqlParser.EXPLAIN]
		 	              return  Utils.testBitLeftShiftArray(testArray, 77)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.FUNCTION,plsqlParser.INSERT,plsqlParser.LOCK]
		 	              return  Utils.testBitLeftShiftArray(testArray, 152)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.MERGE
		 	          testSet = testSet || _la == plsqlParser.PROCEDURE || _la == plsqlParser.SELECT
		 	          testSet = testSet || _la == plsqlParser.UPDATE || _la == plsqlParser.WITH
		 	          testSet = testSet || _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(761)
		 		try unit_statement()


		 		setState(766)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(767)
		 	try match(plsqlParser.EOF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_scriptContext:ParserRuleContext {
		open func EOF() -> TerminalNode? { return getToken(plsqlParser.EOF, 0) }
		open func unit_statement() -> Array<Unit_statementContext> {
			return getRuleContexts(Unit_statementContext.self)
		}
		open func unit_statement(_ i: Int) -> Unit_statementContext? {
			return getRuleContext(Unit_statementContext.self,i)
		}
		open func sql_plus_command() -> Array<Sql_plus_commandContext> {
			return getRuleContexts(Sql_plus_commandContext.self)
		}
		open func sql_plus_command(_ i: Int) -> Sql_plus_commandContext? {
			return getRuleContext(Sql_plus_commandContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_script }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_script(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_script(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_script(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_script(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_script() throws -> Sql_scriptContext {
		var _localctx: Sql_scriptContext = Sql_scriptContext(_ctx, getState())
		try enterRule(_localctx, 4, plsqlParser.RULE_sql_script)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(773)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ALTER
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CREATE,plsqlParser.DELETE,plsqlParser.DROP,plsqlParser.EXIT,plsqlParser.EXPLAIN]
		 	              return  Utils.testBitLeftShiftArray(testArray, 77)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.FUNCTION,plsqlParser.INSERT,plsqlParser.LOCK]
		 	              return  Utils.testBitLeftShiftArray(testArray, 152)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.MERGE
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.PROCEDURE,plsqlParser.SELECT,plsqlParser.SET,plsqlParser.SHOW]
		 	              return  Utils.testBitLeftShiftArray(testArray, 298)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.UPDATE,plsqlParser.WHENEVER,plsqlParser.WITH]
		 	              return  Utils.testBitLeftShiftArray(testArray, 407)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LEFT_PAREN,plsqlParser.SOLIDUS,plsqlParser.PROMPT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 493)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(771)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.ALTER:fallthrough
		 		case plsqlParser.CREATE:fallthrough
		 		case plsqlParser.DELETE:fallthrough
		 		case plsqlParser.DROP:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.INSERT:fallthrough
		 		case plsqlParser.LOCK:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.PROCEDURE:fallthrough
		 		case plsqlParser.SELECT:fallthrough
		 		case plsqlParser.UPDATE:fallthrough
		 		case plsqlParser.WITH:fallthrough
		 		case plsqlParser.LEFT_PAREN:
		 			setState(769)
		 			try unit_statement()

		 			break
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.SOLIDUS:fallthrough
		 		case plsqlParser.PROMPT:
		 			setState(770)
		 			try sql_plus_command()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(775)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(776)
		 	try match(plsqlParser.EOF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unit_statementContext:ParserRuleContext {
		open func alter_function() -> Alter_functionContext? {
			return getRuleContext(Alter_functionContext.self,0)
		}
		open func alter_package() -> Alter_packageContext? {
			return getRuleContext(Alter_packageContext.self,0)
		}
		open func alter_procedure() -> Alter_procedureContext? {
			return getRuleContext(Alter_procedureContext.self,0)
		}
		open func alter_sequence() -> Alter_sequenceContext? {
			return getRuleContext(Alter_sequenceContext.self,0)
		}
		open func alter_trigger() -> Alter_triggerContext? {
			return getRuleContext(Alter_triggerContext.self,0)
		}
		open func alter_type() -> Alter_typeContext? {
			return getRuleContext(Alter_typeContext.self,0)
		}
		open func create_function_body() -> Create_function_bodyContext? {
			return getRuleContext(Create_function_bodyContext.self,0)
		}
		open func create_procedure_body() -> Create_procedure_bodyContext? {
			return getRuleContext(Create_procedure_bodyContext.self,0)
		}
		open func create_package() -> Create_packageContext? {
			return getRuleContext(Create_packageContext.self,0)
		}
		open func create_sequence() -> Create_sequenceContext? {
			return getRuleContext(Create_sequenceContext.self,0)
		}
		open func create_trigger() -> Create_triggerContext? {
			return getRuleContext(Create_triggerContext.self,0)
		}
		open func create_type() -> Create_typeContext? {
			return getRuleContext(Create_typeContext.self,0)
		}
		open func drop_function() -> Drop_functionContext? {
			return getRuleContext(Drop_functionContext.self,0)
		}
		open func drop_package() -> Drop_packageContext? {
			return getRuleContext(Drop_packageContext.self,0)
		}
		open func drop_procedure() -> Drop_procedureContext? {
			return getRuleContext(Drop_procedureContext.self,0)
		}
		open func drop_sequence() -> Drop_sequenceContext? {
			return getRuleContext(Drop_sequenceContext.self,0)
		}
		open func drop_trigger() -> Drop_triggerContext? {
			return getRuleContext(Drop_triggerContext.self,0)
		}
		open func drop_type() -> Drop_typeContext? {
			return getRuleContext(Drop_typeContext.self,0)
		}
		open func data_manipulation_language_statements() -> Data_manipulation_language_statementsContext? {
			return getRuleContext(Data_manipulation_language_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unit_statement() throws -> Unit_statementContext {
		var _localctx: Unit_statementContext = Unit_statementContext(_ctx, getState())
		try enterRule(_localctx, 6, plsqlParser.RULE_unit_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(797)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,4, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(778)
		 		try alter_function()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(779)
		 		try alter_package()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(780)
		 		try alter_procedure()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(781)
		 		try alter_sequence()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(782)
		 		try alter_trigger()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(783)
		 		try alter_type()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(784)
		 		try create_function_body()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(785)
		 		try create_procedure_body()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(786)
		 		try create_package()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(787)
		 		try create_sequence()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(788)
		 		try create_trigger()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(789)
		 		try create_type()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(790)
		 		try drop_function()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(791)
		 		try drop_package()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(792)
		 		try drop_procedure()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(793)
		 		try drop_sequence()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(794)
		 		try drop_trigger()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(795)
		 		try drop_type()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(796)
		 		try data_manipulation_language_statements()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_functionContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_function() throws -> Drop_functionContext {
		var _localctx: Drop_functionContext = Drop_functionContext(_ctx, getState())
		try enterRule(_localctx, 8, plsqlParser.RULE_drop_function)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(799)
		 	try match(plsqlParser.DROP)
		 	setState(800)
		 	try match(plsqlParser.FUNCTION)
		 	setState(801)
		 	try function_name()
		 	setState(802)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_functionContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_function() throws -> Alter_functionContext {
		var _localctx: Alter_functionContext = Alter_functionContext(_ctx, getState())
		try enterRule(_localctx, 10, plsqlParser.RULE_alter_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(804)
		 	try match(plsqlParser.ALTER)
		 	setState(805)
		 	try match(plsqlParser.FUNCTION)
		 	setState(806)
		 	try function_name()
		 	setState(807)
		 	try match(plsqlParser.COMPILE)
		 	setState(809)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,5,_ctx)) {
		 	case 1:
		 		setState(808)
		 		try match(plsqlParser.DEBUG)

		 		break
		 	default: break
		 	}
		 	setState(814)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,6,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(811)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(816)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,6,_ctx)
		 	}
		 	setState(819)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REUSE
		 	      return testSet
		 	 }()) {
		 		setState(817)
		 		try match(plsqlParser.REUSE)
		 		setState(818)
		 		try match(plsqlParser.SETTINGS)

		 	}

		 	setState(821)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_function_bodyContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func implementation_type_name() -> Implementation_type_nameContext? {
			return getRuleContext(Implementation_type_nameContext.self,0)
		}
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func invoker_rights_clause() -> Array<Invoker_rights_clauseContext> {
			return getRuleContexts(Invoker_rights_clauseContext.self)
		}
		open func invoker_rights_clause(_ i: Int) -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,i)
		}
		open func parallel_enable_clause() -> Array<Parallel_enable_clauseContext> {
			return getRuleContexts(Parallel_enable_clauseContext.self)
		}
		open func parallel_enable_clause(_ i: Int) -> Parallel_enable_clauseContext? {
			return getRuleContext(Parallel_enable_clauseContext.self,i)
		}
		open func result_cache_clause() -> Array<Result_cache_clauseContext> {
			return getRuleContexts(Result_cache_clauseContext.self)
		}
		open func result_cache_clause(_ i: Int) -> Result_cache_clauseContext? {
			return getRuleContext(Result_cache_clauseContext.self,i)
		}
		open func DETERMINISTIC() -> Array<TerminalNode> { return getTokens(plsqlParser.DETERMINISTIC) }
		open func DETERMINISTIC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.DETERMINISTIC, i)
		}
		open func PIPELINED() -> TerminalNode? { return getToken(plsqlParser.PIPELINED, 0) }
		open func AGGREGATE() -> TerminalNode? { return getToken(plsqlParser.AGGREGATE, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_function_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_function_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_function_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_function_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_function_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_function_body() throws -> Create_function_bodyContext {
		var _localctx: Create_function_bodyContext = Create_function_bodyContext(_ctx, getState())
		try enterRule(_localctx, 12, plsqlParser.RULE_create_function_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(828)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.CREATE
		 	      return testSet
		 	 }()) {
		 		setState(823)
		 		try match(plsqlParser.CREATE)
		 		setState(826)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.OR
		 		      return testSet
		 		 }()) {
		 			setState(824)
		 			try match(plsqlParser.OR)
		 			setState(825)
		 			try match(plsqlParser.REPLACE)

		 		}


		 	}

		 	setState(830)
		 	try match(plsqlParser.FUNCTION)
		 	setState(831)
		 	try function_name()
		 	setState(843)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(832)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(833)
		 		try parameter()
		 		setState(838)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(834)
		 			try match(plsqlParser.COMMA)
		 			setState(835)
		 			try parameter()


		 			setState(840)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(841)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(845)
		 	try match(plsqlParser.RETURN)
		 	setState(846)
		 	try type_spec()
		 	setState(853)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AUTHID
		 	          testSet = testSet || _la == plsqlParser.DETERMINISTIC
		 	          testSet = testSet || _la == plsqlParser.PARALLEL_ENABLE || _la == plsqlParser.RESULT_CACHE
		 	      return testSet
		 	 }()) {
		 		setState(851)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.AUTHID:
		 			setState(847)
		 			try invoker_rights_clause()

		 			break

		 		case plsqlParser.PARALLEL_ENABLE:
		 			setState(848)
		 			try parallel_enable_clause()

		 			break

		 		case plsqlParser.RESULT_CACHE:
		 			setState(849)
		 			try result_cache_clause()

		 			break

		 		case plsqlParser.DETERMINISTIC:
		 			setState(850)
		 			try match(plsqlParser.DETERMINISTIC)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(855)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(876)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,18, _ctx)) {
		 	case 1:
		 		setState(857)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PIPELINED
		 		      return testSet
		 		 }()) {
		 			setState(856)
		 			try match(plsqlParser.PIPELINED)

		 		}

		 		setState(859)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.AS
		 		          testSet = testSet || _la == plsqlParser.IS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(871)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,17, _ctx)) {
		 		case 1:
		 			setState(861)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.DECLARE
		 			      return testSet
		 			 }()) {
		 				setState(860)
		 				try match(plsqlParser.DECLARE)

		 			}

		 			setState(866)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 65)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 129)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 193)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 258)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 			              return  Utils.testBitLeftShiftArray(testArray, 322)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 			              return  Utils.testBitLeftShiftArray(testArray, 386)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 			              return  Utils.testBitLeftShiftArray(testArray, 450)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 			      return testSet
		 			 }()) {
		 				setState(863)
		 				try declare_spec()


		 				setState(868)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(869)
		 			try body()

		 			break
		 		case 2:
		 			setState(870)
		 			try call_spec()

		 			break
		 		default: break
		 		}


		 		break
		 	case 2:
		 		setState(873)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.AGGREGATE
		 		          testSet = testSet || _la == plsqlParser.PIPELINED
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(874)
		 		try match(plsqlParser.USING)
		 		setState(875)
		 		try implementation_type_name()

		 		break
		 	default: break
		 	}
		 	setState(878)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parallel_enable_clauseContext:ParserRuleContext {
		open func PARALLEL_ENABLE() -> TerminalNode? { return getToken(plsqlParser.PARALLEL_ENABLE, 0) }
		open func partition_by_clause() -> Partition_by_clauseContext? {
			return getRuleContext(Partition_by_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parallel_enable_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParallel_enable_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParallel_enable_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParallel_enable_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParallel_enable_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parallel_enable_clause() throws -> Parallel_enable_clauseContext {
		var _localctx: Parallel_enable_clauseContext = Parallel_enable_clauseContext(_ctx, getState())
		try enterRule(_localctx, 14, plsqlParser.RULE_parallel_enable_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(880)
		 	try match(plsqlParser.PARALLEL_ENABLE)
		 	setState(882)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(881)
		 		try partition_by_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Partition_by_clauseContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.PARTITION, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func ANY() -> TerminalNode? { return getToken(plsqlParser.ANY, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func HASH() -> TerminalNode? { return getToken(plsqlParser.HASH, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.RANGE, 0) }
		open func streaming_clause() -> Streaming_clauseContext? {
			return getRuleContext(Streaming_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_partition_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPartition_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPartition_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPartition_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPartition_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func partition_by_clause() throws -> Partition_by_clauseContext {
		var _localctx: Partition_by_clauseContext = Partition_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 16, plsqlParser.RULE_partition_by_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(884)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(885)
		 	try match(plsqlParser.PARTITION)
		 	setState(886)
		 	try expression()
		 	setState(887)
		 	try match(plsqlParser.BY)
		 	setState(901)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.ANY:
		 		setState(888)
		 		try match(plsqlParser.ANY)

		 		break
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.RANGE:
		 		setState(889)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.HASH
		 		          testSet = testSet || _la == plsqlParser.RANGE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(890)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(891)
		 		try column_name()
		 		setState(896)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(892)
		 			try match(plsqlParser.COMMA)
		 			setState(893)
		 			try column_name()


		 			setState(898)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(899)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(904)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CLUSTER
		 	          testSet = testSet || _la == plsqlParser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(903)
		 		try streaming_clause()

		 	}

		 	setState(906)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Result_cache_clauseContext:ParserRuleContext {
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.RESULT_CACHE, 0) }
		open func relies_on_part() -> Relies_on_partContext? {
			return getRuleContext(Relies_on_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_result_cache_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterResult_cache_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitResult_cache_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitResult_cache_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitResult_cache_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func result_cache_clause() throws -> Result_cache_clauseContext {
		var _localctx: Result_cache_clauseContext = Result_cache_clauseContext(_ctx, getState())
		try enterRule(_localctx, 18, plsqlParser.RULE_result_cache_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(908)
		 	try match(plsqlParser.RESULT_CACHE)
		 	setState(910)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RELIES_ON
		 	      return testSet
		 	 }()) {
		 		setState(909)
		 		try relies_on_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Relies_on_partContext:ParserRuleContext {
		open func RELIES_ON() -> TerminalNode? { return getToken(plsqlParser.RELIES_ON, 0) }
		open func tableview_name() -> Array<Tableview_nameContext> {
			return getRuleContexts(Tableview_nameContext.self)
		}
		open func tableview_name(_ i: Int) -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relies_on_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelies_on_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelies_on_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelies_on_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelies_on_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relies_on_part() throws -> Relies_on_partContext {
		var _localctx: Relies_on_partContext = Relies_on_partContext(_ctx, getState())
		try enterRule(_localctx, 20, plsqlParser.RULE_relies_on_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(912)
		 	try match(plsqlParser.RELIES_ON)
		 	setState(913)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(914)
		 	try tableview_name()
		 	setState(919)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(915)
		 		try match(plsqlParser.COMMA)
		 		setState(916)
		 		try tableview_name()


		 		setState(921)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(922)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Streaming_clauseContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open func CLUSTER() -> TerminalNode? { return getToken(plsqlParser.CLUSTER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_streaming_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStreaming_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStreaming_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStreaming_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStreaming_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func streaming_clause() throws -> Streaming_clauseContext {
		var _localctx: Streaming_clauseContext = Streaming_clauseContext(_ctx, getState())
		try enterRule(_localctx, 22, plsqlParser.RULE_streaming_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(924)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CLUSTER
		 	          testSet = testSet || _la == plsqlParser.ORDER
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(925)
		 	try expression()
		 	setState(926)
		 	try match(plsqlParser.BY)
		 	setState(927)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(928)
		 	try column_name()
		 	setState(933)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(929)
		 		try match(plsqlParser.COMMA)
		 		setState(930)
		 		try column_name()


		 		setState(935)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(936)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_packageContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.PACKAGE, 0) }
		open func package_name() -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,0)
		}
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_package() throws -> Drop_packageContext {
		var _localctx: Drop_packageContext = Drop_packageContext(_ctx, getState())
		try enterRule(_localctx, 24, plsqlParser.RULE_drop_package)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(938)
		 	try match(plsqlParser.DROP)
		 	setState(939)
		 	try match(plsqlParser.PACKAGE)
		 	setState(941)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,26,_ctx)) {
		 	case 1:
		 		setState(940)
		 		try match(plsqlParser.BODY)

		 		break
		 	default: break
		 	}
		 	setState(943)
		 	try package_name()
		 	setState(944)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_packageContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func PACKAGE() -> Array<TerminalNode> { return getTokens(plsqlParser.PACKAGE) }
		open func PACKAGE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.PACKAGE, i)
		}
		open func package_name() -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.SPECIFICATION, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_package() throws -> Alter_packageContext {
		var _localctx: Alter_packageContext = Alter_packageContext(_ctx, getState())
		try enterRule(_localctx, 26, plsqlParser.RULE_alter_package)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(946)
		 	try match(plsqlParser.ALTER)
		 	setState(947)
		 	try match(plsqlParser.PACKAGE)
		 	setState(948)
		 	try package_name()
		 	setState(949)
		 	try match(plsqlParser.COMPILE)
		 	setState(951)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,27,_ctx)) {
		 	case 1:
		 		setState(950)
		 		try match(plsqlParser.DEBUG)

		 		break
		 	default: break
		 	}
		 	setState(954)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,28,_ctx)) {
		 	case 1:
		 		setState(953)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.BODY
		 		          testSet = testSet || _la == plsqlParser.PACKAGE
		 		          testSet = testSet || _la == plsqlParser.SPECIFICATION
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(959)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,29,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(956)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(961)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,29,_ctx)
		 	}
		 	setState(964)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REUSE
		 	      return testSet
		 	 }()) {
		 		setState(962)
		 		try match(plsqlParser.REUSE)
		 		setState(963)
		 		try match(plsqlParser.SETTINGS)

		 	}

		 	setState(966)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_packageContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.PACKAGE, 0) }
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open func package_spec() -> Package_specContext? {
			return getRuleContext(Package_specContext.self,0)
		}
		open func package_body() -> Package_bodyContext? {
			return getRuleContext(Package_bodyContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_package() throws -> Create_packageContext {
		var _localctx: Create_packageContext = Create_packageContext(_ctx, getState())
		try enterRule(_localctx, 28, plsqlParser.RULE_create_package)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(968)
		 	try match(plsqlParser.CREATE)
		 	setState(971)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(969)
		 		try match(plsqlParser.OR)
		 		setState(970)
		 		try match(plsqlParser.REPLACE)

		 	}

		 	setState(973)
		 	try match(plsqlParser.PACKAGE)
		 	setState(976)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,32,_ctx)) {
		 	case 1:
		 		setState(974)
		 		try package_spec()

		 		break
		 	case 2:
		 		setState(975)
		 		try package_body()

		 		break
		 	default: break
		 	}
		 	setState(978)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_bodyContext:ParserRuleContext {
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open func package_name() -> Array<Package_nameContext> {
			return getRuleContexts(Package_nameContext.self)
		}
		open func package_name(_ i: Int) -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func BEGIN() -> TerminalNode? { return getToken(plsqlParser.BEGIN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func package_obj_body() -> Array<Package_obj_bodyContext> {
			return getRuleContexts(Package_obj_bodyContext.self)
		}
		open func package_obj_body(_ i: Int) -> Package_obj_bodyContext? {
			return getRuleContext(Package_obj_bodyContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_body() throws -> Package_bodyContext {
		var _localctx: Package_bodyContext = Package_bodyContext(_ctx, getState())
		try enterRule(_localctx, 30, plsqlParser.RULE_package_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(980)
		 	try match(plsqlParser.BODY)
		 	setState(981)
		 	try package_name()
		 	setState(982)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(986)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(983)
		 		try package_obj_body()


		 		setState(988)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(995)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BEGIN:
		 		setState(989)
		 		try match(plsqlParser.BEGIN)
		 		setState(990)
		 		try seq_of_statements()

		 		break

		 	case plsqlParser.END:
		 		setState(991)
		 		try match(plsqlParser.END)
		 		setState(993)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(992)
		 			try package_name()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_specContext:ParserRuleContext {
		open func package_name() -> Array<Package_nameContext> {
			return getRuleContexts(Package_nameContext.self)
		}
		open func package_name(_ i: Int) -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,i)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func package_obj_spec() -> Array<Package_obj_specContext> {
			return getRuleContexts(Package_obj_specContext.self)
		}
		open func package_obj_spec(_ i: Int) -> Package_obj_specContext? {
			return getRuleContext(Package_obj_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_spec() throws -> Package_specContext {
		var _localctx: Package_specContext = Package_specContext(_ctx, getState())
		try enterRule(_localctx, 32, plsqlParser.RULE_package_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(997)
		 	try package_name()
		 	setState(999)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AUTHID
		 	      return testSet
		 	 }()) {
		 		setState(998)
		 		try invoker_rights_clause()

		 	}

		 	setState(1001)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1005)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(1002)
		 		try package_obj_spec()


		 		setState(1007)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1008)
		 	try match(plsqlParser.END)
		 	setState(1010)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(1009)
		 		try package_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_obj_specContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func pragma_declaration() -> Pragma_declarationContext? {
			return getRuleContext(Pragma_declarationContext.self,0)
		}
		open func record_declaration() -> Record_declarationContext? {
			return getRuleContext(Record_declarationContext.self,0)
		}
		open func table_declaration() -> Table_declarationContext? {
			return getRuleContext(Table_declarationContext.self,0)
		}
		open func procedure_spec() -> Procedure_specContext? {
			return getRuleContext(Procedure_specContext.self,0)
		}
		open func function_spec() -> Function_specContext? {
			return getRuleContext(Function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_obj_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_obj_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_obj_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_obj_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_obj_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_obj_spec() throws -> Package_obj_specContext {
		var _localctx: Package_obj_specContext = Package_obj_specContext(_ctx, getState())
		try enterRule(_localctx, 34, plsqlParser.RULE_package_obj_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1021)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,39, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1012)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1013)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1014)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1015)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1016)
		 		try pragma_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1017)
		 		try record_declaration()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1018)
		 		try table_declaration()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1019)
		 		try procedure_spec()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1020)
		 		try function_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_specContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_procedure_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProcedure_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProcedure_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProcedure_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProcedure_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_spec() throws -> Procedure_specContext {
		var _localctx: Procedure_specContext = Procedure_specContext(_ctx, getState())
		try enterRule(_localctx, 36, plsqlParser.RULE_procedure_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1023)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1024)
		 	try procedure_name()
		 	setState(1036)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1025)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1026)
		 		try parameter()
		 		setState(1031)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1027)
		 			try match(plsqlParser.COMMA)
		 			setState(1028)
		 			try parameter()


		 			setState(1033)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1034)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1038)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_specContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func DETERMINISTIC() -> TerminalNode? { return getToken(plsqlParser.DETERMINISTIC, 0) }
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.RESULT_CACHE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_spec() throws -> Function_specContext {
		var _localctx: Function_specContext = Function_specContext(_ctx, getState())
		try enterRule(_localctx, 38, plsqlParser.RULE_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1040)
		 	try match(plsqlParser.FUNCTION)
		 	setState(1041)
		 	try function_name()
		 	setState(1053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1042)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1043)
		 		try parameter()
		 		setState(1048)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1044)
		 			try match(plsqlParser.COMMA)
		 			setState(1045)
		 			try parameter()


		 			setState(1050)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1051)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1055)
		 	try match(plsqlParser.RETURN)
		 	setState(1056)
		 	try type_spec()
		 	setState(1058)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.DETERMINISTIC
		 	      return testSet
		 	 }()) {
		 		setState(1057)
		 		try match(plsqlParser.DETERMINISTIC)

		 	}

		 	setState(1061)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RESULT_CACHE
		 	      return testSet
		 	 }()) {
		 		setState(1060)
		 		try match(plsqlParser.RESULT_CACHE)

		 	}

		 	setState(1063)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_obj_bodyContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func record_declaration() -> Record_declarationContext? {
			return getRuleContext(Record_declarationContext.self,0)
		}
		open func table_declaration() -> Table_declarationContext? {
			return getRuleContext(Table_declarationContext.self,0)
		}
		open func create_procedure_body() -> Create_procedure_bodyContext? {
			return getRuleContext(Create_procedure_bodyContext.self,0)
		}
		open func create_function_body() -> Create_function_bodyContext? {
			return getRuleContext(Create_function_bodyContext.self,0)
		}
		open func procedure_spec() -> Procedure_specContext? {
			return getRuleContext(Procedure_specContext.self,0)
		}
		open func function_spec() -> Function_specContext? {
			return getRuleContext(Function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_obj_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_obj_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_obj_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_obj_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_obj_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_obj_body() throws -> Package_obj_bodyContext {
		var _localctx: Package_obj_bodyContext = Package_obj_bodyContext(_ctx, getState())
		try enterRule(_localctx, 40, plsqlParser.RULE_package_obj_body)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1075)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,46, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1065)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1066)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1067)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1068)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1069)
		 		try record_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1070)
		 		try table_declaration()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1071)
		 		try create_procedure_body()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1072)
		 		try create_function_body()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1073)
		 		try procedure_spec()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1074)
		 		try function_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_procedureContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_procedure(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_procedure() throws -> Drop_procedureContext {
		var _localctx: Drop_procedureContext = Drop_procedureContext(_ctx, getState())
		try enterRule(_localctx, 42, plsqlParser.RULE_drop_procedure)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1077)
		 	try match(plsqlParser.DROP)
		 	setState(1078)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1079)
		 	try procedure_name()
		 	setState(1080)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_procedureContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_procedure(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_procedure() throws -> Alter_procedureContext {
		var _localctx: Alter_procedureContext = Alter_procedureContext(_ctx, getState())
		try enterRule(_localctx, 44, plsqlParser.RULE_alter_procedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1082)
		 	try match(plsqlParser.ALTER)
		 	setState(1083)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1084)
		 	try procedure_name()
		 	setState(1085)
		 	try match(plsqlParser.COMPILE)
		 	setState(1087)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,47,_ctx)) {
		 	case 1:
		 		setState(1086)
		 		try match(plsqlParser.DEBUG)

		 		break
		 	default: break
		 	}
		 	setState(1092)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,48,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1089)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(1094)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,48,_ctx)
		 	}
		 	setState(1097)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REUSE
		 	      return testSet
		 	 }()) {
		 		setState(1095)
		 		try match(plsqlParser.REUSE)
		 		setState(1096)
		 		try match(plsqlParser.SETTINGS)

		 	}

		 	setState(1099)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_procedure_bodyContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.EXTERNAL, 0) }
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_procedure_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_procedure_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_procedure_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_procedure_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_procedure_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_procedure_body() throws -> Create_procedure_bodyContext {
		var _localctx: Create_procedure_bodyContext = Create_procedure_bodyContext(_ctx, getState())
		try enterRule(_localctx, 46, plsqlParser.RULE_create_procedure_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1106)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.CREATE
		 	      return testSet
		 	 }()) {
		 		setState(1101)
		 		try match(plsqlParser.CREATE)
		 		setState(1104)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.OR
		 		      return testSet
		 		 }()) {
		 			setState(1102)
		 			try match(plsqlParser.OR)
		 			setState(1103)
		 			try match(plsqlParser.REPLACE)

		 		}


		 	}

		 	setState(1108)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1109)
		 	try procedure_name()
		 	setState(1121)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1110)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1111)
		 		try parameter()
		 		setState(1116)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1112)
		 			try match(plsqlParser.COMMA)
		 			setState(1113)
		 			try parameter()


		 			setState(1118)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1119)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1124)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AUTHID
		 	      return testSet
		 	 }()) {
		 		setState(1123)
		 		try invoker_rights_clause()

		 	}

		 	setState(1126)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1139)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,57, _ctx)) {
		 	case 1:
		 		setState(1128)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DECLARE
		 		      return testSet
		 		 }()) {
		 			setState(1127)
		 			try match(plsqlParser.DECLARE)

		 		}

		 		setState(1133)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(1130)
		 			try declare_spec()


		 			setState(1135)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1136)
		 		try body()

		 		break
		 	case 2:
		 		setState(1137)
		 		try call_spec()

		 		break
		 	case 3:
		 		setState(1138)
		 		try match(plsqlParser.EXTERNAL)

		 		break
		 	default: break
		 	}
		 	setState(1141)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_triggerContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_trigger() throws -> Drop_triggerContext {
		var _localctx: Drop_triggerContext = Drop_triggerContext(_ctx, getState())
		try enterRule(_localctx, 48, plsqlParser.RULE_drop_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1143)
		 	try match(plsqlParser.DROP)
		 	setState(1144)
		 	try match(plsqlParser.TRIGGER)
		 	setState(1145)
		 	try trigger_name()
		 	setState(1146)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_triggerContext:ParserRuleContext {
		public var tn1: Trigger_nameContext!
		public var tn2: Trigger_nameContext!
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func trigger_name() -> Array<Trigger_nameContext> {
			return getRuleContexts(Trigger_nameContext.self)
		}
		open func trigger_name(_ i: Int) -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,i)
		}
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.RENAME, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.ENABLE, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.DISABLE, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_trigger() throws -> Alter_triggerContext {
		var _localctx: Alter_triggerContext = Alter_triggerContext(_ctx, getState())
		try enterRule(_localctx, 50, plsqlParser.RULE_alter_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1148)
		 	try match(plsqlParser.ALTER)
		 	setState(1149)
		 	try match(plsqlParser.TRIGGER)
		 	setState(1150)
		 	try {
		 			let assignmentValue = try trigger_name()
		 			_localctx.castdown(Alter_triggerContext.self).tn1 = assignmentValue
		 	     }()

		 	setState(1169)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.ENABLE:
		 		setState(1151)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DISABLE || _la == plsqlParser.ENABLE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break

		 	case plsqlParser.RENAME:
		 		setState(1152)
		 		try match(plsqlParser.RENAME)
		 		setState(1153)
		 		try match(plsqlParser.TO)
		 		setState(1154)
		 		try {
		 				let assignmentValue = try trigger_name()
		 				_localctx.castdown(Alter_triggerContext.self).tn2 = assignmentValue
		 		     }()


		 		break

		 	case plsqlParser.COMPILE:
		 		setState(1155)
		 		try match(plsqlParser.COMPILE)
		 		setState(1157)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,58,_ctx)) {
		 		case 1:
		 			setState(1156)
		 			try match(plsqlParser.DEBUG)

		 			break
		 		default: break
		 		}
		 		setState(1162)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,59,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(1159)
		 				try compiler_parameters_clause()

		 		 
		 			}
		 			setState(1164)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,59,_ctx)
		 		}
		 		setState(1167)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.REUSE
		 		      return testSet
		 		 }()) {
		 			setState(1165)
		 			try match(plsqlParser.REUSE)
		 			setState(1166)
		 			try match(plsqlParser.SETTINGS)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1171)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_triggerContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open func trigger_body() -> Trigger_bodyContext? {
			return getRuleContext(Trigger_bodyContext.self,0)
		}
		open func simple_dml_trigger() -> Simple_dml_triggerContext? {
			return getRuleContext(Simple_dml_triggerContext.self,0)
		}
		open func compound_dml_trigger() -> Compound_dml_triggerContext? {
			return getRuleContext(Compound_dml_triggerContext.self,0)
		}
		open func non_dml_trigger() -> Non_dml_triggerContext? {
			return getRuleContext(Non_dml_triggerContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open func trigger_follows_clause() -> Trigger_follows_clauseContext? {
			return getRuleContext(Trigger_follows_clauseContext.self,0)
		}
		open func trigger_when_clause() -> Trigger_when_clauseContext? {
			return getRuleContext(Trigger_when_clauseContext.self,0)
		}
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.ENABLE, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.DISABLE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_trigger() throws -> Create_triggerContext {
		var _localctx: Create_triggerContext = Create_triggerContext(_ctx, getState())
		try enterRule(_localctx, 52, plsqlParser.RULE_create_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1173)
		 	try match(plsqlParser.CREATE)
		 	setState(1176)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(1174)
		 		try match(plsqlParser.OR)
		 		setState(1175)
		 		try match(plsqlParser.REPLACE)

		 	}

		 	setState(1178)
		 	try match(plsqlParser.TRIGGER)
		 	setState(1179)
		 	try trigger_name()
		 	setState(1183)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,63, _ctx)) {
		 	case 1:
		 		setState(1180)
		 		try simple_dml_trigger()

		 		break
		 	case 2:
		 		setState(1181)
		 		try compound_dml_trigger()

		 		break
		 	case 3:
		 		setState(1182)
		 		try non_dml_trigger()

		 		break
		 	default: break
		 	}
		 	setState(1186)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,64,_ctx)) {
		 	case 1:
		 		setState(1185)
		 		try trigger_follows_clause()

		 		break
		 	default: break
		 	}
		 	setState(1189)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,65,_ctx)) {
		 	case 1:
		 		setState(1188)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DISABLE || _la == plsqlParser.ENABLE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1192)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(1191)
		 		try trigger_when_clause()

		 	}

		 	setState(1194)
		 	try trigger_body()
		 	setState(1195)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_follows_clauseContext:ParserRuleContext {
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.FOLLOWS, 0) }
		open func trigger_name() -> Array<Trigger_nameContext> {
			return getRuleContexts(Trigger_nameContext.self)
		}
		open func trigger_name(_ i: Int) -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_follows_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_follows_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_follows_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_follows_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_follows_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_follows_clause() throws -> Trigger_follows_clauseContext {
		var _localctx: Trigger_follows_clauseContext = Trigger_follows_clauseContext(_ctx, getState())
		try enterRule(_localctx, 54, plsqlParser.RULE_trigger_follows_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1197)
		 	try match(plsqlParser.FOLLOWS)
		 	setState(1198)
		 	try trigger_name()
		 	setState(1203)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1199)
		 		try match(plsqlParser.COMMA)
		 		setState(1200)
		 		try trigger_name()


		 		setState(1205)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_when_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_when_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_when_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_when_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_when_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_when_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_when_clause() throws -> Trigger_when_clauseContext {
		var _localctx: Trigger_when_clauseContext = Trigger_when_clauseContext(_ctx, getState())
		try enterRule(_localctx, 56, plsqlParser.RULE_trigger_when_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1206)
		 	try match(plsqlParser.WHEN)
		 	setState(1207)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1208)
		 	try condition()
		 	setState(1209)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_dml_triggerContext:ParserRuleContext {
		open func dml_event_clause() -> Dml_event_clauseContext? {
			return getRuleContext(Dml_event_clauseContext.self,0)
		}
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.AFTER, 0) }
		open func INSTEAD() -> TerminalNode? { return getToken(plsqlParser.INSTEAD, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func referencing_clause() -> Referencing_clauseContext? {
			return getRuleContext(Referencing_clauseContext.self,0)
		}
		open func for_each_row() -> For_each_rowContext? {
			return getRuleContext(For_each_rowContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_dml_trigger() throws -> Simple_dml_triggerContext {
		var _localctx: Simple_dml_triggerContext = Simple_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 58, plsqlParser.RULE_simple_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1215)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BEFORE:
		 		setState(1211)
		 		try match(plsqlParser.BEFORE)

		 		break

		 	case plsqlParser.AFTER:
		 		setState(1212)
		 		try match(plsqlParser.AFTER)

		 		break

		 	case plsqlParser.INSTEAD:
		 		setState(1213)
		 		try match(plsqlParser.INSTEAD)
		 		setState(1214)
		 		try match(plsqlParser.OF)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1217)
		 	try dml_event_clause()
		 	setState(1219)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,69,_ctx)) {
		 	case 1:
		 		setState(1218)
		 		try referencing_clause()

		 		break
		 	default: break
		 	}
		 	setState(1222)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(1221)
		 		try for_each_row()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_each_rowContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func EACH() -> TerminalNode? { return getToken(plsqlParser.EACH, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.ROW, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_each_row }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_each_row(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_each_row(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_each_row(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_each_row(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_each_row() throws -> For_each_rowContext {
		var _localctx: For_each_rowContext = For_each_rowContext(_ctx, getState())
		try enterRule(_localctx, 60, plsqlParser.RULE_for_each_row)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1224)
		 	try match(plsqlParser.FOR)
		 	setState(1225)
		 	try match(plsqlParser.EACH)
		 	setState(1226)
		 	try match(plsqlParser.ROW)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compound_dml_triggerContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func dml_event_clause() -> Dml_event_clauseContext? {
			return getRuleContext(Dml_event_clauseContext.self,0)
		}
		open func referencing_clause() -> Referencing_clauseContext? {
			return getRuleContext(Referencing_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_dml_trigger() throws -> Compound_dml_triggerContext {
		var _localctx: Compound_dml_triggerContext = Compound_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 62, plsqlParser.RULE_compound_dml_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1228)
		 	try match(plsqlParser.FOR)
		 	setState(1229)
		 	try dml_event_clause()
		 	setState(1231)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,71,_ctx)) {
		 	case 1:
		 		setState(1230)
		 		try referencing_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Non_dml_triggerContext:ParserRuleContext {
		open func non_dml_event() -> Array<Non_dml_eventContext> {
			return getRuleContexts(Non_dml_eventContext.self)
		}
		open func non_dml_event(_ i: Int) -> Non_dml_eventContext? {
			return getRuleContext(Non_dml_eventContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.BEFORE, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.AFTER, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.DATABASE, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.SCHEMA, 0) }
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.OR) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.OR, i)
		}
		open func schema_name() -> Schema_nameContext? {
			return getRuleContext(Schema_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_non_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNon_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNon_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNon_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNon_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func non_dml_trigger() throws -> Non_dml_triggerContext {
		var _localctx: Non_dml_triggerContext = Non_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 64, plsqlParser.RULE_non_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1233)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AFTER || _la == plsqlParser.BEFORE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1234)
		 	try non_dml_event()
		 	setState(1239)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(1235)
		 		try match(plsqlParser.OR)
		 		setState(1236)
		 		try non_dml_event()


		 		setState(1241)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1242)
		 	try match(plsqlParser.ON)
		 	setState(1250)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,74, _ctx)) {
		 	case 1:
		 		setState(1243)
		 		try match(plsqlParser.DATABASE)

		 		break
		 	case 2:
		 		setState(1247)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,73,_ctx)) {
		 		case 1:
		 			setState(1244)
		 			try schema_name()
		 			setState(1245)
		 			try match(plsqlParser.PERIOD)

		 			break
		 		default: break
		 		}
		 		setState(1249)
		 		try match(plsqlParser.SCHEMA)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_bodyContext:ParserRuleContext {
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.COMPOUND, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.CALL, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func trigger_block() -> Trigger_blockContext? {
			return getRuleContext(Trigger_blockContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_body() throws -> Trigger_bodyContext {
		var _localctx: Trigger_bodyContext = Trigger_bodyContext(_ctx, getState())
		try enterRule(_localctx, 66, plsqlParser.RULE_trigger_body)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1257)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,75, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1252)
		 		try match(plsqlParser.COMPOUND)
		 		setState(1253)
		 		try match(plsqlParser.TRIGGER)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1254)
		 		try match(plsqlParser.CALL)
		 		setState(1255)
		 		try id()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1256)
		 		try trigger_block()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Routine_clauseContext:ParserRuleContext {
		open func routine_name() -> Routine_nameContext? {
			return getRuleContext(Routine_nameContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_routine_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRoutine_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRoutine_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRoutine_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRoutine_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func routine_clause() throws -> Routine_clauseContext {
		var _localctx: Routine_clauseContext = Routine_clauseContext(_ctx, getState())
		try enterRule(_localctx, 68, plsqlParser.RULE_routine_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1259)
		 	try routine_name()
		 	setState(1261)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1260)
		 		try function_argument()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compound_trigger_blockContext:ParserRuleContext {
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.COMPOUND, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open func timing_point_section() -> Array<Timing_point_sectionContext> {
			return getRuleContexts(Timing_point_sectionContext.self)
		}
		open func timing_point_section(_ i: Int) -> Timing_point_sectionContext? {
			return getRuleContext(Timing_point_sectionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_trigger_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_trigger_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_trigger_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_trigger_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_trigger_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_trigger_block() throws -> Compound_trigger_blockContext {
		var _localctx: Compound_trigger_blockContext = Compound_trigger_blockContext(_ctx, getState())
		try enterRule(_localctx, 70, plsqlParser.RULE_compound_trigger_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1263)
		 	try match(plsqlParser.COMPOUND)
		 	setState(1264)
		 	try match(plsqlParser.TRIGGER)
		 	setState(1268)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,77,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1265)
		 			try declare_spec()

		 	 
		 		}
		 		setState(1270)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,77,_ctx)
		 	}
		 	setState(1272) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1271)
		 		try timing_point_section()


		 		setState(1274); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AFTER || _la == plsqlParser.BEFORE
		 	      return testSet
		 	 }())
		 	setState(1276)
		 	try match(plsqlParser.END)
		 	setState(1277)
		 	try trigger_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Timing_point_sectionContext:ParserRuleContext {
		public var bk: Token!
		public var ak: Token!
		open func STATEMENT() -> Array<TerminalNode> { return getTokens(plsqlParser.STATEMENT) }
		open func STATEMENT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.STATEMENT, i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func trigger_block() -> Trigger_blockContext? {
			return getRuleContext(Trigger_blockContext.self,0)
		}
		open func BEFORE() -> Array<TerminalNode> { return getTokens(plsqlParser.BEFORE) }
		open func BEFORE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.BEFORE, i)
		}
		open func EACH() -> Array<TerminalNode> { return getTokens(plsqlParser.EACH) }
		open func EACH(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.EACH, i)
		}
		open func ROW() -> Array<TerminalNode> { return getTokens(plsqlParser.ROW) }
		open func ROW(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.ROW, i)
		}
		open func AFTER() -> Array<TerminalNode> { return getTokens(plsqlParser.AFTER) }
		open func AFTER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.AFTER, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_timing_point_section }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTiming_point_section(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTiming_point_section(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTiming_point_section(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTiming_point_section(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func timing_point_section() throws -> Timing_point_sectionContext {
		var _localctx: Timing_point_sectionContext = Timing_point_sectionContext(_ctx, getState())
		try enterRule(_localctx, 72, plsqlParser.RULE_timing_point_section)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1315)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,79, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1279)
		 		try {
		 				let assignmentValue = try match(plsqlParser.BEFORE)
		 				_localctx.castdown(Timing_point_sectionContext.self).bk = assignmentValue
		 		     }()

		 		setState(1280)
		 		try match(plsqlParser.STATEMENT)
		 		setState(1281)
		 		try match(plsqlParser.IS)
		 		setState(1282)
		 		try trigger_block()
		 		setState(1283)
		 		try match(plsqlParser.BEFORE)
		 		setState(1284)
		 		try match(plsqlParser.STATEMENT)
		 		setState(1285)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1287)
		 		try {
		 				let assignmentValue = try match(plsqlParser.BEFORE)
		 				_localctx.castdown(Timing_point_sectionContext.self).bk = assignmentValue
		 		     }()

		 		setState(1288)
		 		try match(plsqlParser.EACH)
		 		setState(1289)
		 		try match(plsqlParser.ROW)
		 		setState(1290)
		 		try match(plsqlParser.IS)
		 		setState(1291)
		 		try trigger_block()
		 		setState(1292)
		 		try match(plsqlParser.BEFORE)
		 		setState(1293)
		 		try match(plsqlParser.EACH)
		 		setState(1294)
		 		try match(plsqlParser.ROW)
		 		setState(1295)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1297)
		 		try {
		 				let assignmentValue = try match(plsqlParser.AFTER)
		 				_localctx.castdown(Timing_point_sectionContext.self).ak = assignmentValue
		 		     }()

		 		setState(1298)
		 		try match(plsqlParser.STATEMENT)
		 		setState(1299)
		 		try match(plsqlParser.IS)
		 		setState(1300)
		 		try trigger_block()
		 		setState(1301)
		 		try match(plsqlParser.AFTER)
		 		setState(1302)
		 		try match(plsqlParser.STATEMENT)
		 		setState(1303)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1305)
		 		try {
		 				let assignmentValue = try match(plsqlParser.AFTER)
		 				_localctx.castdown(Timing_point_sectionContext.self).ak = assignmentValue
		 		     }()

		 		setState(1306)
		 		try match(plsqlParser.EACH)
		 		setState(1307)
		 		try match(plsqlParser.ROW)
		 		setState(1308)
		 		try match(plsqlParser.IS)
		 		setState(1309)
		 		try trigger_block()
		 		setState(1310)
		 		try match(plsqlParser.AFTER)
		 		setState(1311)
		 		try match(plsqlParser.EACH)
		 		setState(1312)
		 		try match(plsqlParser.ROW)
		 		setState(1313)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Non_dml_eventContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func ANALYZE() -> TerminalNode? { return getToken(plsqlParser.ANALYZE, 0) }
		open func ASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.ASSOCIATE, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(plsqlParser.STATISTICS, 0) }
		open func AUDIT() -> TerminalNode? { return getToken(plsqlParser.AUDIT, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.COMMENT, 0) }
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func DISASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.DISASSOCIATE, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func GRANT() -> TerminalNode? { return getToken(plsqlParser.GRANT, 0) }
		open func NOAUDIT() -> TerminalNode? { return getToken(plsqlParser.NOAUDIT, 0) }
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.RENAME, 0) }
		open func REVOKE() -> TerminalNode? { return getToken(plsqlParser.REVOKE, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.TRUNCATE, 0) }
		open func DDL() -> TerminalNode? { return getToken(plsqlParser.DDL, 0) }
		open func STARTUP() -> TerminalNode? { return getToken(plsqlParser.STARTUP, 0) }
		open func SHUTDOWN() -> TerminalNode? { return getToken(plsqlParser.SHUTDOWN, 0) }
		open func DB_ROLE_CHANGE() -> TerminalNode? { return getToken(plsqlParser.DB_ROLE_CHANGE, 0) }
		open func LOGON() -> TerminalNode? { return getToken(plsqlParser.LOGON, 0) }
		open func LOGOFF() -> TerminalNode? { return getToken(plsqlParser.LOGOFF, 0) }
		open func SERVERERROR() -> TerminalNode? { return getToken(plsqlParser.SERVERERROR, 0) }
		open func SUSPEND() -> TerminalNode? { return getToken(plsqlParser.SUSPEND, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.DATABASE, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.SCHEMA, 0) }
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.FOLLOWS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_non_dml_event }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNon_dml_event(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNon_dml_event(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNon_dml_event(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNon_dml_event(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func non_dml_event() throws -> Non_dml_eventContext {
		var _localctx: Non_dml_eventContext = Non_dml_eventContext(_ctx, getState())
		try enterRule(_localctx, 74, plsqlParser.RULE_non_dml_event)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1343)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.ALTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1317)
		 		try match(plsqlParser.ALTER)

		 		break

		 	case plsqlParser.ANALYZE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1318)
		 		try match(plsqlParser.ANALYZE)

		 		break

		 	case plsqlParser.ASSOCIATE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1319)
		 		try match(plsqlParser.ASSOCIATE)
		 		setState(1320)
		 		try match(plsqlParser.STATISTICS)

		 		break

		 	case plsqlParser.AUDIT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1321)
		 		try match(plsqlParser.AUDIT)

		 		break

		 	case plsqlParser.COMMENT:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1322)
		 		try match(plsqlParser.COMMENT)

		 		break

		 	case plsqlParser.CREATE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1323)
		 		try match(plsqlParser.CREATE)

		 		break

		 	case plsqlParser.DISASSOCIATE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1324)
		 		try match(plsqlParser.DISASSOCIATE)
		 		setState(1325)
		 		try match(plsqlParser.STATISTICS)

		 		break

		 	case plsqlParser.DROP:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1326)
		 		try match(plsqlParser.DROP)

		 		break

		 	case plsqlParser.GRANT:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1327)
		 		try match(plsqlParser.GRANT)

		 		break

		 	case plsqlParser.NOAUDIT:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1328)
		 		try match(plsqlParser.NOAUDIT)

		 		break

		 	case plsqlParser.RENAME:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1329)
		 		try match(plsqlParser.RENAME)

		 		break

		 	case plsqlParser.REVOKE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1330)
		 		try match(plsqlParser.REVOKE)

		 		break

		 	case plsqlParser.TRUNCATE:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1331)
		 		try match(plsqlParser.TRUNCATE)

		 		break

		 	case plsqlParser.DDL:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(1332)
		 		try match(plsqlParser.DDL)

		 		break

		 	case plsqlParser.STARTUP:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(1333)
		 		try match(plsqlParser.STARTUP)

		 		break

		 	case plsqlParser.SHUTDOWN:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(1334)
		 		try match(plsqlParser.SHUTDOWN)

		 		break

		 	case plsqlParser.DB_ROLE_CHANGE:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(1335)
		 		try match(plsqlParser.DB_ROLE_CHANGE)

		 		break

		 	case plsqlParser.LOGON:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(1336)
		 		try match(plsqlParser.LOGON)

		 		break

		 	case plsqlParser.LOGOFF:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(1337)
		 		try match(plsqlParser.LOGOFF)

		 		break

		 	case plsqlParser.SERVERERROR:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(1338)
		 		try match(plsqlParser.SERVERERROR)

		 		break

		 	case plsqlParser.SUSPEND:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(1339)
		 		try match(plsqlParser.SUSPEND)

		 		break

		 	case plsqlParser.DATABASE:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(1340)
		 		try match(plsqlParser.DATABASE)

		 		break

		 	case plsqlParser.SCHEMA:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(1341)
		 		try match(plsqlParser.SCHEMA)

		 		break

		 	case plsqlParser.FOLLOWS:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(1342)
		 		try match(plsqlParser.FOLLOWS)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_clauseContext:ParserRuleContext {
		open func dml_event_element() -> Array<Dml_event_elementContext> {
			return getRuleContexts(Dml_event_elementContext.self)
		}
		open func dml_event_element(_ i: Int) -> Dml_event_elementContext? {
			return getRuleContext(Dml_event_elementContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.OR) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.OR, i)
		}
		open func dml_event_nested_clause() -> Dml_event_nested_clauseContext? {
			return getRuleContext(Dml_event_nested_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_clause() throws -> Dml_event_clauseContext {
		var _localctx: Dml_event_clauseContext = Dml_event_clauseContext(_ctx, getState())
		try enterRule(_localctx, 76, plsqlParser.RULE_dml_event_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1345)
		 	try dml_event_element()
		 	setState(1350)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(1346)
		 		try match(plsqlParser.OR)
		 		setState(1347)
		 		try dml_event_element()


		 		setState(1352)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1353)
		 	try match(plsqlParser.ON)
		 	setState(1355)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,82,_ctx)) {
		 	case 1:
		 		setState(1354)
		 		try dml_event_nested_clause()

		 		break
		 	default: break
		 	}
		 	setState(1357)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_elementContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.DELETE, 0) }
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.INSERT, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_element() throws -> Dml_event_elementContext {
		var _localctx: Dml_event_elementContext = Dml_event_elementContext(_ctx, getState())
		try enterRule(_localctx, 78, plsqlParser.RULE_dml_event_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1359)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DELETE
		 	          testSet = testSet || _la == plsqlParser.INSERT
		 	          testSet = testSet || _la == plsqlParser.UPDATE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1369)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OF
		 	      return testSet
		 	 }()) {
		 		setState(1360)
		 		try match(plsqlParser.OF)
		 		setState(1361)
		 		try column_name()
		 		setState(1366)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1362)
		 			try match(plsqlParser.COMMA)
		 			setState(1363)
		 			try column_name()


		 			setState(1368)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_nested_clauseContext:ParserRuleContext {
		open func NESTED() -> TerminalNode? { return getToken(plsqlParser.NESTED, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_nested_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_nested_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_nested_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_nested_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_nested_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_nested_clause() throws -> Dml_event_nested_clauseContext {
		var _localctx: Dml_event_nested_clauseContext = Dml_event_nested_clauseContext(_ctx, getState())
		try enterRule(_localctx, 80, plsqlParser.RULE_dml_event_nested_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1371)
		 	try match(plsqlParser.NESTED)
		 	setState(1372)
		 	try match(plsqlParser.TABLE)
		 	setState(1373)
		 	try tableview_name()
		 	setState(1374)
		 	try match(plsqlParser.OF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Referencing_clauseContext:ParserRuleContext {
		open func REFERENCING() -> TerminalNode? { return getToken(plsqlParser.REFERENCING, 0) }
		open func referencing_element() -> Array<Referencing_elementContext> {
			return getRuleContexts(Referencing_elementContext.self)
		}
		open func referencing_element(_ i: Int) -> Referencing_elementContext? {
			return getRuleContext(Referencing_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_referencing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReferencing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReferencing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReferencing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReferencing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func referencing_clause() throws -> Referencing_clauseContext {
		var _localctx: Referencing_clauseContext = Referencing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 82, plsqlParser.RULE_referencing_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1376)
		 	try match(plsqlParser.REFERENCING)
		 	setState(1378); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1377)
		 			try referencing_element()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1380); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,85,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Referencing_elementContext:ParserRuleContext {
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.NEW, 0) }
		open func OLD() -> TerminalNode? { return getToken(plsqlParser.OLD, 0) }
		open func PARENT() -> TerminalNode? { return getToken(plsqlParser.PARENT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_referencing_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReferencing_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReferencing_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReferencing_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReferencing_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func referencing_element() throws -> Referencing_elementContext {
		var _localctx: Referencing_elementContext = Referencing_elementContext(_ctx, getState())
		try enterRule(_localctx, 84, plsqlParser.RULE_referencing_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1382)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.NEW,plsqlParser.OLD,plsqlParser.PARENT]
		 	    return  Utils.testBitLeftShiftArray(testArray, 237)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1383)
		 	try column_alias()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_typeContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.FORCE, 0) }
		open func VALIDATE() -> TerminalNode? { return getToken(plsqlParser.VALIDATE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_type() throws -> Drop_typeContext {
		var _localctx: Drop_typeContext = Drop_typeContext(_ctx, getState())
		try enterRule(_localctx, 86, plsqlParser.RULE_drop_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1385)
		 	try match(plsqlParser.DROP)
		 	setState(1386)
		 	try match(plsqlParser.TYPE)
		 	setState(1388)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,86,_ctx)) {
		 	case 1:
		 		setState(1387)
		 		try match(plsqlParser.BODY)

		 		break
		 	default: break
		 	}
		 	setState(1390)
		 	try type_name()
		 	setState(1392)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.FORCE
		 	          testSet = testSet || _la == plsqlParser.VALIDATE
		 	      return testSet
		 	 }()) {
		 		setState(1391)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.FORCE
		 		          testSet = testSet || _la == plsqlParser.VALIDATE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(1394)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_typeContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func compile_type_clause() -> Compile_type_clauseContext? {
			return getRuleContext(Compile_type_clauseContext.self,0)
		}
		open func replace_type_clause() -> Replace_type_clauseContext? {
			return getRuleContext(Replace_type_clauseContext.self,0)
		}
		open func alter_method_spec() -> Alter_method_specContext? {
			return getRuleContext(Alter_method_specContext.self,0)
		}
		open func alter_collection_clauses() -> Alter_collection_clausesContext? {
			return getRuleContext(Alter_collection_clausesContext.self,0)
		}
		open func modifier_clause() -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,0)
		}
		open func dependent_handling_clause() -> Dependent_handling_clauseContext? {
			return getRuleContext(Dependent_handling_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_type() throws -> Alter_typeContext {
		var _localctx: Alter_typeContext = Alter_typeContext(_ctx, getState())
		try enterRule(_localctx, 88, plsqlParser.RULE_alter_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1396)
		 	try match(plsqlParser.ALTER)
		 	setState(1397)
		 	try match(plsqlParser.TYPE)
		 	setState(1398)
		 	try type_name()
		 	setState(1404)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.COMPILE:
		 		setState(1399)
		 		try compile_type_clause()

		 		break

		 	case plsqlParser.REPLACE:
		 		setState(1400)
		 		try replace_type_clause()

		 		break
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.DROP:
		 		setState(1401)
		 		try alter_method_spec()

		 		break

		 	case plsqlParser.MODIFY:
		 		setState(1402)
		 		try alter_collection_clauses()

		 		break
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.NOT:fallthrough
		 	case plsqlParser.OVERRIDING:
		 		setState(1403)
		 		try modifier_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1407)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CASCADE
		 	          testSet = testSet || _la == plsqlParser.INVALIDATE
		 	      return testSet
		 	 }()) {
		 		setState(1406)
		 		try dependent_handling_clause()

		 	}

		 	setState(1409)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compile_type_clauseContext:ParserRuleContext {
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.SPECIFICATION, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compile_type_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompile_type_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompile_type_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompile_type_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompile_type_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compile_type_clause() throws -> Compile_type_clauseContext {
		var _localctx: Compile_type_clauseContext = Compile_type_clauseContext(_ctx, getState())
		try enterRule(_localctx, 90, plsqlParser.RULE_compile_type_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1411)
		 	try match(plsqlParser.COMPILE)
		 	setState(1413)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,90,_ctx)) {
		 	case 1:
		 		setState(1412)
		 		try match(plsqlParser.DEBUG)

		 		break
		 	default: break
		 	}
		 	setState(1416)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,91,_ctx)) {
		 	case 1:
		 		setState(1415)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.BODY
		 		          testSet = testSet || _la == plsqlParser.SPECIFICATION
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1421)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,92,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1418)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(1423)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,92,_ctx)
		 	}
		 	setState(1426)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REUSE
		 	      return testSet
		 	 }()) {
		 		setState(1424)
		 		try match(plsqlParser.REUSE)
		 		setState(1425)
		 		try match(plsqlParser.SETTINGS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Replace_type_clauseContext:ParserRuleContext {
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.OBJECT, 0) }
		open func object_member_spec() -> Array<Object_member_specContext> {
			return getRuleContexts(Object_member_specContext.self)
		}
		open func object_member_spec(_ i: Int) -> Object_member_specContext? {
			return getRuleContext(Object_member_specContext.self,i)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_replace_type_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReplace_type_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReplace_type_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReplace_type_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReplace_type_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func replace_type_clause() throws -> Replace_type_clauseContext {
		var _localctx: Replace_type_clauseContext = Replace_type_clauseContext(_ctx, getState())
		try enterRule(_localctx, 92, plsqlParser.RULE_replace_type_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1428)
		 	try match(plsqlParser.REPLACE)
		 	setState(1430)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AUTHID
		 	      return testSet
		 	 }()) {
		 		setState(1429)
		 		try invoker_rights_clause()

		 	}

		 	setState(1432)
		 	try match(plsqlParser.AS)
		 	setState(1433)
		 	try match(plsqlParser.OBJECT)
		 	setState(1434)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1435)
		 	try object_member_spec()
		 	setState(1440)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1436)
		 		try match(plsqlParser.COMMA)
		 		setState(1437)
		 		try object_member_spec()


		 		setState(1442)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1443)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_method_specContext:ParserRuleContext {
		open func alter_method_element() -> Array<Alter_method_elementContext> {
			return getRuleContexts(Alter_method_elementContext.self)
		}
		open func alter_method_element(_ i: Int) -> Alter_method_elementContext? {
			return getRuleContext(Alter_method_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_method_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_method_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_method_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_method_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_method_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_method_spec() throws -> Alter_method_specContext {
		var _localctx: Alter_method_specContext = Alter_method_specContext(_ctx, getState())
		try enterRule(_localctx, 94, plsqlParser.RULE_alter_method_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1445)
		 	try alter_method_element()
		 	setState(1450)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1446)
		 		try match(plsqlParser.COMMA)
		 		setState(1447)
		 		try alter_method_element()


		 		setState(1452)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_method_elementContext:ParserRuleContext {
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.ADD, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func map_order_function_spec() -> Map_order_function_specContext? {
			return getRuleContext(Map_order_function_specContext.self,0)
		}
		open func subprogram_spec() -> Subprogram_specContext? {
			return getRuleContext(Subprogram_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_method_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_method_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_method_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_method_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_method_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_method_element() throws -> Alter_method_elementContext {
		var _localctx: Alter_method_elementContext = Alter_method_elementContext(_ctx, getState())
		try enterRule(_localctx, 96, plsqlParser.RULE_alter_method_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1453)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ADD
		 	          testSet = testSet || _la == plsqlParser.DROP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1456)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.ORDER:
		 		setState(1454)
		 		try map_order_function_spec()

		 		break
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.STATIC:
		 		setState(1455)
		 		try subprogram_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_attribute_definitionContext:ParserRuleContext {
		open func ATTRIBUTE() -> TerminalNode? { return getToken(plsqlParser.ATTRIBUTE, 0) }
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.ADD, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.MODIFY, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func attribute_definition() -> Array<Attribute_definitionContext> {
			return getRuleContexts(Attribute_definitionContext.self)
		}
		open func attribute_definition(_ i: Int) -> Attribute_definitionContext? {
			return getRuleContext(Attribute_definitionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_attribute_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_attribute_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_attribute_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_attribute_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_attribute_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_attribute_definition() throws -> Alter_attribute_definitionContext {
		var _localctx: Alter_attribute_definitionContext = Alter_attribute_definitionContext(_ctx, getState())
		try enterRule(_localctx, 98, plsqlParser.RULE_alter_attribute_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1458)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ADD
		 	          testSet = testSet || _la == plsqlParser.DROP
		 	          testSet = testSet || _la == plsqlParser.MODIFY
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1459)
		 	try match(plsqlParser.ATTRIBUTE)
		 	setState(1472)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(1460)
		 		try attribute_definition()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(1461)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1462)
		 		try attribute_definition()
		 		setState(1467)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1463)
		 			try match(plsqlParser.COMMA)
		 			setState(1464)
		 			try attribute_definition()


		 			setState(1469)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1470)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Attribute_definitionContext:ParserRuleContext {
		open func attribute_name() -> Attribute_nameContext? {
			return getRuleContext(Attribute_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_attribute_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAttribute_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAttribute_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAttribute_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAttribute_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func attribute_definition() throws -> Attribute_definitionContext {
		var _localctx: Attribute_definitionContext = Attribute_definitionContext(_ctx, getState())
		try enterRule(_localctx, 100, plsqlParser.RULE_attribute_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1474)
		 	try attribute_name()
		 	setState(1476)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(1475)
		 		try type_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_collection_clausesContext:ParserRuleContext {
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.MODIFY, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.LIMIT, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ELEMENT() -> TerminalNode? { return getToken(plsqlParser.ELEMENT, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_collection_clauses }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_collection_clauses(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_collection_clauses(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_collection_clauses(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_collection_clauses(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_collection_clauses() throws -> Alter_collection_clausesContext {
		var _localctx: Alter_collection_clausesContext = Alter_collection_clausesContext(_ctx, getState())
		try enterRule(_localctx, 102, plsqlParser.RULE_alter_collection_clauses)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1478)
		 	try match(plsqlParser.MODIFY)
		 	setState(1484)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.LIMIT:
		 		setState(1479)
		 		try match(plsqlParser.LIMIT)
		 		setState(1480)
		 		try expression()

		 		break

		 	case plsqlParser.ELEMENT:
		 		setState(1481)
		 		try match(plsqlParser.ELEMENT)
		 		setState(1482)
		 		try match(plsqlParser.TYPE)
		 		setState(1483)
		 		try type_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dependent_handling_clauseContext:ParserRuleContext {
		open func INVALIDATE() -> TerminalNode? { return getToken(plsqlParser.INVALIDATE, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(plsqlParser.CASCADE, 0) }
		open func CONVERT() -> TerminalNode? { return getToken(plsqlParser.CONVERT, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func SUBSTITUTABLE() -> TerminalNode? { return getToken(plsqlParser.SUBSTITUTABLE, 0) }
		open func INCLUDING() -> TerminalNode? { return getToken(plsqlParser.INCLUDING, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func DATA() -> TerminalNode? { return getToken(plsqlParser.DATA, 0) }
		open func dependent_exceptions_part() -> Dependent_exceptions_partContext? {
			return getRuleContext(Dependent_exceptions_partContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dependent_handling_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDependent_handling_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDependent_handling_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDependent_handling_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDependent_handling_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dependent_handling_clause() throws -> Dependent_handling_clauseContext {
		var _localctx: Dependent_handling_clauseContext = Dependent_handling_clauseContext(_ctx, getState())
		try enterRule(_localctx, 104, plsqlParser.RULE_dependent_handling_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1502)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INVALIDATE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1486)
		 		try match(plsqlParser.INVALIDATE)

		 		break

		 	case plsqlParser.CASCADE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1487)
		 		try match(plsqlParser.CASCADE)
		 		setState(1497)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.CONVERT:
		 		 	setState(1488)
		 		 	try match(plsqlParser.CONVERT)
		 		 	setState(1489)
		 		 	try match(plsqlParser.TO)
		 		 	setState(1490)
		 		 	try match(plsqlParser.SUBSTITUTABLE)

		 			break
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.NOT:
		 		 	setState(1492)
		 		 	try _errHandler.sync(self)
		 		 	_la = try _input.LA(1)
		 		 	if (//closure
		 		 	 { () -> Bool in
		 		 	      let testSet: Bool = _la == plsqlParser.NOT
		 		 	      return testSet
		 		 	 }()) {
		 		 		setState(1491)
		 		 		try match(plsqlParser.NOT)

		 		 	}

		 		 	setState(1494)
		 		 	try match(plsqlParser.INCLUDING)
		 		 	setState(1495)
		 		 	try match(plsqlParser.TABLE)
		 		 	setState(1496)
		 		 	try match(plsqlParser.DATA)

		 			break
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.SEMICOLON:
		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1500)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.EXCEPTIONS || _la == plsqlParser.FORCE
		 		      return testSet
		 		 }()) {
		 			setState(1499)
		 			try dependent_exceptions_part()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dependent_exceptions_partContext:ParserRuleContext {
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.EXCEPTIONS, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.FORCE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dependent_exceptions_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDependent_exceptions_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDependent_exceptions_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDependent_exceptions_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDependent_exceptions_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dependent_exceptions_part() throws -> Dependent_exceptions_partContext {
		var _localctx: Dependent_exceptions_partContext = Dependent_exceptions_partContext(_ctx, getState())
		try enterRule(_localctx, 106, plsqlParser.RULE_dependent_exceptions_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1505)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FORCE
		 	      return testSet
		 	 }()) {
		 		setState(1504)
		 		try match(plsqlParser.FORCE)

		 	}

		 	setState(1507)
		 	try match(plsqlParser.EXCEPTIONS)
		 	setState(1508)
		 	try match(plsqlParser.INTO)
		 	setState(1509)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_typeContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_definition() -> Type_definitionContext? {
			return getRuleContext(Type_definitionContext.self,0)
		}
		open func type_body() -> Type_bodyContext? {
			return getRuleContext(Type_bodyContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_type() throws -> Create_typeContext {
		var _localctx: Create_typeContext = Create_typeContext(_ctx, getState())
		try enterRule(_localctx, 108, plsqlParser.RULE_create_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1511)
		 	try match(plsqlParser.CREATE)
		 	setState(1514)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(1512)
		 		try match(plsqlParser.OR)
		 		setState(1513)
		 		try match(plsqlParser.REPLACE)

		 	}

		 	setState(1516)
		 	try match(plsqlParser.TYPE)
		 	setState(1519)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,108, _ctx)) {
		 	case 1:
		 		setState(1517)
		 		try type_definition()

		 		break
		 	case 2:
		 		setState(1518)
		 		try type_body()

		 		break
		 	default: break
		 	}
		 	setState(1521)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_definitionContext:ParserRuleContext {
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func OID() -> TerminalNode? { return getToken(plsqlParser.OID, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.CHAR_STRING, 0) }
		open func object_type_def() -> Object_type_defContext? {
			return getRuleContext(Object_type_defContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_definition() throws -> Type_definitionContext {
		var _localctx: Type_definitionContext = Type_definitionContext(_ctx, getState())
		try enterRule(_localctx, 110, plsqlParser.RULE_type_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1523)
		 	try type_name()
		 	setState(1526)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OID
		 	      return testSet
		 	 }()) {
		 		setState(1524)
		 		try match(plsqlParser.OID)
		 		setState(1525)
		 		try match(plsqlParser.CHAR_STRING)

		 	}

		 	setState(1529)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS || _la == plsqlParser.AUTHID
		 	          testSet = testSet || _la == plsqlParser.IS
		 	          testSet = testSet || _la == plsqlParser.UNDER
		 	      return testSet
		 	 }()) {
		 		setState(1528)
		 		try object_type_def()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_type_defContext:ParserRuleContext {
		open func object_as_part() -> Object_as_partContext? {
			return getRuleContext(Object_as_partContext.self,0)
		}
		open func object_under_part() -> Object_under_partContext? {
			return getRuleContext(Object_under_partContext.self,0)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func sqlj_object_type() -> Sqlj_object_typeContext? {
			return getRuleContext(Sqlj_object_typeContext.self,0)
		}
		open func object_member_spec() -> Array<Object_member_specContext> {
			return getRuleContexts(Object_member_specContext.self)
		}
		open func object_member_spec(_ i: Int) -> Object_member_specContext? {
			return getRuleContext(Object_member_specContext.self,i)
		}
		open func modifier_clause() -> Array<Modifier_clauseContext> {
			return getRuleContexts(Modifier_clauseContext.self)
		}
		open func modifier_clause(_ i: Int) -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_type_def() throws -> Object_type_defContext {
		var _localctx: Object_type_defContext = Object_type_defContext(_ctx, getState())
		try enterRule(_localctx, 112, plsqlParser.RULE_object_type_def)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1532)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AUTHID
		 	      return testSet
		 	 }()) {
		 		setState(1531)
		 		try invoker_rights_clause()

		 	}

		 	setState(1536)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.AS:fallthrough
		 	case plsqlParser.IS:
		 		setState(1534)
		 		try object_as_part()

		 		break

		 	case plsqlParser.UNDER:
		 		setState(1535)
		 		try object_under_part()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1539)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.EXTERNAL
		 	      return testSet
		 	 }()) {
		 		setState(1538)
		 		try sqlj_object_type()

		 	}

		 	setState(1552)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1541)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1542)
		 		try object_member_spec()
		 		setState(1547)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1543)
		 			try match(plsqlParser.COMMA)
		 			setState(1544)
		 			try object_member_spec()


		 			setState(1549)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1550)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1557)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.FINAL || _la == plsqlParser.INSTANTIABLE
		 	          testSet = testSet || _la == plsqlParser.NOT || _la == plsqlParser.OVERRIDING
		 	      return testSet
		 	 }()) {
		 		setState(1554)
		 		try modifier_clause()


		 		setState(1559)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_as_partContext:ParserRuleContext {
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.OBJECT, 0) }
		open func varray_type_def() -> Varray_type_defContext? {
			return getRuleContext(Varray_type_defContext.self,0)
		}
		open func nested_table_type_def() -> Nested_table_type_defContext? {
			return getRuleContext(Nested_table_type_defContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_as_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_as_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_as_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_as_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_as_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_as_part() throws -> Object_as_partContext {
		var _localctx: Object_as_partContext = Object_as_partContext(_ctx, getState())
		try enterRule(_localctx, 114, plsqlParser.RULE_object_as_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1560)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1564)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.OBJECT:
		 		setState(1561)
		 		try match(plsqlParser.OBJECT)

		 		break
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:
		 		setState(1562)
		 		try varray_type_def()

		 		break

		 	case plsqlParser.TABLE:
		 		setState(1563)
		 		try nested_table_type_def()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_under_partContext:ParserRuleContext {
		open func UNDER() -> TerminalNode? { return getToken(plsqlParser.UNDER, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_under_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_under_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_under_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_under_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_under_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_under_part() throws -> Object_under_partContext {
		var _localctx: Object_under_partContext = Object_under_partContext(_ctx, getState())
		try enterRule(_localctx, 116, plsqlParser.RULE_object_under_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1566)
		 	try match(plsqlParser.UNDER)
		 	setState(1567)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Nested_table_type_defContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_nested_table_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNested_table_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNested_table_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNested_table_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNested_table_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func nested_table_type_def() throws -> Nested_table_type_defContext {
		var _localctx: Nested_table_type_defContext = Nested_table_type_defContext(_ctx, getState())
		try enterRule(_localctx, 118, plsqlParser.RULE_nested_table_type_def)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1569)
		 	try match(plsqlParser.TABLE)
		 	setState(1570)
		 	try match(plsqlParser.OF)
		 	setState(1571)
		 	try type_spec()
		 	setState(1574)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,118,_ctx)) {
		 	case 1:
		 		setState(1572)
		 		try match(plsqlParser.NOT)
		 		setState(1573)
		 		try match(plsqlParser.NULL)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sqlj_object_typeContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.EXTERNAL, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.LANGUAGE, 0) }
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.JAVA, 0) }
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func SQLDATA() -> TerminalNode? { return getToken(plsqlParser.SQLDATA, 0) }
		open func CUSTOMDATUM() -> TerminalNode? { return getToken(plsqlParser.CUSTOMDATUM, 0) }
		open func ORADATA() -> TerminalNode? { return getToken(plsqlParser.ORADATA, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sqlj_object_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSqlj_object_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSqlj_object_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSqlj_object_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSqlj_object_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sqlj_object_type() throws -> Sqlj_object_typeContext {
		var _localctx: Sqlj_object_typeContext = Sqlj_object_typeContext(_ctx, getState())
		try enterRule(_localctx, 120, plsqlParser.RULE_sqlj_object_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1576)
		 	try match(plsqlParser.EXTERNAL)
		 	setState(1577)
		 	try match(plsqlParser.NAME)
		 	setState(1578)
		 	try expression()
		 	setState(1579)
		 	try match(plsqlParser.LANGUAGE)
		 	setState(1580)
		 	try match(plsqlParser.JAVA)
		 	setState(1581)
		 	try match(plsqlParser.USING)
		 	setState(1582)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CUSTOMDATUM
		 	          testSet = testSet || _la == plsqlParser.ORADATA
		 	          testSet = testSet || _la == plsqlParser.SQLDATA
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_bodyContext:ParserRuleContext {
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func type_body_elements() -> Array<Type_body_elementsContext> {
			return getRuleContexts(Type_body_elementsContext.self)
		}
		open func type_body_elements(_ i: Int) -> Type_body_elementsContext? {
			return getRuleContext(Type_body_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_body() throws -> Type_bodyContext {
		var _localctx: Type_bodyContext = Type_bodyContext(_ctx, getState())
		try enterRule(_localctx, 122, plsqlParser.RULE_type_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1584)
		 	try match(plsqlParser.BODY)
		 	setState(1585)
		 	try type_name()
		 	setState(1586)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1588) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1587)
		 		try type_body_elements()


		 		setState(1590); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.MAP,plsqlParser.MEMBER,plsqlParser.ORDER]
		 	    return  Utils.testBitLeftShiftArray(testArray, 213)
		 	}()
		 	          testSet = testSet || _la == plsqlParser.STATIC
		 	      return testSet
		 	 }())
		 	setState(1592)
		 	try match(plsqlParser.END)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_body_elementsContext:ParserRuleContext {
		open func map_order_func_declaration() -> Map_order_func_declarationContext? {
			return getRuleContext(Map_order_func_declarationContext.self,0)
		}
		open func subprog_decl_in_type() -> Subprog_decl_in_typeContext? {
			return getRuleContext(Subprog_decl_in_typeContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_body_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_body_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_body_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_body_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_body_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_body_elements() throws -> Type_body_elementsContext {
		var _localctx: Type_body_elementsContext = Type_body_elementsContext(_ctx, getState())
		try enterRule(_localctx, 124, plsqlParser.RULE_type_body_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1596)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.ORDER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1594)
		 		try map_order_func_declaration()

		 		break
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.STATIC:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1595)
		 		try subprog_decl_in_type()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Map_order_func_declarationContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func func_decl_in_type() -> Func_decl_in_typeContext? {
			return getRuleContext(Func_decl_in_typeContext.self,0)
		}
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.MAP, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_map_order_func_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMap_order_func_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMap_order_func_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMap_order_func_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMap_order_func_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func map_order_func_declaration() throws -> Map_order_func_declarationContext {
		var _localctx: Map_order_func_declarationContext = Map_order_func_declarationContext(_ctx, getState())
		try enterRule(_localctx, 126, plsqlParser.RULE_map_order_func_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1598)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.MAP || _la == plsqlParser.ORDER
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1599)
		 	try match(plsqlParser.MEMBER)
		 	setState(1600)
		 	try func_decl_in_type()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subprog_decl_in_typeContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.STATIC, 0) }
		open func proc_decl_in_type() -> Proc_decl_in_typeContext? {
			return getRuleContext(Proc_decl_in_typeContext.self,0)
		}
		open func func_decl_in_type() -> Func_decl_in_typeContext? {
			return getRuleContext(Func_decl_in_typeContext.self,0)
		}
		open func constructor_declaration() -> Constructor_declarationContext? {
			return getRuleContext(Constructor_declarationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subprog_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubprog_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubprog_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubprog_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubprog_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subprog_decl_in_type() throws -> Subprog_decl_in_typeContext {
		var _localctx: Subprog_decl_in_typeContext = Subprog_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 128, plsqlParser.RULE_subprog_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1602)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.MEMBER
		 	          testSet = testSet || _la == plsqlParser.STATIC
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1606)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.PROCEDURE:
		 		setState(1603)
		 		try proc_decl_in_type()

		 		break

		 	case plsqlParser.FUNCTION:
		 		setState(1604)
		 		try func_decl_in_type()

		 		break
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.INSTANTIABLE:
		 		setState(1605)
		 		try constructor_declaration()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Proc_decl_in_typeContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_proc_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProc_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProc_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProc_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProc_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func proc_decl_in_type() throws -> Proc_decl_in_typeContext {
		var _localctx: Proc_decl_in_typeContext = Proc_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 130, plsqlParser.RULE_proc_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1608)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1609)
		 	try procedure_name()
		 	setState(1610)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1611)
		 	try type_elements_parameter()
		 	setState(1616)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1612)
		 		try match(plsqlParser.COMMA)
		 		setState(1613)
		 		try type_elements_parameter()


		 		setState(1618)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1619)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(1620)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1634)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,125, _ctx)) {
		 	case 1:
		 		setState(1621)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1623)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DECLARE
		 		      return testSet
		 		 }()) {
		 			setState(1622)
		 			try match(plsqlParser.DECLARE)

		 		}

		 		setState(1628)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(1625)
		 			try declare_spec()


		 			setState(1630)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1631)
		 		try body()
		 		setState(1632)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_decl_in_typeContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_func_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunc_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunc_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunc_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunc_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_decl_in_type() throws -> Func_decl_in_typeContext {
		var _localctx: Func_decl_in_typeContext = Func_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 132, plsqlParser.RULE_func_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1636)
		 	try match(plsqlParser.FUNCTION)
		 	setState(1637)
		 	try function_name()
		 	setState(1649)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1638)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1639)
		 		try type_elements_parameter()
		 		setState(1644)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1640)
		 			try match(plsqlParser.COMMA)
		 			setState(1641)
		 			try type_elements_parameter()


		 			setState(1646)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1647)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1651)
		 	try match(plsqlParser.RETURN)
		 	setState(1652)
		 	try type_spec()
		 	setState(1653)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1667)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,130, _ctx)) {
		 	case 1:
		 		setState(1654)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1656)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DECLARE
		 		      return testSet
		 		 }()) {
		 			setState(1655)
		 			try match(plsqlParser.DECLARE)

		 		}

		 		setState(1661)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(1658)
		 			try declare_spec()


		 			setState(1663)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1664)
		 		try body()
		 		setState(1665)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constructor_declarationContext:ParserRuleContext {
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.CONSTRUCTOR, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func SELF() -> Array<TerminalNode> { return getTokens(plsqlParser.SELF) }
		open func SELF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.SELF, i)
		}
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.AS) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.AS, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.RESULT, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.FINAL, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.INSTANTIABLE, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.OUT, 0) }
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constructor_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstructor_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstructor_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstructor_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstructor_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constructor_declaration() throws -> Constructor_declarationContext {
		var _localctx: Constructor_declarationContext = Constructor_declarationContext(_ctx, getState())
		try enterRule(_localctx, 134, plsqlParser.RULE_constructor_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1670)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FINAL
		 	      return testSet
		 	 }()) {
		 		setState(1669)
		 		try match(plsqlParser.FINAL)

		 	}

		 	setState(1673)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INSTANTIABLE
		 	      return testSet
		 	 }()) {
		 		setState(1672)
		 		try match(plsqlParser.INSTANTIABLE)

		 	}

		 	setState(1675)
		 	try match(plsqlParser.CONSTRUCTOR)
		 	setState(1676)
		 	try match(plsqlParser.FUNCTION)
		 	setState(1677)
		 	try type_spec()
		 	setState(1695)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1678)
		 		try match(plsqlParser.LEFT_PAREN)

		 		setState(1679)
		 		try match(plsqlParser.SELF)
		 		setState(1680)
		 		try match(plsqlParser.IN)
		 		setState(1681)
		 		try match(plsqlParser.OUT)
		 		setState(1682)
		 		try type_spec()
		 		setState(1683)
		 		try match(plsqlParser.COMMA)

		 		setState(1685)
		 		try type_elements_parameter()
		 		setState(1690)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1686)
		 			try match(plsqlParser.COMMA)
		 			setState(1687)
		 			try type_elements_parameter()


		 			setState(1692)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1693)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1697)
		 	try match(plsqlParser.RETURN)
		 	setState(1698)
		 	try match(plsqlParser.SELF)
		 	setState(1699)
		 	try match(plsqlParser.AS)
		 	setState(1700)
		 	try match(plsqlParser.RESULT)
		 	setState(1701)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1715)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,137, _ctx)) {
		 	case 1:
		 		setState(1702)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1704)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DECLARE
		 		      return testSet
		 		 }()) {
		 			setState(1703)
		 			try match(plsqlParser.DECLARE)

		 		}

		 		setState(1709)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(1706)
		 			try declare_spec()


		 			setState(1711)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1712)
		 		try body()
		 		setState(1713)
		 		try match(plsqlParser.SEMICOLON)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Modifier_clauseContext:ParserRuleContext {
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.INSTANTIABLE, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.FINAL, 0) }
		open func OVERRIDING() -> TerminalNode? { return getToken(plsqlParser.OVERRIDING, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_modifier_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModifier_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModifier_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModifier_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModifier_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func modifier_clause() throws -> Modifier_clauseContext {
		var _localctx: Modifier_clauseContext = Modifier_clauseContext(_ctx, getState())
		try enterRule(_localctx, 136, plsqlParser.RULE_modifier_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1718)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(1717)
		 		try match(plsqlParser.NOT)

		 	}

		 	setState(1720)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.FINAL || _la == plsqlParser.INSTANTIABLE
		 	          testSet = testSet || _la == plsqlParser.OVERRIDING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_member_specContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func sqlj_object_type_attr() -> Sqlj_object_type_attrContext? {
			return getRuleContext(Sqlj_object_type_attrContext.self,0)
		}
		open func element_spec() -> Element_specContext? {
			return getRuleContext(Element_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_member_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_member_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_member_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_member_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_member_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_member_spec() throws -> Object_member_specContext {
		var _localctx: Object_member_specContext = Object_member_specContext(_ctx, getState())
		try enterRule(_localctx, 138, plsqlParser.RULE_object_member_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1728)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,140, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1722)
		 		try id()
		 		setState(1723)
		 		try type_spec()
		 		setState(1725)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.EXTERNAL
		 		      return testSet
		 		 }()) {
		 			setState(1724)
		 			try sqlj_object_type_attr()

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1727)
		 		try element_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sqlj_object_type_attrContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.EXTERNAL, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sqlj_object_type_attr }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSqlj_object_type_attr(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSqlj_object_type_attr(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSqlj_object_type_attr(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSqlj_object_type_attr(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sqlj_object_type_attr() throws -> Sqlj_object_type_attrContext {
		var _localctx: Sqlj_object_type_attrContext = Sqlj_object_type_attrContext(_ctx, getState())
		try enterRule(_localctx, 140, plsqlParser.RULE_sqlj_object_type_attr)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1730)
		 	try match(plsqlParser.EXTERNAL)
		 	setState(1731)
		 	try match(plsqlParser.NAME)
		 	setState(1732)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Element_specContext:ParserRuleContext {
		open func modifier_clause() -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,0)
		}
		open func element_spec_options() -> Array<Element_spec_optionsContext> {
			return getRuleContexts(Element_spec_optionsContext.self)
		}
		open func element_spec_options(_ i: Int) -> Element_spec_optionsContext? {
			return getRuleContext(Element_spec_optionsContext.self,i)
		}
		open func pragma_clause() -> Pragma_clauseContext? {
			return getRuleContext(Pragma_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_element_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElement_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElement_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElement_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElement_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func element_spec() throws -> Element_specContext {
		var _localctx: Element_specContext = Element_specContext(_ctx, getState())
		try enterRule(_localctx, 142, plsqlParser.RULE_element_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1735)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,141,_ctx)) {
		 	case 1:
		 		setState(1734)
		 		try modifier_clause()

		 		break
		 	default: break
		 	}
		 	setState(1738) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1737)
		 		try element_spec_options()


		 		setState(1740); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CONSTRUCTOR
		 	          testSet = testSet || _la == plsqlParser.FINAL || _la == plsqlParser.INSTANTIABLE
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.MAP,plsqlParser.MEMBER,plsqlParser.ORDER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 213)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.STATIC
		 	      return testSet
		 	 }())
		 	setState(1744)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,143,_ctx)) {
		 	case 1:
		 		setState(1742)
		 		try match(plsqlParser.COMMA)
		 		setState(1743)
		 		try pragma_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Element_spec_optionsContext:ParserRuleContext {
		open func subprogram_spec() -> Subprogram_specContext? {
			return getRuleContext(Subprogram_specContext.self,0)
		}
		open func constructor_spec() -> Constructor_specContext? {
			return getRuleContext(Constructor_specContext.self,0)
		}
		open func map_order_function_spec() -> Map_order_function_specContext? {
			return getRuleContext(Map_order_function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_element_spec_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElement_spec_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElement_spec_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElement_spec_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElement_spec_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func element_spec_options() throws -> Element_spec_optionsContext {
		var _localctx: Element_spec_optionsContext = Element_spec_optionsContext(_ctx, getState())
		try enterRule(_localctx, 144, plsqlParser.RULE_element_spec_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1749)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.STATIC:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1746)
		 		try subprogram_spec()

		 		break
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.INSTANTIABLE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1747)
		 		try constructor_spec()

		 		break
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.ORDER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1748)
		 		try map_order_function_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subprogram_specContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.STATIC, 0) }
		open func type_procedure_spec() -> Type_procedure_specContext? {
			return getRuleContext(Type_procedure_specContext.self,0)
		}
		open func type_function_spec() -> Type_function_specContext? {
			return getRuleContext(Type_function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subprogram_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubprogram_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubprogram_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubprogram_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubprogram_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subprogram_spec() throws -> Subprogram_specContext {
		var _localctx: Subprogram_specContext = Subprogram_specContext(_ctx, getState())
		try enterRule(_localctx, 146, plsqlParser.RULE_subprogram_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1751)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.MEMBER
		 	          testSet = testSet || _la == plsqlParser.STATIC
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1754)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.PROCEDURE:
		 		setState(1752)
		 		try type_procedure_spec()

		 		break

		 	case plsqlParser.FUNCTION:
		 		setState(1753)
		 		try type_function_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_procedure_specContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.PROCEDURE, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_procedure_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_procedure_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_procedure_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_procedure_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_procedure_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_procedure_spec() throws -> Type_procedure_specContext {
		var _localctx: Type_procedure_specContext = Type_procedure_specContext(_ctx, getState())
		try enterRule(_localctx, 148, plsqlParser.RULE_type_procedure_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1756)
		 	try match(plsqlParser.PROCEDURE)
		 	setState(1757)
		 	try procedure_name()
		 	setState(1758)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1759)
		 	try type_elements_parameter()
		 	setState(1764)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1760)
		 		try match(plsqlParser.COMMA)
		 		setState(1761)
		 		try type_elements_parameter()


		 		setState(1766)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1767)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(1770)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1768)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.AS
		 		          testSet = testSet || _la == plsqlParser.IS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(1769)
		 		try call_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_function_specContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func SELF() -> TerminalNode? { return getToken(plsqlParser.SELF, 0) }
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.AS) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.AS, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.RESULT, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.EXTERNAL, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func VARIABLE() -> TerminalNode? { return getToken(plsqlParser.VARIABLE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_function_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_function_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_function_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_function_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_function_spec() throws -> Type_function_specContext {
		var _localctx: Type_function_specContext = Type_function_specContext(_ctx, getState())
		try enterRule(_localctx, 150, plsqlParser.RULE_type_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1772)
		 	try match(plsqlParser.FUNCTION)
		 	setState(1773)
		 	try function_name()
		 	setState(1785)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1774)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(1775)
		 		try type_elements_parameter()
		 		setState(1780)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1776)
		 			try match(plsqlParser.COMMA)
		 			setState(1777)
		 			try type_elements_parameter()


		 			setState(1782)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1783)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1787)
		 	try match(plsqlParser.RETURN)
		 	setState(1792)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,150, _ctx)) {
		 	case 1:
		 		setState(1788)
		 		try type_spec()

		 		break
		 	case 2:
		 		setState(1789)
		 		try match(plsqlParser.SELF)
		 		setState(1790)
		 		try match(plsqlParser.AS)
		 		setState(1791)
		 		try match(plsqlParser.RESULT)

		 		break
		 	default: break
		 	}
		 	setState(1802)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.AS:fallthrough
		 	case plsqlParser.IS:
		 	 	setState(1794)
		 	 	_la = try _input.LA(1)
		 	 	if (!(//closure
		 	 	 { () -> Bool in
		 	 	      var testSet: Bool = _la == plsqlParser.AS
		 	 	          testSet = testSet || _la == plsqlParser.IS
		 	 	      return testSet
		 	 	 }())) {
		 	 	try _errHandler.recoverInline(self)
		 	 	} else {
		 	 		try consume()
		 	 	}
		 	 	setState(1795)
		 	 	try call_spec()

		 		break

		 	case plsqlParser.EXTERNAL:
		 	 	setState(1796)
		 	 	try match(plsqlParser.EXTERNAL)
		 	 	setState(1798)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.VARIABLE
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(1797)
		 	 		try match(plsqlParser.VARIABLE)

		 	 	}

		 	 	setState(1800)
		 	 	try match(plsqlParser.NAME)
		 	 	setState(1801)
		 	 	try expression()

		 		break
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.ORDER:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.RIGHT_PAREN:fallthrough
		 	case plsqlParser.COMMA:fallthrough
		 	case plsqlParser.SEMICOLON:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constructor_specContext:ParserRuleContext {
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.CONSTRUCTOR, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func SELF() -> Array<TerminalNode> { return getTokens(plsqlParser.SELF) }
		open func SELF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.SELF, i)
		}
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.AS) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.AS, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.RESULT, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.FINAL, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.INSTANTIABLE, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.OUT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constructor_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstructor_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstructor_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstructor_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstructor_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constructor_spec() throws -> Constructor_specContext {
		var _localctx: Constructor_specContext = Constructor_specContext(_ctx, getState())
		try enterRule(_localctx, 152, plsqlParser.RULE_constructor_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1805)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FINAL
		 	      return testSet
		 	 }()) {
		 		setState(1804)
		 		try match(plsqlParser.FINAL)

		 	}

		 	setState(1808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INSTANTIABLE
		 	      return testSet
		 	 }()) {
		 		setState(1807)
		 		try match(plsqlParser.INSTANTIABLE)

		 	}

		 	setState(1810)
		 	try match(plsqlParser.CONSTRUCTOR)
		 	setState(1811)
		 	try match(plsqlParser.FUNCTION)
		 	setState(1812)
		 	try type_spec()
		 	setState(1830)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(1813)
		 		try match(plsqlParser.LEFT_PAREN)

		 		setState(1814)
		 		try match(plsqlParser.SELF)
		 		setState(1815)
		 		try match(plsqlParser.IN)
		 		setState(1816)
		 		try match(plsqlParser.OUT)
		 		setState(1817)
		 		try type_spec()
		 		setState(1818)
		 		try match(plsqlParser.COMMA)

		 		setState(1820)
		 		try type_elements_parameter()
		 		setState(1825)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1821)
		 			try match(plsqlParser.COMMA)
		 			setState(1822)
		 			try type_elements_parameter()


		 			setState(1827)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1828)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(1832)
		 	try match(plsqlParser.RETURN)
		 	setState(1833)
		 	try match(plsqlParser.SELF)
		 	setState(1834)
		 	try match(plsqlParser.AS)
		 	setState(1835)
		 	try match(plsqlParser.RESULT)
		 	setState(1838)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AS
		 	          testSet = testSet || _la == plsqlParser.IS
		 	      return testSet
		 	 }()) {
		 		setState(1836)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.AS
		 		          testSet = testSet || _la == plsqlParser.IS
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(1837)
		 		try call_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Map_order_function_specContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func type_function_spec() -> Type_function_specContext? {
			return getRuleContext(Type_function_specContext.self,0)
		}
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.MAP, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_map_order_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMap_order_function_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMap_order_function_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMap_order_function_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMap_order_function_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func map_order_function_spec() throws -> Map_order_function_specContext {
		var _localctx: Map_order_function_specContext = Map_order_function_specContext(_ctx, getState())
		try enterRule(_localctx, 154, plsqlParser.RULE_map_order_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1840)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.MAP || _la == plsqlParser.ORDER
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1841)
		 	try match(plsqlParser.MEMBER)
		 	setState(1842)
		 	try type_function_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_clauseContext:ParserRuleContext {
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.PRAGMA, 0) }
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.RESTRICT_REFERENCES, 0) }
		open func pragma_elements() -> Array<Pragma_elementsContext> {
			return getRuleContexts(Pragma_elementsContext.self)
		}
		open func pragma_elements(_ i: Int) -> Pragma_elementsContext? {
			return getRuleContext(Pragma_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_clause() throws -> Pragma_clauseContext {
		var _localctx: Pragma_clauseContext = Pragma_clauseContext(_ctx, getState())
		try enterRule(_localctx, 156, plsqlParser.RULE_pragma_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1844)
		 	try match(plsqlParser.PRAGMA)
		 	setState(1845)
		 	try match(plsqlParser.RESTRICT_REFERENCES)
		 	setState(1846)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1847)
		 	try pragma_elements()
		 	setState(1852)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1848)
		 		try match(plsqlParser.COMMA)
		 		setState(1849)
		 		try pragma_elements()


		 		setState(1854)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1855)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_elementsContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_elements() throws -> Pragma_elementsContext {
		var _localctx: Pragma_elementsContext = Pragma_elementsContext(_ctx, getState())
		try enterRule(_localctx, 158, plsqlParser.RULE_pragma_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1859)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1857)
		 		try id()

		 		break

		 	case plsqlParser.DEFAULT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1858)
		 		try match(plsqlParser.DEFAULT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_elements_parameterContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_elements_parameter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_elements_parameter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_elements_parameter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_elements_parameter(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_elements_parameter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_elements_parameter() throws -> Type_elements_parameterContext {
		var _localctx: Type_elements_parameterContext = Type_elements_parameterContext(_ctx, getState())
		try enterRule(_localctx, 160, plsqlParser.RULE_type_elements_parameter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1861)
		 	try parameter_name()
		 	setState(1862)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_sequenceContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.DROP, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.SEQUENCE, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_sequence() throws -> Drop_sequenceContext {
		var _localctx: Drop_sequenceContext = Drop_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 162, plsqlParser.RULE_drop_sequence)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1864)
		 	try match(plsqlParser.DROP)
		 	setState(1865)
		 	try match(plsqlParser.SEQUENCE)
		 	setState(1866)
		 	try sequence_name()
		 	setState(1867)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_sequenceContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.SEQUENCE, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open func sequence_spec() -> Array<Sequence_specContext> {
			return getRuleContexts(Sequence_specContext.self)
		}
		open func sequence_spec(_ i: Int) -> Sequence_specContext? {
			return getRuleContext(Sequence_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_sequence() throws -> Alter_sequenceContext {
		var _localctx: Alter_sequenceContext = Alter_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 164, plsqlParser.RULE_alter_sequence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1869)
		 	try match(plsqlParser.ALTER)
		 	setState(1870)
		 	try match(plsqlParser.SEQUENCE)
		 	setState(1871)
		 	try sequence_name()
		 	setState(1873) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1872)
		 		try sequence_spec()


		 		setState(1875); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CACHE || _la == plsqlParser.CYCLE
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.INCREMENT,plsqlParser.MAXVALUE,plsqlParser.MINVALUE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 167)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.NOCACHE,plsqlParser.NOCYCLE,plsqlParser.NOMAXVALUE,plsqlParser.NOMINVALUE,plsqlParser.NOORDER,plsqlParser.ORDER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 240)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(1877)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_sequenceContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.SEQUENCE, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open func sequence_start_clause() -> Array<Sequence_start_clauseContext> {
			return getRuleContexts(Sequence_start_clauseContext.self)
		}
		open func sequence_start_clause(_ i: Int) -> Sequence_start_clauseContext? {
			return getRuleContext(Sequence_start_clauseContext.self,i)
		}
		open func sequence_spec() -> Array<Sequence_specContext> {
			return getRuleContexts(Sequence_specContext.self)
		}
		open func sequence_spec(_ i: Int) -> Sequence_specContext? {
			return getRuleContext(Sequence_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_sequence() throws -> Create_sequenceContext {
		var _localctx: Create_sequenceContext = Create_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 166, plsqlParser.RULE_create_sequence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1879)
		 	try match(plsqlParser.CREATE)
		 	setState(1880)
		 	try match(plsqlParser.SEQUENCE)
		 	setState(1881)
		 	try sequence_name()
		 	setState(1886)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CACHE || _la == plsqlParser.CYCLE
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.INCREMENT,plsqlParser.MAXVALUE,plsqlParser.MINVALUE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 167)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.NOCACHE,plsqlParser.NOCYCLE,plsqlParser.NOMAXVALUE,plsqlParser.NOMINVALUE,plsqlParser.NOORDER,plsqlParser.ORDER]
		 	              return  Utils.testBitLeftShiftArray(testArray, 240)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.START
		 	      return testSet
		 	 }()) {
		 		setState(1884)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.START:
		 			setState(1882)
		 			try sequence_start_clause()

		 			break
		 		case plsqlParser.CACHE:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.NOCACHE:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOMAXVALUE:fallthrough
		 		case plsqlParser.NOMINVALUE:fallthrough
		 		case plsqlParser.NOORDER:fallthrough
		 		case plsqlParser.ORDER:
		 			setState(1883)
		 			try sequence_spec()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1888)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1889)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_specContext:ParserRuleContext {
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.INCREMENT, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.UNSIGNED_INTEGER, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.MAXVALUE, 0) }
		open func NOMAXVALUE() -> TerminalNode? { return getToken(plsqlParser.NOMAXVALUE, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.MINVALUE, 0) }
		open func NOMINVALUE() -> TerminalNode? { return getToken(plsqlParser.NOMINVALUE, 0) }
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.CYCLE, 0) }
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.NOCYCLE, 0) }
		open func CACHE() -> TerminalNode? { return getToken(plsqlParser.CACHE, 0) }
		open func NOCACHE() -> TerminalNode? { return getToken(plsqlParser.NOCACHE, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open func NOORDER() -> TerminalNode? { return getToken(plsqlParser.NOORDER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_spec() throws -> Sequence_specContext {
		var _localctx: Sequence_specContext = Sequence_specContext(_ctx, getState())
		try enterRule(_localctx, 168, plsqlParser.RULE_sequence_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1907)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INCREMENT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1891)
		 		try match(plsqlParser.INCREMENT)
		 		setState(1892)
		 		try match(plsqlParser.BY)
		 		setState(1893)
		 		try match(plsqlParser.UNSIGNED_INTEGER)

		 		break

		 	case plsqlParser.MAXVALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1894)
		 		try match(plsqlParser.MAXVALUE)
		 		setState(1895)
		 		try match(plsqlParser.UNSIGNED_INTEGER)

		 		break

		 	case plsqlParser.NOMAXVALUE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1896)
		 		try match(plsqlParser.NOMAXVALUE)

		 		break

		 	case plsqlParser.MINVALUE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1897)
		 		try match(plsqlParser.MINVALUE)
		 		setState(1898)
		 		try match(plsqlParser.UNSIGNED_INTEGER)

		 		break

		 	case plsqlParser.NOMINVALUE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1899)
		 		try match(plsqlParser.NOMINVALUE)

		 		break

		 	case plsqlParser.CYCLE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1900)
		 		try match(plsqlParser.CYCLE)

		 		break

		 	case plsqlParser.NOCYCLE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1901)
		 		try match(plsqlParser.NOCYCLE)

		 		break

		 	case plsqlParser.CACHE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1902)
		 		try match(plsqlParser.CACHE)
		 		setState(1903)
		 		try match(plsqlParser.UNSIGNED_INTEGER)

		 		break

		 	case plsqlParser.NOCACHE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1904)
		 		try match(plsqlParser.NOCACHE)

		 		break

		 	case plsqlParser.ORDER:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1905)
		 		try match(plsqlParser.ORDER)

		 		break

		 	case plsqlParser.NOORDER:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1906)
		 		try match(plsqlParser.NOORDER)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_start_clauseContext:ParserRuleContext {
		open func START() -> TerminalNode? { return getToken(plsqlParser.START, 0) }
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.UNSIGNED_INTEGER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_start_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_start_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_start_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_start_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_start_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_start_clause() throws -> Sequence_start_clauseContext {
		var _localctx: Sequence_start_clauseContext = Sequence_start_clauseContext(_ctx, getState())
		try enterRule(_localctx, 170, plsqlParser.RULE_sequence_start_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1909)
		 	try match(plsqlParser.START)
		 	setState(1910)
		 	try match(plsqlParser.WITH)
		 	setState(1911)
		 	try match(plsqlParser.UNSIGNED_INTEGER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Invoker_rights_clauseContext:ParserRuleContext {
		open func AUTHID() -> TerminalNode? { return getToken(plsqlParser.AUTHID, 0) }
		open func CURRENT_USER() -> TerminalNode? { return getToken(plsqlParser.CURRENT_USER, 0) }
		open func DEFINER() -> TerminalNode? { return getToken(plsqlParser.DEFINER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_invoker_rights_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInvoker_rights_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInvoker_rights_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInvoker_rights_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInvoker_rights_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func invoker_rights_clause() throws -> Invoker_rights_clauseContext {
		var _localctx: Invoker_rights_clauseContext = Invoker_rights_clauseContext(_ctx, getState())
		try enterRule(_localctx, 172, plsqlParser.RULE_invoker_rights_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1913)
		 	try match(plsqlParser.AUTHID)
		 	setState(1914)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.CURRENT_USER || _la == plsqlParser.DEFINER
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compiler_parameters_clauseContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compiler_parameters_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompiler_parameters_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompiler_parameters_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompiler_parameters_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompiler_parameters_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compiler_parameters_clause() throws -> Compiler_parameters_clauseContext {
		var _localctx: Compiler_parameters_clauseContext = Compiler_parameters_clauseContext(_ctx, getState())
		try enterRule(_localctx, 174, plsqlParser.RULE_compiler_parameters_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1916)
		 	try id()
		 	setState(1917)
		 	try match(plsqlParser.EQUALS_OP)
		 	setState(1918)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Call_specContext:ParserRuleContext {
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.LANGUAGE, 0) }
		open func java_spec() -> Java_specContext? {
			return getRuleContext(Java_specContext.self,0)
		}
		open func c_spec() -> C_specContext? {
			return getRuleContext(C_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_call_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCall_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCall_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCall_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCall_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func call_spec() throws -> Call_specContext {
		var _localctx: Call_specContext = Call_specContext(_ctx, getState())
		try enterRule(_localctx, 176, plsqlParser.RULE_call_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1920)
		 	try match(plsqlParser.LANGUAGE)
		 	setState(1923)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.JAVA:
		 		setState(1921)
		 		try java_spec()

		 		break

		 	case plsqlParser.C_LETTER:
		 		setState(1922)
		 		try c_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Java_specContext:ParserRuleContext {
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.JAVA, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.CHAR_STRING, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_java_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJava_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJava_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJava_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJava_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func java_spec() throws -> Java_specContext {
		var _localctx: Java_specContext = Java_specContext(_ctx, getState())
		try enterRule(_localctx, 178, plsqlParser.RULE_java_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1925)
		 	try match(plsqlParser.JAVA)
		 	setState(1926)
		 	try match(plsqlParser.NAME)
		 	setState(1927)
		 	try match(plsqlParser.CHAR_STRING)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_specContext:ParserRuleContext {
		open func C_LETTER() -> TerminalNode? { return getToken(plsqlParser.C_LETTER, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(plsqlParser.LIBRARY, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.CHAR_STRING, 0) }
		open func c_agent_in_clause() -> C_agent_in_clauseContext? {
			return getRuleContext(C_agent_in_clauseContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func CONTEXT() -> TerminalNode? { return getToken(plsqlParser.CONTEXT, 0) }
		open func c_parameters_clause() -> C_parameters_clauseContext? {
			return getRuleContext(C_parameters_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_spec() throws -> C_specContext {
		var _localctx: C_specContext = C_specContext(_ctx, getState())
		try enterRule(_localctx, 180, plsqlParser.RULE_c_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1929)
		 	try match(plsqlParser.C_LETTER)
		 	setState(1932)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NAME
		 	      return testSet
		 	 }()) {
		 		setState(1930)
		 		try match(plsqlParser.NAME)
		 		setState(1931)
		 		try match(plsqlParser.CHAR_STRING)

		 	}

		 	setState(1934)
		 	try match(plsqlParser.LIBRARY)
		 	setState(1935)
		 	try id()
		 	setState(1937)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AGENT
		 	      return testSet
		 	 }()) {
		 		setState(1936)
		 		try c_agent_in_clause()

		 	}

		 	setState(1941)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(1939)
		 		try match(plsqlParser.WITH)
		 		setState(1940)
		 		try match(plsqlParser.CONTEXT)

		 	}

		 	setState(1944)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PARAMETERS
		 	      return testSet
		 	 }()) {
		 		setState(1943)
		 		try c_parameters_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_agent_in_clauseContext:ParserRuleContext {
		open func AGENT() -> TerminalNode? { return getToken(plsqlParser.AGENT, 0) }
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_agent_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_agent_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_agent_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_agent_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_agent_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_agent_in_clause() throws -> C_agent_in_clauseContext {
		var _localctx: C_agent_in_clauseContext = C_agent_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 182, plsqlParser.RULE_c_agent_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1946)
		 	try match(plsqlParser.AGENT)
		 	setState(1947)
		 	try match(plsqlParser.IN)
		 	setState(1948)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1949)
		 	try expression()
		 	setState(1954)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(1950)
		 		try match(plsqlParser.COMMA)
		 		setState(1951)
		 		try expression()


		 		setState(1956)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1957)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_parameters_clauseContext:ParserRuleContext {
		open func PARAMETERS() -> TerminalNode? { return getToken(plsqlParser.PARAMETERS, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_parameters_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_parameters_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_parameters_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_parameters_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_parameters_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_parameters_clause() throws -> C_parameters_clauseContext {
		var _localctx: C_parameters_clauseContext = C_parameters_clauseContext(_ctx, getState())
		try enterRule(_localctx, 184, plsqlParser.RULE_c_parameters_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1959)
		 	try match(plsqlParser.PARAMETERS)
		 	setState(1960)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(1972)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NOT:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(1961)
		 		try expression()
		 		setState(1966)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(1962)
		 			try match(plsqlParser.COMMA)
		 			setState(1963)
		 			try expression()


		 			setState(1968)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case plsqlParser.PERIOD:
		 		setState(1969)
		 		try match(plsqlParser.PERIOD)
		 		setState(1970)
		 		try match(plsqlParser.PERIOD)
		 		setState(1971)
		 		try match(plsqlParser.PERIOD)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1974)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ParameterContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open func IN() -> Array<TerminalNode> { return getTokens(plsqlParser.IN) }
		open func IN(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.IN, i)
		}
		open func OUT() -> Array<TerminalNode> { return getTokens(plsqlParser.OUT) }
		open func OUT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.OUT, i)
		}
		open func INOUT() -> Array<TerminalNode> { return getTokens(plsqlParser.INOUT) }
		open func INOUT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.INOUT, i)
		}
		open func NOCOPY() -> Array<TerminalNode> { return getTokens(plsqlParser.NOCOPY) }
		open func NOCOPY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NOCOPY, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter() throws -> ParameterContext {
		var _localctx: ParameterContext = ParameterContext(_ctx, getState())
		try enterRule(_localctx, 186, plsqlParser.RULE_parameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1976)
		 	try parameter_name()
		 	setState(1980)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,172,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1977)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.IN || _la == plsqlParser.INOUT
		 			          testSet = testSet || _la == plsqlParser.NOCOPY || _la == plsqlParser.OUT
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 	 
		 		}
		 		setState(1982)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,172,_ctx)
		 	}
		 	setState(1984)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(1983)
		 		try type_spec()

		 	}

		 	setState(1987)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DEFAULT
		 	          testSet = testSet || _la == plsqlParser.ASSIGN_OP
		 	      return testSet
		 	 }()) {
		 		setState(1986)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Default_value_partContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ASSIGN_OP() -> TerminalNode? { return getToken(plsqlParser.ASSIGN_OP, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_default_value_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDefault_value_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDefault_value_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDefault_value_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDefault_value_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func default_value_part() throws -> Default_value_partContext {
		var _localctx: Default_value_partContext = Default_value_partContext(_ctx, getState())
		try enterRule(_localctx, 188, plsqlParser.RULE_default_value_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1989)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DEFAULT
		 	          testSet = testSet || _la == plsqlParser.ASSIGN_OP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(1990)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_specContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func pragma_declaration() -> Pragma_declarationContext? {
			return getRuleContext(Pragma_declarationContext.self,0)
		}
		open func record_declaration() -> Record_declarationContext? {
			return getRuleContext(Record_declarationContext.self,0)
		}
		open func table_declaration() -> Table_declarationContext? {
			return getRuleContext(Table_declarationContext.self,0)
		}
		open func create_procedure_body() -> Create_procedure_bodyContext? {
			return getRuleContext(Create_procedure_bodyContext.self,0)
		}
		open func create_function_body() -> Create_function_bodyContext? {
			return getRuleContext(Create_function_bodyContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_declare_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDeclare_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDeclare_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDeclare_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDeclare_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_spec() throws -> Declare_specContext {
		var _localctx: Declare_specContext = Declare_specContext(_ctx, getState())
		try enterRule(_localctx, 190, plsqlParser.RULE_declare_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2001)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,175, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1992)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1993)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1994)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1995)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1996)
		 		try pragma_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1997)
		 		try record_declaration()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1998)
		 		try table_declaration()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1999)
		 		try create_procedure_body()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2000)
		 		try create_function_body()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Variable_declarationContext:ParserRuleContext {
		open func variable_name() -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func CONSTANT() -> TerminalNode? { return getToken(plsqlParser.CONSTANT, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_variable_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVariable_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVariable_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVariable_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVariable_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func variable_declaration() throws -> Variable_declarationContext {
		var _localctx: Variable_declarationContext = Variable_declarationContext(_ctx, getState())
		try enterRule(_localctx, 192, plsqlParser.RULE_variable_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2003)
		 	try variable_name()
		 	setState(2005)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,176,_ctx)) {
		 	case 1:
		 		setState(2004)
		 		try match(plsqlParser.CONSTANT)

		 		break
		 	default: break
		 	}
		 	setState(2007)
		 	try type_spec()
		 	setState(2010)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(2008)
		 		try match(plsqlParser.NOT)
		 		setState(2009)
		 		try match(plsqlParser.NULL)

		 	}

		 	setState(2013)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DEFAULT
		 	          testSet = testSet || _la == plsqlParser.ASSIGN_OP
		 	      return testSet
		 	 }()) {
		 		setState(2012)
		 		try default_value_part()

		 	}

		 	setState(2015)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subtype_declarationContext:ParserRuleContext {
		open func SUBTYPE() -> TerminalNode? { return getToken(plsqlParser.SUBTYPE, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.RANGE, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subtype_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubtype_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubtype_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubtype_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubtype_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtype_declaration() throws -> Subtype_declarationContext {
		var _localctx: Subtype_declarationContext = Subtype_declarationContext(_ctx, getState())
		try enterRule(_localctx, 194, plsqlParser.RULE_subtype_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2017)
		 	try match(plsqlParser.SUBTYPE)
		 	setState(2018)
		 	try type_name()
		 	setState(2019)
		 	try match(plsqlParser.IS)
		 	setState(2020)
		 	try type_spec()
		 	setState(2026)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RANGE
		 	      return testSet
		 	 }()) {
		 		setState(2021)
		 		try match(plsqlParser.RANGE)
		 		setState(2022)
		 		try expression()
		 		setState(2023)
		 		try match(plsqlParser.T__0)
		 		setState(2024)
		 		try expression()

		 	}

		 	setState(2030)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(2028)
		 		try match(plsqlParser.NOT)
		 		setState(2029)
		 		try match(plsqlParser.NULL)

		 	}

		 	setState(2032)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_declarationContext:ParserRuleContext {
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.CURSOR, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func parameter_spec() -> Array<Parameter_specContext> {
			return getRuleContexts(Parameter_specContext.self)
		}
		open func parameter_spec(_ i: Int) -> Parameter_specContext? {
			return getRuleContext(Parameter_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_declaration() throws -> Cursor_declarationContext {
		var _localctx: Cursor_declarationContext = Cursor_declarationContext(_ctx, getState())
		try enterRule(_localctx, 196, plsqlParser.RULE_cursor_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2034)
		 	try match(plsqlParser.CURSOR)
		 	setState(2035)
		 	try cursor_name()
		 	setState(2047)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(2036)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2037)
		 		try parameter_spec()
		 		setState(2042)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2038)
		 			try match(plsqlParser.COMMA)
		 			setState(2039)
		 			try parameter_spec()


		 			setState(2044)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2045)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(2051)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN
		 	      return testSet
		 	 }()) {
		 		setState(2049)
		 		try match(plsqlParser.RETURN)
		 		setState(2050)
		 		try type_spec()

		 	}

		 	setState(2055)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.IS
		 	      return testSet
		 	 }()) {
		 		setState(2053)
		 		try match(plsqlParser.IS)
		 		setState(2054)
		 		try select_statement()

		 	}

		 	setState(2057)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parameter_specContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter_spec() throws -> Parameter_specContext {
		var _localctx: Parameter_specContext = Parameter_specContext(_ctx, getState())
		try enterRule(_localctx, 198, plsqlParser.RULE_parameter_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2059)
		 	try parameter_name()
		 	setState(2064)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.IN,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2061)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.IN
		 		      return testSet
		 		 }()) {
		 			setState(2060)
		 			try match(plsqlParser.IN)

		 		}

		 		setState(2063)
		 		try type_spec()

		 	}

		 	setState(2067)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DEFAULT
		 	          testSet = testSet || _la == plsqlParser.ASSIGN_OP
		 	      return testSet
		 	 }()) {
		 		setState(2066)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_declarationContext:ParserRuleContext {
		open func exception_name() -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,0)
		}
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.EXCEPTION, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_declaration() throws -> Exception_declarationContext {
		var _localctx: Exception_declarationContext = Exception_declarationContext(_ctx, getState())
		try enterRule(_localctx, 200, plsqlParser.RULE_exception_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2069)
		 	try exception_name()
		 	setState(2070)
		 	try match(plsqlParser.EXCEPTION)
		 	setState(2071)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_declarationContext:ParserRuleContext {
		public var id1: IdContext!
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.PRAGMA, 0) }
		open func SERIALLY_REUSABLE() -> TerminalNode? { return getToken(plsqlParser.SERIALLY_REUSABLE, 0) }
		open func AUTONOMOUS_TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0) }
		open func EXCEPTION_INIT() -> TerminalNode? { return getToken(plsqlParser.EXCEPTION_INIT, 0) }
		open func exception_name() -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,0)
		}
		open func numeric_negative() -> Numeric_negativeContext? {
			return getRuleContext(Numeric_negativeContext.self,0)
		}
		open func INLINE() -> TerminalNode? { return getToken(plsqlParser.INLINE, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.RESTRICT_REFERENCES, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_declaration() throws -> Pragma_declarationContext {
		var _localctx: Pragma_declarationContext = Pragma_declarationContext(_ctx, getState())
		try enterRule(_localctx, 202, plsqlParser.RULE_pragma_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2073)
		 	try match(plsqlParser.PRAGMA)
		 	setState(2104)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.SERIALLY_REUSABLE:
		 		setState(2074)
		 		try match(plsqlParser.SERIALLY_REUSABLE)

		 		break

		 	case plsqlParser.AUTONOMOUS_TRANSACTION:
		 		setState(2075)
		 		try match(plsqlParser.AUTONOMOUS_TRANSACTION)

		 		break

		 	case plsqlParser.EXCEPTION_INIT:
		 		setState(2076)
		 		try match(plsqlParser.EXCEPTION_INIT)
		 		setState(2077)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2078)
		 		try exception_name()
		 		setState(2079)
		 		try match(plsqlParser.COMMA)
		 		setState(2080)
		 		try numeric_negative()
		 		setState(2081)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break

		 	case plsqlParser.INLINE:
		 		setState(2083)
		 		try match(plsqlParser.INLINE)
		 		setState(2084)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2085)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Pragma_declarationContext.self).id1 = assignmentValue
		 		     }()

		 		setState(2086)
		 		try match(plsqlParser.COMMA)
		 		setState(2087)
		 		try expression()
		 		setState(2088)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break

		 	case plsqlParser.RESTRICT_REFERENCES:
		 		setState(2090)
		 		try match(plsqlParser.RESTRICT_REFERENCES)
		 		setState(2091)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2094)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.A_LETTER:fallthrough
		 		case plsqlParser.ADD:fallthrough
		 		case plsqlParser.AFTER:fallthrough
		 		case plsqlParser.AGENT:fallthrough
		 		case plsqlParser.AGGREGATE:fallthrough
		 		case plsqlParser.ANALYZE:fallthrough
		 		case plsqlParser.ARRAY:fallthrough
		 		case plsqlParser.ASSOCIATE:fallthrough
		 		case plsqlParser.AT:fallthrough
		 		case plsqlParser.ATTRIBUTE:fallthrough
		 		case plsqlParser.AUDIT:fallthrough
		 		case plsqlParser.AUTHID:fallthrough
		 		case plsqlParser.AUTO:fallthrough
		 		case plsqlParser.AUTOMATIC:fallthrough
		 		case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 		case plsqlParser.BATCH:fallthrough
		 		case plsqlParser.BEFORE:fallthrough
		 		case plsqlParser.BFILE:fallthrough
		 		case plsqlParser.BINARY_DOUBLE:fallthrough
		 		case plsqlParser.BINARY_FLOAT:fallthrough
		 		case plsqlParser.BINARY_INTEGER:fallthrough
		 		case plsqlParser.BLOB:fallthrough
		 		case plsqlParser.BLOCK:fallthrough
		 		case plsqlParser.BODY:fallthrough
		 		case plsqlParser.BOOLEAN:fallthrough
		 		case plsqlParser.BOTH:fallthrough
		 		case plsqlParser.BULK:fallthrough
		 		case plsqlParser.BYTE:fallthrough
		 		case plsqlParser.C_LETTER:fallthrough
		 		case plsqlParser.CALL:fallthrough
		 		case plsqlParser.CANONICAL:fallthrough
		 		case plsqlParser.CASCADE:fallthrough
		 		case plsqlParser.CAST:fallthrough
		 		case plsqlParser.CHAR:fallthrough
		 		case plsqlParser.CHAR_CS:fallthrough
		 		case plsqlParser.CHARACTER:fallthrough
		 		case plsqlParser.CHR:fallthrough
		 		case plsqlParser.CLOB:fallthrough
		 		case plsqlParser.CLOSE:fallthrough
		 		case plsqlParser.CLUSTER:fallthrough
		 		case plsqlParser.COLLECT:fallthrough
		 		case plsqlParser.COLUMNS:fallthrough
		 		case plsqlParser.COMMENT:fallthrough
		 		case plsqlParser.COMMIT:fallthrough
		 		case plsqlParser.COMMITTED:fallthrough
		 		case plsqlParser.COMPATIBILITY:fallthrough
		 		case plsqlParser.COMPILE:fallthrough
		 		case plsqlParser.COMPOUND:fallthrough
		 		case plsqlParser.CONSTANT:fallthrough
		 		case plsqlParser.CONSTRAINT:fallthrough
		 		case plsqlParser.CONSTRAINTS:fallthrough
		 		case plsqlParser.CONSTRUCTOR:fallthrough
		 		case plsqlParser.CONTENT:fallthrough
		 		case plsqlParser.CONTEXT:fallthrough
		 		case plsqlParser.CONTINUE:fallthrough
		 		case plsqlParser.CONVERT:fallthrough
		 		case plsqlParser.CORRUPT_XID:fallthrough
		 		case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 		case plsqlParser.COST:fallthrough
		 		case plsqlParser.COUNT:fallthrough
		 		case plsqlParser.CROSS:fallthrough
		 		case plsqlParser.CUBE:fallthrough
		 		case plsqlParser.CURRENT_USER:fallthrough
		 		case plsqlParser.CURSOR:fallthrough
		 		case plsqlParser.CUSTOMDATUM:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.DATA:fallthrough
		 		case plsqlParser.DATABASE:fallthrough
		 		case plsqlParser.DAY:fallthrough
		 		case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DDL:fallthrough
		 		case plsqlParser.DEBUG:fallthrough
		 		case plsqlParser.DEC:fallthrough
		 		case plsqlParser.DECIMAL:fallthrough
		 		case plsqlParser.DECOMPOSE:fallthrough
		 		case plsqlParser.DECREMENT:fallthrough
		 		case plsqlParser.DEFAULTS:fallthrough
		 		case plsqlParser.DEFERRED:fallthrough
		 		case plsqlParser.DEFINER:fallthrough
		 		case plsqlParser.DETERMINISTIC:fallthrough
		 		case plsqlParser.DIMENSION:fallthrough
		 		case plsqlParser.DISABLE:fallthrough
		 		case plsqlParser.DISASSOCIATE:fallthrough
		 		case plsqlParser.DOCUMENT:fallthrough
		 		case plsqlParser.DOUBLE:fallthrough
		 		case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.EACH:fallthrough
		 		case plsqlParser.ELEMENT:fallthrough
		 		case plsqlParser.EMPTY:fallthrough
		 		case plsqlParser.ENABLE:fallthrough
		 		case plsqlParser.ENCODING:fallthrough
		 		case plsqlParser.ENTITYESCAPING:fallthrough
		 		case plsqlParser.ERR:fallthrough
		 		case plsqlParser.ERRORS:fallthrough
		 		case plsqlParser.ESCAPE:fallthrough
		 		case plsqlParser.EVALNAME:fallthrough
		 		case plsqlParser.EXCEPTION:fallthrough
		 		case plsqlParser.EXCEPTION_INIT:fallthrough
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.EXCLUDE:fallthrough
		 		case plsqlParser.EXECUTE:fallthrough
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.EXTERNAL:fallthrough
		 		case plsqlParser.EXTRACT:fallthrough
		 		case plsqlParser.FAILURE:fallthrough
		 		case plsqlParser.FINAL:fallthrough
		 		case plsqlParser.FIRST:fallthrough
		 		case plsqlParser.FIRST_VALUE:fallthrough
		 		case plsqlParser.FLOAT:fallthrough
		 		case plsqlParser.FOLLOWING:fallthrough
		 		case plsqlParser.FOLLOWS:fallthrough
		 		case plsqlParser.FORALL:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.FULL:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.GROUPING:fallthrough
		 		case plsqlParser.HASH:fallthrough
		 		case plsqlParser.HIDE:fallthrough
		 		case plsqlParser.HOUR:fallthrough
		 		case plsqlParser.IGNORE:fallthrough
		 		case plsqlParser.IMMEDIATE:fallthrough
		 		case plsqlParser.INCLUDE:fallthrough
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.INDENT:fallthrough
		 		case plsqlParser.INDEXED:fallthrough
		 		case plsqlParser.INDICATOR:fallthrough
		 		case plsqlParser.INDICES:fallthrough
		 		case plsqlParser.INFINITE:fallthrough
		 		case plsqlParser.INLINE:fallthrough
		 		case plsqlParser.INNER:fallthrough
		 		case plsqlParser.INOUT:fallthrough
		 		case plsqlParser.INSTANTIABLE:fallthrough
		 		case plsqlParser.INSTEAD:fallthrough
		 		case plsqlParser.INT:fallthrough
		 		case plsqlParser.INTEGER:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.INVALIDATE:fallthrough
		 		case plsqlParser.ISOLATION:fallthrough
		 		case plsqlParser.ITERATE:fallthrough
		 		case plsqlParser.JAVA:fallthrough
		 		case plsqlParser.JOIN:fallthrough
		 		case plsqlParser.KEEP:fallthrough
		 		case plsqlParser.LANGUAGE:fallthrough
		 		case plsqlParser.LAST:fallthrough
		 		case plsqlParser.LAST_VALUE:fallthrough
		 		case plsqlParser.LEADING:fallthrough
		 		case plsqlParser.LEFT:fallthrough
		 		case plsqlParser.LEVEL:fallthrough
		 		case plsqlParser.LIBRARY:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:fallthrough
		 		case plsqlParser.LIMIT:fallthrough
		 		case plsqlParser.LOCAL:fallthrough
		 		case plsqlParser.LOCKED:fallthrough
		 		case plsqlParser.LOG:fallthrough
		 		case plsqlParser.LOGOFF:fallthrough
		 		case plsqlParser.LOGON:fallthrough
		 		case plsqlParser.LONG:fallthrough
		 		case plsqlParser.LOOP:fallthrough
		 		case plsqlParser.MAIN:fallthrough
		 		case plsqlParser.MAP:fallthrough
		 		case plsqlParser.MATCHED:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MEASURES:fallthrough
		 		case plsqlParser.MEMBER:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.MINUTE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.MLSLABEL:fallthrough
		 		case plsqlParser.MODEL:fallthrough
		 		case plsqlParser.MODIFY:fallthrough
		 		case plsqlParser.MONTH:fallthrough
		 		case plsqlParser.MULTISET:fallthrough
		 		case plsqlParser.NAME:fallthrough
		 		case plsqlParser.NAN:fallthrough
		 		case plsqlParser.NATURAL:fallthrough
		 		case plsqlParser.NATURALN:fallthrough
		 		case plsqlParser.NAV:fallthrough
		 		case plsqlParser.NCHAR:fallthrough
		 		case plsqlParser.NCHAR_CS:fallthrough
		 		case plsqlParser.NCLOB:fallthrough
		 		case plsqlParser.NESTED:fallthrough
		 		case plsqlParser.NEW:fallthrough
		 		case plsqlParser.NO:fallthrough
		 		case plsqlParser.NOAUDIT:fallthrough
		 		case plsqlParser.NOCOPY:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOENTITYESCAPING:fallthrough
		 		case plsqlParser.NONE:fallthrough
		 		case plsqlParser.NOSCHEMACHECK:fallthrough
		 		case plsqlParser.NULLS:fallthrough
		 		case plsqlParser.NUMBER:fallthrough
		 		case plsqlParser.NUMERIC:fallthrough
		 		case plsqlParser.NVARCHAR2:fallthrough
		 		case plsqlParser.OBJECT:fallthrough
		 		case plsqlParser.OFF:fallthrough
		 		case plsqlParser.OID:fallthrough
		 		case plsqlParser.OLD:fallthrough
		 		case plsqlParser.ONLY:fallthrough
		 		case plsqlParser.OPEN:fallthrough
		 		case plsqlParser.ORADATA:fallthrough
		 		case plsqlParser.ORDINALITY:fallthrough
		 		case plsqlParser.OSERROR:fallthrough
		 		case plsqlParser.OUT:fallthrough
		 		case plsqlParser.OUTER:fallthrough
		 		case plsqlParser.OVER:fallthrough
		 		case plsqlParser.OVERRIDING:fallthrough
		 		case plsqlParser.PACKAGE:fallthrough
		 		case plsqlParser.PARALLEL_ENABLE:fallthrough
		 		case plsqlParser.PARAMETERS:fallthrough
		 		case plsqlParser.PARENT:fallthrough
		 		case plsqlParser.PARTITION:fallthrough
		 		case plsqlParser.PASSING:fallthrough
		 		case plsqlParser.PATH:fallthrough
		 		case plsqlParser.PIPELINED:fallthrough
		 		case plsqlParser.PLAN:fallthrough
		 		case plsqlParser.PLS_INTEGER:fallthrough
		 		case plsqlParser.POSITIVE:fallthrough
		 		case plsqlParser.POSITIVEN:fallthrough
		 		case plsqlParser.PRAGMA:fallthrough
		 		case plsqlParser.PRECEDING:fallthrough
		 		case plsqlParser.PRECISION:fallthrough
		 		case plsqlParser.PRESENT:fallthrough
		 		case plsqlParser.RAISE:fallthrough
		 		case plsqlParser.RANGE:fallthrough
		 		case plsqlParser.RAW:fallthrough
		 		case plsqlParser.READ:fallthrough
		 		case plsqlParser.REAL:fallthrough
		 		case plsqlParser.RECORD:fallthrough
		 		case plsqlParser.REF:fallthrough
		 		case plsqlParser.REFERENCE:fallthrough
		 		case plsqlParser.REFERENCING:fallthrough
		 		case plsqlParser.REJECT:fallthrough
		 		case plsqlParser.RELIES_ON:fallthrough
		 		case plsqlParser.RENAME:fallthrough
		 		case plsqlParser.REPLACE:fallthrough
		 		case plsqlParser.RESPECT:fallthrough
		 		case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 		case plsqlParser.RESULT:fallthrough
		 		case plsqlParser.RESULT_CACHE:fallthrough
		 		case plsqlParser.RETURN:fallthrough
		 		case plsqlParser.RETURNING:fallthrough
		 		case plsqlParser.REUSE:fallthrough
		 		case plsqlParser.REVERSE:fallthrough
		 		case plsqlParser.RIGHT:fallthrough
		 		case plsqlParser.ROLLBACK:fallthrough
		 		case plsqlParser.ROLLUP:fallthrough
		 		case plsqlParser.ROW:fallthrough
		 		case plsqlParser.ROWID:fallthrough
		 		case plsqlParser.ROWS:fallthrough
		 		case plsqlParser.RULES:fallthrough
		 		case plsqlParser.SAMPLE:fallthrough
		 		case plsqlParser.SAVE:fallthrough
		 		case plsqlParser.SAVEPOINT:fallthrough
		 		case plsqlParser.SCHEMA:fallthrough
		 		case plsqlParser.SCHEMACHECK:fallthrough
		 		case plsqlParser.SCN:fallthrough
		 		case plsqlParser.SECOND:fallthrough
		 		case plsqlParser.SEED:fallthrough
		 		case plsqlParser.SEGMENT:fallthrough
		 		case plsqlParser.SELF:fallthrough
		 		case plsqlParser.SEQUENTIAL:fallthrough
		 		case plsqlParser.SERIALIZABLE:fallthrough
		 		case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 		case plsqlParser.SERVERERROR:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SETS:fallthrough
		 		case plsqlParser.SETTINGS:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.SHUTDOWN:fallthrough
		 		case plsqlParser.SIBLINGS:fallthrough
		 		case plsqlParser.SIGNTYPE:fallthrough
		 		case plsqlParser.SIMPLE_INTEGER:fallthrough
		 		case plsqlParser.SINGLE:fallthrough
		 		case plsqlParser.SKIP_:fallthrough
		 		case plsqlParser.SMALLINT:fallthrough
		 		case plsqlParser.SNAPSHOT:fallthrough
		 		case plsqlParser.SOME:fallthrough
		 		case plsqlParser.SPECIFICATION:fallthrough
		 		case plsqlParser.SQLDATA:fallthrough
		 		case plsqlParser.SQLERROR:fallthrough
		 		case plsqlParser.STANDALONE:fallthrough
		 		case plsqlParser.STARTUP:fallthrough
		 		case plsqlParser.STATEMENT:fallthrough
		 		case plsqlParser.STATEMENT_ID:fallthrough
		 		case plsqlParser.STATIC:fallthrough
		 		case plsqlParser.STATISTICS:fallthrough
		 		case plsqlParser.STRING:fallthrough
		 		case plsqlParser.SUBMULTISET:fallthrough
		 		case plsqlParser.SUBPARTITION:fallthrough
		 		case plsqlParser.SUBSTITUTABLE:fallthrough
		 		case plsqlParser.SUBTYPE:fallthrough
		 		case plsqlParser.SUCCESS:fallthrough
		 		case plsqlParser.SUSPEND:fallthrough
		 		case plsqlParser.TIME:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMEZONE_ABBR:fallthrough
		 		case plsqlParser.TIMEZONE_HOUR:fallthrough
		 		case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 		case plsqlParser.TIMEZONE_REGION:fallthrough
		 		case plsqlParser.TRAILING:fallthrough
		 		case plsqlParser.TRANSACTION:fallthrough
		 		case plsqlParser.TRANSLATE:fallthrough
		 		case plsqlParser.TREAT:fallthrough
		 		case plsqlParser.TRIGGER:fallthrough
		 		case plsqlParser.TRIM:fallthrough
		 		case plsqlParser.TRUNCATE:fallthrough
		 		case plsqlParser.TYPE:fallthrough
		 		case plsqlParser.UNBOUNDED:fallthrough
		 		case plsqlParser.UNDER:fallthrough
		 		case plsqlParser.UNLIMITED:fallthrough
		 		case plsqlParser.UNTIL:fallthrough
		 		case plsqlParser.UPDATED:fallthrough
		 		case plsqlParser.UPSERT:fallthrough
		 		case plsqlParser.UROWID:fallthrough
		 		case plsqlParser.USE:fallthrough
		 		case plsqlParser.VALIDATE:fallthrough
		 		case plsqlParser.VALUE:fallthrough
		 		case plsqlParser.VARCHAR:fallthrough
		 		case plsqlParser.VARCHAR2:fallthrough
		 		case plsqlParser.VARIABLE:fallthrough
		 		case plsqlParser.VARRAY:fallthrough
		 		case plsqlParser.VARYING:fallthrough
		 		case plsqlParser.VERSION:fallthrough
		 		case plsqlParser.VERSIONS:fallthrough
		 		case plsqlParser.WAIT:fallthrough
		 		case plsqlParser.WARNING:fallthrough
		 		case plsqlParser.WELLFORMED:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.WHILE:fallthrough
		 		case plsqlParser.WITHIN:fallthrough
		 		case plsqlParser.WORK:fallthrough
		 		case plsqlParser.WRITE:fallthrough
		 		case plsqlParser.XML:fallthrough
		 		case plsqlParser.XMLAGG:fallthrough
		 		case plsqlParser.XMLATTRIBUTES:fallthrough
		 		case plsqlParser.XMLCAST:fallthrough
		 		case plsqlParser.XMLCOLATTVAL:fallthrough
		 		case plsqlParser.XMLELEMENT:fallthrough
		 		case plsqlParser.XMLEXISTS:fallthrough
		 		case plsqlParser.XMLFOREST:fallthrough
		 		case plsqlParser.XMLNAMESPACES:fallthrough
		 		case plsqlParser.XMLPARSE:fallthrough
		 		case plsqlParser.XMLPI:fallthrough
		 		case plsqlParser.XMLQUERY:fallthrough
		 		case plsqlParser.XMLROOT:fallthrough
		 		case plsqlParser.XMLSERIALIZE:fallthrough
		 		case plsqlParser.XMLTABLE:fallthrough
		 		case plsqlParser.YEAR:fallthrough
		 		case plsqlParser.YES:fallthrough
		 		case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.ZONE:fallthrough
		 		case plsqlParser.PREDICTION:fallthrough
		 		case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 		case plsqlParser.PREDICTION_COST:fallthrough
		 		case plsqlParser.PREDICTION_DETAILS:fallthrough
		 		case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 		case plsqlParser.PREDICTION_SET:fallthrough
		 		case plsqlParser.CUME_DIST:fallthrough
		 		case plsqlParser.DENSE_RANK:fallthrough
		 		case plsqlParser.LISTAGG:fallthrough
		 		case plsqlParser.PERCENT_RANK:fallthrough
		 		case plsqlParser.PERCENTILE_CONT:fallthrough
		 		case plsqlParser.PERCENTILE_DISC:fallthrough
		 		case plsqlParser.RANK:fallthrough
		 		case plsqlParser.AVG:fallthrough
		 		case plsqlParser.CORR:fallthrough
		 		case plsqlParser.LAG:fallthrough
		 		case plsqlParser.LEAD:fallthrough
		 		case plsqlParser.MAX:fallthrough
		 		case plsqlParser.MEDIAN:fallthrough
		 		case plsqlParser.MIN:fallthrough
		 		case plsqlParser.NTILE:fallthrough
		 		case plsqlParser.RATIO_TO_REPORT:fallthrough
		 		case plsqlParser.ROW_NUMBER:fallthrough
		 		case plsqlParser.SUM:fallthrough
		 		case plsqlParser.VARIANCE:fallthrough
		 		case plsqlParser.REGR_:fallthrough
		 		case plsqlParser.STDDEV:fallthrough
		 		case plsqlParser.VAR_:fallthrough
		 		case plsqlParser.COVAR_:fallthrough
		 		case plsqlParser.DELIMITED_ID:fallthrough
		 		case plsqlParser.INTRODUCER:fallthrough
		 		case plsqlParser.REGULAR_ID:
		 			setState(2092)
		 			try id()

		 			break

		 		case plsqlParser.DEFAULT:
		 			setState(2093)
		 			try match(plsqlParser.DEFAULT)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2098) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2096)
		 			try match(plsqlParser.COMMA)
		 			setState(2097)
		 			try id()


		 			setState(2100); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }())
		 		setState(2102)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2106)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_declarationContext:ParserRuleContext {
		open func record_type_dec() -> Record_type_decContext? {
			return getRuleContext(Record_type_decContext.self,0)
		}
		open func record_var_dec() -> Record_var_decContext? {
			return getRuleContext(Record_var_decContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_declaration() throws -> Record_declarationContext {
		var _localctx: Record_declarationContext = Record_declarationContext(_ctx, getState())
		try enterRule(_localctx, 204, plsqlParser.RULE_record_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2110)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,191, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2108)
		 		try record_type_dec()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2109)
		 		try record_var_dec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_type_decContext:ParserRuleContext {
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func RECORD() -> TerminalNode? { return getToken(plsqlParser.RECORD, 0) }
		open func field_spec() -> Array<Field_specContext> {
			return getRuleContexts(Field_specContext.self)
		}
		open func field_spec(_ i: Int) -> Field_specContext? {
			return getRuleContext(Field_specContext.self,i)
		}
		open func REF() -> TerminalNode? { return getToken(plsqlParser.REF, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.CURSOR, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_type_dec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_type_dec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_type_dec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_type_dec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_type_dec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_type_dec() throws -> Record_type_decContext {
		var _localctx: Record_type_decContext = Record_type_decContext(_ctx, getState())
		try enterRule(_localctx, 206, plsqlParser.RULE_record_type_dec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2112)
		 	try match(plsqlParser.TYPE)
		 	setState(2113)
		 	try type_name()
		 	setState(2114)
		 	try match(plsqlParser.IS)
		 	setState(2133)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.RECORD:
		 		setState(2115)
		 		try match(plsqlParser.RECORD)
		 		setState(2116)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2117)
		 		try field_spec()
		 		setState(2122)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2118)
		 			try match(plsqlParser.COMMA)
		 			setState(2119)
		 			try field_spec()


		 			setState(2124)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2125)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break

		 	case plsqlParser.REF:
		 		setState(2127)
		 		try match(plsqlParser.REF)
		 		setState(2128)
		 		try match(plsqlParser.CURSOR)
		 		setState(2131)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.RETURN
		 		      return testSet
		 		 }()) {
		 			setState(2129)
		 			try match(plsqlParser.RETURN)
		 			setState(2130)
		 			try type_spec()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2135)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Field_specContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_field_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterField_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitField_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitField_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitField_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func field_spec() throws -> Field_specContext {
		var _localctx: Field_specContext = Field_specContext(_ctx, getState())
		try enterRule(_localctx, 208, plsqlParser.RULE_field_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2137)
		 	try column_name()
		 	setState(2139)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2138)
		 		try type_spec()

		 	}

		 	setState(2143)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NOT
		 	      return testSet
		 	 }()) {
		 		setState(2141)
		 		try match(plsqlParser.NOT)
		 		setState(2142)
		 		try match(plsqlParser.NULL)

		 	}

		 	setState(2146)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DEFAULT
		 	          testSet = testSet || _la == plsqlParser.ASSIGN_OP
		 	      return testSet
		 	 }()) {
		 		setState(2145)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_var_decContext:ParserRuleContext {
		open func record_name() -> Record_nameContext? {
			return getRuleContext(Record_nameContext.self,0)
		}
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func PERCENT_ROWTYPE() -> TerminalNode? { return getToken(plsqlParser.PERCENT_ROWTYPE, 0) }
		open func PERCENT_TYPE() -> TerminalNode? { return getToken(plsqlParser.PERCENT_TYPE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_var_dec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_var_dec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_var_dec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_var_dec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_var_dec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_var_dec() throws -> Record_var_decContext {
		var _localctx: Record_var_decContext = Record_var_decContext(_ctx, getState())
		try enterRule(_localctx, 210, plsqlParser.RULE_record_var_dec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2148)
		 	try record_name()
		 	setState(2149)
		 	try type_name()
		 	setState(2150)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERCENT_ROWTYPE || _la == plsqlParser.PERCENT_TYPE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2151)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_declarationContext:ParserRuleContext {
		open func table_type_dec() -> Table_type_decContext? {
			return getRuleContext(Table_type_decContext.self,0)
		}
		open func table_var_dec() -> Table_var_decContext? {
			return getRuleContext(Table_var_decContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_declaration() throws -> Table_declarationContext {
		var _localctx: Table_declarationContext = Table_declarationContext(_ctx, getState())
		try enterRule(_localctx, 212, plsqlParser.RULE_table_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2155)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,198, _ctx)) {
		 	case 1:
		 		setState(2153)
		 		try table_type_dec()

		 		break
		 	case 2:
		 		setState(2154)
		 		try table_var_dec()

		 		break
		 	default: break
		 	}
		 	setState(2157)
		 	try match(plsqlParser.SEMICOLON)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_type_decContext:ParserRuleContext {
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.IS, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func varray_type_def() -> Varray_type_defContext? {
			return getRuleContext(Varray_type_defContext.self,0)
		}
		open func table_indexed_by_part() -> Table_indexed_by_partContext? {
			return getRuleContext(Table_indexed_by_partContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_type_dec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_type_dec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_type_dec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_type_dec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_type_dec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_type_dec() throws -> Table_type_decContext {
		var _localctx: Table_type_decContext = Table_type_decContext(_ctx, getState())
		try enterRule(_localctx, 214, plsqlParser.RULE_table_type_dec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2159)
		 	try match(plsqlParser.TYPE)
		 	setState(2160)
		 	try type_name()
		 	setState(2161)
		 	try match(plsqlParser.IS)
		 	setState(2173)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.TABLE:
		 		setState(2162)
		 		try match(plsqlParser.TABLE)
		 		setState(2163)
		 		try match(plsqlParser.OF)
		 		setState(2164)
		 		try type_spec()
		 		setState(2166)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.INDEX || _la == plsqlParser.INDEXED
		 		      return testSet
		 		 }()) {
		 			setState(2165)
		 			try table_indexed_by_part()

		 		}

		 		setState(2170)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.NOT
		 		      return testSet
		 		 }()) {
		 			setState(2168)
		 			try match(plsqlParser.NOT)
		 			setState(2169)
		 			try match(plsqlParser.NULL)

		 		}


		 		break
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:
		 		setState(2172)
		 		try varray_type_def()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_indexed_by_partContext:ParserRuleContext {
		public var idx1: Token!
		public var idx2: Token!
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func INDEXED() -> TerminalNode? { return getToken(plsqlParser.INDEXED, 0) }
		open func INDEX() -> TerminalNode? { return getToken(plsqlParser.INDEX, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_indexed_by_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_indexed_by_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_indexed_by_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_indexed_by_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_indexed_by_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_indexed_by_part() throws -> Table_indexed_by_partContext {
		var _localctx: Table_indexed_by_partContext = Table_indexed_by_partContext(_ctx, getState())
		try enterRule(_localctx, 216, plsqlParser.RULE_table_indexed_by_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2177)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INDEXED:
		 		setState(2175)
		 		try {
		 				let assignmentValue = try match(plsqlParser.INDEXED)
		 				_localctx.castdown(Table_indexed_by_partContext.self).idx1 = assignmentValue
		 		     }()


		 		break

		 	case plsqlParser.INDEX:
		 		setState(2176)
		 		try {
		 				let assignmentValue = try match(plsqlParser.INDEX)
		 				_localctx.castdown(Table_indexed_by_partContext.self).idx2 = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2179)
		 	try match(plsqlParser.BY)
		 	setState(2180)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Varray_type_defContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func VARRAY() -> TerminalNode? { return getToken(plsqlParser.VARRAY, 0) }
		open func VARYING() -> TerminalNode? { return getToken(plsqlParser.VARYING, 0) }
		open func ARRAY() -> TerminalNode? { return getToken(plsqlParser.ARRAY, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_varray_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVarray_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVarray_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVarray_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVarray_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func varray_type_def() throws -> Varray_type_defContext {
		var _localctx: Varray_type_defContext = Varray_type_defContext(_ctx, getState())
		try enterRule(_localctx, 218, plsqlParser.RULE_varray_type_def)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2185)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.VARRAY:
		 		setState(2182)
		 		try match(plsqlParser.VARRAY)

		 		break

		 	case plsqlParser.VARYING:
		 		setState(2183)
		 		try match(plsqlParser.VARYING)
		 		setState(2184)
		 		try match(plsqlParser.ARRAY)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2187)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2188)
		 	try expression()
		 	setState(2189)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(2190)
		 	try match(plsqlParser.OF)
		 	setState(2191)
		 	try type_spec()
		 	setState(2194)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,204,_ctx)) {
		 	case 1:
		 		setState(2192)
		 		try match(plsqlParser.NOT)
		 		setState(2193)
		 		try match(plsqlParser.NULL)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_var_decContext:ParserRuleContext {
		open func table_var_name() -> Table_var_nameContext? {
			return getRuleContext(Table_var_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_var_dec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_var_dec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_var_dec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_var_dec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_var_dec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_var_dec() throws -> Table_var_decContext {
		var _localctx: Table_var_decContext = Table_var_decContext(_ctx, getState())
		try enterRule(_localctx, 220, plsqlParser.RULE_table_var_dec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2196)
		 	try table_var_name()
		 	setState(2197)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Seq_of_statementsContext:ParserRuleContext {
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open func label_declaration() -> Array<Label_declarationContext> {
			return getRuleContexts(Label_declarationContext.self)
		}
		open func label_declaration(_ i: Int) -> Label_declarationContext? {
			return getRuleContext(Label_declarationContext.self,i)
		}
		open func EOF() -> Array<TerminalNode> { return getTokens(plsqlParser.EOF) }
		open func EOF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.EOF, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_seq_of_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSeq_of_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSeq_of_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSeq_of_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSeq_of_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func seq_of_statements() throws -> Seq_of_statementsContext {
		var _localctx: Seq_of_statementsContext = Seq_of_statementsContext(_ctx, getState())
		try enterRule(_localctx, 222, plsqlParser.RULE_seq_of_statements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2203); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(2203)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.A_LETTER:fallthrough
		 			case plsqlParser.ADD:fallthrough
		 			case plsqlParser.AFTER:fallthrough
		 			case plsqlParser.AGENT:fallthrough
		 			case plsqlParser.AGGREGATE:fallthrough
		 			case plsqlParser.ALTER:fallthrough
		 			case plsqlParser.ANALYZE:fallthrough
		 			case plsqlParser.ARRAY:fallthrough
		 			case plsqlParser.ASSOCIATE:fallthrough
		 			case plsqlParser.AT:fallthrough
		 			case plsqlParser.ATTRIBUTE:fallthrough
		 			case plsqlParser.AUDIT:fallthrough
		 			case plsqlParser.AUTHID:fallthrough
		 			case plsqlParser.AUTO:fallthrough
		 			case plsqlParser.AUTOMATIC:fallthrough
		 			case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 			case plsqlParser.BATCH:fallthrough
		 			case plsqlParser.BEFORE:fallthrough
		 			case plsqlParser.BEGIN:fallthrough
		 			case plsqlParser.BFILE:fallthrough
		 			case plsqlParser.BINARY_DOUBLE:fallthrough
		 			case plsqlParser.BINARY_FLOAT:fallthrough
		 			case plsqlParser.BINARY_INTEGER:fallthrough
		 			case plsqlParser.BLOB:fallthrough
		 			case plsqlParser.BLOCK:fallthrough
		 			case plsqlParser.BODY:fallthrough
		 			case plsqlParser.BOOLEAN:fallthrough
		 			case plsqlParser.BOTH:fallthrough
		 			case plsqlParser.BULK:fallthrough
		 			case plsqlParser.BYTE:fallthrough
		 			case plsqlParser.C_LETTER:fallthrough
		 			case plsqlParser.CALL:fallthrough
		 			case plsqlParser.CANONICAL:fallthrough
		 			case plsqlParser.CASCADE:fallthrough
		 			case plsqlParser.CASE:fallthrough
		 			case plsqlParser.CAST:fallthrough
		 			case plsqlParser.CHAR:fallthrough
		 			case plsqlParser.CHAR_CS:fallthrough
		 			case plsqlParser.CHARACTER:fallthrough
		 			case plsqlParser.CHR:fallthrough
		 			case plsqlParser.CLOB:fallthrough
		 			case plsqlParser.CLOSE:fallthrough
		 			case plsqlParser.CLUSTER:fallthrough
		 			case plsqlParser.COLLECT:fallthrough
		 			case plsqlParser.COLUMNS:fallthrough
		 			case plsqlParser.COMMENT:fallthrough
		 			case plsqlParser.COMMIT:fallthrough
		 			case plsqlParser.COMMITTED:fallthrough
		 			case plsqlParser.COMPATIBILITY:fallthrough
		 			case plsqlParser.COMPILE:fallthrough
		 			case plsqlParser.COMPOUND:fallthrough
		 			case plsqlParser.CONSTANT:fallthrough
		 			case plsqlParser.CONSTRAINT:fallthrough
		 			case plsqlParser.CONSTRAINTS:fallthrough
		 			case plsqlParser.CONSTRUCTOR:fallthrough
		 			case plsqlParser.CONTENT:fallthrough
		 			case plsqlParser.CONTEXT:fallthrough
		 			case plsqlParser.CONTINUE:fallthrough
		 			case plsqlParser.CONVERT:fallthrough
		 			case plsqlParser.CORRUPT_XID:fallthrough
		 			case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 			case plsqlParser.COST:fallthrough
		 			case plsqlParser.COUNT:fallthrough
		 			case plsqlParser.CREATE:fallthrough
		 			case plsqlParser.CROSS:fallthrough
		 			case plsqlParser.CUBE:fallthrough
		 			case plsqlParser.CURRENT_USER:fallthrough
		 			case plsqlParser.CURSOR:fallthrough
		 			case plsqlParser.CUSTOMDATUM:fallthrough
		 			case plsqlParser.CYCLE:fallthrough
		 			case plsqlParser.DATA:fallthrough
		 			case plsqlParser.DATABASE:fallthrough
		 			case plsqlParser.DAY:fallthrough
		 			case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 			case plsqlParser.DBTIMEZONE:fallthrough
		 			case plsqlParser.DDL:fallthrough
		 			case plsqlParser.DEBUG:fallthrough
		 			case plsqlParser.DEC:fallthrough
		 			case plsqlParser.DECIMAL:fallthrough
		 			case plsqlParser.DECLARE:fallthrough
		 			case plsqlParser.DECOMPOSE:fallthrough
		 			case plsqlParser.DECREMENT:fallthrough
		 			case plsqlParser.DEFAULTS:fallthrough
		 			case plsqlParser.DEFERRED:fallthrough
		 			case plsqlParser.DEFINER:fallthrough
		 			case plsqlParser.DELETE:fallthrough
		 			case plsqlParser.DETERMINISTIC:fallthrough
		 			case plsqlParser.DIMENSION:fallthrough
		 			case plsqlParser.DISABLE:fallthrough
		 			case plsqlParser.DISASSOCIATE:fallthrough
		 			case plsqlParser.DOCUMENT:fallthrough
		 			case plsqlParser.DOUBLE:fallthrough
		 			case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 			case plsqlParser.EACH:fallthrough
		 			case plsqlParser.ELEMENT:fallthrough
		 			case plsqlParser.EMPTY:fallthrough
		 			case plsqlParser.ENABLE:fallthrough
		 			case plsqlParser.ENCODING:fallthrough
		 			case plsqlParser.ENTITYESCAPING:fallthrough
		 			case plsqlParser.ERR:fallthrough
		 			case plsqlParser.ERRORS:fallthrough
		 			case plsqlParser.ESCAPE:fallthrough
		 			case plsqlParser.EVALNAME:fallthrough
		 			case plsqlParser.EXCEPTION:fallthrough
		 			case plsqlParser.EXCEPTION_INIT:fallthrough
		 			case plsqlParser.EXCEPTIONS:fallthrough
		 			case plsqlParser.EXCLUDE:fallthrough
		 			case plsqlParser.EXECUTE:fallthrough
		 			case plsqlParser.EXIT:fallthrough
		 			case plsqlParser.EXPLAIN:fallthrough
		 			case plsqlParser.EXTERNAL:fallthrough
		 			case plsqlParser.EXTRACT:fallthrough
		 			case plsqlParser.FAILURE:fallthrough
		 			case plsqlParser.FETCH:fallthrough
		 			case plsqlParser.FINAL:fallthrough
		 			case plsqlParser.FIRST:fallthrough
		 			case plsqlParser.FIRST_VALUE:fallthrough
		 			case plsqlParser.FLOAT:fallthrough
		 			case plsqlParser.FOLLOWING:fallthrough
		 			case plsqlParser.FOLLOWS:fallthrough
		 			case plsqlParser.FOR:fallthrough
		 			case plsqlParser.FORALL:fallthrough
		 			case plsqlParser.FORCE:fallthrough
		 			case plsqlParser.FULL:fallthrough
		 			case plsqlParser.FUNCTION:fallthrough
		 			case plsqlParser.GOTO:fallthrough
		 			case plsqlParser.GRANT:fallthrough
		 			case plsqlParser.GROUPING:fallthrough
		 			case plsqlParser.HASH:fallthrough
		 			case plsqlParser.HIDE:fallthrough
		 			case plsqlParser.HOUR:fallthrough
		 			case plsqlParser.IF:fallthrough
		 			case plsqlParser.IGNORE:fallthrough
		 			case plsqlParser.IMMEDIATE:fallthrough
		 			case plsqlParser.INCLUDE:fallthrough
		 			case plsqlParser.INCLUDING:fallthrough
		 			case plsqlParser.INCREMENT:fallthrough
		 			case plsqlParser.INDENT:fallthrough
		 			case plsqlParser.INDEXED:fallthrough
		 			case plsqlParser.INDICATOR:fallthrough
		 			case plsqlParser.INDICES:fallthrough
		 			case plsqlParser.INFINITE:fallthrough
		 			case plsqlParser.INLINE:fallthrough
		 			case plsqlParser.INNER:fallthrough
		 			case plsqlParser.INOUT:fallthrough
		 			case plsqlParser.INSERT:fallthrough
		 			case plsqlParser.INSTANTIABLE:fallthrough
		 			case plsqlParser.INSTEAD:fallthrough
		 			case plsqlParser.INT:fallthrough
		 			case plsqlParser.INTEGER:fallthrough
		 			case plsqlParser.INTERVAL:fallthrough
		 			case plsqlParser.INVALIDATE:fallthrough
		 			case plsqlParser.ISOLATION:fallthrough
		 			case plsqlParser.ITERATE:fallthrough
		 			case plsqlParser.JAVA:fallthrough
		 			case plsqlParser.JOIN:fallthrough
		 			case plsqlParser.KEEP:fallthrough
		 			case plsqlParser.LANGUAGE:fallthrough
		 			case plsqlParser.LAST:fallthrough
		 			case plsqlParser.LAST_VALUE:fallthrough
		 			case plsqlParser.LEADING:fallthrough
		 			case plsqlParser.LEFT:fallthrough
		 			case plsqlParser.LEVEL:fallthrough
		 			case plsqlParser.LIBRARY:fallthrough
		 			case plsqlParser.LIKE2:fallthrough
		 			case plsqlParser.LIKE4:fallthrough
		 			case plsqlParser.LIKEC:fallthrough
		 			case plsqlParser.LIMIT:fallthrough
		 			case plsqlParser.LOCAL:fallthrough
		 			case plsqlParser.LOCK:fallthrough
		 			case plsqlParser.LOCKED:fallthrough
		 			case plsqlParser.LOG:fallthrough
		 			case plsqlParser.LOGOFF:fallthrough
		 			case plsqlParser.LOGON:fallthrough
		 			case plsqlParser.LONG:fallthrough
		 			case plsqlParser.LOOP:fallthrough
		 			case plsqlParser.MAIN:fallthrough
		 			case plsqlParser.MAP:fallthrough
		 			case plsqlParser.MATCHED:fallthrough
		 			case plsqlParser.MAXVALUE:fallthrough
		 			case plsqlParser.MEASURES:fallthrough
		 			case plsqlParser.MEMBER:fallthrough
		 			case plsqlParser.MERGE:fallthrough
		 			case plsqlParser.MINUTE:fallthrough
		 			case plsqlParser.MINVALUE:fallthrough
		 			case plsqlParser.MLSLABEL:fallthrough
		 			case plsqlParser.MODEL:fallthrough
		 			case plsqlParser.MODIFY:fallthrough
		 			case plsqlParser.MONTH:fallthrough
		 			case plsqlParser.MULTISET:fallthrough
		 			case plsqlParser.NAME:fallthrough
		 			case plsqlParser.NAN:fallthrough
		 			case plsqlParser.NATURAL:fallthrough
		 			case plsqlParser.NATURALN:fallthrough
		 			case plsqlParser.NAV:fallthrough
		 			case plsqlParser.NCHAR:fallthrough
		 			case plsqlParser.NCHAR_CS:fallthrough
		 			case plsqlParser.NCLOB:fallthrough
		 			case plsqlParser.NESTED:fallthrough
		 			case plsqlParser.NEW:fallthrough
		 			case plsqlParser.NO:fallthrough
		 			case plsqlParser.NOAUDIT:fallthrough
		 			case plsqlParser.NOCOPY:fallthrough
		 			case plsqlParser.NOCYCLE:fallthrough
		 			case plsqlParser.NOENTITYESCAPING:fallthrough
		 			case plsqlParser.NONE:fallthrough
		 			case plsqlParser.NOSCHEMACHECK:fallthrough
		 			case plsqlParser.NULL:fallthrough
		 			case plsqlParser.NULLS:fallthrough
		 			case plsqlParser.NUMBER:fallthrough
		 			case plsqlParser.NUMERIC:fallthrough
		 			case plsqlParser.NVARCHAR2:fallthrough
		 			case plsqlParser.OBJECT:fallthrough
		 			case plsqlParser.OFF:fallthrough
		 			case plsqlParser.OID:fallthrough
		 			case plsqlParser.OLD:fallthrough
		 			case plsqlParser.ONLY:fallthrough
		 			case plsqlParser.OPEN:fallthrough
		 			case plsqlParser.ORADATA:fallthrough
		 			case plsqlParser.ORDINALITY:fallthrough
		 			case plsqlParser.OSERROR:fallthrough
		 			case plsqlParser.OUT:fallthrough
		 			case plsqlParser.OUTER:fallthrough
		 			case plsqlParser.OVER:fallthrough
		 			case plsqlParser.OVERRIDING:fallthrough
		 			case plsqlParser.PACKAGE:fallthrough
		 			case plsqlParser.PARALLEL_ENABLE:fallthrough
		 			case plsqlParser.PARAMETERS:fallthrough
		 			case plsqlParser.PARENT:fallthrough
		 			case plsqlParser.PARTITION:fallthrough
		 			case plsqlParser.PASSING:fallthrough
		 			case plsqlParser.PATH:fallthrough
		 			case plsqlParser.PIPELINED:fallthrough
		 			case plsqlParser.PLAN:fallthrough
		 			case plsqlParser.PLS_INTEGER:fallthrough
		 			case plsqlParser.POSITIVE:fallthrough
		 			case plsqlParser.POSITIVEN:fallthrough
		 			case plsqlParser.PRAGMA:fallthrough
		 			case plsqlParser.PRECEDING:fallthrough
		 			case plsqlParser.PRECISION:fallthrough
		 			case plsqlParser.PRESENT:fallthrough
		 			case plsqlParser.PROCEDURE:fallthrough
		 			case plsqlParser.RAISE:fallthrough
		 			case plsqlParser.RANGE:fallthrough
		 			case plsqlParser.RAW:fallthrough
		 			case plsqlParser.READ:fallthrough
		 			case plsqlParser.REAL:fallthrough
		 			case plsqlParser.RECORD:fallthrough
		 			case plsqlParser.REF:fallthrough
		 			case plsqlParser.REFERENCE:fallthrough
		 			case plsqlParser.REFERENCING:fallthrough
		 			case plsqlParser.REJECT:fallthrough
		 			case plsqlParser.RELIES_ON:fallthrough
		 			case plsqlParser.RENAME:fallthrough
		 			case plsqlParser.REPLACE:fallthrough
		 			case plsqlParser.RESPECT:fallthrough
		 			case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 			case plsqlParser.RESULT:fallthrough
		 			case plsqlParser.RESULT_CACHE:fallthrough
		 			case plsqlParser.RETURN:fallthrough
		 			case plsqlParser.RETURNING:fallthrough
		 			case plsqlParser.REUSE:fallthrough
		 			case plsqlParser.REVERSE:fallthrough
		 			case plsqlParser.RIGHT:fallthrough
		 			case plsqlParser.ROLLBACK:fallthrough
		 			case plsqlParser.ROLLUP:fallthrough
		 			case plsqlParser.ROW:fallthrough
		 			case plsqlParser.ROWID:fallthrough
		 			case plsqlParser.ROWS:fallthrough
		 			case plsqlParser.RULES:fallthrough
		 			case plsqlParser.SAMPLE:fallthrough
		 			case plsqlParser.SAVE:fallthrough
		 			case plsqlParser.SAVEPOINT:fallthrough
		 			case plsqlParser.SCHEMA:fallthrough
		 			case plsqlParser.SCHEMACHECK:fallthrough
		 			case plsqlParser.SCN:fallthrough
		 			case plsqlParser.SECOND:fallthrough
		 			case plsqlParser.SEED:fallthrough
		 			case plsqlParser.SEGMENT:fallthrough
		 			case plsqlParser.SELECT:fallthrough
		 			case plsqlParser.SELF:fallthrough
		 			case plsqlParser.SEQUENTIAL:fallthrough
		 			case plsqlParser.SERIALIZABLE:fallthrough
		 			case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 			case plsqlParser.SERVERERROR:fallthrough
		 			case plsqlParser.SESSIONTIMEZONE:fallthrough
		 			case plsqlParser.SET:fallthrough
		 			case plsqlParser.SETS:fallthrough
		 			case plsqlParser.SETTINGS:fallthrough
		 			case plsqlParser.SHOW:fallthrough
		 			case plsqlParser.SHUTDOWN:fallthrough
		 			case plsqlParser.SIBLINGS:fallthrough
		 			case plsqlParser.SIGNTYPE:fallthrough
		 			case plsqlParser.SIMPLE_INTEGER:fallthrough
		 			case plsqlParser.SINGLE:fallthrough
		 			case plsqlParser.SKIP_:fallthrough
		 			case plsqlParser.SMALLINT:fallthrough
		 			case plsqlParser.SNAPSHOT:fallthrough
		 			case plsqlParser.SOME:fallthrough
		 			case plsqlParser.SPECIFICATION:fallthrough
		 			case plsqlParser.SQLDATA:fallthrough
		 			case plsqlParser.SQLERROR:fallthrough
		 			case plsqlParser.STANDALONE:fallthrough
		 			case plsqlParser.STARTUP:fallthrough
		 			case plsqlParser.STATEMENT:fallthrough
		 			case plsqlParser.STATEMENT_ID:fallthrough
		 			case plsqlParser.STATIC:fallthrough
		 			case plsqlParser.STATISTICS:fallthrough
		 			case plsqlParser.STRING:fallthrough
		 			case plsqlParser.SUBMULTISET:fallthrough
		 			case plsqlParser.SUBPARTITION:fallthrough
		 			case plsqlParser.SUBSTITUTABLE:fallthrough
		 			case plsqlParser.SUBTYPE:fallthrough
		 			case plsqlParser.SUCCESS:fallthrough
		 			case plsqlParser.SUSPEND:fallthrough
		 			case plsqlParser.TIME:fallthrough
		 			case plsqlParser.TIMESTAMP:fallthrough
		 			case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 			case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 			case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 			case plsqlParser.TIMEZONE_ABBR:fallthrough
		 			case plsqlParser.TIMEZONE_HOUR:fallthrough
		 			case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 			case plsqlParser.TIMEZONE_REGION:fallthrough
		 			case plsqlParser.TRAILING:fallthrough
		 			case plsqlParser.TRANSACTION:fallthrough
		 			case plsqlParser.TRANSLATE:fallthrough
		 			case plsqlParser.TREAT:fallthrough
		 			case plsqlParser.TRIGGER:fallthrough
		 			case plsqlParser.TRIM:fallthrough
		 			case plsqlParser.TRUNCATE:fallthrough
		 			case plsqlParser.TYPE:fallthrough
		 			case plsqlParser.UNBOUNDED:fallthrough
		 			case plsqlParser.UNDER:fallthrough
		 			case plsqlParser.UNLIMITED:fallthrough
		 			case plsqlParser.UNTIL:fallthrough
		 			case plsqlParser.UPDATE:fallthrough
		 			case plsqlParser.UPDATED:fallthrough
		 			case plsqlParser.UPSERT:fallthrough
		 			case plsqlParser.UROWID:fallthrough
		 			case plsqlParser.USE:fallthrough
		 			case plsqlParser.VALIDATE:fallthrough
		 			case plsqlParser.VALUE:fallthrough
		 			case plsqlParser.VARCHAR:fallthrough
		 			case plsqlParser.VARCHAR2:fallthrough
		 			case plsqlParser.VARIABLE:fallthrough
		 			case plsqlParser.VARRAY:fallthrough
		 			case plsqlParser.VARYING:fallthrough
		 			case plsqlParser.VERSION:fallthrough
		 			case plsqlParser.VERSIONS:fallthrough
		 			case plsqlParser.WAIT:fallthrough
		 			case plsqlParser.WARNING:fallthrough
		 			case plsqlParser.WELLFORMED:fallthrough
		 			case plsqlParser.WHENEVER:fallthrough
		 			case plsqlParser.WHILE:fallthrough
		 			case plsqlParser.WITH:fallthrough
		 			case plsqlParser.WITHIN:fallthrough
		 			case plsqlParser.WORK:fallthrough
		 			case plsqlParser.WRITE:fallthrough
		 			case plsqlParser.XML:fallthrough
		 			case plsqlParser.XMLAGG:fallthrough
		 			case plsqlParser.XMLATTRIBUTES:fallthrough
		 			case plsqlParser.XMLCAST:fallthrough
		 			case plsqlParser.XMLCOLATTVAL:fallthrough
		 			case plsqlParser.XMLELEMENT:fallthrough
		 			case plsqlParser.XMLEXISTS:fallthrough
		 			case plsqlParser.XMLFOREST:fallthrough
		 			case plsqlParser.XMLNAMESPACES:fallthrough
		 			case plsqlParser.XMLPARSE:fallthrough
		 			case plsqlParser.XMLPI:fallthrough
		 			case plsqlParser.XMLQUERY:fallthrough
		 			case plsqlParser.XMLROOT:fallthrough
		 			case plsqlParser.XMLSERIALIZE:fallthrough
		 			case plsqlParser.XMLTABLE:fallthrough
		 			case plsqlParser.YEAR:fallthrough
		 			case plsqlParser.YES:fallthrough
		 			case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 			case plsqlParser.ZONE:fallthrough
		 			case plsqlParser.PREDICTION:fallthrough
		 			case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 			case plsqlParser.PREDICTION_COST:fallthrough
		 			case plsqlParser.PREDICTION_DETAILS:fallthrough
		 			case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 			case plsqlParser.PREDICTION_SET:fallthrough
		 			case plsqlParser.CUME_DIST:fallthrough
		 			case plsqlParser.DENSE_RANK:fallthrough
		 			case plsqlParser.LISTAGG:fallthrough
		 			case plsqlParser.PERCENT_RANK:fallthrough
		 			case plsqlParser.PERCENTILE_CONT:fallthrough
		 			case plsqlParser.PERCENTILE_DISC:fallthrough
		 			case plsqlParser.RANK:fallthrough
		 			case plsqlParser.AVG:fallthrough
		 			case plsqlParser.CORR:fallthrough
		 			case plsqlParser.LAG:fallthrough
		 			case plsqlParser.LEAD:fallthrough
		 			case plsqlParser.MAX:fallthrough
		 			case plsqlParser.MEDIAN:fallthrough
		 			case plsqlParser.MIN:fallthrough
		 			case plsqlParser.NTILE:fallthrough
		 			case plsqlParser.RATIO_TO_REPORT:fallthrough
		 			case plsqlParser.ROW_NUMBER:fallthrough
		 			case plsqlParser.SUM:fallthrough
		 			case plsqlParser.VARIANCE:fallthrough
		 			case plsqlParser.REGR_:fallthrough
		 			case plsqlParser.STDDEV:fallthrough
		 			case plsqlParser.VAR_:fallthrough
		 			case plsqlParser.COVAR_:fallthrough
		 			case plsqlParser.DELIMITED_ID:fallthrough
		 			case plsqlParser.LEFT_PAREN:fallthrough
		 			case plsqlParser.BINDVAR:fallthrough
		 			case plsqlParser.COLON:fallthrough
		 			case plsqlParser.INTRODUCER:fallthrough
		 			case plsqlParser.REGULAR_ID:
		 				setState(2199)
		 				try statement()
		 				setState(2200)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.EOF
		 				          testSet = testSet || _la == plsqlParser.SEMICOLON
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				} else {
		 					try consume()
		 				}

		 				break

		 			case plsqlParser.LESS_THAN_OP:
		 				setState(2202)
		 				try label_declaration()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2205); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,206,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Label_declarationContext:ParserRuleContext {
		public var ltp1: Token!
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_label_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLabel_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLabel_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLabel_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLabel_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func label_declaration() throws -> Label_declarationContext {
		var _localctx: Label_declarationContext = Label_declarationContext(_ctx, getState())
		try enterRule(_localctx, 224, plsqlParser.RULE_label_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2207)
		 	try {
		 			let assignmentValue = try match(plsqlParser.LESS_THAN_OP)
		 			_localctx.castdown(Label_declarationContext.self).ltp1 = assignmentValue
		 	     }()

		 	setState(2208)
		 	try match(plsqlParser.LESS_THAN_OP)
		 	setState(2209)
		 	try label_name()
		 	setState(2210)
		 	try match(plsqlParser.GREATER_THAN_OP)
		 	setState(2211)
		 	try match(plsqlParser.GREATER_THAN_OP)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StatementContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.CREATE, 0) }
		open func swallow_to_semi() -> Swallow_to_semiContext? {
			return getRuleContext(Swallow_to_semiContext.self,0)
		}
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.ALTER, 0) }
		open func GRANT() -> TerminalNode? { return getToken(plsqlParser.GRANT, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.TRUNCATE, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func block() -> BlockContext? {
			return getRuleContext(BlockContext.self,0)
		}
		open func assignment_statement() -> Assignment_statementContext? {
			return getRuleContext(Assignment_statementContext.self,0)
		}
		open func continue_statement() -> Continue_statementContext? {
			return getRuleContext(Continue_statementContext.self,0)
		}
		open func exit_statement() -> Exit_statementContext? {
			return getRuleContext(Exit_statementContext.self,0)
		}
		open func goto_statement() -> Goto_statementContext? {
			return getRuleContext(Goto_statementContext.self,0)
		}
		open func if_statement() -> If_statementContext? {
			return getRuleContext(If_statementContext.self,0)
		}
		open func loop_statement() -> Loop_statementContext? {
			return getRuleContext(Loop_statementContext.self,0)
		}
		open func forall_statement() -> Forall_statementContext? {
			return getRuleContext(Forall_statementContext.self,0)
		}
		open func null_statement() -> Null_statementContext? {
			return getRuleContext(Null_statementContext.self,0)
		}
		open func raise_statement() -> Raise_statementContext? {
			return getRuleContext(Raise_statementContext.self,0)
		}
		open func return_statement() -> Return_statementContext? {
			return getRuleContext(Return_statementContext.self,0)
		}
		open func case_statement() -> Case_statementContext? {
			return getRuleContext(Case_statementContext.self,0)
		}
		open func sql_statement() -> Sql_statementContext? {
			return getRuleContext(Sql_statementContext.self,0)
		}
		open func function_call() -> Function_callContext? {
			return getRuleContext(Function_callContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStatement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func statement() throws -> StatementContext {
		var _localctx: StatementContext = StatementContext(_ctx, getState())
		try enterRule(_localctx, 226, plsqlParser.RULE_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2239)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,208, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2213)
		 		try match(plsqlParser.CREATE)
		 		setState(2214)
		 		try swallow_to_semi()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2215)
		 		try match(plsqlParser.ALTER)
		 		setState(2216)
		 		try swallow_to_semi()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2217)
		 		try match(plsqlParser.GRANT)
		 		setState(2219)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,207,_ctx)) {
		 		case 1:
		 			setState(2218)
		 			try match(plsqlParser.ALL)

		 			break
		 		default: break
		 		}
		 		setState(2221)
		 		try swallow_to_semi()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2222)
		 		try match(plsqlParser.TRUNCATE)
		 		setState(2223)
		 		try swallow_to_semi()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2224)
		 		try body()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2225)
		 		try block()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2226)
		 		try assignment_statement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2227)
		 		try continue_statement()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2228)
		 		try exit_statement()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2229)
		 		try goto_statement()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2230)
		 		try if_statement()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(2231)
		 		try loop_statement()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(2232)
		 		try forall_statement()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(2233)
		 		try null_statement()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(2234)
		 		try raise_statement()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(2235)
		 		try return_statement()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(2236)
		 		try case_statement()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(2237)
		 		try sql_statement()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(2238)
		 		try function_call()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Assignment_statementContext:ParserRuleContext {
		open func ASSIGN_OP() -> TerminalNode? { return getToken(plsqlParser.ASSIGN_OP, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_assignment_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAssignment_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAssignment_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAssignment_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAssignment_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func assignment_statement() throws -> Assignment_statementContext {
		var _localctx: Assignment_statementContext = Assignment_statementContext(_ctx, getState())
		try enterRule(_localctx, 228, plsqlParser.RULE_assignment_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2243)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(2241)
		 		try general_element()

		 		break
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:
		 		setState(2242)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2245)
		 	try match(plsqlParser.ASSIGN_OP)
		 	setState(2246)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Continue_statementContext:ParserRuleContext {
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.CONTINUE, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_continue_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterContinue_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitContinue_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitContinue_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitContinue_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func continue_statement() throws -> Continue_statementContext {
		var _localctx: Continue_statementContext = Continue_statementContext(_ctx, getState())
		try enterRule(_localctx, 230, plsqlParser.RULE_continue_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2248)
		 	try match(plsqlParser.CONTINUE)
		 	setState(2250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2249)
		 		try label_name()

		 	}

		 	setState(2254)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(2252)
		 		try match(plsqlParser.WHEN)
		 		setState(2253)
		 		try condition()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exit_statementContext:ParserRuleContext {
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.EXIT, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exit_statement() throws -> Exit_statementContext {
		var _localctx: Exit_statementContext = Exit_statementContext(_ctx, getState())
		try enterRule(_localctx, 232, plsqlParser.RULE_exit_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2256)
		 	try match(plsqlParser.EXIT)
		 	setState(2258)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2257)
		 		try label_name()

		 	}

		 	setState(2262)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }()) {
		 		setState(2260)
		 		try match(plsqlParser.WHEN)
		 		setState(2261)
		 		try condition()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Goto_statementContext:ParserRuleContext {
		open func GOTO() -> TerminalNode? { return getToken(plsqlParser.GOTO, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_goto_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGoto_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGoto_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGoto_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGoto_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func goto_statement() throws -> Goto_statementContext {
		var _localctx: Goto_statementContext = Goto_statementContext(_ctx, getState())
		try enterRule(_localctx, 234, plsqlParser.RULE_goto_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2264)
		 	try match(plsqlParser.GOTO)
		 	setState(2265)
		 	try label_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class If_statementContext:ParserRuleContext {
		open func IF() -> Array<TerminalNode> { return getTokens(plsqlParser.IF) }
		open func IF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.IF, i)
		}
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func elsif_part() -> Array<Elsif_partContext> {
			return getRuleContexts(Elsif_partContext.self)
		}
		open func elsif_part(_ i: Int) -> Elsif_partContext? {
			return getRuleContext(Elsif_partContext.self,i)
		}
		open func else_part() -> Else_partContext? {
			return getRuleContext(Else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_if_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIf_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIf_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIf_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIf_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func if_statement() throws -> If_statementContext {
		var _localctx: If_statementContext = If_statementContext(_ctx, getState())
		try enterRule(_localctx, 236, plsqlParser.RULE_if_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2267)
		 	try match(plsqlParser.IF)
		 	setState(2268)
		 	try condition()
		 	setState(2269)
		 	try match(plsqlParser.THEN)
		 	setState(2270)
		 	try seq_of_statements()
		 	setState(2274)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ELSIF
		 	      return testSet
		 	 }()) {
		 		setState(2271)
		 		try elsif_part()


		 		setState(2276)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2278)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ELSE
		 	      return testSet
		 	 }()) {
		 		setState(2277)
		 		try else_part()

		 	}

		 	setState(2280)
		 	try match(plsqlParser.END)
		 	setState(2281)
		 	try match(plsqlParser.IF)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Elsif_partContext:ParserRuleContext {
		open func ELSIF() -> TerminalNode? { return getToken(plsqlParser.ELSIF, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_elsif_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElsif_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElsif_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElsif_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElsif_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func elsif_part() throws -> Elsif_partContext {
		var _localctx: Elsif_partContext = Elsif_partContext(_ctx, getState())
		try enterRule(_localctx, 238, plsqlParser.RULE_elsif_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2283)
		 	try match(plsqlParser.ELSIF)
		 	setState(2284)
		 	try condition()
		 	setState(2285)
		 	try match(plsqlParser.THEN)
		 	setState(2286)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.ELSE, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElse_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElse_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElse_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElse_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func else_part() throws -> Else_partContext {
		var _localctx: Else_partContext = Else_partContext(_ctx, getState())
		try enterRule(_localctx, 240, plsqlParser.RULE_else_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2288)
		 	try match(plsqlParser.ELSE)
		 	setState(2289)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Loop_statementContext:ParserRuleContext {
		open func LOOP() -> Array<TerminalNode> { return getTokens(plsqlParser.LOOP) }
		open func LOOP(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.LOOP, i)
		}
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func WHILE() -> TerminalNode? { return getToken(plsqlParser.WHILE, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func cursor_loop_param() -> Cursor_loop_paramContext? {
			return getRuleContext(Cursor_loop_paramContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_loop_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLoop_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLoop_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLoop_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLoop_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func loop_statement() throws -> Loop_statementContext {
		var _localctx: Loop_statementContext = Loop_statementContext(_ctx, getState())
		try enterRule(_localctx, 242, plsqlParser.RULE_loop_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2292)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,216,_ctx)) {
		 	case 1:
		 		setState(2291)
		 		try label_name()

		 		break
		 	default: break
		 	}
		 	setState(2298)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.WHILE:
		 	 	setState(2294)
		 	 	try match(plsqlParser.WHILE)
		 	 	setState(2295)
		 	 	try condition()

		 		break

		 	case plsqlParser.FOR:
		 	 	setState(2296)
		 	 	try match(plsqlParser.FOR)
		 	 	setState(2297)
		 	 	try cursor_loop_param()

		 		break

		 	case plsqlParser.LOOP:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2300)
		 	try match(plsqlParser.LOOP)
		 	setState(2301)
		 	try seq_of_statements()
		 	setState(2302)
		 	try match(plsqlParser.END)
		 	setState(2303)
		 	try match(plsqlParser.LOOP)
		 	setState(2305)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2304)
		 		try label_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_loop_paramContext:ParserRuleContext {
		public var range: Token!
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open func REVERSE() -> TerminalNode? { return getToken(plsqlParser.REVERSE, 0) }
		open func record_name() -> Record_nameContext? {
			return getRuleContext(Record_nameContext.self,0)
		}
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_loop_param }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_loop_param(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_loop_param(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_loop_param(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_loop_param(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_loop_param() throws -> Cursor_loop_paramContext {
		var _localctx: Cursor_loop_paramContext = Cursor_loop_paramContext(_ctx, getState())
		try enterRule(_localctx, 244, plsqlParser.RULE_cursor_loop_param)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2328)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,222, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2307)
		 		try index_name()
		 		setState(2308)
		 		try match(plsqlParser.IN)
		 		setState(2310)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,219,_ctx)) {
		 		case 1:
		 			setState(2309)
		 			try match(plsqlParser.REVERSE)

		 			break
		 		default: break
		 		}
		 		setState(2312)
		 		try lower_bound()
		 		setState(2313)
		 		try {
		 				let assignmentValue = try match(plsqlParser.T__0)
		 				_localctx.castdown(Cursor_loop_paramContext.self).range = assignmentValue
		 		     }()

		 		setState(2314)
		 		try upper_bound()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2316)
		 		try record_name()
		 		setState(2317)
		 		try match(plsqlParser.IN)
		 		setState(2326)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.A_LETTER:fallthrough
		 		case plsqlParser.ADD:fallthrough
		 		case plsqlParser.AFTER:fallthrough
		 		case plsqlParser.AGENT:fallthrough
		 		case plsqlParser.AGGREGATE:fallthrough
		 		case plsqlParser.ANALYZE:fallthrough
		 		case plsqlParser.ARRAY:fallthrough
		 		case plsqlParser.ASSOCIATE:fallthrough
		 		case plsqlParser.AT:fallthrough
		 		case plsqlParser.ATTRIBUTE:fallthrough
		 		case plsqlParser.AUDIT:fallthrough
		 		case plsqlParser.AUTHID:fallthrough
		 		case plsqlParser.AUTO:fallthrough
		 		case plsqlParser.AUTOMATIC:fallthrough
		 		case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 		case plsqlParser.BATCH:fallthrough
		 		case plsqlParser.BEFORE:fallthrough
		 		case plsqlParser.BFILE:fallthrough
		 		case plsqlParser.BINARY_DOUBLE:fallthrough
		 		case plsqlParser.BINARY_FLOAT:fallthrough
		 		case plsqlParser.BINARY_INTEGER:fallthrough
		 		case plsqlParser.BLOB:fallthrough
		 		case plsqlParser.BLOCK:fallthrough
		 		case plsqlParser.BODY:fallthrough
		 		case plsqlParser.BOOLEAN:fallthrough
		 		case plsqlParser.BOTH:fallthrough
		 		case plsqlParser.BULK:fallthrough
		 		case plsqlParser.BYTE:fallthrough
		 		case plsqlParser.C_LETTER:fallthrough
		 		case plsqlParser.CALL:fallthrough
		 		case plsqlParser.CANONICAL:fallthrough
		 		case plsqlParser.CASCADE:fallthrough
		 		case plsqlParser.CAST:fallthrough
		 		case plsqlParser.CHAR:fallthrough
		 		case plsqlParser.CHAR_CS:fallthrough
		 		case plsqlParser.CHARACTER:fallthrough
		 		case plsqlParser.CHR:fallthrough
		 		case plsqlParser.CLOB:fallthrough
		 		case plsqlParser.CLOSE:fallthrough
		 		case plsqlParser.CLUSTER:fallthrough
		 		case plsqlParser.COLLECT:fallthrough
		 		case plsqlParser.COLUMNS:fallthrough
		 		case plsqlParser.COMMENT:fallthrough
		 		case plsqlParser.COMMIT:fallthrough
		 		case plsqlParser.COMMITTED:fallthrough
		 		case plsqlParser.COMPATIBILITY:fallthrough
		 		case plsqlParser.COMPILE:fallthrough
		 		case plsqlParser.COMPOUND:fallthrough
		 		case plsqlParser.CONSTANT:fallthrough
		 		case plsqlParser.CONSTRAINT:fallthrough
		 		case plsqlParser.CONSTRAINTS:fallthrough
		 		case plsqlParser.CONSTRUCTOR:fallthrough
		 		case plsqlParser.CONTENT:fallthrough
		 		case plsqlParser.CONTEXT:fallthrough
		 		case plsqlParser.CONTINUE:fallthrough
		 		case plsqlParser.CONVERT:fallthrough
		 		case plsqlParser.CORRUPT_XID:fallthrough
		 		case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 		case plsqlParser.COST:fallthrough
		 		case plsqlParser.COUNT:fallthrough
		 		case plsqlParser.CROSS:fallthrough
		 		case plsqlParser.CUBE:fallthrough
		 		case plsqlParser.CURRENT_USER:fallthrough
		 		case plsqlParser.CURSOR:fallthrough
		 		case plsqlParser.CUSTOMDATUM:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.DATA:fallthrough
		 		case plsqlParser.DATABASE:fallthrough
		 		case plsqlParser.DAY:fallthrough
		 		case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DDL:fallthrough
		 		case plsqlParser.DEBUG:fallthrough
		 		case plsqlParser.DEC:fallthrough
		 		case plsqlParser.DECIMAL:fallthrough
		 		case plsqlParser.DECOMPOSE:fallthrough
		 		case plsqlParser.DECREMENT:fallthrough
		 		case plsqlParser.DEFAULTS:fallthrough
		 		case plsqlParser.DEFERRED:fallthrough
		 		case plsqlParser.DEFINER:fallthrough
		 		case plsqlParser.DETERMINISTIC:fallthrough
		 		case plsqlParser.DIMENSION:fallthrough
		 		case plsqlParser.DISABLE:fallthrough
		 		case plsqlParser.DISASSOCIATE:fallthrough
		 		case plsqlParser.DOCUMENT:fallthrough
		 		case plsqlParser.DOUBLE:fallthrough
		 		case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.EACH:fallthrough
		 		case plsqlParser.ELEMENT:fallthrough
		 		case plsqlParser.EMPTY:fallthrough
		 		case plsqlParser.ENABLE:fallthrough
		 		case plsqlParser.ENCODING:fallthrough
		 		case plsqlParser.ENTITYESCAPING:fallthrough
		 		case plsqlParser.ERR:fallthrough
		 		case plsqlParser.ERRORS:fallthrough
		 		case plsqlParser.ESCAPE:fallthrough
		 		case plsqlParser.EVALNAME:fallthrough
		 		case plsqlParser.EXCEPTION:fallthrough
		 		case plsqlParser.EXCEPTION_INIT:fallthrough
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.EXCLUDE:fallthrough
		 		case plsqlParser.EXECUTE:fallthrough
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.EXTERNAL:fallthrough
		 		case plsqlParser.EXTRACT:fallthrough
		 		case plsqlParser.FAILURE:fallthrough
		 		case plsqlParser.FINAL:fallthrough
		 		case plsqlParser.FIRST:fallthrough
		 		case plsqlParser.FIRST_VALUE:fallthrough
		 		case plsqlParser.FLOAT:fallthrough
		 		case plsqlParser.FOLLOWING:fallthrough
		 		case plsqlParser.FOLLOWS:fallthrough
		 		case plsqlParser.FORALL:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.FULL:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.GROUPING:fallthrough
		 		case plsqlParser.HASH:fallthrough
		 		case plsqlParser.HIDE:fallthrough
		 		case plsqlParser.HOUR:fallthrough
		 		case plsqlParser.IGNORE:fallthrough
		 		case plsqlParser.IMMEDIATE:fallthrough
		 		case plsqlParser.INCLUDE:fallthrough
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.INDENT:fallthrough
		 		case plsqlParser.INDEXED:fallthrough
		 		case plsqlParser.INDICATOR:fallthrough
		 		case plsqlParser.INDICES:fallthrough
		 		case plsqlParser.INFINITE:fallthrough
		 		case plsqlParser.INLINE:fallthrough
		 		case plsqlParser.INNER:fallthrough
		 		case plsqlParser.INOUT:fallthrough
		 		case plsqlParser.INSTANTIABLE:fallthrough
		 		case plsqlParser.INSTEAD:fallthrough
		 		case plsqlParser.INT:fallthrough
		 		case plsqlParser.INTEGER:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.INVALIDATE:fallthrough
		 		case plsqlParser.ISOLATION:fallthrough
		 		case plsqlParser.ITERATE:fallthrough
		 		case plsqlParser.JAVA:fallthrough
		 		case plsqlParser.JOIN:fallthrough
		 		case plsqlParser.KEEP:fallthrough
		 		case plsqlParser.LANGUAGE:fallthrough
		 		case plsqlParser.LAST:fallthrough
		 		case plsqlParser.LAST_VALUE:fallthrough
		 		case plsqlParser.LEADING:fallthrough
		 		case plsqlParser.LEFT:fallthrough
		 		case plsqlParser.LEVEL:fallthrough
		 		case plsqlParser.LIBRARY:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:fallthrough
		 		case plsqlParser.LIMIT:fallthrough
		 		case plsqlParser.LOCAL:fallthrough
		 		case plsqlParser.LOCKED:fallthrough
		 		case plsqlParser.LOG:fallthrough
		 		case plsqlParser.LOGOFF:fallthrough
		 		case plsqlParser.LOGON:fallthrough
		 		case plsqlParser.LONG:fallthrough
		 		case plsqlParser.LOOP:fallthrough
		 		case plsqlParser.MAIN:fallthrough
		 		case plsqlParser.MAP:fallthrough
		 		case plsqlParser.MATCHED:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MEASURES:fallthrough
		 		case plsqlParser.MEMBER:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.MINUTE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.MLSLABEL:fallthrough
		 		case plsqlParser.MODEL:fallthrough
		 		case plsqlParser.MODIFY:fallthrough
		 		case plsqlParser.MONTH:fallthrough
		 		case plsqlParser.MULTISET:fallthrough
		 		case plsqlParser.NAME:fallthrough
		 		case plsqlParser.NAN:fallthrough
		 		case plsqlParser.NATURAL:fallthrough
		 		case plsqlParser.NATURALN:fallthrough
		 		case plsqlParser.NAV:fallthrough
		 		case plsqlParser.NCHAR:fallthrough
		 		case plsqlParser.NCHAR_CS:fallthrough
		 		case plsqlParser.NCLOB:fallthrough
		 		case plsqlParser.NESTED:fallthrough
		 		case plsqlParser.NEW:fallthrough
		 		case plsqlParser.NO:fallthrough
		 		case plsqlParser.NOAUDIT:fallthrough
		 		case plsqlParser.NOCOPY:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOENTITYESCAPING:fallthrough
		 		case plsqlParser.NONE:fallthrough
		 		case plsqlParser.NOSCHEMACHECK:fallthrough
		 		case plsqlParser.NULLS:fallthrough
		 		case plsqlParser.NUMBER:fallthrough
		 		case plsqlParser.NUMERIC:fallthrough
		 		case plsqlParser.NVARCHAR2:fallthrough
		 		case plsqlParser.OBJECT:fallthrough
		 		case plsqlParser.OFF:fallthrough
		 		case plsqlParser.OID:fallthrough
		 		case plsqlParser.OLD:fallthrough
		 		case plsqlParser.ONLY:fallthrough
		 		case plsqlParser.OPEN:fallthrough
		 		case plsqlParser.ORADATA:fallthrough
		 		case plsqlParser.ORDINALITY:fallthrough
		 		case plsqlParser.OSERROR:fallthrough
		 		case plsqlParser.OUT:fallthrough
		 		case plsqlParser.OUTER:fallthrough
		 		case plsqlParser.OVER:fallthrough
		 		case plsqlParser.OVERRIDING:fallthrough
		 		case plsqlParser.PACKAGE:fallthrough
		 		case plsqlParser.PARALLEL_ENABLE:fallthrough
		 		case plsqlParser.PARAMETERS:fallthrough
		 		case plsqlParser.PARENT:fallthrough
		 		case plsqlParser.PARTITION:fallthrough
		 		case plsqlParser.PASSING:fallthrough
		 		case plsqlParser.PATH:fallthrough
		 		case plsqlParser.PIPELINED:fallthrough
		 		case plsqlParser.PLAN:fallthrough
		 		case plsqlParser.PLS_INTEGER:fallthrough
		 		case plsqlParser.POSITIVE:fallthrough
		 		case plsqlParser.POSITIVEN:fallthrough
		 		case plsqlParser.PRAGMA:fallthrough
		 		case plsqlParser.PRECEDING:fallthrough
		 		case plsqlParser.PRECISION:fallthrough
		 		case plsqlParser.PRESENT:fallthrough
		 		case plsqlParser.RAISE:fallthrough
		 		case plsqlParser.RANGE:fallthrough
		 		case plsqlParser.RAW:fallthrough
		 		case plsqlParser.READ:fallthrough
		 		case plsqlParser.REAL:fallthrough
		 		case plsqlParser.RECORD:fallthrough
		 		case plsqlParser.REF:fallthrough
		 		case plsqlParser.REFERENCE:fallthrough
		 		case plsqlParser.REFERENCING:fallthrough
		 		case plsqlParser.REJECT:fallthrough
		 		case plsqlParser.RELIES_ON:fallthrough
		 		case plsqlParser.RENAME:fallthrough
		 		case plsqlParser.REPLACE:fallthrough
		 		case plsqlParser.RESPECT:fallthrough
		 		case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 		case plsqlParser.RESULT:fallthrough
		 		case plsqlParser.RESULT_CACHE:fallthrough
		 		case plsqlParser.RETURN:fallthrough
		 		case plsqlParser.RETURNING:fallthrough
		 		case plsqlParser.REUSE:fallthrough
		 		case plsqlParser.REVERSE:fallthrough
		 		case plsqlParser.RIGHT:fallthrough
		 		case plsqlParser.ROLLBACK:fallthrough
		 		case plsqlParser.ROLLUP:fallthrough
		 		case plsqlParser.ROW:fallthrough
		 		case plsqlParser.ROWID:fallthrough
		 		case plsqlParser.ROWS:fallthrough
		 		case plsqlParser.RULES:fallthrough
		 		case plsqlParser.SAMPLE:fallthrough
		 		case plsqlParser.SAVE:fallthrough
		 		case plsqlParser.SAVEPOINT:fallthrough
		 		case plsqlParser.SCHEMA:fallthrough
		 		case plsqlParser.SCHEMACHECK:fallthrough
		 		case plsqlParser.SCN:fallthrough
		 		case plsqlParser.SECOND:fallthrough
		 		case plsqlParser.SEED:fallthrough
		 		case plsqlParser.SEGMENT:fallthrough
		 		case plsqlParser.SELF:fallthrough
		 		case plsqlParser.SEQUENTIAL:fallthrough
		 		case plsqlParser.SERIALIZABLE:fallthrough
		 		case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 		case plsqlParser.SERVERERROR:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SETS:fallthrough
		 		case plsqlParser.SETTINGS:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.SHUTDOWN:fallthrough
		 		case plsqlParser.SIBLINGS:fallthrough
		 		case plsqlParser.SIGNTYPE:fallthrough
		 		case plsqlParser.SIMPLE_INTEGER:fallthrough
		 		case plsqlParser.SINGLE:fallthrough
		 		case plsqlParser.SKIP_:fallthrough
		 		case plsqlParser.SMALLINT:fallthrough
		 		case plsqlParser.SNAPSHOT:fallthrough
		 		case plsqlParser.SOME:fallthrough
		 		case plsqlParser.SPECIFICATION:fallthrough
		 		case plsqlParser.SQLDATA:fallthrough
		 		case plsqlParser.SQLERROR:fallthrough
		 		case plsqlParser.STANDALONE:fallthrough
		 		case plsqlParser.STARTUP:fallthrough
		 		case plsqlParser.STATEMENT:fallthrough
		 		case plsqlParser.STATEMENT_ID:fallthrough
		 		case plsqlParser.STATIC:fallthrough
		 		case plsqlParser.STATISTICS:fallthrough
		 		case plsqlParser.STRING:fallthrough
		 		case plsqlParser.SUBMULTISET:fallthrough
		 		case plsqlParser.SUBPARTITION:fallthrough
		 		case plsqlParser.SUBSTITUTABLE:fallthrough
		 		case plsqlParser.SUBTYPE:fallthrough
		 		case plsqlParser.SUCCESS:fallthrough
		 		case plsqlParser.SUSPEND:fallthrough
		 		case plsqlParser.TIME:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMEZONE_ABBR:fallthrough
		 		case plsqlParser.TIMEZONE_HOUR:fallthrough
		 		case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 		case plsqlParser.TIMEZONE_REGION:fallthrough
		 		case plsqlParser.TRAILING:fallthrough
		 		case plsqlParser.TRANSACTION:fallthrough
		 		case plsqlParser.TRANSLATE:fallthrough
		 		case plsqlParser.TREAT:fallthrough
		 		case plsqlParser.TRIGGER:fallthrough
		 		case plsqlParser.TRIM:fallthrough
		 		case plsqlParser.TRUNCATE:fallthrough
		 		case plsqlParser.TYPE:fallthrough
		 		case plsqlParser.UNBOUNDED:fallthrough
		 		case plsqlParser.UNDER:fallthrough
		 		case plsqlParser.UNLIMITED:fallthrough
		 		case plsqlParser.UNTIL:fallthrough
		 		case plsqlParser.UPDATED:fallthrough
		 		case plsqlParser.UPSERT:fallthrough
		 		case plsqlParser.UROWID:fallthrough
		 		case plsqlParser.USE:fallthrough
		 		case plsqlParser.VALIDATE:fallthrough
		 		case plsqlParser.VALUE:fallthrough
		 		case plsqlParser.VARCHAR:fallthrough
		 		case plsqlParser.VARCHAR2:fallthrough
		 		case plsqlParser.VARIABLE:fallthrough
		 		case plsqlParser.VARRAY:fallthrough
		 		case plsqlParser.VARYING:fallthrough
		 		case plsqlParser.VERSION:fallthrough
		 		case plsqlParser.VERSIONS:fallthrough
		 		case plsqlParser.WAIT:fallthrough
		 		case plsqlParser.WARNING:fallthrough
		 		case plsqlParser.WELLFORMED:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.WHILE:fallthrough
		 		case plsqlParser.WITHIN:fallthrough
		 		case plsqlParser.WORK:fallthrough
		 		case plsqlParser.WRITE:fallthrough
		 		case plsqlParser.XML:fallthrough
		 		case plsqlParser.XMLAGG:fallthrough
		 		case plsqlParser.XMLATTRIBUTES:fallthrough
		 		case plsqlParser.XMLCAST:fallthrough
		 		case plsqlParser.XMLCOLATTVAL:fallthrough
		 		case plsqlParser.XMLELEMENT:fallthrough
		 		case plsqlParser.XMLEXISTS:fallthrough
		 		case plsqlParser.XMLFOREST:fallthrough
		 		case plsqlParser.XMLNAMESPACES:fallthrough
		 		case plsqlParser.XMLPARSE:fallthrough
		 		case plsqlParser.XMLPI:fallthrough
		 		case plsqlParser.XMLQUERY:fallthrough
		 		case plsqlParser.XMLROOT:fallthrough
		 		case plsqlParser.XMLSERIALIZE:fallthrough
		 		case plsqlParser.XMLTABLE:fallthrough
		 		case plsqlParser.YEAR:fallthrough
		 		case plsqlParser.YES:fallthrough
		 		case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.ZONE:fallthrough
		 		case plsqlParser.PREDICTION:fallthrough
		 		case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 		case plsqlParser.PREDICTION_COST:fallthrough
		 		case plsqlParser.PREDICTION_DETAILS:fallthrough
		 		case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 		case plsqlParser.PREDICTION_SET:fallthrough
		 		case plsqlParser.CUME_DIST:fallthrough
		 		case plsqlParser.DENSE_RANK:fallthrough
		 		case plsqlParser.LISTAGG:fallthrough
		 		case plsqlParser.PERCENT_RANK:fallthrough
		 		case plsqlParser.PERCENTILE_CONT:fallthrough
		 		case plsqlParser.PERCENTILE_DISC:fallthrough
		 		case plsqlParser.RANK:fallthrough
		 		case plsqlParser.AVG:fallthrough
		 		case plsqlParser.CORR:fallthrough
		 		case plsqlParser.LAG:fallthrough
		 		case plsqlParser.LEAD:fallthrough
		 		case plsqlParser.MAX:fallthrough
		 		case plsqlParser.MEDIAN:fallthrough
		 		case plsqlParser.MIN:fallthrough
		 		case plsqlParser.NTILE:fallthrough
		 		case plsqlParser.RATIO_TO_REPORT:fallthrough
		 		case plsqlParser.ROW_NUMBER:fallthrough
		 		case plsqlParser.SUM:fallthrough
		 		case plsqlParser.VARIANCE:fallthrough
		 		case plsqlParser.REGR_:fallthrough
		 		case plsqlParser.STDDEV:fallthrough
		 		case plsqlParser.VAR_:fallthrough
		 		case plsqlParser.COVAR_:fallthrough
		 		case plsqlParser.DELIMITED_ID:fallthrough
		 		case plsqlParser.BINDVAR:fallthrough
		 		case plsqlParser.COLON:fallthrough
		 		case plsqlParser.INTRODUCER:fallthrough
		 		case plsqlParser.REGULAR_ID:
		 			setState(2318)
		 			try cursor_name()
		 			setState(2320)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 			      return testSet
		 			 }()) {
		 				setState(2319)
		 				try expression_list()

		 			}


		 			break

		 		case plsqlParser.LEFT_PAREN:
		 			setState(2322)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(2323)
		 			try select_statement()
		 			setState(2324)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Forall_statementContext:ParserRuleContext {
		open func FORALL() -> TerminalNode? { return getToken(plsqlParser.FORALL, 0) }
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func bounds_clause() -> Bounds_clauseContext? {
			return getRuleContext(Bounds_clauseContext.self,0)
		}
		open func sql_statement() -> Sql_statementContext? {
			return getRuleContext(Sql_statementContext.self,0)
		}
		open func SAVE() -> TerminalNode? { return getToken(plsqlParser.SAVE, 0) }
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.EXCEPTIONS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_forall_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterForall_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitForall_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitForall_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitForall_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func forall_statement() throws -> Forall_statementContext {
		var _localctx: Forall_statementContext = Forall_statementContext(_ctx, getState())
		try enterRule(_localctx, 246, plsqlParser.RULE_forall_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2330)
		 	try match(plsqlParser.FORALL)
		 	setState(2331)
		 	try index_name()
		 	setState(2332)
		 	try match(plsqlParser.IN)
		 	setState(2333)
		 	try bounds_clause()
		 	setState(2334)
		 	try sql_statement()
		 	setState(2337)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.SAVE
		 	      return testSet
		 	 }()) {
		 		setState(2335)
		 		try match(plsqlParser.SAVE)
		 		setState(2336)
		 		try match(plsqlParser.EXCEPTIONS)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Bounds_clauseContext:ParserRuleContext {
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open func INDICES() -> TerminalNode? { return getToken(plsqlParser.INDICES, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func collection_name() -> Collection_nameContext? {
			return getRuleContext(Collection_nameContext.self,0)
		}
		open func between_bound() -> Between_boundContext? {
			return getRuleContext(Between_boundContext.self,0)
		}
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.VALUES, 0) }
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_bounds_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBounds_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBounds_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBounds_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBounds_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func bounds_clause() throws -> Bounds_clauseContext {
		var _localctx: Bounds_clauseContext = Bounds_clauseContext(_ctx, getState())
		try enterRule(_localctx, 248, plsqlParser.RULE_bounds_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2352)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,225, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2339)
		 		try lower_bound()
		 		setState(2340)
		 		try match(plsqlParser.T__0)
		 		setState(2341)
		 		try upper_bound()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2343)
		 		try match(plsqlParser.INDICES)
		 		setState(2344)
		 		try match(plsqlParser.OF)
		 		setState(2345)
		 		try collection_name()
		 		setState(2347)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.BETWEEN
		 		      return testSet
		 		 }()) {
		 			setState(2346)
		 			try between_bound()

		 		}


		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2349)
		 		try match(plsqlParser.VALUES)
		 		setState(2350)
		 		try match(plsqlParser.OF)
		 		setState(2351)
		 		try index_name()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Between_boundContext:ParserRuleContext {
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.BETWEEN, 0) }
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.AND, 0) }
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_between_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBetween_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBetween_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBetween_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBetween_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func between_bound() throws -> Between_boundContext {
		var _localctx: Between_boundContext = Between_boundContext(_ctx, getState())
		try enterRule(_localctx, 250, plsqlParser.RULE_between_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2354)
		 	try match(plsqlParser.BETWEEN)
		 	setState(2355)
		 	try lower_bound()
		 	setState(2356)
		 	try match(plsqlParser.AND)
		 	setState(2357)
		 	try upper_bound()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lower_boundContext:ParserRuleContext {
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lower_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLower_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLower_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLower_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLower_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lower_bound() throws -> Lower_boundContext {
		var _localctx: Lower_boundContext = Lower_boundContext(_ctx, getState())
		try enterRule(_localctx, 252, plsqlParser.RULE_lower_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2359)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Upper_boundContext:ParserRuleContext {
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_upper_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpper_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpper_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpper_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpper_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func upper_bound() throws -> Upper_boundContext {
		var _localctx: Upper_boundContext = Upper_boundContext(_ctx, getState())
		try enterRule(_localctx, 254, plsqlParser.RULE_upper_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2361)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Null_statementContext:ParserRuleContext {
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_null_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNull_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNull_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNull_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNull_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func null_statement() throws -> Null_statementContext {
		var _localctx: Null_statementContext = Null_statementContext(_ctx, getState())
		try enterRule(_localctx, 256, plsqlParser.RULE_null_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2363)
		 	try match(plsqlParser.NULL)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Raise_statementContext:ParserRuleContext {
		open func RAISE() -> TerminalNode? { return getToken(plsqlParser.RAISE, 0) }
		open func exception_name() -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_raise_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRaise_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRaise_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRaise_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRaise_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func raise_statement() throws -> Raise_statementContext {
		var _localctx: Raise_statementContext = Raise_statementContext(_ctx, getState())
		try enterRule(_localctx, 258, plsqlParser.RULE_raise_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2365)
		 	try match(plsqlParser.RAISE)
		 	setState(2367)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2366)
		 		try exception_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Return_statementContext:ParserRuleContext {
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_return_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReturn_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReturn_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReturn_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReturn_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func return_statement() throws -> Return_statementContext {
		var _localctx: Return_statementContext = Return_statementContext(_ctx, getState())
		try enterRule(_localctx, 260, plsqlParser.RULE_return_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2369)
		 	try match(plsqlParser.RETURN)
		 	setState(2371)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ALL,plsqlParser.ANALYZE,plsqlParser.ANY,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CASE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONNECT_BY_ROOT,plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DISTINCT,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTION_INIT,plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXISTS,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FALSE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LANGUAGE,plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NOT,plsqlParser.NULL,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OBJECT,plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PRIOR,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.RIGHT,plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 321)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMESTAMP_UNCONSTRAINED,plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUE,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 385)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YEAR,plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.UNSIGNED_INTEGER,plsqlParser.APPROXIMATE_NUM_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID,plsqlParser.LEFT_PAREN,plsqlParser.PLUS_SIGN,plsqlParser.MINUS_SIGN,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 449)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2370)
		 		try condition()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_callContext:ParserRuleContext {
		open func routine_name() -> Routine_nameContext? {
			return getRuleContext(Routine_nameContext.self,0)
		}
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.CALL, 0) }
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_call }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_call(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_call(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_call(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_call(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_call() throws -> Function_callContext {
		var _localctx: Function_callContext = Function_callContext(_ctx, getState())
		try enterRule(_localctx, 262, plsqlParser.RULE_function_call)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2374)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,228,_ctx)) {
		 	case 1:
		 		setState(2373)
		 		try match(plsqlParser.CALL)

		 		break
		 	default: break
		 	}
		 	setState(2376)
		 	try routine_name()
		 	setState(2378)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(2377)
		 		try function_argument()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BodyContext:ParserRuleContext {
		open func BEGIN() -> TerminalNode? { return getToken(plsqlParser.BEGIN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.EXCEPTION, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func exception_handler() -> Array<Exception_handlerContext> {
			return getRuleContexts(Exception_handlerContext.self)
		}
		open func exception_handler(_ i: Int) -> Exception_handlerContext? {
			return getRuleContext(Exception_handlerContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBody(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func body() throws -> BodyContext {
		var _localctx: BodyContext = BodyContext(_ctx, getState())
		try enterRule(_localctx, 264, plsqlParser.RULE_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2380)
		 	try match(plsqlParser.BEGIN)
		 	setState(2381)
		 	try seq_of_statements()
		 	setState(2388)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.EXCEPTION
		 	      return testSet
		 	 }()) {
		 		setState(2382)
		 		try match(plsqlParser.EXCEPTION)
		 		setState(2384) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2383)
		 			try exception_handler()


		 			setState(2386); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WHEN
		 		      return testSet
		 		 }())

		 	}

		 	setState(2390)
		 	try match(plsqlParser.END)
		 	setState(2392)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,232,_ctx)) {
		 	case 1:
		 		setState(2391)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_handlerContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func exception_name() -> Array<Exception_nameContext> {
			return getRuleContexts(Exception_nameContext.self)
		}
		open func exception_name(_ i: Int) -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.OR) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.OR, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_handler }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_handler(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_handler(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_handler(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_handler(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_handler() throws -> Exception_handlerContext {
		var _localctx: Exception_handlerContext = Exception_handlerContext(_ctx, getState())
		try enterRule(_localctx, 266, plsqlParser.RULE_exception_handler)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2394)
		 	try match(plsqlParser.WHEN)
		 	setState(2395)
		 	try exception_name()
		 	setState(2400)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OR
		 	      return testSet
		 	 }()) {
		 		setState(2396)
		 		try match(plsqlParser.OR)
		 		setState(2397)
		 		try exception_name()


		 		setState(2402)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2403)
		 	try match(plsqlParser.THEN)
		 	setState(2404)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_blockContext:ParserRuleContext {
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_block() throws -> Trigger_blockContext {
		var _localctx: Trigger_blockContext = Trigger_blockContext(_ctx, getState())
		try enterRule(_localctx, 268, plsqlParser.RULE_trigger_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2414)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECLARE,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2407)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DECLARE
		 		      return testSet
		 		 }()) {
		 			setState(2406)
		 			try match(plsqlParser.DECLARE)

		 		}

		 		setState(2410) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2409)
		 			try declare_spec()


		 			setState(2412); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }())

		 	}

		 	setState(2416)
		 	try body()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BlockContext:ParserRuleContext {
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.DECLARE, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBlock(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBlock(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBlock(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBlock(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func block() throws -> BlockContext {
		var _localctx: BlockContext = BlockContext(_ctx, getState())
		try enterRule(_localctx, 270, plsqlParser.RULE_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2419)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.DECLARE
		 	      return testSet
		 	 }()) {
		 		setState(2418)
		 		try match(plsqlParser.DECLARE)

		 	}

		 	setState(2422) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2421)
		 		try declare_spec()


		 		setState(2424); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CREATE,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PROCEDURE,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }())
		 	setState(2426)
		 	try body()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_statementContext:ParserRuleContext {
		open func execute_immediate() -> Execute_immediateContext? {
			return getRuleContext(Execute_immediateContext.self,0)
		}
		open func data_manipulation_language_statements() -> Data_manipulation_language_statementsContext? {
			return getRuleContext(Data_manipulation_language_statementsContext.self,0)
		}
		open func cursor_manipulation_statements() -> Cursor_manipulation_statementsContext? {
			return getRuleContext(Cursor_manipulation_statementsContext.self,0)
		}
		open func transaction_control_statements() -> Transaction_control_statementsContext? {
			return getRuleContext(Transaction_control_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_statement() throws -> Sql_statementContext {
		var _localctx: Sql_statementContext = Sql_statementContext(_ctx, getState())
		try enterRule(_localctx, 272, plsqlParser.RULE_sql_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2432)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.EXECUTE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2428)
		 		try execute_immediate()

		 		break
		 	case plsqlParser.DELETE:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.INSERT:fallthrough
		 	case plsqlParser.LOCK:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.SELECT:fallthrough
		 	case plsqlParser.UPDATE:fallthrough
		 	case plsqlParser.WITH:fallthrough
		 	case plsqlParser.LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2429)
		 		try data_manipulation_language_statements()

		 		break
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.FETCH:fallthrough
		 	case plsqlParser.OPEN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2430)
		 		try cursor_manipulation_statements()

		 		break
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SET:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2431)
		 		try transaction_control_statements()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_immediateContext:ParserRuleContext {
		open func EXECUTE() -> TerminalNode? { return getToken(plsqlParser.EXECUTE, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.IMMEDIATE, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open func dynamic_returning_clause() -> Dynamic_returning_clauseContext? {
			return getRuleContext(Dynamic_returning_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_execute_immediate }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExecute_immediate(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExecute_immediate(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExecute_immediate(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExecute_immediate(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_immediate() throws -> Execute_immediateContext {
		var _localctx: Execute_immediateContext = Execute_immediateContext(_ctx, getState())
		try enterRule(_localctx, 274, plsqlParser.RULE_execute_immediate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2434)
		 	try match(plsqlParser.EXECUTE)
		 	setState(2435)
		 	try match(plsqlParser.IMMEDIATE)
		 	setState(2436)
		 	try expression()
		 	setState(2446)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.INTO:
		 	 	setState(2437)
		 	 	try into_clause()
		 	 	setState(2439)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.USING
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2438)
		 	 		try using_clause()

		 	 	}


		 		break

		 	case plsqlParser.USING:
		 	 	setState(2441)
		 	 	try using_clause()
		 	 	setState(2443)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2442)
		 	 		try dynamic_returning_clause()

		 	 	}


		 		break
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:
		 	 	setState(2445)
		 	 	try dynamic_returning_clause()

		 		break
		 	case plsqlParser.EOF:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SEMICOLON:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dynamic_returning_clauseContext:ParserRuleContext {
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.RETURNING, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dynamic_returning_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDynamic_returning_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDynamic_returning_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDynamic_returning_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDynamic_returning_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dynamic_returning_clause() throws -> Dynamic_returning_clauseContext {
		var _localctx: Dynamic_returning_clauseContext = Dynamic_returning_clauseContext(_ctx, getState())
		try enterRule(_localctx, 276, plsqlParser.RULE_dynamic_returning_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2448)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2449)
		 	try into_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Data_manipulation_language_statementsContext:ParserRuleContext {
		open func merge_statement() -> Merge_statementContext? {
			return getRuleContext(Merge_statementContext.self,0)
		}
		open func lock_table_statement() -> Lock_table_statementContext? {
			return getRuleContext(Lock_table_statementContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func update_statement() -> Update_statementContext? {
			return getRuleContext(Update_statementContext.self,0)
		}
		open func delete_statement() -> Delete_statementContext? {
			return getRuleContext(Delete_statementContext.self,0)
		}
		open func insert_statement() -> Insert_statementContext? {
			return getRuleContext(Insert_statementContext.self,0)
		}
		open func explain_statement() -> Explain_statementContext? {
			return getRuleContext(Explain_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_data_manipulation_language_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterData_manipulation_language_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitData_manipulation_language_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitData_manipulation_language_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitData_manipulation_language_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func data_manipulation_language_statements() throws -> Data_manipulation_language_statementsContext {
		var _localctx: Data_manipulation_language_statementsContext = Data_manipulation_language_statementsContext(_ctx, getState())
		try enterRule(_localctx, 278, plsqlParser.RULE_data_manipulation_language_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2458)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.MERGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2451)
		 		try merge_statement()

		 		break

		 	case plsqlParser.LOCK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2452)
		 		try lock_table_statement()

		 		break
		 	case plsqlParser.SELECT:fallthrough
		 	case plsqlParser.WITH:fallthrough
		 	case plsqlParser.LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2453)
		 		try select_statement()

		 		break

		 	case plsqlParser.UPDATE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2454)
		 		try update_statement()

		 		break

		 	case plsqlParser.DELETE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2455)
		 		try delete_statement()

		 		break

		 	case plsqlParser.INSERT:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2456)
		 		try insert_statement()

		 		break

		 	case plsqlParser.EXPLAIN:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2457)
		 		try explain_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_manipulation_statementsContext:ParserRuleContext {
		open func close_statement() -> Close_statementContext? {
			return getRuleContext(Close_statementContext.self,0)
		}
		open func open_statement() -> Open_statementContext? {
			return getRuleContext(Open_statementContext.self,0)
		}
		open func fetch_statement() -> Fetch_statementContext? {
			return getRuleContext(Fetch_statementContext.self,0)
		}
		open func open_for_statement() -> Open_for_statementContext? {
			return getRuleContext(Open_for_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_manipulation_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_manipulation_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_manipulation_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_manipulation_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_manipulation_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_manipulation_statements() throws -> Cursor_manipulation_statementsContext {
		var _localctx: Cursor_manipulation_statementsContext = Cursor_manipulation_statementsContext(_ctx, getState())
		try enterRule(_localctx, 280, plsqlParser.RULE_cursor_manipulation_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2464)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,244, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2460)
		 		try close_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2461)
		 		try open_statement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2462)
		 		try fetch_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2463)
		 		try open_for_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Close_statementContext:ParserRuleContext {
		open func CLOSE() -> TerminalNode? { return getToken(plsqlParser.CLOSE, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_close_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterClose_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitClose_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitClose_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitClose_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func close_statement() throws -> Close_statementContext {
		var _localctx: Close_statementContext = Close_statementContext(_ctx, getState())
		try enterRule(_localctx, 282, plsqlParser.RULE_close_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2466)
		 	try match(plsqlParser.CLOSE)
		 	setState(2467)
		 	try cursor_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_statementContext:ParserRuleContext {
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.OPEN, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_open_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOpen_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOpen_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOpen_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOpen_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_statement() throws -> Open_statementContext {
		var _localctx: Open_statementContext = Open_statementContext(_ctx, getState())
		try enterRule(_localctx, 284, plsqlParser.RULE_open_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2469)
		 	try match(plsqlParser.OPEN)
		 	setState(2470)
		 	try cursor_name()
		 	setState(2472)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(2471)
		 		try expression_list()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Fetch_statementContext:ParserRuleContext {
		public var it1: Token!
		open func FETCH() -> TerminalNode? { return getToken(plsqlParser.FETCH, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func variable_name() -> Array<Variable_nameContext> {
			return getRuleContexts(Variable_nameContext.self)
		}
		open func variable_name(_ i: Int) -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,i)
		}
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.BULK, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.COLLECT, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_fetch_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFetch_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFetch_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFetch_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFetch_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fetch_statement() throws -> Fetch_statementContext {
		var _localctx: Fetch_statementContext = Fetch_statementContext(_ctx, getState())
		try enterRule(_localctx, 286, plsqlParser.RULE_fetch_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2474)
		 	try match(plsqlParser.FETCH)
		 	setState(2475)
		 	try cursor_name()
		 	setState(2496)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INTO:
		 		setState(2476)
		 		try {
		 				let assignmentValue = try match(plsqlParser.INTO)
		 				_localctx.castdown(Fetch_statementContext.self).it1 = assignmentValue
		 		     }()

		 		setState(2477)
		 		try variable_name()
		 		setState(2482)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2478)
		 			try match(plsqlParser.COMMA)
		 			setState(2479)
		 			try variable_name()


		 			setState(2484)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case plsqlParser.BULK:
		 		setState(2485)
		 		try match(plsqlParser.BULK)
		 		setState(2486)
		 		try match(plsqlParser.COLLECT)
		 		setState(2487)
		 		try match(plsqlParser.INTO)
		 		setState(2488)
		 		try variable_name()
		 		setState(2493)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2489)
		 			try match(plsqlParser.COMMA)
		 			setState(2490)
		 			try variable_name()


		 			setState(2495)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_for_statementContext:ParserRuleContext {
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.OPEN, 0) }
		open func variable_name() -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_open_for_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOpen_for_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOpen_for_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOpen_for_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOpen_for_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_for_statement() throws -> Open_for_statementContext {
		var _localctx: Open_for_statementContext = Open_for_statementContext(_ctx, getState())
		try enterRule(_localctx, 288, plsqlParser.RULE_open_for_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2498)
		 	try match(plsqlParser.OPEN)
		 	setState(2499)
		 	try variable_name()
		 	setState(2500)
		 	try match(plsqlParser.FOR)
		 	setState(2503)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,249, _ctx)) {
		 	case 1:
		 		setState(2501)
		 		try select_statement()

		 		break
		 	case 2:
		 		setState(2502)
		 		try expression()

		 		break
		 	default: break
		 	}
		 	setState(2506)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.USING
		 	      return testSet
		 	 }()) {
		 		setState(2505)
		 		try using_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Transaction_control_statementsContext:ParserRuleContext {
		open func set_transaction_command() -> Set_transaction_commandContext? {
			return getRuleContext(Set_transaction_commandContext.self,0)
		}
		open func set_constraint_command() -> Set_constraint_commandContext? {
			return getRuleContext(Set_constraint_commandContext.self,0)
		}
		open func commit_statement() -> Commit_statementContext? {
			return getRuleContext(Commit_statementContext.self,0)
		}
		open func rollback_statement() -> Rollback_statementContext? {
			return getRuleContext(Rollback_statementContext.self,0)
		}
		open func savepoint_statement() -> Savepoint_statementContext? {
			return getRuleContext(Savepoint_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_transaction_control_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTransaction_control_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTransaction_control_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTransaction_control_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTransaction_control_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func transaction_control_statements() throws -> Transaction_control_statementsContext {
		var _localctx: Transaction_control_statementsContext = Transaction_control_statementsContext(_ctx, getState())
		try enterRule(_localctx, 290, plsqlParser.RULE_transaction_control_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2513)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,251, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2508)
		 		try set_transaction_command()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2509)
		 		try set_constraint_command()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2510)
		 		try commit_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2511)
		 		try rollback_statement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2512)
		 		try savepoint_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_transaction_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.TRANSACTION, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.READ, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(plsqlParser.ISOLATION, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(plsqlParser.LEVEL, 0) }
		open func USE() -> TerminalNode? { return getToken(plsqlParser.USE, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.ROLLBACK, 0) }
		open func SEGMENT() -> TerminalNode? { return getToken(plsqlParser.SEGMENT, 0) }
		open func rollback_segment_name() -> Rollback_segment_nameContext? {
			return getRuleContext(Rollback_segment_nameContext.self,0)
		}
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.ONLY, 0) }
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.WRITE, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(plsqlParser.SERIALIZABLE, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(plsqlParser.COMMITTED, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_transaction_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_transaction_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_transaction_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_transaction_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_transaction_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_transaction_command() throws -> Set_transaction_commandContext {
		var _localctx: Set_transaction_commandContext = Set_transaction_commandContext(_ctx, getState())
		try enterRule(_localctx, 292, plsqlParser.RULE_set_transaction_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2515)
		 	try match(plsqlParser.SET)
		 	setState(2516)
		 	try match(plsqlParser.TRANSACTION)
		 	setState(2530)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.READ:
		 	 	setState(2517)
		 	 	try match(plsqlParser.READ)
		 	 	setState(2518)
		 	 	_la = try _input.LA(1)
		 	 	if (!(//closure
		 	 	 { () -> Bool in
		 	 	      var testSet: Bool = _la == plsqlParser.ONLY
		 	 	          testSet = testSet || _la == plsqlParser.WRITE
		 	 	      return testSet
		 	 	 }())) {
		 	 	try _errHandler.recoverInline(self)
		 	 	} else {
		 	 		try consume()
		 	 	}

		 		break

		 	case plsqlParser.ISOLATION:
		 	 	setState(2519)
		 	 	try match(plsqlParser.ISOLATION)
		 	 	setState(2520)
		 	 	try match(plsqlParser.LEVEL)
		 	 	setState(2524)
		 	 	try _errHandler.sync(self)
		 	 	switch (try _input.LA(1)) {
		 	 	case plsqlParser.SERIALIZABLE:
		 	 		setState(2521)
		 	 		try match(plsqlParser.SERIALIZABLE)

		 	 		break

		 	 	case plsqlParser.READ:
		 	 		setState(2522)
		 	 		try match(plsqlParser.READ)
		 	 		setState(2523)
		 	 		try match(plsqlParser.COMMITTED)

		 	 		break
		 	 	default:
		 	 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	 	}

		 		break

		 	case plsqlParser.USE:
		 	 	setState(2526)
		 	 	try match(plsqlParser.USE)
		 	 	setState(2527)
		 	 	try match(plsqlParser.ROLLBACK)
		 	 	setState(2528)
		 	 	try match(plsqlParser.SEGMENT)
		 	 	setState(2529)
		 	 	try rollback_segment_name()

		 		break
		 	case plsqlParser.EOF:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SEMICOLON:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2534)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NAME
		 	      return testSet
		 	 }()) {
		 		setState(2532)
		 		try match(plsqlParser.NAME)
		 		setState(2533)
		 		try quoted_string()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_constraint_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.CONSTRAINT, 0) }
		open func CONSTRAINTS() -> TerminalNode? { return getToken(plsqlParser.CONSTRAINTS, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.IMMEDIATE, 0) }
		open func DEFERRED() -> TerminalNode? { return getToken(plsqlParser.DEFERRED, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func constraint_name() -> Array<Constraint_nameContext> {
			return getRuleContexts(Constraint_nameContext.self)
		}
		open func constraint_name(_ i: Int) -> Constraint_nameContext? {
			return getRuleContext(Constraint_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_constraint_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_constraint_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_constraint_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_constraint_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_constraint_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_constraint_command() throws -> Set_constraint_commandContext {
		var _localctx: Set_constraint_commandContext = Set_constraint_commandContext(_ctx, getState())
		try enterRule(_localctx, 294, plsqlParser.RULE_set_constraint_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2536)
		 	try match(plsqlParser.SET)
		 	setState(2537)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.CONSTRAINT || _la == plsqlParser.CONSTRAINTS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2547)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.ALL:
		 		setState(2538)
		 		try match(plsqlParser.ALL)

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(2539)
		 		try constraint_name()
		 		setState(2544)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2540)
		 			try match(plsqlParser.COMMA)
		 			setState(2541)
		 			try constraint_name()


		 			setState(2546)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2549)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.DEFERRED || _la == plsqlParser.IMMEDIATE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Commit_statementContext:ParserRuleContext {
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.COMMIT, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.WORK, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.COMMENT, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.FORCE, 0) }
		open func write_clause() -> Write_clauseContext? {
			return getRuleContext(Write_clauseContext.self,0)
		}
		open func CORRUPT_XID() -> TerminalNode? { return getToken(plsqlParser.CORRUPT_XID, 0) }
		open func CORRUPT_XID_ALL() -> TerminalNode? { return getToken(plsqlParser.CORRUPT_XID_ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_commit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCommit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCommit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCommit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCommit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func commit_statement() throws -> Commit_statementContext {
		var _localctx: Commit_statementContext = Commit_statementContext(_ctx, getState())
		try enterRule(_localctx, 296, plsqlParser.RULE_commit_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2551)
		 	try match(plsqlParser.COMMIT)
		 	setState(2553)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WORK
		 	      return testSet
		 	 }()) {
		 		setState(2552)
		 		try match(plsqlParser.WORK)

		 	}

		 	setState(2568)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.COMMENT:
		 	 	setState(2555)
		 	 	try match(plsqlParser.COMMENT)
		 	 	setState(2556)
		 	 	try expression()

		 		break

		 	case plsqlParser.FORCE:
		 	 	setState(2557)
		 	 	try match(plsqlParser.FORCE)
		 	 	setState(2566)
		 	 	try _errHandler.sync(self)
		 	 	switch(try getInterpreter().adaptivePredict(_input,259, _ctx)) {
		 	 	case 1:
		 	 		setState(2558)
		 	 		try match(plsqlParser.CORRUPT_XID)
		 	 		setState(2559)
		 	 		try expression()

		 	 		break
		 	 	case 2:
		 	 		setState(2560)
		 	 		try match(plsqlParser.CORRUPT_XID_ALL)

		 	 		break
		 	 	case 3:
		 	 		setState(2561)
		 	 		try expression()
		 	 		setState(2564)
		 	 		try _errHandler.sync(self)
		 	 		_la = try _input.LA(1)
		 	 		if (//closure
		 	 		 { () -> Bool in
		 	 		      let testSet: Bool = _la == plsqlParser.COMMA
		 	 		      return testSet
		 	 		 }()) {
		 	 			setState(2562)
		 	 			try match(plsqlParser.COMMA)
		 	 			setState(2563)
		 	 			try expression()

		 	 		}


		 	 		break
		 	 	default: break
		 	 	}

		 		break
		 	case plsqlParser.EOF:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.SEMICOLON:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2571)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WRITE
		 	      return testSet
		 	 }()) {
		 		setState(2570)
		 		try write_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Write_clauseContext:ParserRuleContext {
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.WRITE, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.WAIT, 0) }
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.NOWAIT, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.IMMEDIATE, 0) }
		open func BATCH() -> TerminalNode? { return getToken(plsqlParser.BATCH, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_write_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWrite_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWrite_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWrite_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWrite_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func write_clause() throws -> Write_clauseContext {
		var _localctx: Write_clauseContext = Write_clauseContext(_ctx, getState())
		try enterRule(_localctx, 298, plsqlParser.RULE_write_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2573)
		 	try match(plsqlParser.WRITE)
		 	setState(2575)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.NOWAIT
		 	          testSet = testSet || _la == plsqlParser.WAIT
		 	      return testSet
		 	 }()) {
		 		setState(2574)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.NOWAIT
		 		          testSet = testSet || _la == plsqlParser.WAIT
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(2578)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.BATCH
		 	          testSet = testSet || _la == plsqlParser.IMMEDIATE
		 	      return testSet
		 	 }()) {
		 		setState(2577)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.BATCH
		 		          testSet = testSet || _la == plsqlParser.IMMEDIATE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollback_statementContext:ParserRuleContext {
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.ROLLBACK, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.WORK, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func savepoint_name() -> Savepoint_nameContext? {
			return getRuleContext(Savepoint_nameContext.self,0)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.FORCE, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.SAVEPOINT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollback_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollback_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollback_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollback_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollback_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollback_statement() throws -> Rollback_statementContext {
		var _localctx: Rollback_statementContext = Rollback_statementContext(_ctx, getState())
		try enterRule(_localctx, 300, plsqlParser.RULE_rollback_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2580)
		 	try match(plsqlParser.ROLLBACK)
		 	setState(2582)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WORK
		 	      return testSet
		 	 }()) {
		 		setState(2581)
		 		try match(plsqlParser.WORK)

		 	}

		 	setState(2591)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.TO:
		 	 	setState(2584)
		 	 	try match(plsqlParser.TO)
		 	 	setState(2586)
		 	 	try _errHandler.sync(self)
		 	 	switch (try getInterpreter().adaptivePredict(_input,265,_ctx)) {
		 	 	case 1:
		 	 		setState(2585)
		 	 		try match(plsqlParser.SAVEPOINT)

		 	 		break
		 	 	default: break
		 	 	}
		 	 	setState(2588)
		 	 	try savepoint_name()

		 		break

		 	case plsqlParser.FORCE:
		 	 	setState(2589)
		 	 	try match(plsqlParser.FORCE)
		 	 	setState(2590)
		 	 	try quoted_string()

		 		break
		 	case plsqlParser.EOF:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SEMICOLON:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Savepoint_statementContext:ParserRuleContext {
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.SAVEPOINT, 0) }
		open func savepoint_name() -> Savepoint_nameContext? {
			return getRuleContext(Savepoint_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_savepoint_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSavepoint_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSavepoint_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSavepoint_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSavepoint_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func savepoint_statement() throws -> Savepoint_statementContext {
		var _localctx: Savepoint_statementContext = Savepoint_statementContext(_ctx, getState())
		try enterRule(_localctx, 302, plsqlParser.RULE_savepoint_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2593)
		 	try match(plsqlParser.SAVEPOINT)
		 	setState(2594)
		 	try savepoint_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Explain_statementContext:ParserRuleContext {
		open func EXPLAIN() -> TerminalNode? { return getToken(plsqlParser.EXPLAIN, 0) }
		open func PLAN() -> TerminalNode? { return getToken(plsqlParser.PLAN, 0) }
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func update_statement() -> Update_statementContext? {
			return getRuleContext(Update_statementContext.self,0)
		}
		open func delete_statement() -> Delete_statementContext? {
			return getRuleContext(Delete_statementContext.self,0)
		}
		open func insert_statement() -> Insert_statementContext? {
			return getRuleContext(Insert_statementContext.self,0)
		}
		open func merge_statement() -> Merge_statementContext? {
			return getRuleContext(Merge_statementContext.self,0)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func STATEMENT_ID() -> TerminalNode? { return getToken(plsqlParser.STATEMENT_ID, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_explain_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExplain_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExplain_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExplain_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExplain_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func explain_statement() throws -> Explain_statementContext {
		var _localctx: Explain_statementContext = Explain_statementContext(_ctx, getState())
		try enterRule(_localctx, 304, plsqlParser.RULE_explain_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2596)
		 	try match(plsqlParser.EXPLAIN)
		 	setState(2597)
		 	try match(plsqlParser.PLAN)
		 	setState(2602)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.SET
		 	      return testSet
		 	 }()) {
		 		setState(2598)
		 		try match(plsqlParser.SET)
		 		setState(2599)
		 		try match(plsqlParser.STATEMENT_ID)
		 		setState(2600)
		 		try match(plsqlParser.EQUALS_OP)
		 		setState(2601)
		 		try quoted_string()

		 	}

		 	setState(2606)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTO
		 	      return testSet
		 	 }()) {
		 		setState(2604)
		 		try match(plsqlParser.INTO)
		 		setState(2605)
		 		try tableview_name()

		 	}

		 	setState(2608)
		 	try match(plsqlParser.FOR)
		 	setState(2614)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.SELECT:fallthrough
		 	case plsqlParser.WITH:fallthrough
		 	case plsqlParser.LEFT_PAREN:
		 		setState(2609)
		 		try select_statement()

		 		break

		 	case plsqlParser.UPDATE:
		 		setState(2610)
		 		try update_statement()

		 		break

		 	case plsqlParser.DELETE:
		 		setState(2611)
		 		try delete_statement()

		 		break

		 	case plsqlParser.INSERT:
		 		setState(2612)
		 		try insert_statement()

		 		break

		 	case plsqlParser.MERGE:
		 		setState(2613)
		 		try merge_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_statementContext:ParserRuleContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func subquery_factoring_clause() -> Subquery_factoring_clauseContext? {
			return getRuleContext(Subquery_factoring_clauseContext.self,0)
		}
		open func for_update_clause() -> Array<For_update_clauseContext> {
			return getRuleContexts(For_update_clauseContext.self)
		}
		open func for_update_clause(_ i: Int) -> For_update_clauseContext? {
			return getRuleContext(For_update_clauseContext.self,i)
		}
		open func order_by_clause() -> Array<Order_by_clauseContext> {
			return getRuleContexts(Order_by_clauseContext.self)
		}
		open func order_by_clause(_ i: Int) -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_select_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelect_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelect_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelect_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelect_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_statement() throws -> Select_statementContext {
		var _localctx: Select_statementContext = Select_statementContext(_ctx, getState())
		try enterRule(_localctx, 306, plsqlParser.RULE_select_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2617)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WITH
		 	      return testSet
		 	 }()) {
		 		setState(2616)
		 		try subquery_factoring_clause()

		 	}

		 	setState(2619)
		 	try subquery()
		 	setState(2624)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.FOR
		 	          testSet = testSet || _la == plsqlParser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(2622)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.FOR:
		 			setState(2620)
		 			try for_update_clause()

		 			break

		 		case plsqlParser.ORDER:
		 			setState(2621)
		 			try order_by_clause()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2626)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_factoring_clauseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func factoring_element() -> Array<Factoring_elementContext> {
			return getRuleContexts(Factoring_elementContext.self)
		}
		open func factoring_element(_ i: Int) -> Factoring_elementContext? {
			return getRuleContext(Factoring_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_factoring_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_factoring_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_factoring_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_factoring_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_factoring_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_factoring_clause() throws -> Subquery_factoring_clauseContext {
		var _localctx: Subquery_factoring_clauseContext = Subquery_factoring_clauseContext(_ctx, getState())
		try enterRule(_localctx, 308, plsqlParser.RULE_subquery_factoring_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2627)
		 	try match(plsqlParser.WITH)
		 	setState(2628)
		 	try factoring_element()
		 	setState(2633)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(2629)
		 		try match(plsqlParser.COMMA)
		 		setState(2630)
		 		try factoring_element()


		 		setState(2635)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Factoring_elementContext:ParserRuleContext {
		open func query_name() -> Query_nameContext? {
			return getRuleContext(Query_nameContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func search_clause() -> Search_clauseContext? {
			return getRuleContext(Search_clauseContext.self,0)
		}
		open func cycle_clause() -> Cycle_clauseContext? {
			return getRuleContext(Cycle_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_factoring_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFactoring_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFactoring_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFactoring_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFactoring_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func factoring_element() throws -> Factoring_elementContext {
		var _localctx: Factoring_elementContext = Factoring_elementContext(_ctx, getState())
		try enterRule(_localctx, 310, plsqlParser.RULE_factoring_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2636)
		 	try query_name()
		 	setState(2648)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(2637)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2638)
		 		try column_name()
		 		setState(2643)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2639)
		 			try match(plsqlParser.COMMA)
		 			setState(2640)
		 			try column_name()


		 			setState(2645)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2646)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(2650)
		 	try match(plsqlParser.AS)
		 	setState(2651)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2652)
		 	try subquery()
		 	setState(2654)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(2653)
		 		try order_by_clause()

		 	}

		 	setState(2656)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(2658)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.SEARCH
		 	      return testSet
		 	 }()) {
		 		setState(2657)
		 		try search_clause()

		 	}

		 	setState(2661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.CYCLE
		 	      return testSet
		 	 }()) {
		 		setState(2660)
		 		try cycle_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_clauseContext:ParserRuleContext {
		open func SEARCH() -> TerminalNode? { return getToken(plsqlParser.SEARCH, 0) }
		open func FIRST() -> Array<TerminalNode> { return getTokens(plsqlParser.FIRST) }
		open func FIRST(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.FIRST, i)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func DEPTH() -> TerminalNode? { return getToken(plsqlParser.DEPTH, 0) }
		open func BREADTH() -> TerminalNode? { return getToken(plsqlParser.BREADTH, 0) }
		open func ASC() -> Array<TerminalNode> { return getTokens(plsqlParser.ASC) }
		open func ASC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.ASC, i)
		}
		open func DESC() -> Array<TerminalNode> { return getTokens(plsqlParser.DESC) }
		open func DESC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.DESC, i)
		}
		open func NULLS() -> Array<TerminalNode> { return getTokens(plsqlParser.NULLS) }
		open func NULLS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NULLS, i)
		}
		open func LAST() -> Array<TerminalNode> { return getTokens(plsqlParser.LAST) }
		open func LAST(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.LAST, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_search_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearch_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearch_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearch_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearch_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_clause() throws -> Search_clauseContext {
		var _localctx: Search_clauseContext = Search_clauseContext(_ctx, getState())
		try enterRule(_localctx, 312, plsqlParser.RULE_search_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2663)
		 	try match(plsqlParser.SEARCH)
		 	setState(2664)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.BREADTH
		 	          testSet = testSet || _la == plsqlParser.DEPTH
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2665)
		 	try match(plsqlParser.FIRST)
		 	setState(2666)
		 	try match(plsqlParser.BY)
		 	setState(2667)
		 	try column_name()
		 	setState(2669)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ASC
		 	      return testSet
		 	 }()) {
		 		setState(2668)
		 		try match(plsqlParser.ASC)

		 	}

		 	setState(2672)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.DESC
		 	      return testSet
		 	 }()) {
		 		setState(2671)
		 		try match(plsqlParser.DESC)

		 	}

		 	setState(2676)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,281,_ctx)) {
		 	case 1:
		 		setState(2674)
		 		try match(plsqlParser.NULLS)
		 		setState(2675)
		 		try match(plsqlParser.FIRST)

		 		break
		 	default: break
		 	}
		 	setState(2680)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NULLS
		 	      return testSet
		 	 }()) {
		 		setState(2678)
		 		try match(plsqlParser.NULLS)
		 		setState(2679)
		 		try match(plsqlParser.LAST)

		 	}

		 	setState(2700)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(2682)
		 		try match(plsqlParser.COMMA)
		 		setState(2683)
		 		try column_name()
		 		setState(2685)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.ASC
		 		      return testSet
		 		 }()) {
		 			setState(2684)
		 			try match(plsqlParser.ASC)

		 		}

		 		setState(2688)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DESC
		 		      return testSet
		 		 }()) {
		 			setState(2687)
		 			try match(plsqlParser.DESC)

		 		}

		 		setState(2692)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,285,_ctx)) {
		 		case 1:
		 			setState(2690)
		 			try match(plsqlParser.NULLS)
		 			setState(2691)
		 			try match(plsqlParser.FIRST)

		 			break
		 		default: break
		 		}
		 		setState(2696)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.NULLS
		 		      return testSet
		 		 }()) {
		 			setState(2694)
		 			try match(plsqlParser.NULLS)
		 			setState(2695)
		 			try match(plsqlParser.LAST)

		 		}



		 		setState(2702)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2703)
		 	try match(plsqlParser.SET)
		 	setState(2704)
		 	try column_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cycle_clauseContext:ParserRuleContext {
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.CYCLE, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cycle_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCycle_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCycle_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCycle_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCycle_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cycle_clause() throws -> Cycle_clauseContext {
		var _localctx: Cycle_clauseContext = Cycle_clauseContext(_ctx, getState())
		try enterRule(_localctx, 314, plsqlParser.RULE_cycle_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2706)
		 	try match(plsqlParser.CYCLE)
		 	setState(2707)
		 	try column_name()
		 	setState(2712)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(2708)
		 		try match(plsqlParser.COMMA)
		 		setState(2709)
		 		try column_name()


		 		setState(2714)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2715)
		 	try match(plsqlParser.SET)
		 	setState(2716)
		 	try column_name()
		 	setState(2717)
		 	try match(plsqlParser.TO)
		 	setState(2718)
		 	try expression()
		 	setState(2719)
		 	try match(plsqlParser.DEFAULT)
		 	setState(2720)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubqueryContext:ParserRuleContext {
		open func subquery_basic_elements() -> Subquery_basic_elementsContext? {
			return getRuleContext(Subquery_basic_elementsContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery() throws -> SubqueryContext {
		var _localctx: SubqueryContext = SubqueryContext(_ctx, getState())
		try enterRule(_localctx, 316, plsqlParser.RULE_subquery)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2722)
		 	try subquery_basic_elements()
		 	setState(2726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.INTERSECT || _la == plsqlParser.MINUS
		 	          testSet = testSet || _la == plsqlParser.UNION
		 	      return testSet
		 	 }()) {
		 		setState(2723)
		 		try subquery_operation_part()


		 		setState(2728)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_operation_partContext:ParserRuleContext {
		open func subquery_basic_elements() -> Subquery_basic_elementsContext? {
			return getRuleContext(Subquery_basic_elementsContext.self,0)
		}
		open func UNION() -> TerminalNode? { return getToken(plsqlParser.UNION, 0) }
		open func INTERSECT() -> TerminalNode? { return getToken(plsqlParser.INTERSECT, 0) }
		open func MINUS() -> TerminalNode? { return getToken(plsqlParser.MINUS, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_operation_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_operation_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_operation_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_operation_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_operation_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_operation_part() throws -> Subquery_operation_partContext {
		var _localctx: Subquery_operation_partContext = Subquery_operation_partContext(_ctx, getState())
		try enterRule(_localctx, 318, plsqlParser.RULE_subquery_operation_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2735)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.UNION:
		 		setState(2729)
		 		try match(plsqlParser.UNION)
		 		setState(2731)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.ALL
		 		      return testSet
		 		 }()) {
		 			setState(2730)
		 			try match(plsqlParser.ALL)

		 		}


		 		break

		 	case plsqlParser.INTERSECT:
		 		setState(2733)
		 		try match(plsqlParser.INTERSECT)

		 		break

		 	case plsqlParser.MINUS:
		 		setState(2734)
		 		try match(plsqlParser.MINUS)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2737)
		 	try subquery_basic_elements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_basic_elementsContext:ParserRuleContext {
		open func query_block() -> Query_blockContext? {
			return getRuleContext(Query_blockContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_basic_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_basic_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_basic_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_basic_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_basic_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_basic_elements() throws -> Subquery_basic_elementsContext {
		var _localctx: Subquery_basic_elementsContext = Subquery_basic_elementsContext(_ctx, getState())
		try enterRule(_localctx, 320, plsqlParser.RULE_subquery_basic_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2744)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.SELECT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2739)
		 		try query_block()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2740)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2741)
		 		try subquery()
		 		setState(2742)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_blockContext:ParserRuleContext {
		open func SELECT() -> TerminalNode? { return getToken(plsqlParser.SELECT, 0) }
		open func from_clause() -> From_clauseContext? {
			return getRuleContext(From_clauseContext.self,0)
		}
		open func selected_element() -> Array<Selected_elementContext> {
			return getRuleContexts(Selected_elementContext.self)
		}
		open func selected_element(_ i: Int) -> Selected_elementContext? {
			return getRuleContext(Selected_elementContext.self,i)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func hierarchical_query_clause() -> Hierarchical_query_clauseContext? {
			return getRuleContext(Hierarchical_query_clauseContext.self,0)
		}
		open func group_by_clause() -> Group_by_clauseContext? {
			return getRuleContext(Group_by_clauseContext.self,0)
		}
		open func model_clause() -> Model_clauseContext? {
			return getRuleContext(Model_clauseContext.self,0)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.DISTINCT, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.UNIQUE, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_block() throws -> Query_blockContext {
		var _localctx: Query_blockContext = Query_blockContext(_ctx, getState())
		try enterRule(_localctx, 322, plsqlParser.RULE_query_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2746)
		 	try match(plsqlParser.SELECT)
		 	setState(2748)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,293,_ctx)) {
		 	case 1:
		 		setState(2747)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.ALL
		 		          testSet = testSet || _la == plsqlParser.DISTINCT
		 		          testSet = testSet || _la == plsqlParser.UNIQUE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2759)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.ASTERISK:
		 		setState(2750)
		 		try match(plsqlParser.ASTERISK)

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NOT:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(2751)
		 		try selected_element()
		 		setState(2756)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2752)
		 			try match(plsqlParser.COMMA)
		 			setState(2753)
		 			try selected_element()


		 			setState(2758)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2762)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.BULK
		 	          testSet = testSet || _la == plsqlParser.INTO
		 	      return testSet
		 	 }()) {
		 		setState(2761)
		 		try into_clause()

		 	}

		 	setState(2764)
		 	try from_clause()
		 	setState(2766)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,297,_ctx)) {
		 	case 1:
		 		setState(2765)
		 		try where_clause()

		 		break
		 	default: break
		 	}
		 	setState(2769)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,298,_ctx)) {
		 	case 1:
		 		setState(2768)
		 		try hierarchical_query_clause()

		 		break
		 	default: break
		 	}
		 	setState(2772)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,299,_ctx)) {
		 	case 1:
		 		setState(2771)
		 		try group_by_clause()

		 		break
		 	default: break
		 	}
		 	setState(2775)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,300,_ctx)) {
		 	case 1:
		 		setState(2774)
		 		try model_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Selected_elementContext:ParserRuleContext {
		open func select_list_elements() -> Select_list_elementsContext? {
			return getRuleContext(Select_list_elementsContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_selected_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelected_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelected_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelected_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelected_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func selected_element() throws -> Selected_elementContext {
		var _localctx: Selected_elementContext = Selected_elementContext(_ctx, getState())
		try enterRule(_localctx, 324, plsqlParser.RULE_selected_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2777)
		 	try select_list_elements()
		 	setState(2779)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,301,_ctx)) {
		 	case 1:
		 		setState(2778)
		 		try column_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class From_clauseContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.FROM, 0) }
		open func table_ref_list() -> Table_ref_listContext? {
			return getRuleContext(Table_ref_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_from_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFrom_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFrom_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFrom_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFrom_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func from_clause() throws -> From_clauseContext {
		var _localctx: From_clauseContext = From_clauseContext(_ctx, getState())
		try enterRule(_localctx, 326, plsqlParser.RULE_from_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2781)
		 	try match(plsqlParser.FROM)
		 	setState(2782)
		 	try table_ref_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_list_elementsContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_select_list_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelect_list_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelect_list_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelect_list_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelect_list_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_list_elements() throws -> Select_list_elementsContext {
		var _localctx: Select_list_elementsContext = Select_list_elementsContext(_ctx, getState())
		try enterRule(_localctx, 328, plsqlParser.RULE_select_list_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2789)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,302, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2784)
		 		try tableview_name()
		 		setState(2785)
		 		try match(plsqlParser.PERIOD)
		 		setState(2786)
		 		try match(plsqlParser.ASTERISK)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2788)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_ref_listContext:ParserRuleContext {
		open func table_ref() -> Array<Table_refContext> {
			return getRuleContexts(Table_refContext.self)
		}
		open func table_ref(_ i: Int) -> Table_refContext? {
			return getRuleContext(Table_refContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref_list() throws -> Table_ref_listContext {
		var _localctx: Table_ref_listContext = Table_ref_listContext(_ctx, getState())
		try enterRule(_localctx, 330, plsqlParser.RULE_table_ref_list)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2791)
		 	try table_ref()
		 	setState(2796)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,303,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2792)
		 			try match(plsqlParser.COMMA)
		 			setState(2793)
		 			try table_ref()

		 	 
		 		}
		 		setState(2798)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,303,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_refContext:ParserRuleContext {
		open func table_ref_aux() -> Table_ref_auxContext? {
			return getRuleContext(Table_ref_auxContext.self,0)
		}
		open func join_clause() -> Array<Join_clauseContext> {
			return getRuleContexts(Join_clauseContext.self)
		}
		open func join_clause(_ i: Int) -> Join_clauseContext? {
			return getRuleContext(Join_clauseContext.self,i)
		}
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref() throws -> Table_refContext {
		var _localctx: Table_refContext = Table_refContext(_ctx, getState())
		try enterRule(_localctx, 332, plsqlParser.RULE_table_ref)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2799)
		 	try table_ref_aux()
		 	setState(2803)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,304,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2800)
		 			try join_clause()

		 	 
		 		}
		 		setState(2805)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,304,_ctx)
		 	}
		 	setState(2808)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,305,_ctx)) {
		 	case 1:
		 		setState(2806)
		 		try pivot_clause()

		 		break
		 	case 2:
		 		setState(2807)
		 		try unpivot_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_ref_auxContext:ParserRuleContext {
		open func dml_table_expression_clause() -> Dml_table_expression_clauseContext? {
			return getRuleContext(Dml_table_expression_clauseContext.self,0)
		}
		open func table_ref() -> Table_refContext? {
			return getRuleContext(Table_refContext.self,0)
		}
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.ONLY, 0) }
		open func flashback_query_clause() -> Array<Flashback_query_clauseContext> {
			return getRuleContexts(Flashback_query_clauseContext.self)
		}
		open func flashback_query_clause(_ i: Int) -> Flashback_query_clauseContext? {
			return getRuleContext(Flashback_query_clauseContext.self,i)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref_aux }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_aux(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_aux(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_aux(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_aux(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref_aux() throws -> Table_ref_auxContext {
		var _localctx: Table_ref_auxContext = Table_ref_auxContext(_ctx, getState())
		try enterRule(_localctx, 334, plsqlParser.RULE_table_ref_aux)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2838)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,310, _ctx)) {
		 	case 1:
		 		setState(2810)
		 		try dml_table_expression_clause()
		 		setState(2813)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,306,_ctx)) {
		 		case 1:
		 			setState(2811)
		 			try pivot_clause()

		 			break
		 		case 2:
		 			setState(2812)
		 			try unpivot_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(2815)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2816)
		 		try table_ref()
		 		setState(2820)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.INTERSECT || _la == plsqlParser.MINUS
		 		          testSet = testSet || _la == plsqlParser.UNION
		 		      return testSet
		 		 }()) {
		 			setState(2817)
		 			try subquery_operation_part()


		 			setState(2822)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2823)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(2826)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,308,_ctx)) {
		 		case 1:
		 			setState(2824)
		 			try pivot_clause()

		 			break
		 		case 2:
		 			setState(2825)
		 			try unpivot_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		setState(2828)
		 		try match(plsqlParser.ONLY)
		 		setState(2829)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2830)
		 		try dml_table_expression_clause()
		 		setState(2831)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 4:
		 		setState(2833)
		 		try dml_table_expression_clause()
		 		setState(2836)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,309,_ctx)) {
		 		case 1:
		 			setState(2834)
		 			try pivot_clause()

		 			break
		 		case 2:
		 			setState(2835)
		 			try unpivot_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2843)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,311,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2840)
		 			try flashback_query_clause()

		 	 
		 		}
		 		setState(2845)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,311,_ctx)
		 	}
		 	setState(2847)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,312,_ctx)) {
		 	case 1:
		 		setState(2846)
		 		try table_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_clauseContext:ParserRuleContext {
		open func JOIN() -> TerminalNode? { return getToken(plsqlParser.JOIN, 0) }
		open func table_ref_aux() -> Table_ref_auxContext? {
			return getRuleContext(Table_ref_auxContext.self,0)
		}
		open func query_partition_clause() -> Array<Query_partition_clauseContext> {
			return getRuleContexts(Query_partition_clauseContext.self)
		}
		open func query_partition_clause(_ i: Int) -> Query_partition_clauseContext? {
			return getRuleContext(Query_partition_clauseContext.self,i)
		}
		open func INNER() -> TerminalNode? { return getToken(plsqlParser.INNER, 0) }
		open func outer_join_type() -> Outer_join_typeContext? {
			return getRuleContext(Outer_join_typeContext.self,0)
		}
		open func join_on_part() -> Array<Join_on_partContext> {
			return getRuleContexts(Join_on_partContext.self)
		}
		open func join_on_part(_ i: Int) -> Join_on_partContext? {
			return getRuleContext(Join_on_partContext.self,i)
		}
		open func join_using_part() -> Array<Join_using_partContext> {
			return getRuleContexts(Join_using_partContext.self)
		}
		open func join_using_part(_ i: Int) -> Join_using_partContext? {
			return getRuleContext(Join_using_partContext.self,i)
		}
		open func CROSS() -> TerminalNode? { return getToken(plsqlParser.CROSS, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.NATURAL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_clause() throws -> Join_clauseContext {
		var _localctx: Join_clauseContext = Join_clauseContext(_ctx, getState())
		try enterRule(_localctx, 336, plsqlParser.RULE_join_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2850)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PARTITION
		 	      return testSet
		 	 }()) {
		 		setState(2849)
		 		try query_partition_clause()

		 	}

		 	setState(2853)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CROSS
		 	          testSet = testSet || _la == plsqlParser.NATURAL
		 	      return testSet
		 	 }()) {
		 		setState(2852)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.CROSS
		 		          testSet = testSet || _la == plsqlParser.NATURAL
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(2857)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INNER:
		 	 	setState(2855)
		 	 	try match(plsqlParser.INNER)

		 		break
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.RIGHT:
		 	 	setState(2856)
		 	 	try outer_join_type()

		 		break

		 	case plsqlParser.JOIN:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2859)
		 	try match(plsqlParser.JOIN)
		 	setState(2860)
		 	try table_ref_aux()
		 	setState(2862)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,316,_ctx)) {
		 	case 1:
		 		setState(2861)
		 		try query_partition_clause()

		 		break
		 	default: break
		 	}
		 	setState(2868)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,318,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2866)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.ON:
		 				setState(2864)
		 				try join_on_part()

		 				break

		 			case plsqlParser.USING:
		 				setState(2865)
		 				try join_using_part()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(2870)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,318,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_on_partContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_on_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_on_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_on_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_on_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_on_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_on_part() throws -> Join_on_partContext {
		var _localctx: Join_on_partContext = Join_on_partContext(_ctx, getState())
		try enterRule(_localctx, 338, plsqlParser.RULE_join_on_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2871)
		 	try match(plsqlParser.ON)
		 	setState(2872)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_using_partContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_using_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_using_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_using_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_using_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_using_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_using_part() throws -> Join_using_partContext {
		var _localctx: Join_using_partContext = Join_using_partContext(_ctx, getState())
		try enterRule(_localctx, 340, plsqlParser.RULE_join_using_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2874)
		 	try match(plsqlParser.USING)
		 	setState(2875)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2876)
		 	try column_name()
		 	setState(2881)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(2877)
		 		try match(plsqlParser.COMMA)
		 		setState(2878)
		 		try column_name()


		 		setState(2883)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2884)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Outer_join_typeContext:ParserRuleContext {
		open func FULL() -> TerminalNode? { return getToken(plsqlParser.FULL, 0) }
		open func LEFT() -> TerminalNode? { return getToken(plsqlParser.LEFT, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(plsqlParser.RIGHT, 0) }
		open func OUTER() -> TerminalNode? { return getToken(plsqlParser.OUTER, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_outer_join_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOuter_join_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOuter_join_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOuter_join_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOuter_join_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func outer_join_type() throws -> Outer_join_typeContext {
		var _localctx: Outer_join_typeContext = Outer_join_typeContext(_ctx, getState())
		try enterRule(_localctx, 342, plsqlParser.RULE_outer_join_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2886)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.FULL || _la == plsqlParser.LEFT
		 	          testSet = testSet || _la == plsqlParser.RIGHT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(2888)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OUTER
		 	      return testSet
		 	 }()) {
		 		setState(2887)
		 		try match(plsqlParser.OUTER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_partition_clauseContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.PARTITION, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_partition_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_partition_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_partition_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_partition_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_partition_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_partition_clause() throws -> Query_partition_clauseContext {
		var _localctx: Query_partition_clauseContext = Query_partition_clauseContext(_ctx, getState())
		try enterRule(_localctx, 344, plsqlParser.RULE_query_partition_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2890)
		 	try match(plsqlParser.PARTITION)
		 	setState(2891)
		 	try match(plsqlParser.BY)
		 	setState(2905)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,322, _ctx)) {
		 	case 1:
		 		setState(2892)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2893)
		 		try subquery()
		 		setState(2894)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 2:
		 		setState(2896)
		 		try expression_list()

		 		break
		 	case 3:
		 		setState(2897)
		 		try expression()
		 		setState(2902)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,321,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2898)
		 				try match(plsqlParser.COMMA)
		 				setState(2899)
		 				try expression()

		 		 
		 			}
		 			setState(2904)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,321,_ctx)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Flashback_query_clauseContext:ParserRuleContext {
		open func VERSIONS() -> TerminalNode? { return getToken(plsqlParser.VERSIONS, 0) }
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.BETWEEN, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func SCN() -> TerminalNode? { return getToken(plsqlParser.SCN, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(plsqlParser.SNAPSHOT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_flashback_query_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFlashback_query_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFlashback_query_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFlashback_query_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFlashback_query_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func flashback_query_clause() throws -> Flashback_query_clauseContext {
		var _localctx: Flashback_query_clauseContext = Flashback_query_clauseContext(_ctx, getState())
		try enterRule(_localctx, 346, plsqlParser.RULE_flashback_query_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2915)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.VERSIONS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2907)
		 		try match(plsqlParser.VERSIONS)
		 		setState(2908)
		 		try match(plsqlParser.BETWEEN)
		 		setState(2909)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.SCN || _la == plsqlParser.TIMESTAMP
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(2910)
		 		try expression()

		 		break

		 	case plsqlParser.AS:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2911)
		 		try match(plsqlParser.AS)
		 		setState(2912)
		 		try match(plsqlParser.OF)
		 		setState(2913)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.SCN,plsqlParser.SNAPSHOT,plsqlParser.TIMESTAMP]
		 		    return  Utils.testBitLeftShiftArray(testArray, 333)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(2914)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_clauseContext:ParserRuleContext {
		open func PIVOT() -> TerminalNode? { return getToken(plsqlParser.PIVOT, 0) }
		open func pivot_element() -> Array<Pivot_elementContext> {
			return getRuleContexts(Pivot_elementContext.self)
		}
		open func pivot_element(_ i: Int) -> Pivot_elementContext? {
			return getRuleContext(Pivot_elementContext.self,i)
		}
		open func pivot_for_clause() -> Pivot_for_clauseContext? {
			return getRuleContext(Pivot_for_clauseContext.self,0)
		}
		open func pivot_in_clause() -> Pivot_in_clauseContext? {
			return getRuleContext(Pivot_in_clauseContext.self,0)
		}
		open func XML() -> TerminalNode? { return getToken(plsqlParser.XML, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_clause() throws -> Pivot_clauseContext {
		var _localctx: Pivot_clauseContext = Pivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 348, plsqlParser.RULE_pivot_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2917)
		 	try match(plsqlParser.PIVOT)
		 	setState(2919)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.XML
		 	      return testSet
		 	 }()) {
		 		setState(2918)
		 		try match(plsqlParser.XML)

		 	}

		 	setState(2921)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2922)
		 	try pivot_element()
		 	setState(2927)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(2923)
		 		try match(plsqlParser.COMMA)
		 		setState(2924)
		 		try pivot_element()


		 		setState(2929)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2930)
		 	try pivot_for_clause()
		 	setState(2931)
		 	try pivot_in_clause()
		 	setState(2932)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_elementContext:ParserRuleContext {
		open func aggregate_function_name() -> Aggregate_function_nameContext? {
			return getRuleContext(Aggregate_function_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_element() throws -> Pivot_elementContext {
		var _localctx: Pivot_elementContext = Pivot_elementContext(_ctx, getState())
		try enterRule(_localctx, 350, plsqlParser.RULE_pivot_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2934)
		 	try aggregate_function_name()
		 	setState(2935)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2936)
		 	try expression()
		 	setState(2937)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(2939)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2938)
		 		try column_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_for_clauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_for_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_for_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_for_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_for_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_for_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_for_clause() throws -> Pivot_for_clauseContext {
		var _localctx: Pivot_for_clauseContext = Pivot_for_clauseContext(_ctx, getState())
		try enterRule(_localctx, 352, plsqlParser.RULE_pivot_for_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2941)
		 	try match(plsqlParser.FOR)
		 	setState(2954)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(2942)
		 		try column_name()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(2943)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2944)
		 		try column_name()
		 		setState(2949)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2945)
		 			try match(plsqlParser.COMMA)
		 			setState(2946)
		 			try column_name()


		 			setState(2951)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2952)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clauseContext:ParserRuleContext {
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func ANY() -> Array<TerminalNode> { return getTokens(plsqlParser.ANY) }
		open func ANY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.ANY, i)
		}
		open func pivot_in_clause_element() -> Array<Pivot_in_clause_elementContext> {
			return getRuleContexts(Pivot_in_clause_elementContext.self)
		}
		open func pivot_in_clause_element(_ i: Int) -> Pivot_in_clause_elementContext? {
			return getRuleContext(Pivot_in_clause_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause() throws -> Pivot_in_clauseContext {
		var _localctx: Pivot_in_clauseContext = Pivot_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 354, plsqlParser.RULE_pivot_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2956)
		 	try match(plsqlParser.IN)
		 	setState(2957)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(2975)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,331, _ctx)) {
		 	case 1:
		 		setState(2958)
		 		try subquery()

		 		break
		 	case 2:
		 		setState(2959)
		 		try match(plsqlParser.ANY)
		 		setState(2964)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2960)
		 			try match(plsqlParser.COMMA)
		 			setState(2961)
		 			try match(plsqlParser.ANY)


		 			setState(2966)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		setState(2967)
		 		try pivot_in_clause_element()
		 		setState(2972)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2968)
		 			try match(plsqlParser.COMMA)
		 			setState(2969)
		 			try pivot_in_clause_element()


		 			setState(2974)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2977)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clause_elementContext:ParserRuleContext {
		open func pivot_in_clause_elements() -> Pivot_in_clause_elementsContext? {
			return getRuleContext(Pivot_in_clause_elementsContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause_element() throws -> Pivot_in_clause_elementContext {
		var _localctx: Pivot_in_clause_elementContext = Pivot_in_clause_elementContext(_ctx, getState())
		try enterRule(_localctx, 356, plsqlParser.RULE_pivot_in_clause_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2979)
		 	try pivot_in_clause_elements()
		 	setState(2981)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(2980)
		 		try column_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clause_elementsContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause_elements() throws -> Pivot_in_clause_elementsContext {
		var _localctx: Pivot_in_clause_elementsContext = Pivot_in_clause_elementsContext(_ctx, getState())
		try enterRule(_localctx, 358, plsqlParser.RULE_pivot_in_clause_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2985)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,333, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2983)
		 		try expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2984)
		 		try expression_list()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_clauseContext:ParserRuleContext {
		open func UNPIVOT() -> TerminalNode? { return getToken(plsqlParser.UNPIVOT, 0) }
		open func pivot_for_clause() -> Pivot_for_clauseContext? {
			return getRuleContext(Pivot_for_clauseContext.self,0)
		}
		open func unpivot_in_clause() -> Unpivot_in_clauseContext? {
			return getRuleContext(Unpivot_in_clauseContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.NULLS, 0) }
		open func INCLUDE() -> TerminalNode? { return getToken(plsqlParser.INCLUDE, 0) }
		open func EXCLUDE() -> TerminalNode? { return getToken(plsqlParser.EXCLUDE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_clause() throws -> Unpivot_clauseContext {
		var _localctx: Unpivot_clauseContext = Unpivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 360, plsqlParser.RULE_unpivot_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2987)
		 	try match(plsqlParser.UNPIVOT)
		 	setState(2990)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.EXCLUDE || _la == plsqlParser.INCLUDE
		 	      return testSet
		 	 }()) {
		 		setState(2988)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.EXCLUDE || _la == plsqlParser.INCLUDE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(2989)
		 		try match(plsqlParser.NULLS)

		 	}

		 	setState(2992)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3005)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(2993)
		 		try column_name()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(2994)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(2995)
		 		try column_name()
		 		setState(3000)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(2996)
		 			try match(plsqlParser.COMMA)
		 			setState(2997)
		 			try column_name()


		 			setState(3002)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3003)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3007)
		 	try pivot_for_clause()
		 	setState(3008)
		 	try unpivot_in_clause()
		 	setState(3009)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_in_clauseContext:ParserRuleContext {
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func unpivot_in_elements() -> Array<Unpivot_in_elementsContext> {
			return getRuleContexts(Unpivot_in_elementsContext.self)
		}
		open func unpivot_in_elements(_ i: Int) -> Unpivot_in_elementsContext? {
			return getRuleContext(Unpivot_in_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_in_clause() throws -> Unpivot_in_clauseContext {
		var _localctx: Unpivot_in_clauseContext = Unpivot_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 362, plsqlParser.RULE_unpivot_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3011)
		 	try match(plsqlParser.IN)
		 	setState(3012)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3013)
		 	try unpivot_in_elements()
		 	setState(3018)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3014)
		 		try match(plsqlParser.COMMA)
		 		setState(3015)
		 		try unpivot_in_elements()


		 		setState(3020)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3021)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_in_elementsContext:ParserRuleContext {
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func constant() -> Array<ConstantContext> {
			return getRuleContexts(ConstantContext.self)
		}
		open func constant(_ i: Int) -> ConstantContext? {
			return getRuleContext(ConstantContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_in_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_in_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_in_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_in_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_in_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_in_elements() throws -> Unpivot_in_elementsContext {
		var _localctx: Unpivot_in_elementsContext = Unpivot_in_elementsContext(_ctx, getState())
		try enterRule(_localctx, 364, plsqlParser.RULE_unpivot_in_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3035)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(3023)
		 		try column_name()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(3024)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3025)
		 		try column_name()
		 		setState(3030)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3026)
		 			try match(plsqlParser.COMMA)
		 			setState(3027)
		 			try column_name()


		 			setState(3032)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3033)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3052)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AS
		 	      return testSet
		 	 }()) {
		 		setState(3037)
		 		try match(plsqlParser.AS)
		 		setState(3050)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.DATE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DEFAULT:fallthrough
		 		case plsqlParser.FALSE:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.NULL:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TRUE:fallthrough
		 		case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 		case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 		case plsqlParser.CHAR_STRING:
		 			setState(3038)
		 			try constant()

		 			break

		 		case plsqlParser.LEFT_PAREN:
		 			setState(3039)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(3040)
		 			try constant()
		 			setState(3045)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.COMMA
		 			      return testSet
		 			 }()) {
		 				setState(3041)
		 				try match(plsqlParser.COMMA)
		 				setState(3042)
		 				try constant()


		 				setState(3047)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(3048)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Hierarchical_query_clauseContext:ParserRuleContext {
		open func CONNECT() -> TerminalNode? { return getToken(plsqlParser.CONNECT, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.NOCYCLE, 0) }
		open func start_part() -> Start_partContext? {
			return getRuleContext(Start_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_hierarchical_query_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterHierarchical_query_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitHierarchical_query_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitHierarchical_query_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitHierarchical_query_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func hierarchical_query_clause() throws -> Hierarchical_query_clauseContext {
		var _localctx: Hierarchical_query_clauseContext = Hierarchical_query_clauseContext(_ctx, getState())
		try enterRule(_localctx, 366, plsqlParser.RULE_hierarchical_query_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3071)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.CONNECT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3054)
		 		try match(plsqlParser.CONNECT)
		 		setState(3055)
		 		try match(plsqlParser.BY)
		 		setState(3057)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,343,_ctx)) {
		 		case 1:
		 			setState(3056)
		 			try match(plsqlParser.NOCYCLE)

		 			break
		 		default: break
		 		}
		 		setState(3059)
		 		try condition()
		 		setState(3061)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,344,_ctx)) {
		 		case 1:
		 			setState(3060)
		 			try start_part()

		 			break
		 		default: break
		 		}

		 		break

		 	case plsqlParser.START:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3063)
		 		try start_part()
		 		setState(3064)
		 		try match(plsqlParser.CONNECT)
		 		setState(3065)
		 		try match(plsqlParser.BY)
		 		setState(3067)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,345,_ctx)) {
		 		case 1:
		 			setState(3066)
		 			try match(plsqlParser.NOCYCLE)

		 			break
		 		default: break
		 		}
		 		setState(3069)
		 		try condition()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Start_partContext:ParserRuleContext {
		open func START() -> TerminalNode? { return getToken(plsqlParser.START, 0) }
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_start_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStart_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStart_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStart_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStart_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func start_part() throws -> Start_partContext {
		var _localctx: Start_partContext = Start_partContext(_ctx, getState())
		try enterRule(_localctx, 368, plsqlParser.RULE_start_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3073)
		 	try match(plsqlParser.START)
		 	setState(3074)
		 	try match(plsqlParser.WITH)
		 	setState(3075)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Group_by_clauseContext:ParserRuleContext {
		open func GROUP() -> TerminalNode? { return getToken(plsqlParser.GROUP, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func group_by_elements() -> Array<Group_by_elementsContext> {
			return getRuleContexts(Group_by_elementsContext.self)
		}
		open func group_by_elements(_ i: Int) -> Group_by_elementsContext? {
			return getRuleContext(Group_by_elementsContext.self,i)
		}
		open func having_clause() -> Having_clauseContext? {
			return getRuleContext(Having_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_group_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGroup_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGroup_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGroup_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGroup_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func group_by_clause() throws -> Group_by_clauseContext {
		var _localctx: Group_by_clauseContext = Group_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 370, plsqlParser.RULE_group_by_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3103)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.GROUP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3077)
		 		try match(plsqlParser.GROUP)
		 		setState(3078)
		 		try match(plsqlParser.BY)
		 		setState(3079)
		 		try group_by_elements()
		 		setState(3084)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,347,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3080)
		 				try match(plsqlParser.COMMA)
		 				setState(3081)
		 				try group_by_elements()

		 		 
		 			}
		 			setState(3086)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,347,_ctx)
		 		}
		 		setState(3088)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,348,_ctx)) {
		 		case 1:
		 			setState(3087)
		 			try having_clause()

		 			break
		 		default: break
		 		}

		 		break

		 	case plsqlParser.HAVING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3090)
		 		try having_clause()
		 		setState(3101)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,350,_ctx)) {
		 		case 1:
		 			setState(3091)
		 			try match(plsqlParser.GROUP)
		 			setState(3092)
		 			try match(plsqlParser.BY)
		 			setState(3093)
		 			try group_by_elements()
		 			setState(3098)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,349,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(3094)
		 					try match(plsqlParser.COMMA)
		 					setState(3095)
		 					try group_by_elements()

		 			 
		 				}
		 				setState(3100)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,349,_ctx)
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Group_by_elementsContext:ParserRuleContext {
		open func grouping_sets_clause() -> Grouping_sets_clauseContext? {
			return getRuleContext(Grouping_sets_clauseContext.self,0)
		}
		open func rollup_cube_clause() -> Rollup_cube_clauseContext? {
			return getRuleContext(Rollup_cube_clauseContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_group_by_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGroup_by_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGroup_by_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGroup_by_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGroup_by_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func group_by_elements() throws -> Group_by_elementsContext {
		var _localctx: Group_by_elementsContext = Group_by_elementsContext(_ctx, getState())
		try enterRule(_localctx, 372, plsqlParser.RULE_group_by_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3108)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,352, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3105)
		 		try grouping_sets_clause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3106)
		 		try rollup_cube_clause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3107)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollup_cube_clauseContext:ParserRuleContext {
		open func grouping_sets_elements() -> Array<Grouping_sets_elementsContext> {
			return getRuleContexts(Grouping_sets_elementsContext.self)
		}
		open func grouping_sets_elements(_ i: Int) -> Grouping_sets_elementsContext? {
			return getRuleContext(Grouping_sets_elementsContext.self,i)
		}
		open func ROLLUP() -> TerminalNode? { return getToken(plsqlParser.ROLLUP, 0) }
		open func CUBE() -> TerminalNode? { return getToken(plsqlParser.CUBE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollup_cube_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollup_cube_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollup_cube_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollup_cube_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollup_cube_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollup_cube_clause() throws -> Rollup_cube_clauseContext {
		var _localctx: Rollup_cube_clauseContext = Rollup_cube_clauseContext(_ctx, getState())
		try enterRule(_localctx, 374, plsqlParser.RULE_rollup_cube_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3110)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.CUBE
		 	          testSet = testSet || _la == plsqlParser.ROLLUP
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3111)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3112)
		 	try grouping_sets_elements()
		 	setState(3117)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3113)
		 		try match(plsqlParser.COMMA)
		 		setState(3114)
		 		try grouping_sets_elements()


		 		setState(3119)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3120)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Grouping_sets_clauseContext:ParserRuleContext {
		open func GROUPING() -> TerminalNode? { return getToken(plsqlParser.GROUPING, 0) }
		open func SETS() -> TerminalNode? { return getToken(plsqlParser.SETS, 0) }
		open func grouping_sets_elements() -> Array<Grouping_sets_elementsContext> {
			return getRuleContexts(Grouping_sets_elementsContext.self)
		}
		open func grouping_sets_elements(_ i: Int) -> Grouping_sets_elementsContext? {
			return getRuleContext(Grouping_sets_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_grouping_sets_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGrouping_sets_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGrouping_sets_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGrouping_sets_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGrouping_sets_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func grouping_sets_clause() throws -> Grouping_sets_clauseContext {
		var _localctx: Grouping_sets_clauseContext = Grouping_sets_clauseContext(_ctx, getState())
		try enterRule(_localctx, 376, plsqlParser.RULE_grouping_sets_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3122)
		 	try match(plsqlParser.GROUPING)
		 	setState(3123)
		 	try match(plsqlParser.SETS)
		 	setState(3124)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3125)
		 	try grouping_sets_elements()
		 	setState(3130)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3126)
		 		try match(plsqlParser.COMMA)
		 		setState(3127)
		 		try grouping_sets_elements()


		 		setState(3132)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3133)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Grouping_sets_elementsContext:ParserRuleContext {
		open func rollup_cube_clause() -> Rollup_cube_clauseContext? {
			return getRuleContext(Rollup_cube_clauseContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_grouping_sets_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGrouping_sets_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGrouping_sets_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGrouping_sets_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGrouping_sets_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func grouping_sets_elements() throws -> Grouping_sets_elementsContext {
		var _localctx: Grouping_sets_elementsContext = Grouping_sets_elementsContext(_ctx, getState())
		try enterRule(_localctx, 378, plsqlParser.RULE_grouping_sets_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3138)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,355, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3135)
		 		try rollup_cube_clause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3136)
		 		try expression_list()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3137)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Having_clauseContext:ParserRuleContext {
		open func HAVING() -> TerminalNode? { return getToken(plsqlParser.HAVING, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_having_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterHaving_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitHaving_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitHaving_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitHaving_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func having_clause() throws -> Having_clauseContext {
		var _localctx: Having_clauseContext = Having_clauseContext(_ctx, getState())
		try enterRule(_localctx, 380, plsqlParser.RULE_having_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3140)
		 	try match(plsqlParser.HAVING)
		 	setState(3141)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_clauseContext:ParserRuleContext {
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.MODEL, 0) }
		open func main_model() -> Main_modelContext? {
			return getRuleContext(Main_modelContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open func return_rows_clause() -> Return_rows_clauseContext? {
			return getRuleContext(Return_rows_clauseContext.self,0)
		}
		open func reference_model() -> Array<Reference_modelContext> {
			return getRuleContexts(Reference_modelContext.self)
		}
		open func reference_model(_ i: Int) -> Reference_modelContext? {
			return getRuleContext(Reference_modelContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_clause() throws -> Model_clauseContext {
		var _localctx: Model_clauseContext = Model_clauseContext(_ctx, getState())
		try enterRule(_localctx, 382, plsqlParser.RULE_model_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3143)
		 	try match(plsqlParser.MODEL)
		 	setState(3147)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.IGNORE || _la == plsqlParser.KEEP
		 	          testSet = testSet || _la == plsqlParser.UNIQUE
		 	      return testSet
		 	 }()) {
		 		setState(3144)
		 		try cell_reference_options()


		 		setState(3149)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3151)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN
		 	      return testSet
		 	 }()) {
		 		setState(3150)
		 		try return_rows_clause()

		 	}

		 	setState(3156)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REFERENCE
		 	      return testSet
		 	 }()) {
		 		setState(3153)
		 		try reference_model()


		 		setState(3158)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3159)
		 	try main_model()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cell_reference_optionsContext:ParserRuleContext {
		open func NAV() -> TerminalNode? { return getToken(plsqlParser.NAV, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.IGNORE, 0) }
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.KEEP, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.UNIQUE, 0) }
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.DIMENSION, 0) }
		open func SINGLE() -> TerminalNode? { return getToken(plsqlParser.SINGLE, 0) }
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.REFERENCE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cell_reference_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCell_reference_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCell_reference_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCell_reference_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCell_reference_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cell_reference_options() throws -> Cell_reference_optionsContext {
		var _localctx: Cell_reference_optionsContext = Cell_reference_optionsContext(_ctx, getState())
		try enterRule(_localctx, 384, plsqlParser.RULE_cell_reference_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3169)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.KEEP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3161)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.IGNORE || _la == plsqlParser.KEEP
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(3162)
		 		try match(plsqlParser.NAV)

		 		break

		 	case plsqlParser.UNIQUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3163)
		 		try match(plsqlParser.UNIQUE)
		 		setState(3167)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.DIMENSION:
		 			setState(3164)
		 			try match(plsqlParser.DIMENSION)

		 			break

		 		case plsqlParser.SINGLE:
		 			setState(3165)
		 			try match(plsqlParser.SINGLE)
		 			setState(3166)
		 			try match(plsqlParser.REFERENCE)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Return_rows_clauseContext:ParserRuleContext {
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.ROWS, 0) }
		open func UPDATED() -> TerminalNode? { return getToken(plsqlParser.UPDATED, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_return_rows_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReturn_rows_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReturn_rows_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReturn_rows_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReturn_rows_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func return_rows_clause() throws -> Return_rows_clauseContext {
		var _localctx: Return_rows_clauseContext = Return_rows_clauseContext(_ctx, getState())
		try enterRule(_localctx, 386, plsqlParser.RULE_return_rows_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3171)
		 	try match(plsqlParser.RETURN)
		 	setState(3172)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ALL
		 	          testSet = testSet || _la == plsqlParser.UPDATED
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3173)
		 	try match(plsqlParser.ROWS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Reference_modelContext:ParserRuleContext {
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.REFERENCE, 0) }
		open func reference_model_name() -> Reference_model_nameContext? {
			return getRuleContext(Reference_model_nameContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func model_column_clauses() -> Model_column_clausesContext? {
			return getRuleContext(Model_column_clausesContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_reference_model }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReference_model(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReference_model(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReference_model(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReference_model(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reference_model() throws -> Reference_modelContext {
		var _localctx: Reference_modelContext = Reference_modelContext(_ctx, getState())
		try enterRule(_localctx, 388, plsqlParser.RULE_reference_model)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3175)
		 	try match(plsqlParser.REFERENCE)
		 	setState(3176)
		 	try reference_model_name()
		 	setState(3177)
		 	try match(plsqlParser.ON)
		 	setState(3178)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3179)
		 	try subquery()
		 	setState(3180)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(3181)
		 	try model_column_clauses()
		 	setState(3185)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.IGNORE || _la == plsqlParser.KEEP
		 	          testSet = testSet || _la == plsqlParser.UNIQUE
		 	      return testSet
		 	 }()) {
		 		setState(3182)
		 		try cell_reference_options()


		 		setState(3187)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Main_modelContext:ParserRuleContext {
		open func model_column_clauses() -> Model_column_clausesContext? {
			return getRuleContext(Model_column_clausesContext.self,0)
		}
		open func model_rules_clause() -> Model_rules_clauseContext? {
			return getRuleContext(Model_rules_clauseContext.self,0)
		}
		open func MAIN() -> TerminalNode? { return getToken(plsqlParser.MAIN, 0) }
		open func main_model_name() -> Main_model_nameContext? {
			return getRuleContext(Main_model_nameContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_main_model }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMain_model(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMain_model(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMain_model(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMain_model(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func main_model() throws -> Main_modelContext {
		var _localctx: Main_modelContext = Main_modelContext(_ctx, getState())
		try enterRule(_localctx, 390, plsqlParser.RULE_main_model)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3190)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.MAIN
		 	      return testSet
		 	 }()) {
		 		setState(3188)
		 		try match(plsqlParser.MAIN)
		 		setState(3189)
		 		try main_model_name()

		 	}

		 	setState(3192)
		 	try model_column_clauses()
		 	setState(3196)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.IGNORE || _la == plsqlParser.KEEP
		 	          testSet = testSet || _la == plsqlParser.UNIQUE
		 	      return testSet
		 	 }()) {
		 		setState(3193)
		 		try cell_reference_options()


		 		setState(3198)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3199)
		 	try model_rules_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_clausesContext:ParserRuleContext {
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.DIMENSION, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func model_column_list() -> Array<Model_column_listContext> {
			return getRuleContexts(Model_column_listContext.self)
		}
		open func model_column_list(_ i: Int) -> Model_column_listContext? {
			return getRuleContext(Model_column_listContext.self,i)
		}
		open func MEASURES() -> TerminalNode? { return getToken(plsqlParser.MEASURES, 0) }
		open func model_column_partition_part() -> Model_column_partition_partContext? {
			return getRuleContext(Model_column_partition_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_clauses }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_clauses(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_clauses(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_clauses(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_clauses(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_clauses() throws -> Model_column_clausesContext {
		var _localctx: Model_column_clausesContext = Model_column_clausesContext(_ctx, getState())
		try enterRule(_localctx, 392, plsqlParser.RULE_model_column_clauses)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3202)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PARTITION
		 	      return testSet
		 	 }()) {
		 		setState(3201)
		 		try model_column_partition_part()

		 	}

		 	setState(3204)
		 	try match(plsqlParser.DIMENSION)
		 	setState(3205)
		 	try match(plsqlParser.BY)
		 	setState(3206)
		 	try model_column_list()
		 	setState(3207)
		 	try match(plsqlParser.MEASURES)
		 	setState(3208)
		 	try model_column_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_partition_partContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.PARTITION, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func model_column_list() -> Model_column_listContext? {
			return getRuleContext(Model_column_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_partition_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_partition_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_partition_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_partition_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_partition_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_partition_part() throws -> Model_column_partition_partContext {
		var _localctx: Model_column_partition_partContext = Model_column_partition_partContext(_ctx, getState())
		try enterRule(_localctx, 394, plsqlParser.RULE_model_column_partition_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3210)
		 	try match(plsqlParser.PARTITION)
		 	setState(3211)
		 	try match(plsqlParser.BY)
		 	setState(3212)
		 	try model_column_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_listContext:ParserRuleContext {
		open func model_column() -> Array<Model_columnContext> {
			return getRuleContexts(Model_columnContext.self)
		}
		open func model_column(_ i: Int) -> Model_columnContext? {
			return getRuleContext(Model_columnContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_list() throws -> Model_column_listContext {
		var _localctx: Model_column_listContext = Model_column_listContext(_ctx, getState())
		try enterRule(_localctx, 396, plsqlParser.RULE_model_column_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3214)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3215)
		 	try model_column()
		 	setState(3220)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3216)
		 		try match(plsqlParser.COMMA)
		 		setState(3217)
		 		try model_column()


		 		setState(3222)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3223)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_columnContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column() throws -> Model_columnContext {
		var _localctx: Model_columnContext = Model_columnContext(_ctx, getState())
		try enterRule(_localctx, 398, plsqlParser.RULE_model_column)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3225)
		 	try expression()
		 	setState(3227)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(3226)
		 		try table_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_clauseContext:ParserRuleContext {
		open func model_rules_element() -> Array<Model_rules_elementContext> {
			return getRuleContexts(Model_rules_elementContext.self)
		}
		open func model_rules_element(_ i: Int) -> Model_rules_elementContext? {
			return getRuleContext(Model_rules_elementContext.self,i)
		}
		open func model_rules_part() -> Model_rules_partContext? {
			return getRuleContext(Model_rules_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_clause() throws -> Model_rules_clauseContext {
		var _localctx: Model_rules_clauseContext = Model_rules_clauseContext(_ctx, getState())
		try enterRule(_localctx, 400, plsqlParser.RULE_model_rules_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3230)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RULES
		 	      return testSet
		 	 }()) {
		 		setState(3229)
		 		try model_rules_part()

		 	}

		 	setState(3232)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3233)
		 	try model_rules_element()
		 	setState(3238)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3234)
		 		try match(plsqlParser.COMMA)
		 		setState(3235)
		 		try model_rules_element()


		 		setState(3240)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3241)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_partContext:ParserRuleContext {
		open func RULES() -> TerminalNode? { return getToken(plsqlParser.RULES, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.UPSERT, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open func model_iterate_clause() -> Model_iterate_clauseContext? {
			return getRuleContext(Model_iterate_clauseContext.self,0)
		}
		open func AUTOMATIC() -> TerminalNode? { return getToken(plsqlParser.AUTOMATIC, 0) }
		open func SEQUENTIAL() -> TerminalNode? { return getToken(plsqlParser.SEQUENTIAL, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_part() throws -> Model_rules_partContext {
		var _localctx: Model_rules_partContext = Model_rules_partContext(_ctx, getState())
		try enterRule(_localctx, 402, plsqlParser.RULE_model_rules_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3243)
		 	try match(plsqlParser.RULES)
		 	setState(3249)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.UPDATE:
		 	 	setState(3244)
		 	 	try match(plsqlParser.UPDATE)

		 		break

		 	case plsqlParser.UPSERT:
		 	 	setState(3245)
		 	 	try match(plsqlParser.UPSERT)
		 	 	setState(3247)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.ALL
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3246)
		 	 		try match(plsqlParser.ALL)

		 	 	}


		 		break
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.LEFT_PAREN:
		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.AUTOMATIC
		 	          testSet = testSet || _la == plsqlParser.SEQUENTIAL
		 	      return testSet
		 	 }()) {
		 		setState(3251)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.AUTOMATIC
		 		          testSet = testSet || _la == plsqlParser.SEQUENTIAL
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(3252)
		 		try match(plsqlParser.ORDER)

		 	}

		 	setState(3256)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ITERATE
		 	      return testSet
		 	 }()) {
		 		setState(3255)
		 		try model_iterate_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_elementContext:ParserRuleContext {
		open func cell_assignment() -> Cell_assignmentContext? {
			return getRuleContext(Cell_assignmentContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.UPSERT, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_element() throws -> Model_rules_elementContext {
		var _localctx: Model_rules_elementContext = Model_rules_elementContext(_ctx, getState())
		try enterRule(_localctx, 404, plsqlParser.RULE_model_rules_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3263)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,374,_ctx)) {
		 	case 1:
		 		setState(3258)
		 		try match(plsqlParser.UPDATE)

		 		break
		 	case 2:
		 		setState(3259)
		 		try match(plsqlParser.UPSERT)
		 		setState(3261)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,373,_ctx)) {
		 		case 1:
		 			setState(3260)
		 			try match(plsqlParser.ALL)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(3265)
		 	try cell_assignment()
		 	setState(3267)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(3266)
		 		try order_by_clause()

		 	}

		 	setState(3269)
		 	try match(plsqlParser.EQUALS_OP)
		 	setState(3270)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cell_assignmentContext:ParserRuleContext {
		open func model_expression() -> Model_expressionContext? {
			return getRuleContext(Model_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cell_assignment }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCell_assignment(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCell_assignment(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCell_assignment(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCell_assignment(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cell_assignment() throws -> Cell_assignmentContext {
		var _localctx: Cell_assignmentContext = Cell_assignmentContext(_ctx, getState())
		try enterRule(_localctx, 406, plsqlParser.RULE_cell_assignment)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3272)
		 	try model_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_iterate_clauseContext:ParserRuleContext {
		open func ITERATE() -> TerminalNode? { return getToken(plsqlParser.ITERATE, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func until_part() -> Until_partContext? {
			return getRuleContext(Until_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_iterate_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_iterate_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_iterate_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_iterate_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_iterate_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_iterate_clause() throws -> Model_iterate_clauseContext {
		var _localctx: Model_iterate_clauseContext = Model_iterate_clauseContext(_ctx, getState())
		try enterRule(_localctx, 408, plsqlParser.RULE_model_iterate_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3274)
		 	try match(plsqlParser.ITERATE)
		 	setState(3275)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3276)
		 	try expression()
		 	setState(3277)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(3279)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.UNTIL
		 	      return testSet
		 	 }()) {
		 		setState(3278)
		 		try until_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Until_partContext:ParserRuleContext {
		open func UNTIL() -> TerminalNode? { return getToken(plsqlParser.UNTIL, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_until_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUntil_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUntil_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUntil_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUntil_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func until_part() throws -> Until_partContext {
		var _localctx: Until_partContext = Until_partContext(_ctx, getState())
		try enterRule(_localctx, 410, plsqlParser.RULE_until_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3281)
		 	try match(plsqlParser.UNTIL)
		 	setState(3282)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3283)
		 	try condition()
		 	setState(3284)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_clauseContext:ParserRuleContext {
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func order_by_elements() -> Array<Order_by_elementsContext> {
			return getRuleContexts(Order_by_elementsContext.self)
		}
		open func order_by_elements(_ i: Int) -> Order_by_elementsContext? {
			return getRuleContext(Order_by_elementsContext.self,i)
		}
		open func SIBLINGS() -> TerminalNode? { return getToken(plsqlParser.SIBLINGS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_order_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOrder_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOrder_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOrder_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOrder_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_clause() throws -> Order_by_clauseContext {
		var _localctx: Order_by_clauseContext = Order_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 412, plsqlParser.RULE_order_by_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3286)
		 	try match(plsqlParser.ORDER)
		 	setState(3288)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.SIBLINGS
		 	      return testSet
		 	 }()) {
		 		setState(3287)
		 		try match(plsqlParser.SIBLINGS)

		 	}

		 	setState(3290)
		 	try match(plsqlParser.BY)
		 	setState(3291)
		 	try order_by_elements()
		 	setState(3296)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3292)
		 		try match(plsqlParser.COMMA)
		 		setState(3293)
		 		try order_by_elements()


		 		setState(3298)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_elementsContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.NULLS, 0) }
		open func ASC() -> TerminalNode? { return getToken(plsqlParser.ASC, 0) }
		open func DESC() -> TerminalNode? { return getToken(plsqlParser.DESC, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.FIRST, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.LAST, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_order_by_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOrder_by_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOrder_by_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOrder_by_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOrder_by_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_elements() throws -> Order_by_elementsContext {
		var _localctx: Order_by_elementsContext = Order_by_elementsContext(_ctx, getState())
		try enterRule(_localctx, 414, plsqlParser.RULE_order_by_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3299)
		 	try expression()
		 	setState(3301)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ASC
		 	          testSet = testSet || _la == plsqlParser.DESC
		 	      return testSet
		 	 }()) {
		 		setState(3300)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.ASC
		 		          testSet = testSet || _la == plsqlParser.DESC
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(3305)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NULLS
		 	      return testSet
		 	 }()) {
		 		setState(3303)
		 		try match(plsqlParser.NULLS)
		 		setState(3304)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.FIRST || _la == plsqlParser.LAST
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_clauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func for_update_of_part() -> For_update_of_partContext? {
			return getRuleContext(For_update_of_partContext.self,0)
		}
		open func for_update_options() -> For_update_optionsContext? {
			return getRuleContext(For_update_optionsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_clause() throws -> For_update_clauseContext {
		var _localctx: For_update_clauseContext = For_update_clauseContext(_ctx, getState())
		try enterRule(_localctx, 416, plsqlParser.RULE_for_update_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3307)
		 	try match(plsqlParser.FOR)
		 	setState(3308)
		 	try match(plsqlParser.UPDATE)
		 	setState(3310)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.OF
		 	      return testSet
		 	 }()) {
		 		setState(3309)
		 		try for_update_of_part()

		 	}

		 	setState(3313)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.NOWAIT
		 	          testSet = testSet || _la == plsqlParser.SKIP_
		 	          testSet = testSet || _la == plsqlParser.WAIT
		 	      return testSet
		 	 }()) {
		 		setState(3312)
		 		try for_update_options()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_of_partContext:ParserRuleContext {
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_of_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_of_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_of_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_of_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_of_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_of_part() throws -> For_update_of_partContext {
		var _localctx: For_update_of_partContext = For_update_of_partContext(_ctx, getState())
		try enterRule(_localctx, 418, plsqlParser.RULE_for_update_of_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3315)
		 	try match(plsqlParser.OF)
		 	setState(3316)
		 	try column_name()
		 	setState(3321)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3317)
		 		try match(plsqlParser.COMMA)
		 		setState(3318)
		 		try column_name()


		 		setState(3323)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_optionsContext:ParserRuleContext {
		open func SKIP_() -> TerminalNode? { return getToken(plsqlParser.SKIP_, 0) }
		open func LOCKED() -> TerminalNode? { return getToken(plsqlParser.LOCKED, 0) }
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.NOWAIT, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.WAIT, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_options() throws -> For_update_optionsContext {
		var _localctx: For_update_optionsContext = For_update_optionsContext(_ctx, getState())
		try enterRule(_localctx, 420, plsqlParser.RULE_for_update_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3329)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.SKIP_:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3324)
		 		try match(plsqlParser.SKIP_)
		 		setState(3325)
		 		try match(plsqlParser.LOCKED)

		 		break

		 	case plsqlParser.NOWAIT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3326)
		 		try match(plsqlParser.NOWAIT)

		 		break

		 	case plsqlParser.WAIT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3327)
		 		try match(plsqlParser.WAIT)
		 		setState(3328)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_statementContext:ParserRuleContext {
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func update_set_clause() -> Update_set_clauseContext? {
			return getRuleContext(Update_set_clauseContext.self,0)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_update_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpdate_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpdate_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpdate_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpdate_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_statement() throws -> Update_statementContext {
		var _localctx: Update_statementContext = Update_statementContext(_ctx, getState())
		try enterRule(_localctx, 422, plsqlParser.RULE_update_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3331)
		 	try match(plsqlParser.UPDATE)
		 	setState(3332)
		 	try general_table_ref()
		 	setState(3333)
		 	try update_set_clause()
		 	setState(3335)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHERE
		 	      return testSet
		 	 }()) {
		 		setState(3334)
		 		try where_clause()

		 	}

		 	setState(3338)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 	      return testSet
		 	 }()) {
		 		setState(3337)
		 		try static_returning_clause()

		 	}

		 	setState(3341)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LOG
		 	      return testSet
		 	 }()) {
		 		setState(3340)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_set_clauseContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func column_based_update_set_clause() -> Array<Column_based_update_set_clauseContext> {
			return getRuleContexts(Column_based_update_set_clauseContext.self)
		}
		open func column_based_update_set_clause(_ i: Int) -> Column_based_update_set_clauseContext? {
			return getRuleContext(Column_based_update_set_clauseContext.self,i)
		}
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.VALUE, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_update_set_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpdate_set_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpdate_set_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpdate_set_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpdate_set_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_set_clause() throws -> Update_set_clauseContext {
		var _localctx: Update_set_clauseContext = Update_set_clauseContext(_ctx, getState())
		try enterRule(_localctx, 424, plsqlParser.RULE_update_set_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3343)
		 	try match(plsqlParser.SET)
		 	setState(3359)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,389, _ctx)) {
		 	case 1:
		 		setState(3344)
		 		try column_based_update_set_clause()
		 		setState(3349)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3345)
		 			try match(plsqlParser.COMMA)
		 			setState(3346)
		 			try column_based_update_set_clause()


		 			setState(3351)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		setState(3352)
		 		try match(plsqlParser.VALUE)
		 		setState(3353)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3354)
		 		try id()
		 		setState(3355)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(3356)
		 		try match(plsqlParser.EQUALS_OP)
		 		setState(3357)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_based_update_set_clauseContext:ParserRuleContext {
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_based_update_set_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_based_update_set_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_based_update_set_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_based_update_set_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_based_update_set_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_based_update_set_clause() throws -> Column_based_update_set_clauseContext {
		var _localctx: Column_based_update_set_clauseContext = Column_based_update_set_clauseContext(_ctx, getState())
		try enterRule(_localctx, 426, plsqlParser.RULE_column_based_update_set_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3378)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3361)
		 		try column_name()
		 		setState(3362)
		 		try match(plsqlParser.EQUALS_OP)
		 		setState(3363)
		 		try expression()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3365)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3366)
		 		try column_name()
		 		setState(3371)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3367)
		 			try match(plsqlParser.COMMA)
		 			setState(3368)
		 			try column_name()


		 			setState(3373)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3374)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(3375)
		 		try match(plsqlParser.EQUALS_OP)
		 		setState(3376)
		 		try subquery()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Delete_statementContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.DELETE, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.FROM, 0) }
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_delete_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDelete_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDelete_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDelete_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDelete_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func delete_statement() throws -> Delete_statementContext {
		var _localctx: Delete_statementContext = Delete_statementContext(_ctx, getState())
		try enterRule(_localctx, 428, plsqlParser.RULE_delete_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3380)
		 	try match(plsqlParser.DELETE)
		 	setState(3382)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FROM
		 	      return testSet
		 	 }()) {
		 		setState(3381)
		 		try match(plsqlParser.FROM)

		 	}

		 	setState(3384)
		 	try general_table_ref()
		 	setState(3386)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHERE
		 	      return testSet
		 	 }()) {
		 		setState(3385)
		 		try where_clause()

		 	}

		 	setState(3389)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 	      return testSet
		 	 }()) {
		 		setState(3388)
		 		try static_returning_clause()

		 	}

		 	setState(3392)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LOG
		 	      return testSet
		 	 }()) {
		 		setState(3391)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_statementContext:ParserRuleContext {
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.INSERT, 0) }
		open func single_table_insert() -> Single_table_insertContext? {
			return getRuleContext(Single_table_insertContext.self,0)
		}
		open func multi_table_insert() -> Multi_table_insertContext? {
			return getRuleContext(Multi_table_insertContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_insert_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInsert_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInsert_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInsert_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInsert_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_statement() throws -> Insert_statementContext {
		var _localctx: Insert_statementContext = Insert_statementContext(_ctx, getState())
		try enterRule(_localctx, 430, plsqlParser.RULE_insert_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3394)
		 	try match(plsqlParser.INSERT)
		 	setState(3397)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INTO:
		 		setState(3395)
		 		try single_table_insert()

		 		break
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.WHEN:
		 		setState(3396)
		 		try multi_table_insert()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Single_table_insertContext:ParserRuleContext {
		open func insert_into_clause() -> Insert_into_clauseContext? {
			return getRuleContext(Insert_into_clauseContext.self,0)
		}
		open func values_clause() -> Values_clauseContext? {
			return getRuleContext(Values_clauseContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_single_table_insert }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSingle_table_insert(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSingle_table_insert(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSingle_table_insert(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSingle_table_insert(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func single_table_insert() throws -> Single_table_insertContext {
		var _localctx: Single_table_insertContext = Single_table_insertContext(_ctx, getState())
		try enterRule(_localctx, 432, plsqlParser.RULE_single_table_insert)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3399)
		 	try insert_into_clause()
		 	setState(3405)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.VALUES:
		 		setState(3400)
		 		try values_clause()
		 		setState(3402)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 		      return testSet
		 		 }()) {
		 			setState(3401)
		 			try static_returning_clause()

		 		}


		 		break
		 	case plsqlParser.SELECT:fallthrough
		 	case plsqlParser.WITH:fallthrough
		 	case plsqlParser.LEFT_PAREN:
		 		setState(3404)
		 		try select_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3408)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LOG
		 	      return testSet
		 	 }()) {
		 		setState(3407)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_table_insertContext:ParserRuleContext {
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func conditional_insert_clause() -> Conditional_insert_clauseContext? {
			return getRuleContext(Conditional_insert_clauseContext.self,0)
		}
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_table_insert }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_table_insert(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_table_insert(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_table_insert(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_table_insert(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_table_insert() throws -> Multi_table_insertContext {
		var _localctx: Multi_table_insertContext = Multi_table_insertContext(_ctx, getState())
		try enterRule(_localctx, 434, plsqlParser.RULE_multi_table_insert)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3417)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,401, _ctx)) {
		 	case 1:
		 		setState(3410)
		 		try match(plsqlParser.ALL)
		 		setState(3412) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3411)
		 			try multi_table_element()


		 			setState(3414); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.INTO
		 		      return testSet
		 		 }())

		 		break
		 	case 2:
		 		setState(3416)
		 		try conditional_insert_clause()

		 		break
		 	default: break
		 	}
		 	setState(3419)
		 	try select_statement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_table_elementContext:ParserRuleContext {
		open func insert_into_clause() -> Insert_into_clauseContext? {
			return getRuleContext(Insert_into_clauseContext.self,0)
		}
		open func values_clause() -> Values_clauseContext? {
			return getRuleContext(Values_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_table_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_table_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_table_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_table_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_table_element() throws -> Multi_table_elementContext {
		var _localctx: Multi_table_elementContext = Multi_table_elementContext(_ctx, getState())
		try enterRule(_localctx, 436, plsqlParser.RULE_multi_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3421)
		 	try insert_into_clause()
		 	setState(3423)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.VALUES
		 	      return testSet
		 	 }()) {
		 		setState(3422)
		 		try values_clause()

		 	}

		 	setState(3426)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LOG
		 	      return testSet
		 	 }()) {
		 		setState(3425)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_clauseContext:ParserRuleContext {
		open func conditional_insert_when_part() -> Array<Conditional_insert_when_partContext> {
			return getRuleContexts(Conditional_insert_when_partContext.self)
		}
		open func conditional_insert_when_part(_ i: Int) -> Conditional_insert_when_partContext? {
			return getRuleContext(Conditional_insert_when_partContext.self,i)
		}
		open func conditional_insert_else_part() -> Conditional_insert_else_partContext? {
			return getRuleContext(Conditional_insert_else_partContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.FIRST, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_clause() throws -> Conditional_insert_clauseContext {
		var _localctx: Conditional_insert_clauseContext = Conditional_insert_clauseContext(_ctx, getState())
		try enterRule(_localctx, 438, plsqlParser.RULE_conditional_insert_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3429)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ALL
		 	          testSet = testSet || _la == plsqlParser.FIRST
		 	      return testSet
		 	 }()) {
		 		setState(3428)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.ALL
		 		          testSet = testSet || _la == plsqlParser.FIRST
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(3432) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3431)
		 		try conditional_insert_when_part()


		 		setState(3434); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }())
		 	setState(3437)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ELSE
		 	      return testSet
		 	 }()) {
		 		setState(3436)
		 		try conditional_insert_else_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_when_part() throws -> Conditional_insert_when_partContext {
		var _localctx: Conditional_insert_when_partContext = Conditional_insert_when_partContext(_ctx, getState())
		try enterRule(_localctx, 440, plsqlParser.RULE_conditional_insert_when_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3439)
		 	try match(plsqlParser.WHEN)
		 	setState(3440)
		 	try condition()
		 	setState(3441)
		 	try match(plsqlParser.THEN)
		 	setState(3443) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3442)
		 		try multi_table_element()


		 		setState(3445); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTO
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.ELSE, 0) }
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_else_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_else_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_else_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_else_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_else_part() throws -> Conditional_insert_else_partContext {
		var _localctx: Conditional_insert_else_partContext = Conditional_insert_else_partContext(_ctx, getState())
		try enterRule(_localctx, 442, plsqlParser.RULE_conditional_insert_else_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3447)
		 	try match(plsqlParser.ELSE)
		 	setState(3449) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3448)
		 		try multi_table_element()


		 		setState(3451); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTO
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_into_clauseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_insert_into_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInsert_into_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInsert_into_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInsert_into_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInsert_into_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_into_clause() throws -> Insert_into_clauseContext {
		var _localctx: Insert_into_clauseContext = Insert_into_clauseContext(_ctx, getState())
		try enterRule(_localctx, 444, plsqlParser.RULE_insert_into_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3453)
		 	try match(plsqlParser.INTO)
		 	setState(3454)
		 	try general_table_ref()
		 	setState(3466)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,410,_ctx)) {
		 	case 1:
		 		setState(3455)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3456)
		 		try column_name()
		 		setState(3461)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3457)
		 			try match(plsqlParser.COMMA)
		 			setState(3458)
		 			try column_name()


		 			setState(3463)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3464)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Values_clauseContext:ParserRuleContext {
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.VALUES, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_values_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterValues_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitValues_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitValues_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitValues_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func values_clause() throws -> Values_clauseContext {
		var _localctx: Values_clauseContext = Values_clauseContext(_ctx, getState())
		try enterRule(_localctx, 446, plsqlParser.RULE_values_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3468)
		 	try match(plsqlParser.VALUES)
		 	setState(3469)
		 	try expression_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_statementContext:ParserRuleContext {
		open func MERGE() -> TerminalNode? { return getToken(plsqlParser.MERGE, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func selected_tableview() -> Selected_tableviewContext? {
			return getRuleContext(Selected_tableviewContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open func merge_update_clause() -> Merge_update_clauseContext? {
			return getRuleContext(Merge_update_clauseContext.self,0)
		}
		open func merge_insert_clause() -> Merge_insert_clauseContext? {
			return getRuleContext(Merge_insert_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_statement() throws -> Merge_statementContext {
		var _localctx: Merge_statementContext = Merge_statementContext(_ctx, getState())
		try enterRule(_localctx, 448, plsqlParser.RULE_merge_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3471)
		 	try match(plsqlParser.MERGE)
		 	setState(3472)
		 	try match(plsqlParser.INTO)
		 	setState(3473)
		 	try tableview_name()
		 	setState(3475)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(3474)
		 		try table_alias()

		 	}

		 	setState(3477)
		 	try match(plsqlParser.USING)
		 	setState(3478)
		 	try selected_tableview()
		 	setState(3479)
		 	try match(plsqlParser.ON)
		 	setState(3480)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3481)
		 	try condition()
		 	setState(3482)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(3491)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,414,_ctx)) {
		 	case 1:
		 		setState(3483)
		 		try merge_update_clause()
		 		setState(3485)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WHEN
		 		      return testSet
		 		 }()) {
		 			setState(3484)
		 			try merge_insert_clause()

		 		}


		 		break
		 	case 2:
		 		setState(3487)
		 		try merge_insert_clause()
		 		setState(3489)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WHEN
		 		      return testSet
		 		 }()) {
		 			setState(3488)
		 			try merge_update_clause()

		 		}


		 		break
		 	default: break
		 	}
		 	setState(3494)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LOG
		 	      return testSet
		 	 }()) {
		 		setState(3493)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_update_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.MATCHED, 0) }
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func merge_element() -> Array<Merge_elementContext> {
			return getRuleContexts(Merge_elementContext.self)
		}
		open func merge_element(_ i: Int) -> Merge_elementContext? {
			return getRuleContext(Merge_elementContext.self,i)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func merge_update_delete_part() -> Merge_update_delete_partContext? {
			return getRuleContext(Merge_update_delete_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_update_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_update_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_update_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_update_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_update_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_update_clause() throws -> Merge_update_clauseContext {
		var _localctx: Merge_update_clauseContext = Merge_update_clauseContext(_ctx, getState())
		try enterRule(_localctx, 450, plsqlParser.RULE_merge_update_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3496)
		 	try match(plsqlParser.WHEN)
		 	setState(3497)
		 	try match(plsqlParser.MATCHED)
		 	setState(3498)
		 	try match(plsqlParser.THEN)
		 	setState(3499)
		 	try match(plsqlParser.UPDATE)
		 	setState(3500)
		 	try match(plsqlParser.SET)
		 	setState(3501)
		 	try merge_element()
		 	setState(3506)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3502)
		 		try match(plsqlParser.COMMA)
		 		setState(3503)
		 		try merge_element()


		 		setState(3508)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3510)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHERE
		 	      return testSet
		 	 }()) {
		 		setState(3509)
		 		try where_clause()

		 	}

		 	setState(3513)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,418,_ctx)) {
		 	case 1:
		 		setState(3512)
		 		try merge_update_delete_part()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_elementContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_element() throws -> Merge_elementContext {
		var _localctx: Merge_elementContext = Merge_elementContext(_ctx, getState())
		try enterRule(_localctx, 452, plsqlParser.RULE_merge_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3515)
		 	try column_name()
		 	setState(3516)
		 	try match(plsqlParser.EQUALS_OP)
		 	setState(3517)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_update_delete_partContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.DELETE, 0) }
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_update_delete_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_update_delete_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_update_delete_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_update_delete_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_update_delete_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_update_delete_part() throws -> Merge_update_delete_partContext {
		var _localctx: Merge_update_delete_partContext = Merge_update_delete_partContext(_ctx, getState())
		try enterRule(_localctx, 454, plsqlParser.RULE_merge_update_delete_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3519)
		 	try match(plsqlParser.DELETE)
		 	setState(3520)
		 	try where_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_insert_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.MATCHED, 0) }
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.INSERT, 0) }
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.VALUES, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_insert_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_insert_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_insert_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_insert_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_insert_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_insert_clause() throws -> Merge_insert_clauseContext {
		var _localctx: Merge_insert_clauseContext = Merge_insert_clauseContext(_ctx, getState())
		try enterRule(_localctx, 456, plsqlParser.RULE_merge_insert_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3522)
		 	try match(plsqlParser.WHEN)
		 	setState(3523)
		 	try match(plsqlParser.NOT)
		 	setState(3524)
		 	try match(plsqlParser.MATCHED)
		 	setState(3525)
		 	try match(plsqlParser.THEN)
		 	setState(3526)
		 	try match(plsqlParser.INSERT)
		 	setState(3538)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 	      return testSet
		 	 }()) {
		 		setState(3527)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3528)
		 		try column_name()
		 		setState(3533)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3529)
		 			try match(plsqlParser.COMMA)
		 			setState(3530)
		 			try column_name()


		 			setState(3535)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3536)
		 		try match(plsqlParser.RIGHT_PAREN)

		 	}

		 	setState(3540)
		 	try match(plsqlParser.VALUES)
		 	setState(3541)
		 	try expression_list()
		 	setState(3543)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHERE
		 	      return testSet
		 	 }()) {
		 		setState(3542)
		 		try where_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Selected_tableviewContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_selected_tableview }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelected_tableview(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelected_tableview(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelected_tableview(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelected_tableview(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func selected_tableview() throws -> Selected_tableviewContext {
		var _localctx: Selected_tableviewContext = Selected_tableviewContext(_ctx, getState())
		try enterRule(_localctx, 458, plsqlParser.RULE_selected_tableview)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3550)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(3545)
		 		try tableview_name()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(3546)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3547)
		 		try select_statement()
		 		setState(3548)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3553)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(3552)
		 		try table_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_table_statementContext:ParserRuleContext {
		open func LOCK() -> TerminalNode? { return getToken(plsqlParser.LOCK, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func lock_table_element() -> Array<Lock_table_elementContext> {
			return getRuleContexts(Lock_table_elementContext.self)
		}
		open func lock_table_element(_ i: Int) -> Lock_table_elementContext? {
			return getRuleContext(Lock_table_elementContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func lock_mode() -> Lock_modeContext? {
			return getRuleContext(Lock_modeContext.self,0)
		}
		open func MODE() -> TerminalNode? { return getToken(plsqlParser.MODE, 0) }
		open func wait_nowait_part() -> Wait_nowait_partContext? {
			return getRuleContext(Wait_nowait_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_table_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_table_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_table_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_table_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_table_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_table_statement() throws -> Lock_table_statementContext {
		var _localctx: Lock_table_statementContext = Lock_table_statementContext(_ctx, getState())
		try enterRule(_localctx, 460, plsqlParser.RULE_lock_table_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3555)
		 	try match(plsqlParser.LOCK)
		 	setState(3556)
		 	try match(plsqlParser.TABLE)
		 	setState(3557)
		 	try lock_table_element()
		 	setState(3562)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3558)
		 		try match(plsqlParser.COMMA)
		 		setState(3559)
		 		try lock_table_element()


		 		setState(3564)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3565)
		 	try match(plsqlParser.IN)
		 	setState(3566)
		 	try lock_mode()
		 	setState(3567)
		 	try match(plsqlParser.MODE)
		 	setState(3569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.NOWAIT
		 	          testSet = testSet || _la == plsqlParser.WAIT
		 	      return testSet
		 	 }()) {
		 		setState(3568)
		 		try wait_nowait_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Wait_nowait_partContext:ParserRuleContext {
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.WAIT, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.NOWAIT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_wait_nowait_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWait_nowait_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWait_nowait_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWait_nowait_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWait_nowait_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func wait_nowait_part() throws -> Wait_nowait_partContext {
		var _localctx: Wait_nowait_partContext = Wait_nowait_partContext(_ctx, getState())
		try enterRule(_localctx, 462, plsqlParser.RULE_wait_nowait_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3574)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.WAIT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3571)
		 		try match(plsqlParser.WAIT)
		 		setState(3572)
		 		try expression()

		 		break

		 	case plsqlParser.NOWAIT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3573)
		 		try match(plsqlParser.NOWAIT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_table_elementContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func partition_extension_clause() -> Partition_extension_clauseContext? {
			return getRuleContext(Partition_extension_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_table_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_table_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_table_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_table_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_table_element() throws -> Lock_table_elementContext {
		var _localctx: Lock_table_elementContext = Lock_table_elementContext(_ctx, getState())
		try enterRule(_localctx, 464, plsqlParser.RULE_lock_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3576)
		 	try tableview_name()
		 	setState(3578)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.PARTITION
		 	          testSet = testSet || _la == plsqlParser.SUBPARTITION
		 	      return testSet
		 	 }()) {
		 		setState(3577)
		 		try partition_extension_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_modeContext:ParserRuleContext {
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.ROW, 0) }
		open func SHARE() -> TerminalNode? { return getToken(plsqlParser.SHARE, 0) }
		open func EXCLUSIVE() -> TerminalNode? { return getToken(plsqlParser.EXCLUSIVE, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.UPDATE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_mode }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_mode(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_mode(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_mode(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_mode(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_mode() throws -> Lock_modeContext {
		var _localctx: Lock_modeContext = Lock_modeContext(_ctx, getState())
		try enterRule(_localctx, 466, plsqlParser.RULE_lock_mode)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3592)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,429, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3580)
		 		try match(plsqlParser.ROW)
		 		setState(3581)
		 		try match(plsqlParser.SHARE)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3582)
		 		try match(plsqlParser.ROW)
		 		setState(3583)
		 		try match(plsqlParser.EXCLUSIVE)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3584)
		 		try match(plsqlParser.SHARE)
		 		setState(3586)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.UPDATE
		 		      return testSet
		 		 }()) {
		 			setState(3585)
		 			try match(plsqlParser.UPDATE)

		 		}


		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3588)
		 		try match(plsqlParser.SHARE)
		 		setState(3589)
		 		try match(plsqlParser.ROW)
		 		setState(3590)
		 		try match(plsqlParser.EXCLUSIVE)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3591)
		 		try match(plsqlParser.EXCLUSIVE)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_table_refContext:ParserRuleContext {
		open func dml_table_expression_clause() -> Dml_table_expression_clauseContext? {
			return getRuleContext(Dml_table_expression_clauseContext.self,0)
		}
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.ONLY, 0) }
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_table_ref }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_table_ref(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_table_ref(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_table_ref(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_table_ref(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_table_ref() throws -> General_table_refContext {
		var _localctx: General_table_refContext = General_table_refContext(_ctx, getState())
		try enterRule(_localctx, 468, plsqlParser.RULE_general_table_ref)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3600)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,430, _ctx)) {
		 	case 1:
		 		setState(3594)
		 		try dml_table_expression_clause()

		 		break
		 	case 2:
		 		setState(3595)
		 		try match(plsqlParser.ONLY)
		 		setState(3596)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3597)
		 		try dml_table_expression_clause()
		 		setState(3598)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default: break
		 	}
		 	setState(3603)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,431,_ctx)) {
		 	case 1:
		 		setState(3602)
		 		try table_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Static_returning_clauseContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.RETURNING, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_static_returning_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStatic_returning_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStatic_returning_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStatic_returning_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStatic_returning_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func static_returning_clause() throws -> Static_returning_clauseContext {
		var _localctx: Static_returning_clauseContext = Static_returning_clauseContext(_ctx, getState())
		try enterRule(_localctx, 470, plsqlParser.RULE_static_returning_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3605)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RETURN || _la == plsqlParser.RETURNING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3606)
		 	try expression()
		 	setState(3611)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3607)
		 		try match(plsqlParser.COMMA)
		 		setState(3608)
		 		try expression()


		 		setState(3613)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3614)
		 	try into_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_clauseContext:ParserRuleContext {
		open func LOG() -> TerminalNode? { return getToken(plsqlParser.LOG, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.ERRORS, 0) }
		open func error_logging_into_part() -> Error_logging_into_partContext? {
			return getRuleContext(Error_logging_into_partContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func error_logging_reject_part() -> Error_logging_reject_partContext? {
			return getRuleContext(Error_logging_reject_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_clause() throws -> Error_logging_clauseContext {
		var _localctx: Error_logging_clauseContext = Error_logging_clauseContext(_ctx, getState())
		try enterRule(_localctx, 472, plsqlParser.RULE_error_logging_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3616)
		 	try match(plsqlParser.LOG)
		 	setState(3617)
		 	try match(plsqlParser.ERRORS)
		 	setState(3619)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,433,_ctx)) {
		 	case 1:
		 		setState(3618)
		 		try error_logging_into_part()

		 		break
		 	default: break
		 	}
		 	setState(3622)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,434,_ctx)) {
		 	case 1:
		 		setState(3621)
		 		try expression()

		 		break
		 	default: break
		 	}
		 	setState(3625)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.REJECT
		 	      return testSet
		 	 }()) {
		 		setState(3624)
		 		try error_logging_reject_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_into_partContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_into_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_into_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_into_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_into_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_into_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_into_part() throws -> Error_logging_into_partContext {
		var _localctx: Error_logging_into_partContext = Error_logging_into_partContext(_ctx, getState())
		try enterRule(_localctx, 474, plsqlParser.RULE_error_logging_into_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3627)
		 	try match(plsqlParser.INTO)
		 	setState(3628)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_reject_partContext:ParserRuleContext {
		open func REJECT() -> TerminalNode? { return getToken(plsqlParser.REJECT, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.LIMIT, 0) }
		open func UNLIMITED() -> TerminalNode? { return getToken(plsqlParser.UNLIMITED, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_reject_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_reject_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_reject_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_reject_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_reject_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_reject_part() throws -> Error_logging_reject_partContext {
		var _localctx: Error_logging_reject_partContext = Error_logging_reject_partContext(_ctx, getState())
		try enterRule(_localctx, 476, plsqlParser.RULE_error_logging_reject_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3630)
		 	try match(plsqlParser.REJECT)
		 	setState(3631)
		 	try match(plsqlParser.LIMIT)
		 	setState(3634)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,436, _ctx)) {
		 	case 1:
		 		setState(3632)
		 		try match(plsqlParser.UNLIMITED)

		 		break
		 	case 2:
		 		setState(3633)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_table_expression_clauseContext:ParserRuleContext {
		open func table_collection_expression() -> Table_collection_expressionContext? {
			return getRuleContext(Table_collection_expressionContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func subquery_restriction_clause() -> Subquery_restriction_clauseContext? {
			return getRuleContext(Subquery_restriction_clauseContext.self,0)
		}
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func sample_clause() -> Sample_clauseContext? {
			return getRuleContext(Sample_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_table_expression_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_table_expression_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_table_expression_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_table_expression_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_table_expression_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_table_expression_clause() throws -> Dml_table_expression_clauseContext {
		var _localctx: Dml_table_expression_clauseContext = Dml_table_expression_clauseContext(_ctx, getState())
		try enterRule(_localctx, 478, plsqlParser.RULE_dml_table_expression_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3648)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.TABLE:fallthrough
		 	case plsqlParser.THE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3636)
		 		try table_collection_expression()

		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3637)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3638)
		 		try select_statement()
		 		setState(3640)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(3639)
		 			try subquery_restriction_clause()

		 		}

		 		setState(3642)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3644)
		 		try tableview_name()
		 		setState(3646)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,438,_ctx)) {
		 		case 1:
		 			setState(3645)
		 			try sample_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_collection_expressionContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.TABLE, 0) }
		open func THE() -> TerminalNode? { return getToken(plsqlParser.THE, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_collection_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_collection_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_collection_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_collection_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_collection_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_collection_expression() throws -> Table_collection_expressionContext {
		var _localctx: Table_collection_expressionContext = Table_collection_expressionContext(_ctx, getState())
		try enterRule(_localctx, 480, plsqlParser.RULE_table_collection_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3650)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.TABLE || _la == plsqlParser.THE
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(3663)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,441, _ctx)) {
		 	case 1:
		 		setState(3651)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3652)
		 		try subquery()
		 		setState(3653)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 2:
		 		setState(3655)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3656)
		 		try expression()
		 		setState(3657)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(3661)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,440,_ctx)) {
		 		case 1:
		 			setState(3658)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(3659)
		 			try match(plsqlParser.PLUS_SIGN)
		 			setState(3660)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_restriction_clauseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.READ, 0) }
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.ONLY, 0) }
		open func CHECK() -> TerminalNode? { return getToken(plsqlParser.CHECK, 0) }
		open func OPTION() -> TerminalNode? { return getToken(plsqlParser.OPTION, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.CONSTRAINT, 0) }
		open func constraint_name() -> Constraint_nameContext? {
			return getRuleContext(Constraint_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_restriction_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_restriction_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_restriction_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_restriction_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_restriction_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_restriction_clause() throws -> Subquery_restriction_clauseContext {
		var _localctx: Subquery_restriction_clauseContext = Subquery_restriction_clauseContext(_ctx, getState())
		try enterRule(_localctx, 482, plsqlParser.RULE_subquery_restriction_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3665)
		 	try match(plsqlParser.WITH)
		 	setState(3674)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.READ:
		 		setState(3666)
		 		try match(plsqlParser.READ)
		 		setState(3667)
		 		try match(plsqlParser.ONLY)

		 		break

		 	case plsqlParser.CHECK:
		 		setState(3668)
		 		try match(plsqlParser.CHECK)
		 		setState(3669)
		 		try match(plsqlParser.OPTION)
		 		setState(3672)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.CONSTRAINT
		 		      return testSet
		 		 }()) {
		 			setState(3670)
		 			try match(plsqlParser.CONSTRAINT)
		 			setState(3671)
		 			try constraint_name()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sample_clauseContext:ParserRuleContext {
		open func SAMPLE() -> TerminalNode? { return getToken(plsqlParser.SAMPLE, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func BLOCK() -> TerminalNode? { return getToken(plsqlParser.BLOCK, 0) }
		open func seed_part() -> Seed_partContext? {
			return getRuleContext(Seed_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sample_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSample_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSample_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSample_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSample_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sample_clause() throws -> Sample_clauseContext {
		var _localctx: Sample_clauseContext = Sample_clauseContext(_ctx, getState())
		try enterRule(_localctx, 484, plsqlParser.RULE_sample_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3676)
		 	try match(plsqlParser.SAMPLE)
		 	setState(3678)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.BLOCK
		 	      return testSet
		 	 }()) {
		 		setState(3677)
		 		try match(plsqlParser.BLOCK)

		 	}

		 	setState(3680)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3681)
		 	try expression()
		 	setState(3684)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3682)
		 		try match(plsqlParser.COMMA)
		 		setState(3683)
		 		try expression()

		 	}

		 	setState(3686)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(3688)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,446,_ctx)) {
		 	case 1:
		 		setState(3687)
		 		try seed_part()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Seed_partContext:ParserRuleContext {
		open func SEED() -> TerminalNode? { return getToken(plsqlParser.SEED, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_seed_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSeed_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSeed_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSeed_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSeed_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func seed_part() throws -> Seed_partContext {
		var _localctx: Seed_partContext = Seed_partContext(_ctx, getState())
		try enterRule(_localctx, 486, plsqlParser.RULE_seed_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3690)
		 	try match(plsqlParser.SEED)
		 	setState(3691)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3692)
		 	try expression()
		 	setState(3693)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_expressionContext:ParserRuleContext {
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.CURSOR, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_expression() throws -> Cursor_expressionContext {
		var _localctx: Cursor_expressionContext = Cursor_expressionContext(_ctx, getState())
		try enterRule(_localctx, 488, plsqlParser.RULE_cursor_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3695)
		 	try match(plsqlParser.CURSOR)
		 	setState(3696)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3697)
		 	try subquery()
		 	setState(3698)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Expression_listContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression_list() throws -> Expression_listContext {
		var _localctx: Expression_listContext = Expression_listContext(_ctx, getState())
		try enterRule(_localctx, 490, plsqlParser.RULE_expression_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3700)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3702)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ALL,plsqlParser.ANALYZE,plsqlParser.ANY,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CASE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONNECT_BY_ROOT,plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DISTINCT,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTION_INIT,plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXISTS,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FALSE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LANGUAGE,plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NOT,plsqlParser.NULL,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OBJECT,plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PRIOR,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.RIGHT,plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 321)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMESTAMP_UNCONSTRAINED,plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUE,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 385)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YEAR,plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.UNSIGNED_INTEGER,plsqlParser.APPROXIMATE_NUM_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID,plsqlParser.LEFT_PAREN,plsqlParser.PLUS_SIGN,plsqlParser.MINUS_SIGN,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 449)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(3701)
		 		try expression()

		 	}

		 	setState(3708)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3704)
		 		try match(plsqlParser.COMMA)
		 		setState(3705)
		 		try expression()


		 		setState(3710)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3711)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_condition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCondition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func condition() throws -> ConditionContext {
		var _localctx: ConditionContext = ConditionContext(_ctx, getState())
		try enterRule(_localctx, 492, plsqlParser.RULE_condition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3713)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExpressionContext:ParserRuleContext {
		open func cursor_expression() -> Cursor_expressionContext? {
			return getRuleContext(Cursor_expressionContext.self,0)
		}
		open func logical_or_expression() -> Logical_or_expressionContext? {
			return getRuleContext(Logical_or_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression() throws -> ExpressionContext {
		var _localctx: ExpressionContext = ExpressionContext(_ctx, getState())
		try enterRule(_localctx, 494, plsqlParser.RULE_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3717)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,449, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3715)
		 		try cursor_expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3716)
		 		try logical_or_expression(0)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	open class Logical_or_expressionContext:ParserRuleContext {
		open func logical_and_expression() -> Logical_and_expressionContext? {
			return getRuleContext(Logical_and_expressionContext.self,0)
		}
		open func logical_or_expression() -> Logical_or_expressionContext? {
			return getRuleContext(Logical_or_expressionContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.OR, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_logical_or_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLogical_or_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLogical_or_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLogical_or_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLogical_or_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func logical_or_expression( ) throws -> Logical_or_expressionContext   {
		return try logical_or_expression(0)
	}
	@discardableResult
	private func logical_or_expression(_ _p: Int) throws -> Logical_or_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Logical_or_expressionContext = Logical_or_expressionContext(_ctx, _parentState)
		var  _prevctx: Logical_or_expressionContext = _localctx
		var _startState: Int = 496
		try enterRecursionRule(_localctx, 496, plsqlParser.RULE_logical_or_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3720)
			try logical_and_expression(0)

			_ctx!.stop = try _input.LT(-1)
			setState(3727)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,450,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Logical_or_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_logical_or_expression)
					setState(3722)
					if (!(precpred(_ctx, 1))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 1)"))
					}
					setState(3723)
					try match(plsqlParser.OR)
					setState(3724)
					try logical_and_expression(0)

			 
				}
				setState(3729)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,450,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}

	open class Logical_and_expressionContext:ParserRuleContext {
		open func negated_expression() -> Negated_expressionContext? {
			return getRuleContext(Negated_expressionContext.self,0)
		}
		open func logical_and_expression() -> Logical_and_expressionContext? {
			return getRuleContext(Logical_and_expressionContext.self,0)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.AND, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_logical_and_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLogical_and_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLogical_and_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLogical_and_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLogical_and_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func logical_and_expression( ) throws -> Logical_and_expressionContext   {
		return try logical_and_expression(0)
	}
	@discardableResult
	private func logical_and_expression(_ _p: Int) throws -> Logical_and_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Logical_and_expressionContext = Logical_and_expressionContext(_ctx, _parentState)
		var  _prevctx: Logical_and_expressionContext = _localctx
		var _startState: Int = 498
		try enterRecursionRule(_localctx, 498, plsqlParser.RULE_logical_and_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3731)
			try negated_expression()

			_ctx!.stop = try _input.LT(-1)
			setState(3738)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,451,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Logical_and_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_logical_and_expression)
					setState(3733)
					if (!(precpred(_ctx, 1))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 1)"))
					}
					setState(3734)
					try match(plsqlParser.AND)
					setState(3735)
					try negated_expression()

			 
				}
				setState(3740)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,451,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}
	open class Negated_expressionContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func negated_expression() -> Negated_expressionContext? {
			return getRuleContext(Negated_expressionContext.self,0)
		}
		open func equality_expression() -> Equality_expressionContext? {
			return getRuleContext(Equality_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_negated_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNegated_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNegated_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNegated_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNegated_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func negated_expression() throws -> Negated_expressionContext {
		var _localctx: Negated_expressionContext = Negated_expressionContext(_ctx, getState())
		try enterRule(_localctx, 500, plsqlParser.RULE_negated_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3744)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.NOT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3741)
		 		try match(plsqlParser.NOT)
		 		setState(3742)
		 		try negated_expression()

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3743)
		 		try equality_expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Equality_expressionContext:ParserRuleContext {
		open func multiset_expression() -> Multiset_expressionContext? {
			return getRuleContext(Multiset_expressionContext.self,0)
		}
		open func IS() -> Array<TerminalNode> { return getTokens(plsqlParser.IS) }
		open func IS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.IS, i)
		}
		open func NULL() -> Array<TerminalNode> { return getTokens(plsqlParser.NULL) }
		open func NULL(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NULL, i)
		}
		open func NAN() -> Array<TerminalNode> { return getTokens(plsqlParser.NAN) }
		open func NAN(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NAN, i)
		}
		open func PRESENT() -> Array<TerminalNode> { return getTokens(plsqlParser.PRESENT) }
		open func PRESENT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.PRESENT, i)
		}
		open func INFINITE() -> Array<TerminalNode> { return getTokens(plsqlParser.INFINITE) }
		open func INFINITE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.INFINITE, i)
		}
		open func A_LETTER() -> Array<TerminalNode> { return getTokens(plsqlParser.A_LETTER) }
		open func A_LETTER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.A_LETTER, i)
		}
		open func SET() -> Array<TerminalNode> { return getTokens(plsqlParser.SET) }
		open func SET(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.SET, i)
		}
		open func EMPTY() -> Array<TerminalNode> { return getTokens(plsqlParser.EMPTY) }
		open func EMPTY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.EMPTY, i)
		}
		open func OF() -> Array<TerminalNode> { return getTokens(plsqlParser.OF) }
		open func OF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.OF, i)
		}
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func NOT() -> Array<TerminalNode> { return getTokens(plsqlParser.NOT) }
		open func NOT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NOT, i)
		}
		open func TYPE() -> Array<TerminalNode> { return getTokens(plsqlParser.TYPE) }
		open func TYPE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.TYPE, i)
		}
		open func ONLY() -> Array<TerminalNode> { return getTokens(plsqlParser.ONLY) }
		open func ONLY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.ONLY, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_equality_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterEquality_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitEquality_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitEquality_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitEquality_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func equality_expression() throws -> Equality_expressionContext {
		var _localctx: Equality_expressionContext = Equality_expressionContext(_ctx, getState())
		try enterRule(_localctx, 502, plsqlParser.RULE_equality_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3746)
		 	try multiset_expression()
		 	setState(3780)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,458,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3747)
		 			try match(plsqlParser.IS)
		 			setState(3749)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.NOT
		 			      return testSet
		 			 }()) {
		 				setState(3748)
		 				try match(plsqlParser.NOT)

		 			}

		 			setState(3776)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.NULL:
		 				setState(3751)
		 				try match(plsqlParser.NULL)

		 				break

		 			case plsqlParser.NAN:
		 				setState(3752)
		 				try match(plsqlParser.NAN)

		 				break

		 			case plsqlParser.PRESENT:
		 				setState(3753)
		 				try match(plsqlParser.PRESENT)

		 				break

		 			case plsqlParser.INFINITE:
		 				setState(3754)
		 				try match(plsqlParser.INFINITE)

		 				break

		 			case plsqlParser.A_LETTER:
		 				setState(3755)
		 				try match(plsqlParser.A_LETTER)
		 				setState(3756)
		 				try match(plsqlParser.SET)

		 				break

		 			case plsqlParser.EMPTY:
		 				setState(3757)
		 				try match(plsqlParser.EMPTY)

		 				break

		 			case plsqlParser.OF:
		 				setState(3758)
		 				try match(plsqlParser.OF)
		 				setState(3760)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == plsqlParser.TYPE
		 				      return testSet
		 				 }()) {
		 					setState(3759)
		 					try match(plsqlParser.TYPE)

		 				}

		 				setState(3762)
		 				try match(plsqlParser.LEFT_PAREN)
		 				setState(3764)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,455,_ctx)) {
		 				case 1:
		 					setState(3763)
		 					try match(plsqlParser.ONLY)

		 					break
		 				default: break
		 				}
		 				setState(3766)
		 				try type_spec()
		 				setState(3771)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				while (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == plsqlParser.COMMA
		 				      return testSet
		 				 }()) {
		 					setState(3767)
		 					try match(plsqlParser.COMMA)
		 					setState(3768)
		 					try type_spec()


		 					setState(3773)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 				}
		 				setState(3774)
		 				try match(plsqlParser.RIGHT_PAREN)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 	 
		 		}
		 		setState(3782)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,458,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiset_expressionContext:ParserRuleContext {
		open func relational_expression() -> Relational_expressionContext? {
			return getRuleContext(Relational_expressionContext.self,0)
		}
		open func multiset_type() -> Multiset_typeContext? {
			return getRuleContext(Multiset_typeContext.self,0)
		}
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiset_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiset_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiset_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiset_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiset_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiset_expression() throws -> Multiset_expressionContext {
		var _localctx: Multiset_expressionContext = Multiset_expressionContext(_ctx, getState())
		try enterRule(_localctx, 504, plsqlParser.RULE_multiset_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3783)
		 	try relational_expression(0)
		 	setState(3790)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,460,_ctx)) {
		 	case 1:
		 		setState(3784)
		 		try multiset_type()
		 		setState(3786)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.OF
		 		      return testSet
		 		 }()) {
		 			setState(3785)
		 			try match(plsqlParser.OF)

		 		}

		 		setState(3788)
		 		try concatenation()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiset_typeContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func SUBMULTISET() -> TerminalNode? { return getToken(plsqlParser.SUBMULTISET, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiset_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiset_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiset_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiset_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiset_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiset_type() throws -> Multiset_typeContext {
		var _localctx: Multiset_typeContext = Multiset_typeContext(_ctx, getState())
		try enterRule(_localctx, 506, plsqlParser.RULE_multiset_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3792)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.MEMBER
		 	          testSet = testSet || _la == plsqlParser.SUBMULTISET
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	open class Relational_expressionContext:ParserRuleContext {
		open func compound_expression() -> Compound_expressionContext? {
			return getRuleContext(Compound_expressionContext.self,0)
		}
		open func relational_expression() -> Array<Relational_expressionContext> {
			return getRuleContexts(Relational_expressionContext.self)
		}
		open func relational_expression(_ i: Int) -> Relational_expressionContext? {
			return getRuleContext(Relational_expressionContext.self,i)
		}
		open func relational_operator() -> Relational_operatorContext? {
			return getRuleContext(Relational_operatorContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relational_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelational_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelational_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelational_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelational_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func relational_expression( ) throws -> Relational_expressionContext   {
		return try relational_expression(0)
	}
	@discardableResult
	private func relational_expression(_ _p: Int) throws -> Relational_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Relational_expressionContext = Relational_expressionContext(_ctx, _parentState)
		var  _prevctx: Relational_expressionContext = _localctx
		var _startState: Int = 508
		try enterRecursionRule(_localctx, 508, plsqlParser.RULE_relational_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3795)
			try compound_expression()

			_ctx!.stop = try _input.LT(-1)
			setState(3803)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,461,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Relational_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_relational_expression)
					setState(3797)
					if (!(precpred(_ctx, 2))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 2)"))
					}
					setState(3798)
					try relational_operator()
					setState(3799)
					try relational_expression(3)

			 
				}
				setState(3805)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,461,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}
	open class Compound_expressionContext:ParserRuleContext {
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func in_elements() -> In_elementsContext? {
			return getRuleContext(In_elementsContext.self,0)
		}
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.BETWEEN, 0) }
		open func between_elements() -> Between_elementsContext? {
			return getRuleContext(Between_elementsContext.self,0)
		}
		open func like_type() -> Like_typeContext? {
			return getRuleContext(Like_typeContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.NOT, 0) }
		open func like_escape_part() -> Like_escape_partContext? {
			return getRuleContext(Like_escape_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_expression() throws -> Compound_expressionContext {
		var _localctx: Compound_expressionContext = Compound_expressionContext(_ctx, getState())
		try enterRule(_localctx, 510, plsqlParser.RULE_compound_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3806)
		 	try concatenation()
		 	setState(3821)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,465,_ctx)) {
		 	case 1:
		 		setState(3808)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.NOT
		 		      return testSet
		 		 }()) {
		 			setState(3807)
		 			try match(plsqlParser.NOT)

		 		}

		 		setState(3819)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.IN:
		 			setState(3810)
		 			try match(plsqlParser.IN)
		 			setState(3811)
		 			try in_elements()

		 			break

		 		case plsqlParser.BETWEEN:
		 			setState(3812)
		 			try match(plsqlParser.BETWEEN)
		 			setState(3813)
		 			try between_elements()

		 			break
		 		case plsqlParser.LIKE:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:
		 			setState(3814)
		 			try like_type()
		 			setState(3815)
		 			try concatenation()
		 			setState(3817)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,463,_ctx)) {
		 			case 1:
		 				setState(3816)
		 				try like_escape_part()

		 				break
		 			default: break
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Relational_operatorContext:ParserRuleContext {
		open func not_equal_op() -> Not_equal_opContext? {
			return getRuleContext(Not_equal_opContext.self,0)
		}
		open func less_than_or_equals_op() -> Less_than_or_equals_opContext? {
			return getRuleContext(Less_than_or_equals_opContext.self,0)
		}
		open func greater_than_or_equals_op() -> Greater_than_or_equals_opContext? {
			return getRuleContext(Greater_than_or_equals_opContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relational_operator }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelational_operator(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelational_operator(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelational_operator(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelational_operator(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relational_operator() throws -> Relational_operatorContext {
		var _localctx: Relational_operatorContext = Relational_operatorContext(_ctx, getState())
		try enterRule(_localctx, 512, plsqlParser.RULE_relational_operator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3829)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,466, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3823)
		 		try match(plsqlParser.EQUALS_OP)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3824)
		 		try not_equal_op()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3825)
		 		try match(plsqlParser.LESS_THAN_OP)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3826)
		 		try match(plsqlParser.GREATER_THAN_OP)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3827)
		 		try less_than_or_equals_op()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3828)
		 		try greater_than_or_equals_op()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Like_typeContext:ParserRuleContext {
		open func LIKE() -> TerminalNode? { return getToken(plsqlParser.LIKE, 0) }
		open func LIKEC() -> TerminalNode? { return getToken(plsqlParser.LIKEC, 0) }
		open func LIKE2() -> TerminalNode? { return getToken(plsqlParser.LIKE2, 0) }
		open func LIKE4() -> TerminalNode? { return getToken(plsqlParser.LIKE4, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_like_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLike_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLike_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLike_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLike_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func like_type() throws -> Like_typeContext {
		var _localctx: Like_typeContext = Like_typeContext(_ctx, getState())
		try enterRule(_localctx, 514, plsqlParser.RULE_like_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3831)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.LIKE,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC]
		 	    return  Utils.testBitLeftShiftArray(testArray, 199)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Like_escape_partContext:ParserRuleContext {
		open func ESCAPE() -> TerminalNode? { return getToken(plsqlParser.ESCAPE, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_like_escape_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLike_escape_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLike_escape_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLike_escape_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLike_escape_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func like_escape_part() throws -> Like_escape_partContext {
		var _localctx: Like_escape_partContext = Like_escape_partContext(_ctx, getState())
		try enterRule(_localctx, 516, plsqlParser.RULE_like_escape_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3833)
		 	try match(plsqlParser.ESCAPE)
		 	setState(3834)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class In_elementsContext:ParserRuleContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_in_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIn_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIn_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIn_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIn_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func in_elements() throws -> In_elementsContext {
		var _localctx: In_elementsContext = In_elementsContext(_ctx, getState())
		try enterRule(_localctx, 518, plsqlParser.RULE_in_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3854)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,468, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3836)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3837)
		 		try subquery()
		 		setState(3838)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3840)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3841)
		 		try concatenation()
		 		setState(3846)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3842)
		 			try match(plsqlParser.COMMA)
		 			setState(3843)
		 			try concatenation()


		 			setState(3848)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3849)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3851)
		 		try constant()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3852)
		 		try bind_variable()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3853)
		 		try general_element()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Between_elementsContext:ParserRuleContext {
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.AND, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_between_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBetween_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBetween_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBetween_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBetween_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func between_elements() throws -> Between_elementsContext {
		var _localctx: Between_elementsContext = Between_elementsContext(_ctx, getState())
		try enterRule(_localctx, 520, plsqlParser.RULE_between_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3856)
		 	try concatenation()
		 	setState(3857)
		 	try match(plsqlParser.AND)
		 	setState(3858)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConcatenationContext:ParserRuleContext {
		open func additive_expression() -> Array<Additive_expressionContext> {
			return getRuleContexts(Additive_expressionContext.self)
		}
		open func additive_expression(_ i: Int) -> Additive_expressionContext? {
			return getRuleContext(Additive_expressionContext.self,i)
		}
		open func concatenation_op() -> Array<Concatenation_opContext> {
			return getRuleContexts(Concatenation_opContext.self)
		}
		open func concatenation_op(_ i: Int) -> Concatenation_opContext? {
			return getRuleContext(Concatenation_opContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_concatenation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConcatenation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConcatenation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConcatenation(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConcatenation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func concatenation() throws -> ConcatenationContext {
		var _localctx: ConcatenationContext = ConcatenationContext(_ctx, getState())
		try enterRule(_localctx, 522, plsqlParser.RULE_concatenation)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3860)
		 	try additive_expression()
		 	setState(3866)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,469,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3861)
		 			try concatenation_op()
		 			setState(3862)
		 			try additive_expression()

		 	 
		 		}
		 		setState(3868)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,469,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Additive_expressionContext:ParserRuleContext {
		public var s497: Token!
		public var op: Array<Token> = Array<Token>()
		public var s498: Token!
		public var _tset6856: Token!
		open func multiply_expression() -> Array<Multiply_expressionContext> {
			return getRuleContexts(Multiply_expressionContext.self)
		}
		open func multiply_expression(_ i: Int) -> Multiply_expressionContext? {
			return getRuleContext(Multiply_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_additive_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAdditive_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAdditive_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAdditive_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAdditive_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func additive_expression() throws -> Additive_expressionContext {
		var _localctx: Additive_expressionContext = Additive_expressionContext(_ctx, getState())
		try enterRule(_localctx, 524, plsqlParser.RULE_additive_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3869)
		 	try multiply_expression()
		 	setState(3874)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,470,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3870)
		 			_localctx.castdown(Additive_expressionContext.self)._tset6856 = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.PLUS_SIGN || _la == plsqlParser.MINUS_SIGN
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Additive_expressionContext.self)._tset6856 = try _errHandler.recoverInline(self) as Token
		 			} else {
		 				try consume()
		 			}
		 			_localctx.castdown(Additive_expressionContext.self).op.append(_localctx.castdown(Additive_expressionContext.self)._tset6856)
		 			setState(3871)
		 			try multiply_expression()

		 	 
		 		}
		 		setState(3876)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,470,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiply_expressionContext:ParserRuleContext {
		public var s496: Token!
		public var op: Array<Token> = Array<Token>()
		public var s500: Token!
		public var _tset6879: Token!
		open func datetime_expression() -> Array<Datetime_expressionContext> {
			return getRuleContexts(Datetime_expressionContext.self)
		}
		open func datetime_expression(_ i: Int) -> Datetime_expressionContext? {
			return getRuleContext(Datetime_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiply_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiply_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiply_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiply_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiply_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiply_expression() throws -> Multiply_expressionContext {
		var _localctx: Multiply_expressionContext = Multiply_expressionContext(_ctx, getState())
		try enterRule(_localctx, 526, plsqlParser.RULE_multiply_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3877)
		 	try datetime_expression()
		 	setState(3882)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,471,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3878)
		 			_localctx.castdown(Multiply_expressionContext.self)._tset6879 = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.ASTERISK || _la == plsqlParser.SOLIDUS
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Multiply_expressionContext.self)._tset6879 = try _errHandler.recoverInline(self) as Token
		 			} else {
		 				try consume()
		 			}
		 			_localctx.castdown(Multiply_expressionContext.self).op.append(_localctx.castdown(Multiply_expressionContext.self)._tset6879)
		 			setState(3879)
		 			try datetime_expression()

		 	 
		 		}
		 		setState(3884)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,471,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Datetime_expressionContext:ParserRuleContext {
		open func model_expression() -> Model_expressionContext? {
			return getRuleContext(Model_expressionContext.self,0)
		}
		open func AT() -> TerminalNode? { return getToken(plsqlParser.AT, 0) }
		open func interval_expression() -> Interval_expressionContext? {
			return getRuleContext(Interval_expressionContext.self,0)
		}
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.LOCAL, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.TIME, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.ZONE, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_datetime_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDatetime_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDatetime_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDatetime_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDatetime_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func datetime_expression() throws -> Datetime_expressionContext {
		var _localctx: Datetime_expressionContext = Datetime_expressionContext(_ctx, getState())
		try enterRule(_localctx, 528, plsqlParser.RULE_datetime_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3885)
		 	try model_expression()
		 	setState(3894)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,473,_ctx)) {
		 	case 1:
		 		setState(3886)
		 		try match(plsqlParser.AT)
		 		setState(3891)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.LOCAL:
		 			setState(3887)
		 			try match(plsqlParser.LOCAL)

		 			break

		 		case plsqlParser.TIME:
		 			setState(3888)
		 			try match(plsqlParser.TIME)
		 			setState(3889)
		 			try match(plsqlParser.ZONE)
		 			setState(3890)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		setState(3893)
		 		try interval_expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Interval_expressionContext:ParserRuleContext {
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.DAY, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.SECOND, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.YEAR, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.MONTH, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_interval_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInterval_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInterval_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInterval_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInterval_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func interval_expression() throws -> Interval_expressionContext {
		var _localctx: Interval_expressionContext = Interval_expressionContext(_ctx, getState())
		try enterRule(_localctx, 530, plsqlParser.RULE_interval_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3920)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.DAY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3896)
		 		try match(plsqlParser.DAY)
		 		setState(3901)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 		      return testSet
		 		 }()) {
		 			setState(3897)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(3898)
		 			try concatenation()
		 			setState(3899)
		 			try match(plsqlParser.RIGHT_PAREN)

		 		}

		 		setState(3903)
		 		try match(plsqlParser.TO)
		 		setState(3904)
		 		try match(plsqlParser.SECOND)
		 		setState(3909)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,475,_ctx)) {
		 		case 1:
		 			setState(3905)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(3906)
		 			try concatenation()
		 			setState(3907)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default: break
		 		}

		 		break

		 	case plsqlParser.YEAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3911)
		 		try match(plsqlParser.YEAR)
		 		setState(3916)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 		      return testSet
		 		 }()) {
		 			setState(3912)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(3913)
		 			try concatenation()
		 			setState(3914)
		 			try match(plsqlParser.RIGHT_PAREN)

		 		}

		 		setState(3918)
		 		try match(plsqlParser.TO)
		 		setState(3919)
		 		try match(plsqlParser.MONTH)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_expressionContext:ParserRuleContext {
		open func unary_expression() -> Unary_expressionContext? {
			return getRuleContext(Unary_expressionContext.self,0)
		}
		open func model_expression_element() -> Model_expression_elementContext? {
			return getRuleContext(Model_expression_elementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_expression() throws -> Model_expressionContext {
		var _localctx: Model_expressionContext = Model_expressionContext(_ctx, getState())
		try enterRule(_localctx, 532, plsqlParser.RULE_model_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3922)
		 	try unary_expression()
		 	setState(3927)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,478,_ctx)) {
		 	case 1:
		 		setState(3923)
		 		try match(plsqlParser.LEFT_BRACKET)
		 		setState(3924)
		 		try model_expression_element()
		 		setState(3925)
		 		try match(plsqlParser.RIGHT_BRACKET)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_expression_elementContext:ParserRuleContext {
		open func ANY() -> Array<TerminalNode> { return getTokens(plsqlParser.ANY) }
		open func ANY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.ANY, i)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func single_column_for_loop() -> Array<Single_column_for_loopContext> {
			return getRuleContexts(Single_column_for_loopContext.self)
		}
		open func single_column_for_loop(_ i: Int) -> Single_column_for_loopContext? {
			return getRuleContext(Single_column_for_loopContext.self,i)
		}
		open func multi_column_for_loop() -> Multi_column_for_loopContext? {
			return getRuleContext(Multi_column_for_loopContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_expression_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_expression_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_expression_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_expression_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_expression_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_expression_element() throws -> Model_expression_elementContext {
		var _localctx: Model_expression_elementContext = Model_expression_elementContext(_ctx, getState())
		try enterRule(_localctx, 534, plsqlParser.RULE_model_expression_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3952)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,483, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3931)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,479, _ctx)) {
		 		case 1:
		 			setState(3929)
		 			try match(plsqlParser.ANY)

		 			break
		 		case 2:
		 			setState(3930)
		 			try expression()

		 			break
		 		default: break
		 		}
		 		setState(3940)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3933)
		 			try match(plsqlParser.COMMA)
		 			setState(3936)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,480, _ctx)) {
		 			case 1:
		 				setState(3934)
		 				try match(plsqlParser.ANY)

		 				break
		 			case 2:
		 				setState(3935)
		 				try expression()

		 				break
		 			default: break
		 			}


		 			setState(3942)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3943)
		 		try single_column_for_loop()
		 		setState(3948)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3944)
		 			try match(plsqlParser.COMMA)
		 			setState(3945)
		 			try single_column_for_loop()


		 			setState(3950)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3951)
		 		try multi_column_for_loop()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Single_column_for_loopContext:ParserRuleContext {
		public var ex1: ExpressionContext!
		public var ex2: ExpressionContext!
		public var ex3: ExpressionContext!
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.FROM, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func for_increment_decrement_type() -> For_increment_decrement_typeContext? {
			return getRuleContext(For_increment_decrement_typeContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func for_like_part() -> For_like_partContext? {
			return getRuleContext(For_like_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_single_column_for_loop }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSingle_column_for_loop(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSingle_column_for_loop(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSingle_column_for_loop(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSingle_column_for_loop(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func single_column_for_loop() throws -> Single_column_for_loopContext {
		var _localctx: Single_column_for_loopContext = Single_column_for_loopContext(_ctx, getState())
		try enterRule(_localctx, 536, plsqlParser.RULE_single_column_for_loop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3954)
		 	try match(plsqlParser.FOR)
		 	setState(3955)
		 	try column_name()
		 	setState(3968)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.IN:
		 		setState(3956)
		 		try match(plsqlParser.IN)
		 		setState(3957)
		 		try expression_list()

		 		break
		 	case plsqlParser.FROM:fallthrough
		 	case plsqlParser.LIKE:
		 		setState(3959)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.LIKE
		 		      return testSet
		 		 }()) {
		 			setState(3958)
		 			try for_like_part()

		 		}

		 		setState(3961)
		 		try match(plsqlParser.FROM)
		 		setState(3962)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex1 = assignmentValue
		 		     }()

		 		setState(3963)
		 		try match(plsqlParser.TO)
		 		setState(3964)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex2 = assignmentValue
		 		     }()

		 		setState(3965)
		 		try for_increment_decrement_type()
		 		setState(3966)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex3 = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_like_partContext:ParserRuleContext {
		open func LIKE() -> TerminalNode? { return getToken(plsqlParser.LIKE, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_like_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_like_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_like_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_like_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_like_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_like_part() throws -> For_like_partContext {
		var _localctx: For_like_partContext = For_like_partContext(_ctx, getState())
		try enterRule(_localctx, 538, plsqlParser.RULE_for_like_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3970)
		 	try match(plsqlParser.LIKE)
		 	setState(3971)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_increment_decrement_typeContext:ParserRuleContext {
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.INCREMENT, 0) }
		open func DECREMENT() -> TerminalNode? { return getToken(plsqlParser.DECREMENT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_increment_decrement_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_increment_decrement_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_increment_decrement_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_increment_decrement_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_increment_decrement_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_increment_decrement_type() throws -> For_increment_decrement_typeContext {
		var _localctx: For_increment_decrement_typeContext = For_increment_decrement_typeContext(_ctx, getState())
		try enterRule(_localctx, 540, plsqlParser.RULE_for_increment_decrement_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3973)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.DECREMENT
		 	          testSet = testSet || _la == plsqlParser.INCREMENT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_column_for_loopContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_list() -> Array<Expression_listContext> {
			return getRuleContexts(Expression_listContext.self)
		}
		open func expression_list(_ i: Int) -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_column_for_loop }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_column_for_loop(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_column_for_loop(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_column_for_loop(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_column_for_loop(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_column_for_loop() throws -> Multi_column_for_loopContext {
		var _localctx: Multi_column_for_loopContext = Multi_column_for_loopContext(_ctx, getState())
		try enterRule(_localctx, 542, plsqlParser.RULE_multi_column_for_loop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3975)
		 	try match(plsqlParser.FOR)
		 	setState(3976)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(3977)
		 	try column_name()
		 	setState(3982)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(3978)
		 		try match(plsqlParser.COMMA)
		 		setState(3979)
		 		try column_name()


		 		setState(3984)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3985)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(3986)
		 	try match(plsqlParser.IN)
		 	setState(3987)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4000)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,488, _ctx)) {
		 	case 1:
		 		setState(3988)
		 		try subquery()

		 		break
		 	case 2:
		 		setState(3989)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(3990)
		 		try expression_list()
		 		setState(3995)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(3991)
		 			try match(plsqlParser.COMMA)
		 			setState(3992)
		 			try expression_list()


		 			setState(3997)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3998)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default: break
		 	}
		 	setState(4002)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unary_expressionContext:ParserRuleContext {
		open func unary_expression() -> Unary_expressionContext? {
			return getRuleContext(Unary_expressionContext.self,0)
		}
		open func PRIOR() -> TerminalNode? { return getToken(plsqlParser.PRIOR, 0) }
		open func CONNECT_BY_ROOT() -> TerminalNode? { return getToken(plsqlParser.CONNECT_BY_ROOT, 0) }
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.NEW, 0) }
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.DISTINCT, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func case_statement() -> Case_statementContext? {
			return getRuleContext(Case_statementContext.self,0)
		}
		open func quantified_expression() -> Quantified_expressionContext? {
			return getRuleContext(Quantified_expressionContext.self,0)
		}
		open func standard_function() -> Standard_functionContext? {
			return getRuleContext(Standard_functionContext.self,0)
		}
		open func atom() -> AtomContext? {
			return getRuleContext(AtomContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unary_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnary_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnary_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnary_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnary_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unary_expression() throws -> Unary_expressionContext {
		var _localctx: Unary_expressionContext = Unary_expressionContext(_ctx, getState())
		try enterRule(_localctx, 544, plsqlParser.RULE_unary_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4020)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,489, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4004)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PLUS_SIGN || _la == plsqlParser.MINUS_SIGN
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4005)
		 		try unary_expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4006)
		 		try match(plsqlParser.PRIOR)
		 		setState(4007)
		 		try unary_expression()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4008)
		 		try match(plsqlParser.CONNECT_BY_ROOT)
		 		setState(4009)
		 		try unary_expression()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4010)
		 		try match(plsqlParser.NEW)
		 		setState(4011)
		 		try unary_expression()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4012)
		 		try match(plsqlParser.DISTINCT)
		 		setState(4013)
		 		try unary_expression()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4014)
		 		try match(plsqlParser.ALL)
		 		setState(4015)
		 		try unary_expression()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4016)
		 		try case_statement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4017)
		 		try quantified_expression()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(4018)
		 		try standard_function()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(4019)
		 		try atom()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Case_statementContext:ParserRuleContext {
		open func searched_case_statement() -> Searched_case_statementContext? {
			return getRuleContext(Searched_case_statementContext.self,0)
		}
		open func simple_case_statement() -> Simple_case_statementContext? {
			return getRuleContext(Simple_case_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCase_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCase_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCase_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCase_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func case_statement() throws -> Case_statementContext {
		var _localctx: Case_statementContext = Case_statementContext(_ctx, getState())
		try enterRule(_localctx, 546, plsqlParser.RULE_case_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4024)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,490, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4022)
		 		try searched_case_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4023)
		 		try simple_case_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_case_statementContext:ParserRuleContext {
		public var ck1: Token!
		open func atom() -> AtomContext? {
			return getRuleContext(AtomContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func CASE() -> Array<TerminalNode> { return getTokens(plsqlParser.CASE) }
		open func CASE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.CASE, i)
		}
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func simple_case_when_part() -> Array<Simple_case_when_partContext> {
			return getRuleContexts(Simple_case_when_partContext.self)
		}
		open func simple_case_when_part(_ i: Int) -> Simple_case_when_partContext? {
			return getRuleContext(Simple_case_when_partContext.self,i)
		}
		open func case_else_part() -> Case_else_partContext? {
			return getRuleContext(Case_else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_case_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_case_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_case_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_case_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_case_statement() throws -> Simple_case_statementContext {
		var _localctx: Simple_case_statementContext = Simple_case_statementContext(_ctx, getState())
		try enterRule(_localctx, 548, plsqlParser.RULE_simple_case_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4027)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(4026)
		 		try label_name()

		 	}

		 	setState(4029)
		 	try {
		 			let assignmentValue = try match(plsqlParser.CASE)
		 			_localctx.castdown(Simple_case_statementContext.self).ck1 = assignmentValue
		 	     }()

		 	setState(4030)
		 	try atom()
		 	setState(4032) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4031)
		 		try simple_case_when_part()


		 		setState(4034); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }())
		 	setState(4037)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ELSE
		 	      return testSet
		 	 }()) {
		 		setState(4036)
		 		try case_else_part()

		 	}

		 	setState(4039)
		 	try match(plsqlParser.END)
		 	setState(4041)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,494,_ctx)) {
		 	case 1:
		 		setState(4040)
		 		try match(plsqlParser.CASE)

		 		break
		 	default: break
		 	}
		 	setState(4044)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,495,_ctx)) {
		 	case 1:
		 		setState(4043)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_case_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_case_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_case_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_case_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_case_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_case_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_case_when_part() throws -> Simple_case_when_partContext {
		var _localctx: Simple_case_when_partContext = Simple_case_when_partContext(_ctx, getState())
		try enterRule(_localctx, 550, plsqlParser.RULE_simple_case_when_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4046)
		 	try match(plsqlParser.WHEN)
		 	setState(4047)
		 	try expression()
		 	setState(4048)
		 	try match(plsqlParser.THEN)
		 	setState(4051)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,496, _ctx)) {
		 	case 1:
		 		setState(4049)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4050)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Searched_case_statementContext:ParserRuleContext {
		public var ck1: Token!
		open func END() -> TerminalNode? { return getToken(plsqlParser.END, 0) }
		open func CASE() -> Array<TerminalNode> { return getTokens(plsqlParser.CASE) }
		open func CASE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.CASE, i)
		}
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func searched_case_when_part() -> Array<Searched_case_when_partContext> {
			return getRuleContexts(Searched_case_when_partContext.self)
		}
		open func searched_case_when_part(_ i: Int) -> Searched_case_when_partContext? {
			return getRuleContext(Searched_case_when_partContext.self,i)
		}
		open func case_else_part() -> Case_else_partContext? {
			return getRuleContext(Case_else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_searched_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearched_case_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearched_case_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearched_case_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearched_case_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searched_case_statement() throws -> Searched_case_statementContext {
		var _localctx: Searched_case_statementContext = Searched_case_statementContext(_ctx, getState())
		try enterRule(_localctx, 552, plsqlParser.RULE_searched_case_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4054)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(4053)
		 		try label_name()

		 	}

		 	setState(4056)
		 	try {
		 			let assignmentValue = try match(plsqlParser.CASE)
		 			_localctx.castdown(Searched_case_statementContext.self).ck1 = assignmentValue
		 	     }()

		 	setState(4058) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4057)
		 		try searched_case_when_part()


		 		setState(4060); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.WHEN
		 	      return testSet
		 	 }())
		 	setState(4063)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ELSE
		 	      return testSet
		 	 }()) {
		 		setState(4062)
		 		try case_else_part()

		 	}

		 	setState(4065)
		 	try match(plsqlParser.END)
		 	setState(4067)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,500,_ctx)) {
		 	case 1:
		 		setState(4066)
		 		try match(plsqlParser.CASE)

		 		break
		 	default: break
		 	}
		 	setState(4070)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,501,_ctx)) {
		 	case 1:
		 		setState(4069)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Searched_case_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.WHEN, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.THEN, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_searched_case_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearched_case_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearched_case_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearched_case_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearched_case_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searched_case_when_part() throws -> Searched_case_when_partContext {
		var _localctx: Searched_case_when_partContext = Searched_case_when_partContext(_ctx, getState())
		try enterRule(_localctx, 554, plsqlParser.RULE_searched_case_when_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4072)
		 	try match(plsqlParser.WHEN)
		 	setState(4073)
		 	try expression()
		 	setState(4074)
		 	try match(plsqlParser.THEN)
		 	setState(4077)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,502, _ctx)) {
		 	case 1:
		 		setState(4075)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4076)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Case_else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.ELSE, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_case_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCase_else_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCase_else_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCase_else_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCase_else_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func case_else_part() throws -> Case_else_partContext {
		var _localctx: Case_else_partContext = Case_else_partContext(_ctx, getState())
		try enterRule(_localctx, 556, plsqlParser.RULE_case_else_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4079)
		 	try match(plsqlParser.ELSE)
		 	setState(4082)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,503, _ctx)) {
		 	case 1:
		 		setState(4080)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4081)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AtomContext:ParserRuleContext {
		open func table_element() -> Table_elementContext? {
			return getRuleContext(Table_elementContext.self,0)
		}
		open func outer_join_sign() -> Outer_join_signContext? {
			return getRuleContext(Outer_join_signContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_or_vector() -> Expression_or_vectorContext? {
			return getRuleContext(Expression_or_vectorContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_atom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAtom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAtom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAtom(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAtom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func atom() throws -> AtomContext {
		var _localctx: AtomContext = AtomContext(_ctx, getState())
		try enterRule(_localctx, 558, plsqlParser.RULE_atom)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(4104)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,506, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4084)
		 		try table_element()
		 		setState(4085)
		 		try outer_join_sign()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4087)
		 		try bind_variable()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4088)
		 		try constant()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4089)
		 		try general_element()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4090)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4102)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,505, _ctx)) {
		 		case 1:
		 			setState(4091)
		 			try subquery()
		 			setState(4092)
		 			try match(plsqlParser.RIGHT_PAREN)
		 			setState(4096)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,504,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(4093)
		 					try subquery_operation_part()

		 			 
		 				}
		 				setState(4098)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,504,_ctx)
		 			}

		 			break
		 		case 2:
		 			setState(4099)
		 			try expression_or_vector()
		 			setState(4100)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Expression_or_vectorContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func vector_expr() -> Vector_exprContext? {
			return getRuleContext(Vector_exprContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression_or_vector }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression_or_vector(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression_or_vector(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression_or_vector(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression_or_vector(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression_or_vector() throws -> Expression_or_vectorContext {
		var _localctx: Expression_or_vectorContext = Expression_or_vectorContext(_ctx, getState())
		try enterRule(_localctx, 560, plsqlParser.RULE_expression_or_vector)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4106)
		 	try expression()
		 	setState(4108)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4107)
		 		try vector_expr()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Vector_exprContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_vector_expr }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVector_expr(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVector_expr(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVector_expr(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVector_expr(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func vector_expr() throws -> Vector_exprContext {
		var _localctx: Vector_exprContext = Vector_exprContext(_ctx, getState())
		try enterRule(_localctx, 562, plsqlParser.RULE_vector_expr)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4110)
		 	try match(plsqlParser.COMMA)
		 	setState(4111)
		 	try expression()
		 	setState(4116)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4112)
		 		try match(plsqlParser.COMMA)
		 		setState(4113)
		 		try expression()


		 		setState(4118)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Quantified_expressionContext:ParserRuleContext {
		open func SOME() -> TerminalNode? { return getToken(plsqlParser.SOME, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(plsqlParser.EXISTS, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func ANY() -> TerminalNode? { return getToken(plsqlParser.ANY, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_quantified_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuantified_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuantified_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuantified_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuantified_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func quantified_expression() throws -> Quantified_expressionContext {
		var _localctx: Quantified_expressionContext = Quantified_expressionContext(_ctx, getState())
		try enterRule(_localctx, 564, plsqlParser.RULE_quantified_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4119)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.ALL || _la == plsqlParser.ANY
		 	          testSet = testSet || _la == plsqlParser.EXISTS
		 	          testSet = testSet || _la == plsqlParser.SOME
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4128)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,509, _ctx)) {
		 	case 1:
		 		setState(4120)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4121)
		 		try subquery()
		 		setState(4122)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 2:
		 		setState(4124)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4125)
		 		try expression()
		 		setState(4126)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Standard_functionContext:ParserRuleContext {
		open func over_clause_keyword() -> Over_clause_keywordContext? {
			return getRuleContext(Over_clause_keywordContext.self,0)
		}
		open func function_argument_analytic() -> Function_argument_analyticContext? {
			return getRuleContext(Function_argument_analyticContext.self,0)
		}
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open func regular_id() -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,0)
		}
		open func function_argument_modeling() -> Function_argument_modelingContext? {
			return getRuleContext(Function_argument_modelingContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.COUNT, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.DISTINCT, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.UNIQUE, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.ALL, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func CAST() -> TerminalNode? { return getToken(plsqlParser.CAST, 0) }
		open func XMLCAST() -> TerminalNode? { return getToken(plsqlParser.XMLCAST, 0) }
		open func MULTISET() -> TerminalNode? { return getToken(plsqlParser.MULTISET, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func CHR() -> TerminalNode? { return getToken(plsqlParser.CHR, 0) }
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func NCHAR_CS() -> TerminalNode? { return getToken(plsqlParser.NCHAR_CS, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.COLLECT, 0) }
		open func collect_order_by_part() -> Collect_order_by_partContext? {
			return getRuleContext(Collect_order_by_partContext.self,0)
		}
		open func within_or_over_clause_keyword() -> Within_or_over_clause_keywordContext? {
			return getRuleContext(Within_or_over_clause_keywordContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open func within_or_over_part() -> Array<Within_or_over_partContext> {
			return getRuleContexts(Within_or_over_partContext.self)
		}
		open func within_or_over_part(_ i: Int) -> Within_or_over_partContext? {
			return getRuleContext(Within_or_over_partContext.self,i)
		}
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func PERCENT_ISOPEN() -> TerminalNode? { return getToken(plsqlParser.PERCENT_ISOPEN, 0) }
		open func PERCENT_FOUND() -> TerminalNode? { return getToken(plsqlParser.PERCENT_FOUND, 0) }
		open func PERCENT_NOTFOUND() -> TerminalNode? { return getToken(plsqlParser.PERCENT_NOTFOUND, 0) }
		open func PERCENT_ROWCOUNT() -> TerminalNode? { return getToken(plsqlParser.PERCENT_ROWCOUNT, 0) }
		open func DECOMPOSE() -> TerminalNode? { return getToken(plsqlParser.DECOMPOSE, 0) }
		open func CANONICAL() -> TerminalNode? { return getToken(plsqlParser.CANONICAL, 0) }
		open func COMPATIBILITY() -> TerminalNode? { return getToken(plsqlParser.COMPATIBILITY, 0) }
		open func EXTRACT() -> TerminalNode? { return getToken(plsqlParser.EXTRACT, 0) }
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.FROM, 0) }
		open func FIRST_VALUE() -> TerminalNode? { return getToken(plsqlParser.FIRST_VALUE, 0) }
		open func LAST_VALUE() -> TerminalNode? { return getToken(plsqlParser.LAST_VALUE, 0) }
		open func respect_or_ignore_nulls() -> Respect_or_ignore_nullsContext? {
			return getRuleContext(Respect_or_ignore_nullsContext.self,0)
		}
		open func standard_prediction_function_keyword() -> Standard_prediction_function_keywordContext? {
			return getRuleContext(Standard_prediction_function_keywordContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func cost_matrix_clause() -> Cost_matrix_clauseContext? {
			return getRuleContext(Cost_matrix_clauseContext.self,0)
		}
		open func TRANSLATE() -> TerminalNode? { return getToken(plsqlParser.TRANSLATE, 0) }
		open func CHAR_CS() -> TerminalNode? { return getToken(plsqlParser.CHAR_CS, 0) }
		open func TREAT() -> TerminalNode? { return getToken(plsqlParser.TREAT, 0) }
		open func REF() -> TerminalNode? { return getToken(plsqlParser.REF, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.TRIM, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func LEADING() -> TerminalNode? { return getToken(plsqlParser.LEADING, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(plsqlParser.TRAILING, 0) }
		open func BOTH() -> TerminalNode? { return getToken(plsqlParser.BOTH, 0) }
		open func XMLAGG() -> TerminalNode? { return getToken(plsqlParser.XMLAGG, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func general_element_part() -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,0)
		}
		open func xml_multiuse_expression_element() -> Array<Xml_multiuse_expression_elementContext> {
			return getRuleContexts(Xml_multiuse_expression_elementContext.self)
		}
		open func xml_multiuse_expression_element(_ i: Int) -> Xml_multiuse_expression_elementContext? {
			return getRuleContext(Xml_multiuse_expression_elementContext.self,i)
		}
		open func XMLCOLATTVAL() -> TerminalNode? { return getToken(plsqlParser.XMLCOLATTVAL, 0) }
		open func XMLFOREST() -> TerminalNode? { return getToken(plsqlParser.XMLFOREST, 0) }
		open func XMLELEMENT() -> TerminalNode? { return getToken(plsqlParser.XMLELEMENT, 0) }
		open func xml_attributes_clause() -> Xml_attributes_clauseContext? {
			return getRuleContext(Xml_attributes_clauseContext.self,0)
		}
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.ENTITYESCAPING, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.NOENTITYESCAPING, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.EVALNAME, 0) }
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open func XMLEXISTS() -> TerminalNode? { return getToken(plsqlParser.XMLEXISTS, 0) }
		open func xml_passing_clause() -> Xml_passing_clauseContext? {
			return getRuleContext(Xml_passing_clauseContext.self,0)
		}
		open func XMLPARSE() -> TerminalNode? { return getToken(plsqlParser.XMLPARSE, 0) }
		open func DOCUMENT() -> TerminalNode? { return getToken(plsqlParser.DOCUMENT, 0) }
		open func CONTENT() -> TerminalNode? { return getToken(plsqlParser.CONTENT, 0) }
		open func WELLFORMED() -> TerminalNode? { return getToken(plsqlParser.WELLFORMED, 0) }
		open func XMLPI() -> TerminalNode? { return getToken(plsqlParser.XMLPI, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func XMLQUERY() -> TerminalNode? { return getToken(plsqlParser.XMLQUERY, 0) }
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.RETURNING, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func EMPTY() -> TerminalNode? { return getToken(plsqlParser.EMPTY, 0) }
		open func XMLROOT() -> TerminalNode? { return getToken(plsqlParser.XMLROOT, 0) }
		open func xmlroot_param_version_part() -> Xmlroot_param_version_partContext? {
			return getRuleContext(Xmlroot_param_version_partContext.self,0)
		}
		open func xmlroot_param_standalone_part() -> Xmlroot_param_standalone_partContext? {
			return getRuleContext(Xmlroot_param_standalone_partContext.self,0)
		}
		open func XMLSERIALIZE() -> TerminalNode? { return getToken(plsqlParser.XMLSERIALIZE, 0) }
		open func xmlserialize_param_enconding_part() -> Xmlserialize_param_enconding_partContext? {
			return getRuleContext(Xmlserialize_param_enconding_partContext.self,0)
		}
		open func xmlserialize_param_version_part() -> Xmlserialize_param_version_partContext? {
			return getRuleContext(Xmlserialize_param_version_partContext.self,0)
		}
		open func xmlserialize_param_ident_part() -> Xmlserialize_param_ident_partContext? {
			return getRuleContext(Xmlserialize_param_ident_partContext.self,0)
		}
		open func DEFAULTS() -> TerminalNode? { return getToken(plsqlParser.DEFAULTS, 0) }
		open func HIDE() -> TerminalNode? { return getToken(plsqlParser.HIDE, 0) }
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.SHOW, 0) }
		open func XMLTABLE() -> TerminalNode? { return getToken(plsqlParser.XMLTABLE, 0) }
		open func xml_namespaces_clause() -> Xml_namespaces_clauseContext? {
			return getRuleContext(Xml_namespaces_clauseContext.self,0)
		}
		open func COLUMNS() -> TerminalNode? { return getToken(plsqlParser.COLUMNS, 0) }
		open func xml_table_column() -> Array<Xml_table_columnContext> {
			return getRuleContexts(Xml_table_columnContext.self)
		}
		open func xml_table_column(_ i: Int) -> Xml_table_columnContext? {
			return getRuleContext(Xml_table_columnContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_standard_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStandard_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStandard_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStandard_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStandard_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func standard_function() throws -> Standard_functionContext {
		var _localctx: Standard_functionContext = Standard_functionContext(_ctx, getState())
		try enterRule(_localctx, 566, plsqlParser.RULE_standard_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(4447)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,562, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4130)
		 		try over_clause_keyword()
		 		setState(4131)
		 		try function_argument_analytic()
		 		setState(4133)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,510,_ctx)) {
		 		case 1:
		 			setState(4132)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4135)
		 		try regular_id()
		 		setState(4136)
		 		try function_argument_modeling()
		 		setState(4138)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,511,_ctx)) {
		 		case 1:
		 			setState(4137)
		 			try using_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4140)
		 		try match(plsqlParser.COUNT)
		 		setState(4141)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4147)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.ASTERISK:
		 			setState(4142)
		 			try match(plsqlParser.ASTERISK)

		 			break
		 		case plsqlParser.A_LETTER:fallthrough
		 		case plsqlParser.ADD:fallthrough
		 		case plsqlParser.AFTER:fallthrough
		 		case plsqlParser.AGENT:fallthrough
		 		case plsqlParser.AGGREGATE:fallthrough
		 		case plsqlParser.ALL:fallthrough
		 		case plsqlParser.ANALYZE:fallthrough
		 		case plsqlParser.ANY:fallthrough
		 		case plsqlParser.ARRAY:fallthrough
		 		case plsqlParser.ASSOCIATE:fallthrough
		 		case plsqlParser.AT:fallthrough
		 		case plsqlParser.ATTRIBUTE:fallthrough
		 		case plsqlParser.AUDIT:fallthrough
		 		case plsqlParser.AUTHID:fallthrough
		 		case plsqlParser.AUTO:fallthrough
		 		case plsqlParser.AUTOMATIC:fallthrough
		 		case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 		case plsqlParser.BATCH:fallthrough
		 		case plsqlParser.BEFORE:fallthrough
		 		case plsqlParser.BFILE:fallthrough
		 		case plsqlParser.BINARY_DOUBLE:fallthrough
		 		case plsqlParser.BINARY_FLOAT:fallthrough
		 		case plsqlParser.BINARY_INTEGER:fallthrough
		 		case plsqlParser.BLOB:fallthrough
		 		case plsqlParser.BLOCK:fallthrough
		 		case plsqlParser.BODY:fallthrough
		 		case plsqlParser.BOOLEAN:fallthrough
		 		case plsqlParser.BOTH:fallthrough
		 		case plsqlParser.BULK:fallthrough
		 		case plsqlParser.BYTE:fallthrough
		 		case plsqlParser.C_LETTER:fallthrough
		 		case plsqlParser.CALL:fallthrough
		 		case plsqlParser.CANONICAL:fallthrough
		 		case plsqlParser.CASCADE:fallthrough
		 		case plsqlParser.CASE:fallthrough
		 		case plsqlParser.CAST:fallthrough
		 		case plsqlParser.CHAR:fallthrough
		 		case plsqlParser.CHAR_CS:fallthrough
		 		case plsqlParser.CHARACTER:fallthrough
		 		case plsqlParser.CHR:fallthrough
		 		case plsqlParser.CLOB:fallthrough
		 		case plsqlParser.CLOSE:fallthrough
		 		case plsqlParser.CLUSTER:fallthrough
		 		case plsqlParser.COLLECT:fallthrough
		 		case plsqlParser.COLUMNS:fallthrough
		 		case plsqlParser.COMMENT:fallthrough
		 		case plsqlParser.COMMIT:fallthrough
		 		case plsqlParser.COMMITTED:fallthrough
		 		case plsqlParser.COMPATIBILITY:fallthrough
		 		case plsqlParser.COMPILE:fallthrough
		 		case plsqlParser.COMPOUND:fallthrough
		 		case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 		case plsqlParser.CONSTANT:fallthrough
		 		case plsqlParser.CONSTRAINT:fallthrough
		 		case plsqlParser.CONSTRAINTS:fallthrough
		 		case plsqlParser.CONSTRUCTOR:fallthrough
		 		case plsqlParser.CONTENT:fallthrough
		 		case plsqlParser.CONTEXT:fallthrough
		 		case plsqlParser.CONTINUE:fallthrough
		 		case plsqlParser.CONVERT:fallthrough
		 		case plsqlParser.CORRUPT_XID:fallthrough
		 		case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 		case plsqlParser.COST:fallthrough
		 		case plsqlParser.COUNT:fallthrough
		 		case plsqlParser.CROSS:fallthrough
		 		case plsqlParser.CUBE:fallthrough
		 		case plsqlParser.CURRENT_USER:fallthrough
		 		case plsqlParser.CURSOR:fallthrough
		 		case plsqlParser.CUSTOMDATUM:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.DATA:fallthrough
		 		case plsqlParser.DATABASE:fallthrough
		 		case plsqlParser.DATE:fallthrough
		 		case plsqlParser.DAY:fallthrough
		 		case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DDL:fallthrough
		 		case plsqlParser.DEBUG:fallthrough
		 		case plsqlParser.DEC:fallthrough
		 		case plsqlParser.DECIMAL:fallthrough
		 		case plsqlParser.DECOMPOSE:fallthrough
		 		case plsqlParser.DECREMENT:fallthrough
		 		case plsqlParser.DEFAULT:fallthrough
		 		case plsqlParser.DEFAULTS:fallthrough
		 		case plsqlParser.DEFERRED:fallthrough
		 		case plsqlParser.DEFINER:fallthrough
		 		case plsqlParser.DETERMINISTIC:fallthrough
		 		case plsqlParser.DIMENSION:fallthrough
		 		case plsqlParser.DISABLE:fallthrough
		 		case plsqlParser.DISASSOCIATE:fallthrough
		 		case plsqlParser.DISTINCT:fallthrough
		 		case plsqlParser.DOCUMENT:fallthrough
		 		case plsqlParser.DOUBLE:fallthrough
		 		case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.EACH:fallthrough
		 		case plsqlParser.ELEMENT:fallthrough
		 		case plsqlParser.EMPTY:fallthrough
		 		case plsqlParser.ENABLE:fallthrough
		 		case plsqlParser.ENCODING:fallthrough
		 		case plsqlParser.ENTITYESCAPING:fallthrough
		 		case plsqlParser.ERR:fallthrough
		 		case plsqlParser.ERRORS:fallthrough
		 		case plsqlParser.ESCAPE:fallthrough
		 		case plsqlParser.EVALNAME:fallthrough
		 		case plsqlParser.EXCEPTION:fallthrough
		 		case plsqlParser.EXCEPTION_INIT:fallthrough
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.EXCLUDE:fallthrough
		 		case plsqlParser.EXECUTE:fallthrough
		 		case plsqlParser.EXISTS:fallthrough
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.EXTERNAL:fallthrough
		 		case plsqlParser.EXTRACT:fallthrough
		 		case plsqlParser.FAILURE:fallthrough
		 		case plsqlParser.FALSE:fallthrough
		 		case plsqlParser.FINAL:fallthrough
		 		case plsqlParser.FIRST:fallthrough
		 		case plsqlParser.FIRST_VALUE:fallthrough
		 		case plsqlParser.FLOAT:fallthrough
		 		case plsqlParser.FOLLOWING:fallthrough
		 		case plsqlParser.FOLLOWS:fallthrough
		 		case plsqlParser.FORALL:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.FULL:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.GROUPING:fallthrough
		 		case plsqlParser.HASH:fallthrough
		 		case plsqlParser.HIDE:fallthrough
		 		case plsqlParser.HOUR:fallthrough
		 		case plsqlParser.IGNORE:fallthrough
		 		case plsqlParser.IMMEDIATE:fallthrough
		 		case plsqlParser.INCLUDE:fallthrough
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.INDENT:fallthrough
		 		case plsqlParser.INDEXED:fallthrough
		 		case plsqlParser.INDICATOR:fallthrough
		 		case plsqlParser.INDICES:fallthrough
		 		case plsqlParser.INFINITE:fallthrough
		 		case plsqlParser.INLINE:fallthrough
		 		case plsqlParser.INNER:fallthrough
		 		case plsqlParser.INOUT:fallthrough
		 		case plsqlParser.INSTANTIABLE:fallthrough
		 		case plsqlParser.INSTEAD:fallthrough
		 		case plsqlParser.INT:fallthrough
		 		case plsqlParser.INTEGER:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.INVALIDATE:fallthrough
		 		case plsqlParser.ISOLATION:fallthrough
		 		case plsqlParser.ITERATE:fallthrough
		 		case plsqlParser.JAVA:fallthrough
		 		case plsqlParser.JOIN:fallthrough
		 		case plsqlParser.KEEP:fallthrough
		 		case plsqlParser.LANGUAGE:fallthrough
		 		case plsqlParser.LAST:fallthrough
		 		case plsqlParser.LAST_VALUE:fallthrough
		 		case plsqlParser.LEADING:fallthrough
		 		case plsqlParser.LEFT:fallthrough
		 		case plsqlParser.LEVEL:fallthrough
		 		case plsqlParser.LIBRARY:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:fallthrough
		 		case plsqlParser.LIMIT:fallthrough
		 		case plsqlParser.LOCAL:fallthrough
		 		case plsqlParser.LOCKED:fallthrough
		 		case plsqlParser.LOG:fallthrough
		 		case plsqlParser.LOGOFF:fallthrough
		 		case plsqlParser.LOGON:fallthrough
		 		case plsqlParser.LONG:fallthrough
		 		case plsqlParser.LOOP:fallthrough
		 		case plsqlParser.MAIN:fallthrough
		 		case plsqlParser.MAP:fallthrough
		 		case plsqlParser.MATCHED:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MEASURES:fallthrough
		 		case plsqlParser.MEMBER:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.MINUTE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.MLSLABEL:fallthrough
		 		case plsqlParser.MODEL:fallthrough
		 		case plsqlParser.MODIFY:fallthrough
		 		case plsqlParser.MONTH:fallthrough
		 		case plsqlParser.MULTISET:fallthrough
		 		case plsqlParser.NAME:fallthrough
		 		case plsqlParser.NAN:fallthrough
		 		case plsqlParser.NATURAL:fallthrough
		 		case plsqlParser.NATURALN:fallthrough
		 		case plsqlParser.NAV:fallthrough
		 		case plsqlParser.NCHAR:fallthrough
		 		case plsqlParser.NCHAR_CS:fallthrough
		 		case plsqlParser.NCLOB:fallthrough
		 		case plsqlParser.NESTED:fallthrough
		 		case plsqlParser.NEW:fallthrough
		 		case plsqlParser.NO:fallthrough
		 		case plsqlParser.NOAUDIT:fallthrough
		 		case plsqlParser.NOCOPY:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOENTITYESCAPING:fallthrough
		 		case plsqlParser.NONE:fallthrough
		 		case plsqlParser.NOSCHEMACHECK:fallthrough
		 		case plsqlParser.NULL:fallthrough
		 		case plsqlParser.NULLS:fallthrough
		 		case plsqlParser.NUMBER:fallthrough
		 		case plsqlParser.NUMERIC:fallthrough
		 		case plsqlParser.NVARCHAR2:fallthrough
		 		case plsqlParser.OBJECT:fallthrough
		 		case plsqlParser.OFF:fallthrough
		 		case plsqlParser.OID:fallthrough
		 		case plsqlParser.OLD:fallthrough
		 		case plsqlParser.ONLY:fallthrough
		 		case plsqlParser.OPEN:fallthrough
		 		case plsqlParser.ORADATA:fallthrough
		 		case plsqlParser.ORDINALITY:fallthrough
		 		case plsqlParser.OSERROR:fallthrough
		 		case plsqlParser.OUT:fallthrough
		 		case plsqlParser.OUTER:fallthrough
		 		case plsqlParser.OVER:fallthrough
		 		case plsqlParser.OVERRIDING:fallthrough
		 		case plsqlParser.PACKAGE:fallthrough
		 		case plsqlParser.PARALLEL_ENABLE:fallthrough
		 		case plsqlParser.PARAMETERS:fallthrough
		 		case plsqlParser.PARENT:fallthrough
		 		case plsqlParser.PARTITION:fallthrough
		 		case plsqlParser.PASSING:fallthrough
		 		case plsqlParser.PATH:fallthrough
		 		case plsqlParser.PIPELINED:fallthrough
		 		case plsqlParser.PLAN:fallthrough
		 		case plsqlParser.PLS_INTEGER:fallthrough
		 		case plsqlParser.POSITIVE:fallthrough
		 		case plsqlParser.POSITIVEN:fallthrough
		 		case plsqlParser.PRAGMA:fallthrough
		 		case plsqlParser.PRECEDING:fallthrough
		 		case plsqlParser.PRECISION:fallthrough
		 		case plsqlParser.PRESENT:fallthrough
		 		case plsqlParser.PRIOR:fallthrough
		 		case plsqlParser.RAISE:fallthrough
		 		case plsqlParser.RANGE:fallthrough
		 		case plsqlParser.RAW:fallthrough
		 		case plsqlParser.READ:fallthrough
		 		case plsqlParser.REAL:fallthrough
		 		case plsqlParser.RECORD:fallthrough
		 		case plsqlParser.REF:fallthrough
		 		case plsqlParser.REFERENCE:fallthrough
		 		case plsqlParser.REFERENCING:fallthrough
		 		case plsqlParser.REJECT:fallthrough
		 		case plsqlParser.RELIES_ON:fallthrough
		 		case plsqlParser.RENAME:fallthrough
		 		case plsqlParser.REPLACE:fallthrough
		 		case plsqlParser.RESPECT:fallthrough
		 		case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 		case plsqlParser.RESULT:fallthrough
		 		case plsqlParser.RESULT_CACHE:fallthrough
		 		case plsqlParser.RETURN:fallthrough
		 		case plsqlParser.RETURNING:fallthrough
		 		case plsqlParser.REUSE:fallthrough
		 		case plsqlParser.REVERSE:fallthrough
		 		case plsqlParser.RIGHT:fallthrough
		 		case plsqlParser.ROLLBACK:fallthrough
		 		case plsqlParser.ROLLUP:fallthrough
		 		case plsqlParser.ROW:fallthrough
		 		case plsqlParser.ROWID:fallthrough
		 		case plsqlParser.ROWS:fallthrough
		 		case plsqlParser.RULES:fallthrough
		 		case plsqlParser.SAMPLE:fallthrough
		 		case plsqlParser.SAVE:fallthrough
		 		case plsqlParser.SAVEPOINT:fallthrough
		 		case plsqlParser.SCHEMA:fallthrough
		 		case plsqlParser.SCHEMACHECK:fallthrough
		 		case plsqlParser.SCN:fallthrough
		 		case plsqlParser.SECOND:fallthrough
		 		case plsqlParser.SEED:fallthrough
		 		case plsqlParser.SEGMENT:fallthrough
		 		case plsqlParser.SELF:fallthrough
		 		case plsqlParser.SEQUENTIAL:fallthrough
		 		case plsqlParser.SERIALIZABLE:fallthrough
		 		case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 		case plsqlParser.SERVERERROR:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SETS:fallthrough
		 		case plsqlParser.SETTINGS:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.SHUTDOWN:fallthrough
		 		case plsqlParser.SIBLINGS:fallthrough
		 		case plsqlParser.SIGNTYPE:fallthrough
		 		case plsqlParser.SIMPLE_INTEGER:fallthrough
		 		case plsqlParser.SINGLE:fallthrough
		 		case plsqlParser.SKIP_:fallthrough
		 		case plsqlParser.SMALLINT:fallthrough
		 		case plsqlParser.SNAPSHOT:fallthrough
		 		case plsqlParser.SOME:fallthrough
		 		case plsqlParser.SPECIFICATION:fallthrough
		 		case plsqlParser.SQLDATA:fallthrough
		 		case plsqlParser.SQLERROR:fallthrough
		 		case plsqlParser.STANDALONE:fallthrough
		 		case plsqlParser.STARTUP:fallthrough
		 		case plsqlParser.STATEMENT:fallthrough
		 		case plsqlParser.STATEMENT_ID:fallthrough
		 		case plsqlParser.STATIC:fallthrough
		 		case plsqlParser.STATISTICS:fallthrough
		 		case plsqlParser.STRING:fallthrough
		 		case plsqlParser.SUBMULTISET:fallthrough
		 		case plsqlParser.SUBPARTITION:fallthrough
		 		case plsqlParser.SUBSTITUTABLE:fallthrough
		 		case plsqlParser.SUBTYPE:fallthrough
		 		case plsqlParser.SUCCESS:fallthrough
		 		case plsqlParser.SUSPEND:fallthrough
		 		case plsqlParser.TIME:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMEZONE_ABBR:fallthrough
		 		case plsqlParser.TIMEZONE_HOUR:fallthrough
		 		case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 		case plsqlParser.TIMEZONE_REGION:fallthrough
		 		case plsqlParser.TRAILING:fallthrough
		 		case plsqlParser.TRANSACTION:fallthrough
		 		case plsqlParser.TRANSLATE:fallthrough
		 		case plsqlParser.TREAT:fallthrough
		 		case plsqlParser.TRIGGER:fallthrough
		 		case plsqlParser.TRIM:fallthrough
		 		case plsqlParser.TRUE:fallthrough
		 		case plsqlParser.TRUNCATE:fallthrough
		 		case plsqlParser.TYPE:fallthrough
		 		case plsqlParser.UNBOUNDED:fallthrough
		 		case plsqlParser.UNDER:fallthrough
		 		case plsqlParser.UNIQUE:fallthrough
		 		case plsqlParser.UNLIMITED:fallthrough
		 		case plsqlParser.UNTIL:fallthrough
		 		case plsqlParser.UPDATED:fallthrough
		 		case plsqlParser.UPSERT:fallthrough
		 		case plsqlParser.UROWID:fallthrough
		 		case plsqlParser.USE:fallthrough
		 		case plsqlParser.VALIDATE:fallthrough
		 		case plsqlParser.VALUE:fallthrough
		 		case plsqlParser.VARCHAR:fallthrough
		 		case plsqlParser.VARCHAR2:fallthrough
		 		case plsqlParser.VARIABLE:fallthrough
		 		case plsqlParser.VARRAY:fallthrough
		 		case plsqlParser.VARYING:fallthrough
		 		case plsqlParser.VERSION:fallthrough
		 		case plsqlParser.VERSIONS:fallthrough
		 		case plsqlParser.WAIT:fallthrough
		 		case plsqlParser.WARNING:fallthrough
		 		case plsqlParser.WELLFORMED:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.WHILE:fallthrough
		 		case plsqlParser.WITHIN:fallthrough
		 		case plsqlParser.WORK:fallthrough
		 		case plsqlParser.WRITE:fallthrough
		 		case plsqlParser.XML:fallthrough
		 		case plsqlParser.XMLAGG:fallthrough
		 		case plsqlParser.XMLATTRIBUTES:fallthrough
		 		case plsqlParser.XMLCAST:fallthrough
		 		case plsqlParser.XMLCOLATTVAL:fallthrough
		 		case plsqlParser.XMLELEMENT:fallthrough
		 		case plsqlParser.XMLEXISTS:fallthrough
		 		case plsqlParser.XMLFOREST:fallthrough
		 		case plsqlParser.XMLNAMESPACES:fallthrough
		 		case plsqlParser.XMLPARSE:fallthrough
		 		case plsqlParser.XMLPI:fallthrough
		 		case plsqlParser.XMLQUERY:fallthrough
		 		case plsqlParser.XMLROOT:fallthrough
		 		case plsqlParser.XMLSERIALIZE:fallthrough
		 		case plsqlParser.XMLTABLE:fallthrough
		 		case plsqlParser.YEAR:fallthrough
		 		case plsqlParser.YES:fallthrough
		 		case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.ZONE:fallthrough
		 		case plsqlParser.PREDICTION:fallthrough
		 		case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 		case plsqlParser.PREDICTION_COST:fallthrough
		 		case plsqlParser.PREDICTION_DETAILS:fallthrough
		 		case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 		case plsqlParser.PREDICTION_SET:fallthrough
		 		case plsqlParser.CUME_DIST:fallthrough
		 		case plsqlParser.DENSE_RANK:fallthrough
		 		case plsqlParser.LISTAGG:fallthrough
		 		case plsqlParser.PERCENT_RANK:fallthrough
		 		case plsqlParser.PERCENTILE_CONT:fallthrough
		 		case plsqlParser.PERCENTILE_DISC:fallthrough
		 		case plsqlParser.RANK:fallthrough
		 		case plsqlParser.AVG:fallthrough
		 		case plsqlParser.CORR:fallthrough
		 		case plsqlParser.LAG:fallthrough
		 		case plsqlParser.LEAD:fallthrough
		 		case plsqlParser.MAX:fallthrough
		 		case plsqlParser.MEDIAN:fallthrough
		 		case plsqlParser.MIN:fallthrough
		 		case plsqlParser.NTILE:fallthrough
		 		case plsqlParser.RATIO_TO_REPORT:fallthrough
		 		case plsqlParser.ROW_NUMBER:fallthrough
		 		case plsqlParser.SUM:fallthrough
		 		case plsqlParser.VARIANCE:fallthrough
		 		case plsqlParser.REGR_:fallthrough
		 		case plsqlParser.STDDEV:fallthrough
		 		case plsqlParser.VAR_:fallthrough
		 		case plsqlParser.COVAR_:fallthrough
		 		case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 		case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 		case plsqlParser.CHAR_STRING:fallthrough
		 		case plsqlParser.DELIMITED_ID:fallthrough
		 		case plsqlParser.LEFT_PAREN:fallthrough
		 		case plsqlParser.PLUS_SIGN:fallthrough
		 		case plsqlParser.MINUS_SIGN:fallthrough
		 		case plsqlParser.BINDVAR:fallthrough
		 		case plsqlParser.COLON:fallthrough
		 		case plsqlParser.INTRODUCER:fallthrough
		 		case plsqlParser.REGULAR_ID:
		 			setState(4144)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,512,_ctx)) {
		 			case 1:
		 				setState(4143)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.ALL
		 				          testSet = testSet || _la == plsqlParser.DISTINCT
		 				          testSet = testSet || _la == plsqlParser.UNIQUE
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				} else {
		 					try consume()
		 				}

		 				break
		 			default: break
		 			}
		 			setState(4146)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4149)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4151)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,514,_ctx)) {
		 		case 1:
		 			setState(4150)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4153)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.CAST
		 		          testSet = testSet || _la == plsqlParser.XMLCAST
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4154)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4161)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,515, _ctx)) {
		 		case 1:
		 			setState(4155)
		 			try match(plsqlParser.MULTISET)
		 			setState(4156)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(4157)
		 			try subquery()
		 			setState(4158)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		case 2:
		 			setState(4160)
		 			try concatenation()

		 			break
		 		default: break
		 		}
		 		setState(4163)
		 		try match(plsqlParser.AS)
		 		setState(4164)
		 		try type_spec()
		 		setState(4165)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4167)
		 		try match(plsqlParser.CHR)
		 		setState(4168)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4169)
		 		try concatenation()
		 		setState(4170)
		 		try match(plsqlParser.USING)
		 		setState(4171)
		 		try match(plsqlParser.NCHAR_CS)
		 		setState(4172)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4174)
		 		try match(plsqlParser.COLLECT)
		 		setState(4175)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4177)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,516,_ctx)) {
		 		case 1:
		 			setState(4176)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.DISTINCT
		 			          testSet = testSet || _la == plsqlParser.UNIQUE
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4179)
		 		try concatenation()
		 		setState(4181)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.ORDER
		 		      return testSet
		 		 }()) {
		 			setState(4180)
		 			try collect_order_by_part()

		 		}

		 		setState(4183)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4185)
		 		try within_or_over_clause_keyword()
		 		setState(4186)
		 		try function_argument()
		 		setState(4188); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(4187)
		 				try within_or_over_part()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(4190); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,518,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4192)
		 		try cursor_name()
		 		setState(4193)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.PERCENT_ISOPEN,plsqlParser.PERCENT_FOUND,plsqlParser.PERCENT_NOTFOUND,plsqlParser.PERCENT_ROWCOUNT]
		 		    return  Utils.testBitLeftShiftArray(testArray, 281)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(4195)
		 		try match(plsqlParser.DECOMPOSE)
		 		setState(4196)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4197)
		 		try concatenation()
		 		setState(4199)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.CANONICAL || _la == plsqlParser.COMPATIBILITY
		 		      return testSet
		 		 }()) {
		 			setState(4198)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.CANONICAL || _la == plsqlParser.COMPATIBILITY
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 		}

		 		setState(4201)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(4203)
		 		try match(plsqlParser.EXTRACT)
		 		setState(4204)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4205)
		 		try regular_id()
		 		setState(4206)
		 		try match(plsqlParser.FROM)
		 		setState(4207)
		 		try concatenation()
		 		setState(4208)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(4210)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.FIRST_VALUE || _la == plsqlParser.LAST_VALUE
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4211)
		 		try function_argument_analytic()
		 		setState(4213)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.IGNORE
		 		          testSet = testSet || _la == plsqlParser.RESPECT
		 		      return testSet
		 		 }()) {
		 			setState(4212)
		 			try respect_or_ignore_nulls()

		 		}

		 		setState(4215)
		 		try over_clause()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(4217)
		 		try standard_prediction_function_keyword()
		 		setState(4218)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4219)
		 		try expression()
		 		setState(4224)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4220)
		 			try match(plsqlParser.COMMA)
		 			setState(4221)
		 			try expression()


		 			setState(4226)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4228)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COST
		 		      return testSet
		 		 }()) {
		 			setState(4227)
		 			try cost_matrix_clause()

		 		}

		 		setState(4231)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.USING
		 		      return testSet
		 		 }()) {
		 			setState(4230)
		 			try using_clause()

		 		}

		 		setState(4233)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(4235)
		 		try match(plsqlParser.TRANSLATE)
		 		setState(4236)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4237)
		 		try expression()
		 		setState(4240)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.USING
		 		      return testSet
		 		 }()) {
		 			setState(4238)
		 			try match(plsqlParser.USING)
		 			setState(4239)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.CHAR_CS
		 			          testSet = testSet || _la == plsqlParser.NCHAR_CS
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 		}

		 		setState(4246)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4242)
		 			try match(plsqlParser.COMMA)
		 			setState(4243)
		 			try expression()


		 			setState(4248)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4249)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(4251)
		 		try match(plsqlParser.TREAT)
		 		setState(4252)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4253)
		 		try expression()
		 		setState(4254)
		 		try match(plsqlParser.AS)
		 		setState(4256)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,526,_ctx)) {
		 		case 1:
		 			setState(4255)
		 			try match(plsqlParser.REF)

		 			break
		 		default: break
		 		}
		 		setState(4258)
		 		try type_spec()
		 		setState(4259)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(4261)
		 		try match(plsqlParser.TRIM)
		 		setState(4262)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4270)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,529,_ctx)) {
		 		case 1:
		 			setState(4264)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.BOTH
		 			          testSet = testSet || _la == plsqlParser.LEADING
		 			          testSet = testSet || _la == plsqlParser.TRAILING
		 			      return testSet
		 			 }()) {
		 				setState(4263)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.BOTH
		 				          testSet = testSet || _la == plsqlParser.LEADING
		 				          testSet = testSet || _la == plsqlParser.TRAILING
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				} else {
		 					try consume()
		 				}

		 			}

		 			setState(4267)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.NATIONAL_CHAR_STRING_LIT || _la == plsqlParser.CHAR_STRING
		 			      return testSet
		 			 }()) {
		 				setState(4266)
		 				try quoted_string()

		 			}

		 			setState(4269)
		 			try match(plsqlParser.FROM)

		 			break
		 		default: break
		 		}
		 		setState(4272)
		 		try concatenation()
		 		setState(4273)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(4275)
		 		try match(plsqlParser.XMLAGG)
		 		setState(4276)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4277)
		 		try expression()
		 		setState(4279)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.ORDER
		 		      return testSet
		 		 }()) {
		 			setState(4278)
		 			try order_by_clause()

		 		}

		 		setState(4281)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4284)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,531,_ctx)) {
		 		case 1:
		 			setState(4282)
		 			try match(plsqlParser.PERIOD)
		 			setState(4283)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(4286)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.XMLCOLATTVAL || _la == plsqlParser.XMLFOREST
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4287)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4288)
		 		try xml_multiuse_expression_element()
		 		setState(4293)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4289)
		 			try match(plsqlParser.COMMA)
		 			setState(4290)
		 			try xml_multiuse_expression_element()


		 			setState(4295)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4296)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4299)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,533,_ctx)) {
		 		case 1:
		 			setState(4297)
		 			try match(plsqlParser.PERIOD)
		 			setState(4298)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(4301)
		 		try match(plsqlParser.XMLELEMENT)
		 		setState(4302)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4304)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,534,_ctx)) {
		 		case 1:
		 			setState(4303)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.ENTITYESCAPING
		 			          testSet = testSet || _la == plsqlParser.NOENTITYESCAPING
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4307)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,535,_ctx)) {
		 		case 1:
		 			setState(4306)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.EVALNAME
		 			          testSet = testSet || _la == plsqlParser.NAME
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4309)
		 		try expression()
		 		setState(4312)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,536,_ctx)) {
		 		case 1:
		 			setState(4310)
		 			try match(plsqlParser.COMMA)
		 			setState(4311)
		 			try xml_attributes_clause()

		 			break
		 		default: break
		 		}
		 		setState(4321)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4314)
		 			try match(plsqlParser.COMMA)
		 			setState(4315)
		 			try expression()
		 			setState(4317)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 65)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 129)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 193)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 258)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 			              return  Utils.testBitLeftShiftArray(testArray, 322)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 			              return  Utils.testBitLeftShiftArray(testArray, 386)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 			              return  Utils.testBitLeftShiftArray(testArray, 450)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 			      return testSet
		 			 }()) {
		 				setState(4316)
		 				try column_alias()

		 			}



		 			setState(4323)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4324)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4327)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,539,_ctx)) {
		 		case 1:
		 			setState(4325)
		 			try match(plsqlParser.PERIOD)
		 			setState(4326)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(4329)
		 		try match(plsqlParser.XMLEXISTS)
		 		setState(4330)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4331)
		 		try expression()
		 		setState(4333)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PASSING
		 		      return testSet
		 		 }()) {
		 			setState(4332)
		 			try xml_passing_clause()

		 		}

		 		setState(4335)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(4337)
		 		try match(plsqlParser.XMLPARSE)
		 		setState(4338)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4339)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.CONTENT || _la == plsqlParser.DOCUMENT
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4340)
		 		try concatenation()
		 		setState(4342)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WELLFORMED
		 		      return testSet
		 		 }()) {
		 			setState(4341)
		 			try match(plsqlParser.WELLFORMED)

		 		}

		 		setState(4344)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4347)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,542,_ctx)) {
		 		case 1:
		 			setState(4345)
		 			try match(plsqlParser.PERIOD)
		 			setState(4346)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(4349)
		 		try match(plsqlParser.XMLPI)
		 		setState(4350)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4355)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.NAME:
		 			setState(4351)
		 			try match(plsqlParser.NAME)
		 			setState(4352)
		 			try id()

		 			break

		 		case plsqlParser.EVALNAME:
		 			setState(4353)
		 			try match(plsqlParser.EVALNAME)
		 			setState(4354)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4359)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4357)
		 			try match(plsqlParser.COMMA)
		 			setState(4358)
		 			try concatenation()

		 		}

		 		setState(4361)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4364)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,545,_ctx)) {
		 		case 1:
		 			setState(4362)
		 			try match(plsqlParser.PERIOD)
		 			setState(4363)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(4366)
		 		try match(plsqlParser.XMLQUERY)
		 		setState(4367)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4368)
		 		try concatenation()
		 		setState(4370)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PASSING
		 		      return testSet
		 		 }()) {
		 			setState(4369)
		 			try xml_passing_clause()

		 		}

		 		setState(4372)
		 		try match(plsqlParser.RETURNING)
		 		setState(4373)
		 		try match(plsqlParser.CONTENT)
		 		setState(4377)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.NULL
		 		      return testSet
		 		 }()) {
		 			setState(4374)
		 			try match(plsqlParser.NULL)
		 			setState(4375)
		 			try match(plsqlParser.ON)
		 			setState(4376)
		 			try match(plsqlParser.EMPTY)

		 		}

		 		setState(4379)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4382)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,548,_ctx)) {
		 		case 1:
		 			setState(4380)
		 			try match(plsqlParser.PERIOD)
		 			setState(4381)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(4384)
		 		try match(plsqlParser.XMLROOT)
		 		setState(4385)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4386)
		 		try concatenation()
		 		setState(4389)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,549,_ctx)) {
		 		case 1:
		 			setState(4387)
		 			try match(plsqlParser.COMMA)
		 			setState(4388)
		 			try xmlroot_param_version_part()

		 			break
		 		default: break
		 		}
		 		setState(4393)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4391)
		 			try match(plsqlParser.COMMA)
		 			setState(4392)
		 			try xmlroot_param_standalone_part()

		 		}

		 		setState(4395)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4398)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,551,_ctx)) {
		 		case 1:
		 			setState(4396)
		 			try match(plsqlParser.PERIOD)
		 			setState(4397)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(4400)
		 		try match(plsqlParser.XMLSERIALIZE)
		 		setState(4401)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4402)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.CONTENT || _la == plsqlParser.DOCUMENT
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4403)
		 		try concatenation()
		 		setState(4406)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.AS
		 		      return testSet
		 		 }()) {
		 			setState(4404)
		 			try match(plsqlParser.AS)
		 			setState(4405)
		 			try type_spec()

		 		}

		 		setState(4409)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.ENCODING
		 		      return testSet
		 		 }()) {
		 			setState(4408)
		 			try xmlserialize_param_enconding_part()

		 		}

		 		setState(4412)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.VERSION
		 		      return testSet
		 		 }()) {
		 			setState(4411)
		 			try xmlserialize_param_version_part()

		 		}

		 		setState(4415)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.INDENT
		 		          testSet = testSet || _la == plsqlParser.NO
		 		      return testSet
		 		 }()) {
		 			setState(4414)
		 			try xmlserialize_param_ident_part()

		 		}

		 		setState(4419)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.HIDE
		 		          testSet = testSet || _la == plsqlParser.SHOW
		 		      return testSet
		 		 }()) {
		 			setState(4417)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.HIDE
		 			          testSet = testSet || _la == plsqlParser.SHOW
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}
		 			setState(4418)
		 			try match(plsqlParser.DEFAULTS)

		 		}

		 		setState(4421)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4424)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,557,_ctx)) {
		 		case 1:
		 			setState(4422)
		 			try match(plsqlParser.PERIOD)
		 			setState(4423)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 25:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(4426)
		 		try match(plsqlParser.XMLTABLE)
		 		setState(4427)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4429)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,558,_ctx)) {
		 		case 1:
		 			setState(4428)
		 			try xml_namespaces_clause()

		 			break
		 		default: break
		 		}
		 		setState(4431)
		 		try concatenation()
		 		setState(4433)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PASSING
		 		      return testSet
		 		 }()) {
		 			setState(4432)
		 			try xml_passing_clause()

		 		}

		 		setState(4440)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COLUMNS
		 		      return testSet
		 		 }()) {
		 			setState(4435)
		 			try match(plsqlParser.COLUMNS)
		 			setState(4436)
		 			try xml_table_column()

		 			setState(4437)
		 			try match(plsqlParser.COMMA)
		 			setState(4438)
		 			try xml_table_column()


		 		}

		 		setState(4442)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4445)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,561,_ctx)) {
		 		case 1:
		 			setState(4443)
		 			try match(plsqlParser.PERIOD)
		 			setState(4444)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Over_clause_keywordContext:ParserRuleContext {
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.AVG, 0) }
		open func CORR() -> TerminalNode? { return getToken(plsqlParser.CORR, 0) }
		open func LAG() -> TerminalNode? { return getToken(plsqlParser.LAG, 0) }
		open func LEAD() -> TerminalNode? { return getToken(plsqlParser.LEAD, 0) }
		open func MAX() -> TerminalNode? { return getToken(plsqlParser.MAX, 0) }
		open func MEDIAN() -> TerminalNode? { return getToken(plsqlParser.MEDIAN, 0) }
		open func MIN() -> TerminalNode? { return getToken(plsqlParser.MIN, 0) }
		open func NTILE() -> TerminalNode? { return getToken(plsqlParser.NTILE, 0) }
		open func RATIO_TO_REPORT() -> TerminalNode? { return getToken(plsqlParser.RATIO_TO_REPORT, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(plsqlParser.ROW_NUMBER, 0) }
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.SUM, 0) }
		open func VARIANCE() -> TerminalNode? { return getToken(plsqlParser.VARIANCE, 0) }
		open func REGR_() -> TerminalNode? { return getToken(plsqlParser.REGR_, 0) }
		open func STDDEV() -> TerminalNode? { return getToken(plsqlParser.STDDEV, 0) }
		open func VAR_() -> TerminalNode? { return getToken(plsqlParser.VAR_, 0) }
		open func COVAR_() -> TerminalNode? { return getToken(plsqlParser.COVAR_, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_over_clause_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOver_clause_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOver_clause_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOver_clause_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOver_clause_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func over_clause_keyword() throws -> Over_clause_keywordContext {
		var _localctx: Over_clause_keywordContext = Over_clause_keywordContext(_ctx, getState())
		try enterRule(_localctx, 568, plsqlParser.RULE_over_clause_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4449)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_]
		 	    return  Utils.testBitLeftShiftArray(testArray, 466)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Within_or_over_clause_keywordContext:ParserRuleContext {
		open func CUME_DIST() -> TerminalNode? { return getToken(plsqlParser.CUME_DIST, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.DENSE_RANK, 0) }
		open func LISTAGG() -> TerminalNode? { return getToken(plsqlParser.LISTAGG, 0) }
		open func PERCENT_RANK() -> TerminalNode? { return getToken(plsqlParser.PERCENT_RANK, 0) }
		open func PERCENTILE_CONT() -> TerminalNode? { return getToken(plsqlParser.PERCENTILE_CONT, 0) }
		open func PERCENTILE_DISC() -> TerminalNode? { return getToken(plsqlParser.PERCENTILE_DISC, 0) }
		open func RANK() -> TerminalNode? { return getToken(plsqlParser.RANK, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_within_or_over_clause_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWithin_or_over_clause_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWithin_or_over_clause_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWithin_or_over_clause_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWithin_or_over_clause_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func within_or_over_clause_keyword() throws -> Within_or_over_clause_keywordContext {
		var _localctx: Within_or_over_clause_keywordContext = Within_or_over_clause_keywordContext(_ctx, getState())
		try enterRule(_localctx, 570, plsqlParser.RULE_within_or_over_clause_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4451)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK]
		 	    return  Utils.testBitLeftShiftArray(testArray, 459)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Standard_prediction_function_keywordContext:ParserRuleContext {
		open func PREDICTION() -> TerminalNode? { return getToken(plsqlParser.PREDICTION, 0) }
		open func PREDICTION_BOUNDS() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_BOUNDS, 0) }
		open func PREDICTION_COST() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_COST, 0) }
		open func PREDICTION_DETAILS() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_DETAILS, 0) }
		open func PREDICTION_PROBABILITY() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_PROBABILITY, 0) }
		open func PREDICTION_SET() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_SET, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_standard_prediction_function_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStandard_prediction_function_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStandard_prediction_function_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStandard_prediction_function_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStandard_prediction_function_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func standard_prediction_function_keyword() throws -> Standard_prediction_function_keywordContext {
		var _localctx: Standard_prediction_function_keywordContext = Standard_prediction_function_keywordContext(_ctx, getState())
		try enterRule(_localctx, 572, plsqlParser.RULE_standard_prediction_function_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4453)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET]
		 	    return  Utils.testBitLeftShiftArray(testArray, 453)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Over_clauseContext:ParserRuleContext {
		open func OVER() -> TerminalNode? { return getToken(plsqlParser.OVER, 0) }
		open func query_partition_clause() -> Query_partition_clauseContext? {
			return getRuleContext(Query_partition_clauseContext.self,0)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func windowing_clause() -> Windowing_clauseContext? {
			return getRuleContext(Windowing_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_over_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOver_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOver_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOver_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOver_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func over_clause() throws -> Over_clauseContext {
		var _localctx: Over_clauseContext = Over_clauseContext(_ctx, getState())
		try enterRule(_localctx, 574, plsqlParser.RULE_over_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4455)
		 	try match(plsqlParser.OVER)
		 	setState(4456)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4458)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PARTITION
		 	      return testSet
		 	 }()) {
		 		setState(4457)
		 		try query_partition_clause()

		 	}

		 	setState(4464)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.ORDER
		 	      return testSet
		 	 }()) {
		 		setState(4460)
		 		try order_by_clause()
		 		setState(4462)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.RANGE || _la == plsqlParser.ROWS
		 		      return testSet
		 		 }()) {
		 			setState(4461)
		 			try windowing_clause()

		 		}


		 	}

		 	setState(4466)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_clauseContext:ParserRuleContext {
		open func windowing_type() -> Windowing_typeContext? {
			return getRuleContext(Windowing_typeContext.self,0)
		}
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.BETWEEN, 0) }
		open func windowing_elements() -> Array<Windowing_elementsContext> {
			return getRuleContexts(Windowing_elementsContext.self)
		}
		open func windowing_elements(_ i: Int) -> Windowing_elementsContext? {
			return getRuleContext(Windowing_elementsContext.self,i)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.AND, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_clause() throws -> Windowing_clauseContext {
		var _localctx: Windowing_clauseContext = Windowing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 576, plsqlParser.RULE_windowing_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4468)
		 	try windowing_type()
		 	setState(4475)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BETWEEN:
		 		setState(4469)
		 		try match(plsqlParser.BETWEEN)
		 		setState(4470)
		 		try windowing_elements()
		 		setState(4471)
		 		try match(plsqlParser.AND)
		 		setState(4472)
		 		try windowing_elements()

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(4474)
		 		try windowing_elements()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_typeContext:ParserRuleContext {
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.ROWS, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.RANGE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_type() throws -> Windowing_typeContext {
		var _localctx: Windowing_typeContext = Windowing_typeContext(_ctx, getState())
		try enterRule(_localctx, 578, plsqlParser.RULE_windowing_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4477)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.RANGE || _la == plsqlParser.ROWS
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_elementsContext:ParserRuleContext {
		open func UNBOUNDED() -> TerminalNode? { return getToken(plsqlParser.UNBOUNDED, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(plsqlParser.PRECEDING, 0) }
		open func CURRENT() -> TerminalNode? { return getToken(plsqlParser.CURRENT, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.ROW, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func FOLLOWING() -> TerminalNode? { return getToken(plsqlParser.FOLLOWING, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_elements() throws -> Windowing_elementsContext {
		var _localctx: Windowing_elementsContext = Windowing_elementsContext(_ctx, getState())
		try enterRule(_localctx, 580, plsqlParser.RULE_windowing_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4486)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,567, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4479)
		 		try match(plsqlParser.UNBOUNDED)
		 		setState(4480)
		 		try match(plsqlParser.PRECEDING)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4481)
		 		try match(plsqlParser.CURRENT)
		 		setState(4482)
		 		try match(plsqlParser.ROW)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4483)
		 		try concatenation()
		 		setState(4484)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.FOLLOWING
		 		          testSet = testSet || _la == plsqlParser.PRECEDING
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Using_clauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func using_element() -> Array<Using_elementContext> {
			return getRuleContexts(Using_elementContext.self)
		}
		open func using_element(_ i: Int) -> Using_elementContext? {
			return getRuleContext(Using_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_using_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUsing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUsing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUsing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUsing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func using_clause() throws -> Using_clauseContext {
		var _localctx: Using_clauseContext = Using_clauseContext(_ctx, getState())
		try enterRule(_localctx, 582, plsqlParser.RULE_using_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4488)
		 	try match(plsqlParser.USING)
		 	setState(4498)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.ASTERISK:
		 		setState(4489)
		 		try match(plsqlParser.ASTERISK)

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.IN:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NOT:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(4490)
		 		try using_element()
		 		setState(4495)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,568,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4491)
		 				try match(plsqlParser.COMMA)
		 				setState(4492)
		 				try using_element()

		 		 
		 			}
		 			setState(4497)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,568,_ctx)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Using_elementContext:ParserRuleContext {
		open func select_list_elements() -> Select_list_elementsContext? {
			return getRuleContext(Select_list_elementsContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.IN, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.OUT, 0) }
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_using_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUsing_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUsing_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUsing_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUsing_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func using_element() throws -> Using_elementContext {
		var _localctx: Using_elementContext = Using_elementContext(_ctx, getState())
		try enterRule(_localctx, 584, plsqlParser.RULE_using_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4505)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,571,_ctx)) {
		 	case 1:
		 		setState(4500)
		 		try match(plsqlParser.IN)
		 		setState(4502)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,570,_ctx)) {
		 		case 1:
		 			setState(4501)
		 			try match(plsqlParser.OUT)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(4504)
		 		try match(plsqlParser.OUT)

		 		break
		 	default: break
		 	}
		 	setState(4507)
		 	try select_list_elements()
		 	setState(4509)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,572,_ctx)) {
		 	case 1:
		 		setState(4508)
		 		try column_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Collect_order_by_partContext:ParserRuleContext {
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.ORDER, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_collect_order_by_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCollect_order_by_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCollect_order_by_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCollect_order_by_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCollect_order_by_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collect_order_by_part() throws -> Collect_order_by_partContext {
		var _localctx: Collect_order_by_partContext = Collect_order_by_partContext(_ctx, getState())
		try enterRule(_localctx, 586, plsqlParser.RULE_collect_order_by_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4511)
		 	try match(plsqlParser.ORDER)
		 	setState(4512)
		 	try match(plsqlParser.BY)
		 	setState(4513)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Within_or_over_partContext:ParserRuleContext {
		open func WITHIN() -> TerminalNode? { return getToken(plsqlParser.WITHIN, 0) }
		open func GROUP() -> TerminalNode? { return getToken(plsqlParser.GROUP, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_within_or_over_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWithin_or_over_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWithin_or_over_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWithin_or_over_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWithin_or_over_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func within_or_over_part() throws -> Within_or_over_partContext {
		var _localctx: Within_or_over_partContext = Within_or_over_partContext(_ctx, getState())
		try enterRule(_localctx, 588, plsqlParser.RULE_within_or_over_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4522)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.WITHIN:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4515)
		 		try match(plsqlParser.WITHIN)
		 		setState(4516)
		 		try match(plsqlParser.GROUP)
		 		setState(4517)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4518)
		 		try order_by_clause()
		 		setState(4519)
		 		try match(plsqlParser.RIGHT_PAREN)

		 		break

		 	case plsqlParser.OVER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4521)
		 		try over_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cost_matrix_clauseContext:ParserRuleContext {
		open func COST() -> TerminalNode? { return getToken(plsqlParser.COST, 0) }
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.MODEL, 0) }
		open func cost_class_name() -> Array<Cost_class_nameContext> {
			return getRuleContexts(Cost_class_nameContext.self)
		}
		open func cost_class_name(_ i: Int) -> Cost_class_nameContext? {
			return getRuleContext(Cost_class_nameContext.self,i)
		}
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.VALUES, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func AUTO() -> TerminalNode? { return getToken(plsqlParser.AUTO, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cost_matrix_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCost_matrix_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCost_matrix_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCost_matrix_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCost_matrix_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cost_matrix_clause() throws -> Cost_matrix_clauseContext {
		var _localctx: Cost_matrix_clauseContext = Cost_matrix_clauseContext(_ctx, getState())
		try enterRule(_localctx, 590, plsqlParser.RULE_cost_matrix_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4524)
		 	try match(plsqlParser.COST)
		 	setState(4542)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.MODEL:
		 		setState(4525)
		 		try match(plsqlParser.MODEL)
		 		setState(4527)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.AUTO
		 		      return testSet
		 		 }()) {
		 			setState(4526)
		 			try match(plsqlParser.AUTO)

		 		}


		 		break

		 	case plsqlParser.LEFT_PAREN:
		 		setState(4529)
		 		try match(plsqlParser.LEFT_PAREN)
		 		setState(4530)
		 		try cost_class_name()
		 		setState(4535)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4531)
		 			try match(plsqlParser.COMMA)
		 			setState(4532)
		 			try cost_class_name()


		 			setState(4537)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4538)
		 		try match(plsqlParser.RIGHT_PAREN)
		 		setState(4539)
		 		try match(plsqlParser.VALUES)
		 		setState(4540)
		 		try expression_list()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_passing_clauseContext:ParserRuleContext {
		open func PASSING() -> TerminalNode? { return getToken(plsqlParser.PASSING, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.BY, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.VALUE, 0) }
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_passing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_passing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_passing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_passing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_passing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_passing_clause() throws -> Xml_passing_clauseContext {
		var _localctx: Xml_passing_clauseContext = Xml_passing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 592, plsqlParser.RULE_xml_passing_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4544)
		 	try match(plsqlParser.PASSING)
		 	setState(4547)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.BY
		 	      return testSet
		 	 }()) {
		 		setState(4545)
		 		try match(plsqlParser.BY)
		 		setState(4546)
		 		try match(plsqlParser.VALUE)

		 	}

		 	setState(4549)
		 	try expression()
		 	setState(4551)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(4550)
		 		try column_alias()

		 	}

		 	setState(4553)
		 	try match(plsqlParser.COMMA)
		 	setState(4554)
		 	try expression()
		 	setState(4556)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,579,_ctx)) {
		 	case 1:
		 		setState(4555)
		 		try column_alias()

		 		break
		 	default: break
		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_attributes_clauseContext:ParserRuleContext {
		open func XMLATTRIBUTES() -> TerminalNode? { return getToken(plsqlParser.XMLATTRIBUTES, 0) }
		open func xml_multiuse_expression_element() -> Array<Xml_multiuse_expression_elementContext> {
			return getRuleContexts(Xml_multiuse_expression_elementContext.self)
		}
		open func xml_multiuse_expression_element(_ i: Int) -> Xml_multiuse_expression_elementContext? {
			return getRuleContext(Xml_multiuse_expression_elementContext.self,i)
		}
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.ENTITYESCAPING, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.NOENTITYESCAPING, 0) }
		open func SCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.SCHEMACHECK, 0) }
		open func NOSCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.NOSCHEMACHECK, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_attributes_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_attributes_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_attributes_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_attributes_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_attributes_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_attributes_clause() throws -> Xml_attributes_clauseContext {
		var _localctx: Xml_attributes_clauseContext = Xml_attributes_clauseContext(_ctx, getState())
		try enterRule(_localctx, 594, plsqlParser.RULE_xml_attributes_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4558)
		 	try match(plsqlParser.XMLATTRIBUTES)
		 	setState(4559)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4561)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,580,_ctx)) {
		 	case 1:
		 		setState(4560)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.ENTITYESCAPING
		 		          testSet = testSet || _la == plsqlParser.NOENTITYESCAPING
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4564)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,581,_ctx)) {
		 	case 1:
		 		setState(4563)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.NOSCHEMACHECK
		 		          testSet = testSet || _la == plsqlParser.SCHEMACHECK
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4566)
		 	try xml_multiuse_expression_element()
		 	setState(4571)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4567)
		 		try match(plsqlParser.COMMA)
		 		setState(4568)
		 		try xml_multiuse_expression_element()


		 		setState(4573)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4574)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_namespaces_clauseContext:ParserRuleContext {
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(plsqlParser.XMLNAMESPACES, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open func xml_general_default_part() -> Xml_general_default_partContext? {
			return getRuleContext(Xml_general_default_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_namespaces_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_namespaces_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_namespaces_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_namespaces_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_namespaces_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_namespaces_clause() throws -> Xml_namespaces_clauseContext {
		var _localctx: Xml_namespaces_clauseContext = Xml_namespaces_clauseContext(_ctx, getState())
		try enterRule(_localctx, 596, plsqlParser.RULE_xml_namespaces_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4576)
		 	try match(plsqlParser.XMLNAMESPACES)
		 	setState(4577)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4581)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,583,_ctx)) {
		 	case 1:
		 		setState(4578)
		 		try concatenation()
		 		setState(4579)
		 		try column_alias()

		 		break
		 	default: break
		 	}
		 	setState(4589)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4583)
		 		try match(plsqlParser.COMMA)
		 		setState(4584)
		 		try concatenation()
		 		setState(4585)
		 		try column_alias()


		 		setState(4591)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4593)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.DEFAULT
		 	      return testSet
		 	 }()) {
		 		setState(4592)
		 		try xml_general_default_part()

		 	}

		 	setState(4595)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_table_columnContext:ParserRuleContext {
		open func xml_column_name() -> Xml_column_nameContext? {
			return getRuleContext(Xml_column_nameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open func ORDINALITY() -> TerminalNode? { return getToken(plsqlParser.ORDINALITY, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func PATH() -> TerminalNode? { return getToken(plsqlParser.PATH, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func xml_general_default_part() -> Xml_general_default_partContext? {
			return getRuleContext(Xml_general_default_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_table_column }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_table_column(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_table_column(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_table_column(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_table_column(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_table_column() throws -> Xml_table_columnContext {
		var _localctx: Xml_table_columnContext = Xml_table_columnContext(_ctx, getState())
		try enterRule(_localctx, 598, plsqlParser.RULE_xml_table_column)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4597)
		 	try xml_column_name()
		 	setState(4608)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.FOR:
		 		setState(4598)
		 		try match(plsqlParser.FOR)
		 		setState(4599)
		 		try match(plsqlParser.ORDINALITY)

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(4600)
		 		try type_spec()
		 		setState(4603)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PATH
		 		      return testSet
		 		 }()) {
		 			setState(4601)
		 			try match(plsqlParser.PATH)
		 			setState(4602)
		 			try concatenation()

		 		}

		 		setState(4606)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.DEFAULT
		 		      return testSet
		 		 }()) {
		 			setState(4605)
		 			try xml_general_default_part()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_general_default_partContext:ParserRuleContext {
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_general_default_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_general_default_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_general_default_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_general_default_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_general_default_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_general_default_part() throws -> Xml_general_default_partContext {
		var _localctx: Xml_general_default_partContext = Xml_general_default_partContext(_ctx, getState())
		try enterRule(_localctx, 600, plsqlParser.RULE_xml_general_default_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4610)
		 	try match(plsqlParser.DEFAULT)
		 	setState(4611)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_multiuse_expression_elementContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.EVALNAME, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_multiuse_expression_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_multiuse_expression_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_multiuse_expression_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_multiuse_expression_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_multiuse_expression_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_multiuse_expression_element() throws -> Xml_multiuse_expression_elementContext {
		var _localctx: Xml_multiuse_expression_elementContext = Xml_multiuse_expression_elementContext(_ctx, getState())
		try enterRule(_localctx, 602, plsqlParser.RULE_xml_multiuse_expression_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4613)
		 	try expression()
		 	setState(4620)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AS
		 	      return testSet
		 	 }()) {
		 		setState(4614)
		 		try match(plsqlParser.AS)
		 		setState(4618)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,589, _ctx)) {
		 		case 1:
		 			setState(4615)
		 			try id_expression()

		 			break
		 		case 2:
		 			setState(4616)
		 			try match(plsqlParser.EVALNAME)
		 			setState(4617)
		 			try concatenation()

		 			break
		 		default: break
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlroot_param_version_partContext:ParserRuleContext {
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.VERSION, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.NO, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.VALUE, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlroot_param_version_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlroot_param_version_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlroot_param_version_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlroot_param_version_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlroot_param_version_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlroot_param_version_part() throws -> Xmlroot_param_version_partContext {
		var _localctx: Xmlroot_param_version_partContext = Xmlroot_param_version_partContext(_ctx, getState())
		try enterRule(_localctx, 604, plsqlParser.RULE_xmlroot_param_version_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4622)
		 	try match(plsqlParser.VERSION)
		 	setState(4626)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,591, _ctx)) {
		 	case 1:
		 		setState(4623)
		 		try match(plsqlParser.NO)
		 		setState(4624)
		 		try match(plsqlParser.VALUE)

		 		break
		 	case 2:
		 		setState(4625)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlroot_param_standalone_partContext:ParserRuleContext {
		open func STANDALONE() -> TerminalNode? { return getToken(plsqlParser.STANDALONE, 0) }
		open func YES() -> TerminalNode? { return getToken(plsqlParser.YES, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.NO, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.VALUE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlroot_param_standalone_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlroot_param_standalone_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlroot_param_standalone_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlroot_param_standalone_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlroot_param_standalone_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlroot_param_standalone_part() throws -> Xmlroot_param_standalone_partContext {
		var _localctx: Xmlroot_param_standalone_partContext = Xmlroot_param_standalone_partContext(_ctx, getState())
		try enterRule(_localctx, 606, plsqlParser.RULE_xmlroot_param_standalone_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4628)
		 	try match(plsqlParser.STANDALONE)
		 	setState(4634)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.YES:
		 		setState(4629)
		 		try match(plsqlParser.YES)

		 		break

		 	case plsqlParser.NO:
		 		setState(4630)
		 		try match(plsqlParser.NO)
		 		setState(4632)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.VALUE
		 		      return testSet
		 		 }()) {
		 			setState(4631)
		 			try match(plsqlParser.VALUE)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_enconding_partContext:ParserRuleContext {
		open func ENCODING() -> TerminalNode? { return getToken(plsqlParser.ENCODING, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_enconding_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_enconding_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_enconding_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_enconding_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_enconding_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_enconding_part() throws -> Xmlserialize_param_enconding_partContext {
		var _localctx: Xmlserialize_param_enconding_partContext = Xmlserialize_param_enconding_partContext(_ctx, getState())
		try enterRule(_localctx, 608, plsqlParser.RULE_xmlserialize_param_enconding_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4636)
		 	try match(plsqlParser.ENCODING)
		 	setState(4637)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_version_partContext:ParserRuleContext {
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.VERSION, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_version_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_version_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_version_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_version_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_version_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_version_part() throws -> Xmlserialize_param_version_partContext {
		var _localctx: Xmlserialize_param_version_partContext = Xmlserialize_param_version_partContext(_ctx, getState())
		try enterRule(_localctx, 610, plsqlParser.RULE_xmlserialize_param_version_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4639)
		 	try match(plsqlParser.VERSION)
		 	setState(4640)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_ident_partContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(plsqlParser.NO, 0) }
		open func INDENT() -> TerminalNode? { return getToken(plsqlParser.INDENT, 0) }
		open func SIZE() -> TerminalNode? { return getToken(plsqlParser.SIZE, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_ident_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_ident_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_ident_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_ident_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_ident_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_ident_part() throws -> Xmlserialize_param_ident_partContext {
		var _localctx: Xmlserialize_param_ident_partContext = Xmlserialize_param_ident_partContext(_ctx, getState())
		try enterRule(_localctx, 612, plsqlParser.RULE_xmlserialize_param_ident_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4650)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.NO:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4642)
		 		try match(plsqlParser.NO)
		 		setState(4643)
		 		try match(plsqlParser.INDENT)

		 		break

		 	case plsqlParser.INDENT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4644)
		 		try match(plsqlParser.INDENT)
		 		setState(4648)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.SIZE
		 		      return testSet
		 		 }()) {
		 			setState(4645)
		 			try match(plsqlParser.SIZE)
		 			setState(4646)
		 			try match(plsqlParser.EQUALS_OP)
		 			setState(4647)
		 			try concatenation()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_plus_commandContext:ParserRuleContext {
		open func whenever_command() -> Whenever_commandContext? {
			return getRuleContext(Whenever_commandContext.self,0)
		}
		open func exit_command() -> Exit_commandContext? {
			return getRuleContext(Exit_commandContext.self,0)
		}
		open func prompt_command() -> Prompt_commandContext? {
			return getRuleContext(Prompt_commandContext.self,0)
		}
		open func set_command() -> Set_commandContext? {
			return getRuleContext(Set_commandContext.self,0)
		}
		open func show_errors_command() -> Show_errors_commandContext? {
			return getRuleContext(Show_errors_commandContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_plus_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_plus_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_plus_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_plus_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_plus_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_plus_command() throws -> Sql_plus_commandContext {
		var _localctx: Sql_plus_commandContext = Sql_plus_commandContext(_ctx, getState())
		try enterRule(_localctx, 614, plsqlParser.RULE_sql_plus_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4658)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.SOLIDUS:
		 		setState(4652)
		 		try match(plsqlParser.SOLIDUS)

		 		break

		 	case plsqlParser.WHENEVER:
		 		setState(4653)
		 		try whenever_command()

		 		break

		 	case plsqlParser.EXIT:
		 		setState(4654)
		 		try exit_command()

		 		break

		 	case plsqlParser.PROMPT:
		 		setState(4655)
		 		try prompt_command()

		 		break

		 	case plsqlParser.SET:
		 		setState(4656)
		 		try set_command()

		 		break

		 	case plsqlParser.SHOW:
		 		setState(4657)
		 		try show_errors_command()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.SEMICOLON
		 	      return testSet
		 	 }()) {
		 		setState(4660)
		 		try match(plsqlParser.SEMICOLON)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Whenever_commandContext:ParserRuleContext {
		open func WHENEVER() -> TerminalNode? { return getToken(plsqlParser.WHENEVER, 0) }
		open func SQLERROR() -> TerminalNode? { return getToken(plsqlParser.SQLERROR, 0) }
		open func OSERROR() -> TerminalNode? { return getToken(plsqlParser.OSERROR, 0) }
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.EXIT, 0) }
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.CONTINUE, 0) }
		open func SUCCESS() -> TerminalNode? { return getToken(plsqlParser.SUCCESS, 0) }
		open func FAILURE() -> TerminalNode? { return getToken(plsqlParser.FAILURE, 0) }
		open func WARNING() -> TerminalNode? { return getToken(plsqlParser.WARNING, 0) }
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.COMMIT, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.ROLLBACK, 0) }
		open func NONE() -> TerminalNode? { return getToken(plsqlParser.NONE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_whenever_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWhenever_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWhenever_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWhenever_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWhenever_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func whenever_command() throws -> Whenever_commandContext {
		var _localctx: Whenever_commandContext = Whenever_commandContext(_ctx, getState())
		try enterRule(_localctx, 616, plsqlParser.RULE_whenever_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4663)
		 	try match(plsqlParser.WHENEVER)
		 	setState(4664)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.OSERROR
		 	          testSet = testSet || _la == plsqlParser.SQLERROR
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4670)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.EXIT:
		 		setState(4665)
		 		try match(plsqlParser.EXIT)
		 		setState(4666)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.FAILURE
		 		          testSet = testSet || _la == plsqlParser.SUCCESS || _la == plsqlParser.WARNING
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(4667)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.COMMIT
		 		          testSet = testSet || _la == plsqlParser.ROLLBACK
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break

		 	case plsqlParser.CONTINUE:
		 		setState(4668)
		 		try match(plsqlParser.CONTINUE)
		 		setState(4669)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.COMMIT
		 		          testSet = testSet || _la == plsqlParser.NONE
		 		          testSet = testSet || _la == plsqlParser.ROLLBACK
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func regular_id() -> Array<Regular_idContext> {
			return getRuleContexts(Regular_idContext.self)
		}
		open func regular_id(_ i: Int) -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,i)
		}
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.CHAR_STRING, 0) }
		open func ON() -> TerminalNode? { return getToken(plsqlParser.ON, 0) }
		open func OFF() -> TerminalNode? { return getToken(plsqlParser.OFF, 0) }
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_command() throws -> Set_commandContext {
		var _localctx: Set_commandContext = Set_commandContext(_ctx, getState())
		try enterRule(_localctx, 618, plsqlParser.RULE_set_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4672)
		 	try match(plsqlParser.SET)
		 	setState(4673)
		 	try regular_id()
		 	setState(4679)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,599, _ctx)) {
		 	case 1:
		 		setState(4674)
		 		try match(plsqlParser.CHAR_STRING)

		 		break
		 	case 2:
		 		setState(4675)
		 		try match(plsqlParser.ON)

		 		break
		 	case 3:
		 		setState(4676)
		 		try match(plsqlParser.OFF)

		 		break
		 	case 4:
		 		setState(4677)
		 		try numeric()

		 		break
		 	case 5:
		 		setState(4678)
		 		try regular_id()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exit_commandContext:ParserRuleContext {
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.EXIT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exit_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExit_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExit_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExit_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExit_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exit_command() throws -> Exit_commandContext {
		var _localctx: Exit_commandContext = Exit_commandContext(_ctx, getState())
		try enterRule(_localctx, 620, plsqlParser.RULE_exit_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4681)
		 	try match(plsqlParser.EXIT)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Prompt_commandContext:ParserRuleContext {
		open func PROMPT() -> TerminalNode? { return getToken(plsqlParser.PROMPT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_prompt_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPrompt_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPrompt_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPrompt_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPrompt_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func prompt_command() throws -> Prompt_commandContext {
		var _localctx: Prompt_commandContext = Prompt_commandContext(_ctx, getState())
		try enterRule(_localctx, 622, plsqlParser.RULE_prompt_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4683)
		 	try match(plsqlParser.PROMPT)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Show_errors_commandContext:ParserRuleContext {
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.SHOW, 0) }
		open func ERR() -> TerminalNode? { return getToken(plsqlParser.ERR, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.ERRORS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_show_errors_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterShow_errors_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitShow_errors_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitShow_errors_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitShow_errors_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func show_errors_command() throws -> Show_errors_commandContext {
		var _localctx: Show_errors_commandContext = Show_errors_commandContext(_ctx, getState())
		try enterRule(_localctx, 624, plsqlParser.RULE_show_errors_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4689)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,600, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4685)
		 		try match(plsqlParser.SHOW)
		 		setState(4686)
		 		try match(plsqlParser.ERR)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4687)
		 		try match(plsqlParser.SHOW)
		 		setState(4688)
		 		try match(plsqlParser.ERRORS)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Partition_extension_clauseContext:ParserRuleContext {
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func SUBPARTITION() -> TerminalNode? { return getToken(plsqlParser.SUBPARTITION, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.PARTITION, 0) }
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.FOR, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_partition_extension_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPartition_extension_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPartition_extension_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPartition_extension_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPartition_extension_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func partition_extension_clause() throws -> Partition_extension_clauseContext {
		var _localctx: Partition_extension_clauseContext = Partition_extension_clauseContext(_ctx, getState())
		try enterRule(_localctx, 626, plsqlParser.RULE_partition_extension_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4691)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.PARTITION
		 	          testSet = testSet || _la == plsqlParser.SUBPARTITION
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4693)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FOR
		 	      return testSet
		 	 }()) {
		 		setState(4692)
		 		try match(plsqlParser.FOR)

		 	}

		 	setState(4695)
		 	try expression_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_aliasContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func alias_quoted_string() -> Alias_quoted_stringContext? {
			return getRuleContext(Alias_quoted_stringContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.AS, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_alias(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_alias() throws -> Column_aliasContext {
		var _localctx: Column_aliasContext = Column_aliasContext(_ctx, getState())
		try enterRule(_localctx, 628, plsqlParser.RULE_column_alias)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4705)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,604, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4698)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.AS
		 		      return testSet
		 		 }()) {
		 			setState(4697)
		 			try match(plsqlParser.AS)

		 		}

		 		setState(4702)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.A_LETTER:fallthrough
		 		case plsqlParser.ADD:fallthrough
		 		case plsqlParser.AFTER:fallthrough
		 		case plsqlParser.AGENT:fallthrough
		 		case plsqlParser.AGGREGATE:fallthrough
		 		case plsqlParser.ANALYZE:fallthrough
		 		case plsqlParser.ARRAY:fallthrough
		 		case plsqlParser.ASSOCIATE:fallthrough
		 		case plsqlParser.AT:fallthrough
		 		case plsqlParser.ATTRIBUTE:fallthrough
		 		case plsqlParser.AUDIT:fallthrough
		 		case plsqlParser.AUTHID:fallthrough
		 		case plsqlParser.AUTO:fallthrough
		 		case plsqlParser.AUTOMATIC:fallthrough
		 		case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 		case plsqlParser.BATCH:fallthrough
		 		case plsqlParser.BEFORE:fallthrough
		 		case plsqlParser.BFILE:fallthrough
		 		case plsqlParser.BINARY_DOUBLE:fallthrough
		 		case plsqlParser.BINARY_FLOAT:fallthrough
		 		case plsqlParser.BINARY_INTEGER:fallthrough
		 		case plsqlParser.BLOB:fallthrough
		 		case plsqlParser.BLOCK:fallthrough
		 		case plsqlParser.BODY:fallthrough
		 		case plsqlParser.BOOLEAN:fallthrough
		 		case plsqlParser.BOTH:fallthrough
		 		case plsqlParser.BULK:fallthrough
		 		case plsqlParser.BYTE:fallthrough
		 		case plsqlParser.C_LETTER:fallthrough
		 		case plsqlParser.CALL:fallthrough
		 		case plsqlParser.CANONICAL:fallthrough
		 		case plsqlParser.CASCADE:fallthrough
		 		case plsqlParser.CAST:fallthrough
		 		case plsqlParser.CHAR:fallthrough
		 		case plsqlParser.CHAR_CS:fallthrough
		 		case plsqlParser.CHARACTER:fallthrough
		 		case plsqlParser.CHR:fallthrough
		 		case plsqlParser.CLOB:fallthrough
		 		case plsqlParser.CLOSE:fallthrough
		 		case plsqlParser.CLUSTER:fallthrough
		 		case plsqlParser.COLLECT:fallthrough
		 		case plsqlParser.COLUMNS:fallthrough
		 		case plsqlParser.COMMENT:fallthrough
		 		case plsqlParser.COMMIT:fallthrough
		 		case plsqlParser.COMMITTED:fallthrough
		 		case plsqlParser.COMPATIBILITY:fallthrough
		 		case plsqlParser.COMPILE:fallthrough
		 		case plsqlParser.COMPOUND:fallthrough
		 		case plsqlParser.CONSTANT:fallthrough
		 		case plsqlParser.CONSTRAINT:fallthrough
		 		case plsqlParser.CONSTRAINTS:fallthrough
		 		case plsqlParser.CONSTRUCTOR:fallthrough
		 		case plsqlParser.CONTENT:fallthrough
		 		case plsqlParser.CONTEXT:fallthrough
		 		case plsqlParser.CONTINUE:fallthrough
		 		case plsqlParser.CONVERT:fallthrough
		 		case plsqlParser.CORRUPT_XID:fallthrough
		 		case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 		case plsqlParser.COST:fallthrough
		 		case plsqlParser.COUNT:fallthrough
		 		case plsqlParser.CROSS:fallthrough
		 		case plsqlParser.CUBE:fallthrough
		 		case plsqlParser.CURRENT_USER:fallthrough
		 		case plsqlParser.CURSOR:fallthrough
		 		case plsqlParser.CUSTOMDATUM:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.DATA:fallthrough
		 		case plsqlParser.DATABASE:fallthrough
		 		case plsqlParser.DAY:fallthrough
		 		case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DDL:fallthrough
		 		case plsqlParser.DEBUG:fallthrough
		 		case plsqlParser.DEC:fallthrough
		 		case plsqlParser.DECIMAL:fallthrough
		 		case plsqlParser.DECOMPOSE:fallthrough
		 		case plsqlParser.DECREMENT:fallthrough
		 		case plsqlParser.DEFAULTS:fallthrough
		 		case plsqlParser.DEFERRED:fallthrough
		 		case plsqlParser.DEFINER:fallthrough
		 		case plsqlParser.DETERMINISTIC:fallthrough
		 		case plsqlParser.DIMENSION:fallthrough
		 		case plsqlParser.DISABLE:fallthrough
		 		case plsqlParser.DISASSOCIATE:fallthrough
		 		case plsqlParser.DOCUMENT:fallthrough
		 		case plsqlParser.DOUBLE:fallthrough
		 		case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.EACH:fallthrough
		 		case plsqlParser.ELEMENT:fallthrough
		 		case plsqlParser.EMPTY:fallthrough
		 		case plsqlParser.ENABLE:fallthrough
		 		case plsqlParser.ENCODING:fallthrough
		 		case plsqlParser.ENTITYESCAPING:fallthrough
		 		case plsqlParser.ERR:fallthrough
		 		case plsqlParser.ERRORS:fallthrough
		 		case plsqlParser.ESCAPE:fallthrough
		 		case plsqlParser.EVALNAME:fallthrough
		 		case plsqlParser.EXCEPTION:fallthrough
		 		case plsqlParser.EXCEPTION_INIT:fallthrough
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.EXCLUDE:fallthrough
		 		case plsqlParser.EXECUTE:fallthrough
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.EXTERNAL:fallthrough
		 		case plsqlParser.EXTRACT:fallthrough
		 		case plsqlParser.FAILURE:fallthrough
		 		case plsqlParser.FINAL:fallthrough
		 		case plsqlParser.FIRST:fallthrough
		 		case plsqlParser.FIRST_VALUE:fallthrough
		 		case plsqlParser.FLOAT:fallthrough
		 		case plsqlParser.FOLLOWING:fallthrough
		 		case plsqlParser.FOLLOWS:fallthrough
		 		case plsqlParser.FORALL:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.FULL:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.GROUPING:fallthrough
		 		case plsqlParser.HASH:fallthrough
		 		case plsqlParser.HIDE:fallthrough
		 		case plsqlParser.HOUR:fallthrough
		 		case plsqlParser.IGNORE:fallthrough
		 		case plsqlParser.IMMEDIATE:fallthrough
		 		case plsqlParser.INCLUDE:fallthrough
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.INDENT:fallthrough
		 		case plsqlParser.INDEXED:fallthrough
		 		case plsqlParser.INDICATOR:fallthrough
		 		case plsqlParser.INDICES:fallthrough
		 		case plsqlParser.INFINITE:fallthrough
		 		case plsqlParser.INLINE:fallthrough
		 		case plsqlParser.INNER:fallthrough
		 		case plsqlParser.INOUT:fallthrough
		 		case plsqlParser.INSTANTIABLE:fallthrough
		 		case plsqlParser.INSTEAD:fallthrough
		 		case plsqlParser.INT:fallthrough
		 		case plsqlParser.INTEGER:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.INVALIDATE:fallthrough
		 		case plsqlParser.ISOLATION:fallthrough
		 		case plsqlParser.ITERATE:fallthrough
		 		case plsqlParser.JAVA:fallthrough
		 		case plsqlParser.JOIN:fallthrough
		 		case plsqlParser.KEEP:fallthrough
		 		case plsqlParser.LANGUAGE:fallthrough
		 		case plsqlParser.LAST:fallthrough
		 		case plsqlParser.LAST_VALUE:fallthrough
		 		case plsqlParser.LEADING:fallthrough
		 		case plsqlParser.LEFT:fallthrough
		 		case plsqlParser.LEVEL:fallthrough
		 		case plsqlParser.LIBRARY:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:fallthrough
		 		case plsqlParser.LIMIT:fallthrough
		 		case plsqlParser.LOCAL:fallthrough
		 		case plsqlParser.LOCKED:fallthrough
		 		case plsqlParser.LOG:fallthrough
		 		case plsqlParser.LOGOFF:fallthrough
		 		case plsqlParser.LOGON:fallthrough
		 		case plsqlParser.LONG:fallthrough
		 		case plsqlParser.LOOP:fallthrough
		 		case plsqlParser.MAIN:fallthrough
		 		case plsqlParser.MAP:fallthrough
		 		case plsqlParser.MATCHED:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MEASURES:fallthrough
		 		case plsqlParser.MEMBER:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.MINUTE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.MLSLABEL:fallthrough
		 		case plsqlParser.MODEL:fallthrough
		 		case plsqlParser.MODIFY:fallthrough
		 		case plsqlParser.MONTH:fallthrough
		 		case plsqlParser.MULTISET:fallthrough
		 		case plsqlParser.NAME:fallthrough
		 		case plsqlParser.NAN:fallthrough
		 		case plsqlParser.NATURAL:fallthrough
		 		case plsqlParser.NATURALN:fallthrough
		 		case plsqlParser.NAV:fallthrough
		 		case plsqlParser.NCHAR:fallthrough
		 		case plsqlParser.NCHAR_CS:fallthrough
		 		case plsqlParser.NCLOB:fallthrough
		 		case plsqlParser.NESTED:fallthrough
		 		case plsqlParser.NEW:fallthrough
		 		case plsqlParser.NO:fallthrough
		 		case plsqlParser.NOAUDIT:fallthrough
		 		case plsqlParser.NOCOPY:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOENTITYESCAPING:fallthrough
		 		case plsqlParser.NONE:fallthrough
		 		case plsqlParser.NOSCHEMACHECK:fallthrough
		 		case plsqlParser.NULLS:fallthrough
		 		case plsqlParser.NUMBER:fallthrough
		 		case plsqlParser.NUMERIC:fallthrough
		 		case plsqlParser.NVARCHAR2:fallthrough
		 		case plsqlParser.OBJECT:fallthrough
		 		case plsqlParser.OFF:fallthrough
		 		case plsqlParser.OID:fallthrough
		 		case plsqlParser.OLD:fallthrough
		 		case plsqlParser.ONLY:fallthrough
		 		case plsqlParser.OPEN:fallthrough
		 		case plsqlParser.ORADATA:fallthrough
		 		case plsqlParser.ORDINALITY:fallthrough
		 		case plsqlParser.OSERROR:fallthrough
		 		case plsqlParser.OUT:fallthrough
		 		case plsqlParser.OUTER:fallthrough
		 		case plsqlParser.OVER:fallthrough
		 		case plsqlParser.OVERRIDING:fallthrough
		 		case plsqlParser.PACKAGE:fallthrough
		 		case plsqlParser.PARALLEL_ENABLE:fallthrough
		 		case plsqlParser.PARAMETERS:fallthrough
		 		case plsqlParser.PARENT:fallthrough
		 		case plsqlParser.PARTITION:fallthrough
		 		case plsqlParser.PASSING:fallthrough
		 		case plsqlParser.PATH:fallthrough
		 		case plsqlParser.PIPELINED:fallthrough
		 		case plsqlParser.PLAN:fallthrough
		 		case plsqlParser.PLS_INTEGER:fallthrough
		 		case plsqlParser.POSITIVE:fallthrough
		 		case plsqlParser.POSITIVEN:fallthrough
		 		case plsqlParser.PRAGMA:fallthrough
		 		case plsqlParser.PRECEDING:fallthrough
		 		case plsqlParser.PRECISION:fallthrough
		 		case plsqlParser.PRESENT:fallthrough
		 		case plsqlParser.RAISE:fallthrough
		 		case plsqlParser.RANGE:fallthrough
		 		case plsqlParser.RAW:fallthrough
		 		case plsqlParser.READ:fallthrough
		 		case plsqlParser.REAL:fallthrough
		 		case plsqlParser.RECORD:fallthrough
		 		case plsqlParser.REF:fallthrough
		 		case plsqlParser.REFERENCE:fallthrough
		 		case plsqlParser.REFERENCING:fallthrough
		 		case plsqlParser.REJECT:fallthrough
		 		case plsqlParser.RELIES_ON:fallthrough
		 		case plsqlParser.RENAME:fallthrough
		 		case plsqlParser.REPLACE:fallthrough
		 		case plsqlParser.RESPECT:fallthrough
		 		case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 		case plsqlParser.RESULT:fallthrough
		 		case plsqlParser.RESULT_CACHE:fallthrough
		 		case plsqlParser.RETURN:fallthrough
		 		case plsqlParser.RETURNING:fallthrough
		 		case plsqlParser.REUSE:fallthrough
		 		case plsqlParser.REVERSE:fallthrough
		 		case plsqlParser.RIGHT:fallthrough
		 		case plsqlParser.ROLLBACK:fallthrough
		 		case plsqlParser.ROLLUP:fallthrough
		 		case plsqlParser.ROW:fallthrough
		 		case plsqlParser.ROWID:fallthrough
		 		case plsqlParser.ROWS:fallthrough
		 		case plsqlParser.RULES:fallthrough
		 		case plsqlParser.SAMPLE:fallthrough
		 		case plsqlParser.SAVE:fallthrough
		 		case plsqlParser.SAVEPOINT:fallthrough
		 		case plsqlParser.SCHEMA:fallthrough
		 		case plsqlParser.SCHEMACHECK:fallthrough
		 		case plsqlParser.SCN:fallthrough
		 		case plsqlParser.SECOND:fallthrough
		 		case plsqlParser.SEED:fallthrough
		 		case plsqlParser.SEGMENT:fallthrough
		 		case plsqlParser.SELF:fallthrough
		 		case plsqlParser.SEQUENTIAL:fallthrough
		 		case plsqlParser.SERIALIZABLE:fallthrough
		 		case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 		case plsqlParser.SERVERERROR:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SETS:fallthrough
		 		case plsqlParser.SETTINGS:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.SHUTDOWN:fallthrough
		 		case plsqlParser.SIBLINGS:fallthrough
		 		case plsqlParser.SIGNTYPE:fallthrough
		 		case plsqlParser.SIMPLE_INTEGER:fallthrough
		 		case plsqlParser.SINGLE:fallthrough
		 		case plsqlParser.SKIP_:fallthrough
		 		case plsqlParser.SMALLINT:fallthrough
		 		case plsqlParser.SNAPSHOT:fallthrough
		 		case plsqlParser.SOME:fallthrough
		 		case plsqlParser.SPECIFICATION:fallthrough
		 		case plsqlParser.SQLDATA:fallthrough
		 		case plsqlParser.SQLERROR:fallthrough
		 		case plsqlParser.STANDALONE:fallthrough
		 		case plsqlParser.STARTUP:fallthrough
		 		case plsqlParser.STATEMENT:fallthrough
		 		case plsqlParser.STATEMENT_ID:fallthrough
		 		case plsqlParser.STATIC:fallthrough
		 		case plsqlParser.STATISTICS:fallthrough
		 		case plsqlParser.STRING:fallthrough
		 		case plsqlParser.SUBMULTISET:fallthrough
		 		case plsqlParser.SUBPARTITION:fallthrough
		 		case plsqlParser.SUBSTITUTABLE:fallthrough
		 		case plsqlParser.SUBTYPE:fallthrough
		 		case plsqlParser.SUCCESS:fallthrough
		 		case plsqlParser.SUSPEND:fallthrough
		 		case plsqlParser.TIME:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMEZONE_ABBR:fallthrough
		 		case plsqlParser.TIMEZONE_HOUR:fallthrough
		 		case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 		case plsqlParser.TIMEZONE_REGION:fallthrough
		 		case plsqlParser.TRAILING:fallthrough
		 		case plsqlParser.TRANSACTION:fallthrough
		 		case plsqlParser.TRANSLATE:fallthrough
		 		case plsqlParser.TREAT:fallthrough
		 		case plsqlParser.TRIGGER:fallthrough
		 		case plsqlParser.TRIM:fallthrough
		 		case plsqlParser.TRUNCATE:fallthrough
		 		case plsqlParser.TYPE:fallthrough
		 		case plsqlParser.UNBOUNDED:fallthrough
		 		case plsqlParser.UNDER:fallthrough
		 		case plsqlParser.UNLIMITED:fallthrough
		 		case plsqlParser.UNTIL:fallthrough
		 		case plsqlParser.UPDATED:fallthrough
		 		case plsqlParser.UPSERT:fallthrough
		 		case plsqlParser.UROWID:fallthrough
		 		case plsqlParser.USE:fallthrough
		 		case plsqlParser.VALIDATE:fallthrough
		 		case plsqlParser.VALUE:fallthrough
		 		case plsqlParser.VARCHAR:fallthrough
		 		case plsqlParser.VARCHAR2:fallthrough
		 		case plsqlParser.VARIABLE:fallthrough
		 		case plsqlParser.VARRAY:fallthrough
		 		case plsqlParser.VARYING:fallthrough
		 		case plsqlParser.VERSION:fallthrough
		 		case plsqlParser.VERSIONS:fallthrough
		 		case plsqlParser.WAIT:fallthrough
		 		case plsqlParser.WARNING:fallthrough
		 		case plsqlParser.WELLFORMED:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.WHILE:fallthrough
		 		case plsqlParser.WITHIN:fallthrough
		 		case plsqlParser.WORK:fallthrough
		 		case plsqlParser.WRITE:fallthrough
		 		case plsqlParser.XML:fallthrough
		 		case plsqlParser.XMLAGG:fallthrough
		 		case plsqlParser.XMLATTRIBUTES:fallthrough
		 		case plsqlParser.XMLCAST:fallthrough
		 		case plsqlParser.XMLCOLATTVAL:fallthrough
		 		case plsqlParser.XMLELEMENT:fallthrough
		 		case plsqlParser.XMLEXISTS:fallthrough
		 		case plsqlParser.XMLFOREST:fallthrough
		 		case plsqlParser.XMLNAMESPACES:fallthrough
		 		case plsqlParser.XMLPARSE:fallthrough
		 		case plsqlParser.XMLPI:fallthrough
		 		case plsqlParser.XMLQUERY:fallthrough
		 		case plsqlParser.XMLROOT:fallthrough
		 		case plsqlParser.XMLSERIALIZE:fallthrough
		 		case plsqlParser.XMLTABLE:fallthrough
		 		case plsqlParser.YEAR:fallthrough
		 		case plsqlParser.YES:fallthrough
		 		case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.ZONE:fallthrough
		 		case plsqlParser.PREDICTION:fallthrough
		 		case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 		case plsqlParser.PREDICTION_COST:fallthrough
		 		case plsqlParser.PREDICTION_DETAILS:fallthrough
		 		case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 		case plsqlParser.PREDICTION_SET:fallthrough
		 		case plsqlParser.CUME_DIST:fallthrough
		 		case plsqlParser.DENSE_RANK:fallthrough
		 		case plsqlParser.LISTAGG:fallthrough
		 		case plsqlParser.PERCENT_RANK:fallthrough
		 		case plsqlParser.PERCENTILE_CONT:fallthrough
		 		case plsqlParser.PERCENTILE_DISC:fallthrough
		 		case plsqlParser.RANK:fallthrough
		 		case plsqlParser.AVG:fallthrough
		 		case plsqlParser.CORR:fallthrough
		 		case plsqlParser.LAG:fallthrough
		 		case plsqlParser.LEAD:fallthrough
		 		case plsqlParser.MAX:fallthrough
		 		case plsqlParser.MEDIAN:fallthrough
		 		case plsqlParser.MIN:fallthrough
		 		case plsqlParser.NTILE:fallthrough
		 		case plsqlParser.RATIO_TO_REPORT:fallthrough
		 		case plsqlParser.ROW_NUMBER:fallthrough
		 		case plsqlParser.SUM:fallthrough
		 		case plsqlParser.VARIANCE:fallthrough
		 		case plsqlParser.REGR_:fallthrough
		 		case plsqlParser.STDDEV:fallthrough
		 		case plsqlParser.VAR_:fallthrough
		 		case plsqlParser.COVAR_:fallthrough
		 		case plsqlParser.DELIMITED_ID:fallthrough
		 		case plsqlParser.INTRODUCER:fallthrough
		 		case plsqlParser.REGULAR_ID:
		 			setState(4700)
		 			try id()

		 			break
		 		case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case plsqlParser.CHAR_STRING:
		 			setState(4701)
		 			try alias_quoted_string()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4704)
		 		try match(plsqlParser.AS)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_aliasContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func alias_quoted_string() -> Alias_quoted_stringContext? {
			return getRuleContext(Alias_quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_alias(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_alias() throws -> Table_aliasContext {
		var _localctx: Table_aliasContext = Table_aliasContext(_ctx, getState())
		try enterRule(_localctx, 630, plsqlParser.RULE_table_alias)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4709)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(4707)
		 		try id()

		 		break
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:
		 		setState(4708)
		 		try alias_quoted_string()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alias_quoted_stringContext:ParserRuleContext {
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alias_quoted_string }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlias_quoted_string(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlias_quoted_string(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlias_quoted_string(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlias_quoted_string(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alias_quoted_string() throws -> Alias_quoted_stringContext {
		var _localctx: Alias_quoted_stringContext = Alias_quoted_stringContext(_ctx, getState())
		try enterRule(_localctx, 632, plsqlParser.RULE_alias_quoted_string)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4711)
		 	try quoted_string()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Where_clauseContext:ParserRuleContext {
		open func WHERE() -> TerminalNode? { return getToken(plsqlParser.WHERE, 0) }
		open func current_of_clause() -> Current_of_clauseContext? {
			return getRuleContext(Current_of_clauseContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_where_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWhere_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWhere_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWhere_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWhere_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func where_clause() throws -> Where_clauseContext {
		var _localctx: Where_clauseContext = Where_clauseContext(_ctx, getState())
		try enterRule(_localctx, 634, plsqlParser.RULE_where_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4713)
		 	try match(plsqlParser.WHERE)
		 	setState(4716)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.CURRENT:
		 		setState(4714)
		 		try current_of_clause()

		 		break
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ALL:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ANY:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CASE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONNECT_BY_ROOT:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DISTINCT:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXISTS:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FALSE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NOT:fallthrough
		 	case plsqlParser.NULL:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.PRIOR:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUE:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.LEFT_PAREN:fallthrough
		 	case plsqlParser.PLUS_SIGN:fallthrough
		 	case plsqlParser.MINUS_SIGN:fallthrough
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		setState(4715)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Current_of_clauseContext:ParserRuleContext {
		open func CURRENT() -> TerminalNode? { return getToken(plsqlParser.CURRENT, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.OF, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_current_of_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCurrent_of_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCurrent_of_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCurrent_of_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCurrent_of_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func current_of_clause() throws -> Current_of_clauseContext {
		var _localctx: Current_of_clauseContext = Current_of_clauseContext(_ctx, getState())
		try enterRule(_localctx, 636, plsqlParser.RULE_current_of_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4718)
		 	try match(plsqlParser.CURRENT)
		 	setState(4719)
		 	try match(plsqlParser.OF)
		 	setState(4720)
		 	try cursor_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Into_clauseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.INTO, 0) }
		open func variable_name() -> Array<Variable_nameContext> {
			return getRuleContexts(Variable_nameContext.self)
		}
		open func variable_name(_ i: Int) -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,i)
		}
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.BULK, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.COLLECT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_into_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInto_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInto_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInto_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInto_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func into_clause() throws -> Into_clauseContext {
		var _localctx: Into_clauseContext = Into_clauseContext(_ctx, getState())
		try enterRule(_localctx, 638, plsqlParser.RULE_into_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4742)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.INTO:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4722)
		 		try match(plsqlParser.INTO)
		 		setState(4723)
		 		try variable_name()
		 		setState(4728)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4724)
		 			try match(plsqlParser.COMMA)
		 			setState(4725)
		 			try variable_name()


		 			setState(4730)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case plsqlParser.BULK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4731)
		 		try match(plsqlParser.BULK)
		 		setState(4732)
		 		try match(plsqlParser.COLLECT)
		 		setState(4733)
		 		try match(plsqlParser.INTO)
		 		setState(4734)
		 		try variable_name()
		 		setState(4739)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4735)
		 			try match(plsqlParser.COMMA)
		 			setState(4736)
		 			try variable_name()


		 			setState(4741)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_column_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_column_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_column_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_column_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_column_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_column_name() throws -> Xml_column_nameContext {
		var _localctx: Xml_column_nameContext = Xml_column_nameContext(_ctx, getState())
		try enterRule(_localctx, 640, plsqlParser.RULE_xml_column_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4746)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4744)
		 		try id()

		 		break
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4745)
		 		try quoted_string()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cost_class_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cost_class_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCost_class_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCost_class_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCost_class_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCost_class_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cost_class_name() throws -> Cost_class_nameContext {
		var _localctx: Cost_class_nameContext = Cost_class_nameContext(_ctx, getState())
		try enterRule(_localctx, 642, plsqlParser.RULE_cost_class_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4748)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Attribute_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_attribute_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAttribute_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAttribute_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAttribute_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAttribute_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func attribute_name() throws -> Attribute_nameContext {
		var _localctx: Attribute_nameContext = Attribute_nameContext(_ctx, getState())
		try enterRule(_localctx, 644, plsqlParser.RULE_attribute_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4750)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Savepoint_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_savepoint_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSavepoint_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSavepoint_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSavepoint_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSavepoint_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func savepoint_name() throws -> Savepoint_nameContext {
		var _localctx: Savepoint_nameContext = Savepoint_nameContext(_ctx, getState())
		try enterRule(_localctx, 646, plsqlParser.RULE_savepoint_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4752)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollback_segment_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollback_segment_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollback_segment_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollback_segment_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollback_segment_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollback_segment_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollback_segment_name() throws -> Rollback_segment_nameContext {
		var _localctx: Rollback_segment_nameContext = Rollback_segment_nameContext(_ctx, getState())
		try enterRule(_localctx, 648, plsqlParser.RULE_rollback_segment_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4754)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_var_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_var_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_var_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_var_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_var_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_var_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_var_name() throws -> Table_var_nameContext {
		var _localctx: Table_var_nameContext = Table_var_nameContext(_ctx, getState())
		try enterRule(_localctx, 650, plsqlParser.RULE_table_var_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4756)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Schema_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_schema_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSchema_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSchema_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSchema_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSchema_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func schema_name() throws -> Schema_nameContext {
		var _localctx: Schema_nameContext = Schema_nameContext(_ctx, getState())
		try enterRule(_localctx, 652, plsqlParser.RULE_schema_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4758)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Routine_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_routine_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRoutine_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRoutine_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRoutine_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRoutine_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func routine_name() throws -> Routine_nameContext {
		var _localctx: Routine_nameContext = Routine_nameContext(_ctx, getState())
		try enterRule(_localctx, 654, plsqlParser.RULE_routine_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4760)
		 	try id()
		 	setState(4765)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4761)
		 		try match(plsqlParser.PERIOD)
		 		setState(4762)
		 		try id_expression()


		 		setState(4767)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4770)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AT_SIGN
		 	      return testSet
		 	 }()) {
		 		setState(4768)
		 		try match(plsqlParser.AT_SIGN)
		 		setState(4769)
		 		try link_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_name() throws -> Package_nameContext {
		var _localctx: Package_nameContext = Package_nameContext(_ctx, getState())
		try enterRule(_localctx, 656, plsqlParser.RULE_package_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4772)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Implementation_type_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_implementation_type_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterImplementation_type_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitImplementation_type_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitImplementation_type_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitImplementation_type_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func implementation_type_name() throws -> Implementation_type_nameContext {
		var _localctx: Implementation_type_nameContext = Implementation_type_nameContext(_ctx, getState())
		try enterRule(_localctx, 658, plsqlParser.RULE_implementation_type_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4774)
		 	try id()
		 	setState(4777)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4775)
		 		try match(plsqlParser.PERIOD)
		 		setState(4776)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parameter_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter_name() throws -> Parameter_nameContext {
		var _localctx: Parameter_nameContext = Parameter_nameContext(_ctx, getState())
		try enterRule(_localctx, 660, plsqlParser.RULE_parameter_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4779)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Reference_model_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_reference_model_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReference_model_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReference_model_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReference_model_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReference_model_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reference_model_name() throws -> Reference_model_nameContext {
		var _localctx: Reference_model_nameContext = Reference_model_nameContext(_ctx, getState())
		try enterRule(_localctx, 662, plsqlParser.RULE_reference_model_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4781)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Main_model_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_main_model_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMain_model_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMain_model_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMain_model_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMain_model_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func main_model_name() throws -> Main_model_nameContext {
		var _localctx: Main_model_nameContext = Main_model_nameContext(_ctx, getState())
		try enterRule(_localctx, 664, plsqlParser.RULE_main_model_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4783)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Aggregate_function_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_aggregate_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAggregate_function_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAggregate_function_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAggregate_function_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAggregate_function_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func aggregate_function_name() throws -> Aggregate_function_nameContext {
		var _localctx: Aggregate_function_nameContext = Aggregate_function_nameContext(_ctx, getState())
		try enterRule(_localctx, 666, plsqlParser.RULE_aggregate_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4785)
		 	try id()
		 	setState(4790)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4786)
		 		try match(plsqlParser.PERIOD)
		 		setState(4787)
		 		try id_expression()


		 		setState(4792)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_name() throws -> Query_nameContext {
		var _localctx: Query_nameContext = Query_nameContext(_ctx, getState())
		try enterRule(_localctx, 668, plsqlParser.RULE_query_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4793)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constraint_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constraint_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstraint_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstraint_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstraint_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstraint_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constraint_name() throws -> Constraint_nameContext {
		var _localctx: Constraint_nameContext = Constraint_nameContext(_ctx, getState())
		try enterRule(_localctx, 670, plsqlParser.RULE_constraint_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4795)
		 	try id()
		 	setState(4800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4796)
		 		try match(plsqlParser.PERIOD)
		 		setState(4797)
		 		try id_expression()


		 		setState(4802)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4805)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.AT_SIGN
		 	      return testSet
		 	 }()) {
		 		setState(4803)
		 		try match(plsqlParser.AT_SIGN)
		 		setState(4804)
		 		try link_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Label_nameContext:ParserRuleContext {
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_label_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLabel_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLabel_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLabel_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLabel_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func label_name() throws -> Label_nameContext {
		var _localctx: Label_nameContext = Label_nameContext(_ctx, getState())
		try enterRule(_localctx, 672, plsqlParser.RULE_label_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4807)
		 	try id_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_name() throws -> Type_nameContext {
		var _localctx: Type_nameContext = Type_nameContext(_ctx, getState())
		try enterRule(_localctx, 674, plsqlParser.RULE_type_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4809)
		 	try id_expression()
		 	setState(4814)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4810)
		 		try match(plsqlParser.PERIOD)
		 		setState(4811)
		 		try id_expression()


		 		setState(4816)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_name() throws -> Sequence_nameContext {
		var _localctx: Sequence_nameContext = Sequence_nameContext(_ctx, getState())
		try enterRule(_localctx, 676, plsqlParser.RULE_sequence_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4817)
		 	try id_expression()
		 	setState(4822)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4818)
		 		try match(plsqlParser.PERIOD)
		 		setState(4819)
		 		try id_expression()


		 		setState(4824)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_name() throws -> Exception_nameContext {
		var _localctx: Exception_nameContext = Exception_nameContext(_ctx, getState())
		try enterRule(_localctx, 678, plsqlParser.RULE_exception_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4825)
		 	try id()
		 	setState(4830)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4826)
		 		try match(plsqlParser.PERIOD)
		 		setState(4827)
		 		try id_expression()


		 		setState(4832)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_name() throws -> Function_nameContext {
		var _localctx: Function_nameContext = Function_nameContext(_ctx, getState())
		try enterRule(_localctx, 680, plsqlParser.RULE_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4833)
		 	try id()
		 	setState(4836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4834)
		 		try match(plsqlParser.PERIOD)
		 		setState(4835)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_procedure_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProcedure_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProcedure_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProcedure_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProcedure_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_name() throws -> Procedure_nameContext {
		var _localctx: Procedure_nameContext = Procedure_nameContext(_ctx, getState())
		try enterRule(_localctx, 682, plsqlParser.RULE_procedure_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4838)
		 	try id()
		 	setState(4841)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4839)
		 		try match(plsqlParser.PERIOD)
		 		setState(4840)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_name() throws -> Trigger_nameContext {
		var _localctx: Trigger_nameContext = Trigger_nameContext(_ctx, getState())
		try enterRule(_localctx, 684, plsqlParser.RULE_trigger_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4843)
		 	try id()
		 	setState(4846)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4844)
		 		try match(plsqlParser.PERIOD)
		 		setState(4845)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Variable_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.INTRODUCER, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_variable_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVariable_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVariable_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVariable_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVariable_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func variable_name() throws -> Variable_nameContext {
		var _localctx: Variable_nameContext = Variable_nameContext(_ctx, getState())
		try enterRule(_localctx, 686, plsqlParser.RULE_variable_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4858)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4850)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.INTRODUCER
		 		      return testSet
		 		 }()) {
		 			setState(4848)
		 			try match(plsqlParser.INTRODUCER)
		 			setState(4849)
		 			try char_set_name()

		 		}

		 		setState(4852)
		 		try id_expression()
		 		setState(4855)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PERIOD
		 		      return testSet
		 		 }()) {
		 			setState(4853)
		 			try match(plsqlParser.PERIOD)
		 			setState(4854)
		 			try id_expression()

		 		}


		 		break
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4857)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Index_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_index_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIndex_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIndex_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIndex_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIndex_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func index_name() throws -> Index_nameContext {
		var _localctx: Index_nameContext = Index_nameContext(_ctx, getState())
		try enterRule(_localctx, 688, plsqlParser.RULE_index_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4860)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_name() throws -> Cursor_nameContext {
		var _localctx: Cursor_nameContext = Cursor_nameContext(_ctx, getState())
		try enterRule(_localctx, 690, plsqlParser.RULE_cursor_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4864)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4862)
		 		try id()

		 		break
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4863)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_name() throws -> Record_nameContext {
		var _localctx: Record_nameContext = Record_nameContext(_ctx, getState())
		try enterRule(_localctx, 692, plsqlParser.RULE_record_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4868)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.DELIMITED_ID:fallthrough
		 	case plsqlParser.INTRODUCER:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4866)
		 		try id()

		 		break
		 	case plsqlParser.BINDVAR:fallthrough
		 	case plsqlParser.COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4867)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Collection_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_collection_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCollection_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCollection_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCollection_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCollection_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collection_name() throws -> Collection_nameContext {
		var _localctx: Collection_nameContext = Collection_nameContext(_ctx, getState())
		try enterRule(_localctx, 694, plsqlParser.RULE_collection_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4870)
		 	try id()
		 	setState(4873)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4871)
		 		try match(plsqlParser.PERIOD)
		 		setState(4872)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Link_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_link_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLink_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLink_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLink_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLink_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func link_name() throws -> Link_nameContext {
		var _localctx: Link_nameContext = Link_nameContext(_ctx, getState())
		try enterRule(_localctx, 696, plsqlParser.RULE_link_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4875)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_name() throws -> Column_nameContext {
		var _localctx: Column_nameContext = Column_nameContext(_ctx, getState())
		try enterRule(_localctx, 698, plsqlParser.RULE_column_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4877)
		 	try id()
		 	setState(4882)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4878)
		 		try match(plsqlParser.PERIOD)
		 		setState(4879)
		 		try id_expression()


		 		setState(4884)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Tableview_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open func partition_extension_clause() -> Partition_extension_clauseContext? {
			return getRuleContext(Partition_extension_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_tableview_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTableview_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTableview_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTableview_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTableview_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func tableview_name() throws -> Tableview_nameContext {
		var _localctx: Tableview_nameContext = Tableview_nameContext(_ctx, getState())
		try enterRule(_localctx, 700, plsqlParser.RULE_tableview_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4885)
		 	try id()
		 	setState(4888)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,630,_ctx)) {
		 	case 1:
		 		setState(4886)
		 		try match(plsqlParser.PERIOD)
		 		setState(4887)
		 		try id_expression()

		 		break
		 	default: break
		 	}
		 	setState(4893)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,631,_ctx)) {
		 	case 1:
		 		setState(4890)
		 		try match(plsqlParser.AT_SIGN)
		 		setState(4891)
		 		try link_name()

		 		break
		 	case 2:
		 		setState(4892)
		 		try partition_extension_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Char_set_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_char_set_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterChar_set_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitChar_set_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitChar_set_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitChar_set_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func char_set_name() throws -> Char_set_nameContext {
		var _localctx: Char_set_nameContext = Char_set_nameContext(_ctx, getState())
		try enterRule(_localctx, 702, plsqlParser.RULE_char_set_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4895)
		 	try id_expression()
		 	setState(4900)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(4896)
		 		try match(plsqlParser.PERIOD)
		 		setState(4897)
		 		try id_expression()


		 		setState(4902)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Keep_clauseContext:ParserRuleContext {
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.KEEP, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.DENSE_RANK, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.FIRST, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.LAST, 0) }
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_keep_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterKeep_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitKeep_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitKeep_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitKeep_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func keep_clause() throws -> Keep_clauseContext {
		var _localctx: Keep_clauseContext = Keep_clauseContext(_ctx, getState())
		try enterRule(_localctx, 704, plsqlParser.RULE_keep_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4903)
		 	try match(plsqlParser.KEEP)
		 	setState(4904)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4905)
		 	try match(plsqlParser.DENSE_RANK)
		 	setState(4906)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.FIRST || _la == plsqlParser.LAST
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4907)
		 	try order_by_clause()
		 	setState(4908)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(4910)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,633,_ctx)) {
		 	case 1:
		 		setState(4909)
		 		try over_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argumentContext:ParserRuleContext {
		open func argument() -> Array<ArgumentContext> {
			return getRuleContexts(ArgumentContext.self)
		}
		open func argument(_ i: Int) -> ArgumentContext? {
			return getRuleContext(ArgumentContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument() throws -> Function_argumentContext {
		var _localctx: Function_argumentContext = Function_argumentContext(_ctx, getState())
		try enterRule(_localctx, 706, plsqlParser.RULE_function_argument)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4912)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4914)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ALL,plsqlParser.ANALYZE,plsqlParser.ANY,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CASE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONNECT_BY_ROOT,plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DISTINCT,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTION_INIT,plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXISTS,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FALSE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LANGUAGE,plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NOT,plsqlParser.NULL,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OBJECT,plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PRIOR,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.RIGHT,plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 321)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMESTAMP_UNCONSTRAINED,plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUE,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 385)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YEAR,plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.UNSIGNED_INTEGER,plsqlParser.APPROXIMATE_NUM_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID,plsqlParser.LEFT_PAREN,plsqlParser.PLUS_SIGN,plsqlParser.MINUS_SIGN,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 449)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(4913)
		 		try argument()

		 	}

		 	setState(4920)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4916)
		 		try match(plsqlParser.COMMA)
		 		setState(4917)
		 		try argument()


		 		setState(4922)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4923)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(4925)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,636,_ctx)) {
		 	case 1:
		 		setState(4924)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argument_analyticContext:ParserRuleContext {
		open func argument() -> Array<ArgumentContext> {
			return getRuleContexts(ArgumentContext.self)
		}
		open func argument(_ i: Int) -> ArgumentContext? {
			return getRuleContext(ArgumentContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open func respect_or_ignore_nulls() -> Array<Respect_or_ignore_nullsContext> {
			return getRuleContexts(Respect_or_ignore_nullsContext.self)
		}
		open func respect_or_ignore_nulls(_ i: Int) -> Respect_or_ignore_nullsContext? {
			return getRuleContext(Respect_or_ignore_nullsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument_analytic }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument_analytic(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument_analytic(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument_analytic(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument_analytic(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument_analytic() throws -> Function_argument_analyticContext {
		var _localctx: Function_argument_analyticContext = Function_argument_analyticContext(_ctx, getState())
		try enterRule(_localctx, 708, plsqlParser.RULE_function_argument_analytic)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4927)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4932)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ALL,plsqlParser.ANALYZE,plsqlParser.ANY,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CASE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONNECT_BY_ROOT,plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DATE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DISTINCT,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTION_INIT,plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXISTS,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FALSE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LANGUAGE,plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NOT,plsqlParser.NULL,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OBJECT,plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.PRIOR,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.RIGHT,plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 321)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMESTAMP_UNCONSTRAINED,plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUE,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 385)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YEAR,plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.UNSIGNED_INTEGER,plsqlParser.APPROXIMATE_NUM_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID,plsqlParser.LEFT_PAREN,plsqlParser.PLUS_SIGN,plsqlParser.MINUS_SIGN,plsqlParser.BINDVAR,plsqlParser.COLON]
		 	              return  Utils.testBitLeftShiftArray(testArray, 449)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }()) {
		 		setState(4928)
		 		try argument()
		 		setState(4930)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.IGNORE
		 		          testSet = testSet || _la == plsqlParser.RESPECT
		 		      return testSet
		 		 }()) {
		 			setState(4929)
		 			try respect_or_ignore_nulls()

		 		}


		 	}

		 	setState(4941)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4934)
		 		try match(plsqlParser.COMMA)
		 		setState(4935)
		 		try argument()
		 		setState(4937)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.IGNORE
		 		          testSet = testSet || _la == plsqlParser.RESPECT
		 		      return testSet
		 		 }()) {
		 			setState(4936)
		 			try respect_or_ignore_nulls()

		 		}



		 		setState(4943)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4944)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(4946)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,641,_ctx)) {
		 	case 1:
		 		setState(4945)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argument_modelingContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.USING, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open func numeric() -> Array<NumericContext> {
			return getRuleContexts(NumericContext.self)
		}
		open func numeric(_ i: Int) -> NumericContext? {
			return getRuleContext(NumericContext.self,i)
		}
		open func NULL() -> Array<TerminalNode> { return getTokens(plsqlParser.NULL) }
		open func NULL(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.NULL, i)
		}
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument_modeling }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument_modeling(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument_modeling(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument_modeling(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument_modeling(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument_modeling() throws -> Function_argument_modelingContext {
		var _localctx: Function_argument_modelingContext = Function_argument_modelingContext(_ctx, getState())
		try enterRule(_localctx, 710, plsqlParser.RULE_function_argument_modeling)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4948)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(4949)
		 	try column_name()
		 	setState(4962)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(4950)
		 		try match(plsqlParser.COMMA)
		 		setState(4953)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 		case plsqlParser.APPROXIMATE_NUM_LIT:
		 			setState(4951)
		 			try numeric()

		 			break

		 		case plsqlParser.NULL:
		 			setState(4952)
		 			try match(plsqlParser.NULL)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4960)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4955)
		 			try match(plsqlParser.COMMA)
		 			setState(4958)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 			case plsqlParser.APPROXIMATE_NUM_LIT:
		 				setState(4956)
		 				try numeric()

		 				break

		 			case plsqlParser.NULL:
		 				setState(4957)
		 				try match(plsqlParser.NULL)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}


		 	}

		 	setState(4964)
		 	try match(plsqlParser.USING)
		 	setState(4984)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,649, _ctx)) {
		 	case 1:
		 		setState(4965)
		 		try tableview_name()
		 		setState(4966)
		 		try match(plsqlParser.PERIOD)
		 		setState(4967)
		 		try match(plsqlParser.ASTERISK)

		 		break
		 	case 2:
		 		setState(4969)
		 		try match(plsqlParser.ASTERISK)

		 		break
		 	case 3:
		 		setState(4970)
		 		try expression()
		 		setState(4972)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 		              return  Utils.testBitLeftShiftArray(testArray, 129)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 193)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 		              return  Utils.testBitLeftShiftArray(testArray, 386)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 		              return  Utils.testBitLeftShiftArray(testArray, 450)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 		      return testSet
		 		 }()) {
		 			setState(4971)
		 			try column_alias()

		 		}

		 		setState(4981)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.COMMA
		 		      return testSet
		 		 }()) {
		 			setState(4974)
		 			try match(plsqlParser.COMMA)
		 			setState(4975)
		 			try expression()
		 			setState(4977)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.AS,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 65)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 			              return  Utils.testBitLeftShiftArray(testArray, 129)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 193)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 			              return  Utils.testBitLeftShiftArray(testArray, 258)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 			              return  Utils.testBitLeftShiftArray(testArray, 322)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 			              return  Utils.testBitLeftShiftArray(testArray, 386)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_,plsqlParser.NATIONAL_CHAR_STRING_LIT,plsqlParser.CHAR_STRING,plsqlParser.DELIMITED_ID]
		 			              return  Utils.testBitLeftShiftArray(testArray, 450)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.INTRODUCER || _la == plsqlParser.REGULAR_ID
		 			      return testSet
		 			 }()) {
		 				setState(4976)
		 				try column_alias()

		 			}



		 			setState(4983)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4986)
		 	try match(plsqlParser.RIGHT_PAREN)
		 	setState(4988)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,650,_ctx)) {
		 	case 1:
		 		setState(4987)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Respect_or_ignore_nullsContext:ParserRuleContext {
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.NULLS, 0) }
		open func RESPECT() -> TerminalNode? { return getToken(plsqlParser.RESPECT, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.IGNORE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_respect_or_ignore_nulls }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRespect_or_ignore_nulls(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRespect_or_ignore_nulls(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRespect_or_ignore_nulls(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRespect_or_ignore_nulls(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func respect_or_ignore_nulls() throws -> Respect_or_ignore_nullsContext {
		var _localctx: Respect_or_ignore_nullsContext = Respect_or_ignore_nullsContext(_ctx, getState())
		try enterRule(_localctx, 712, plsqlParser.RULE_respect_or_ignore_nulls)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4990)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.IGNORE
		 	          testSet = testSet || _la == plsqlParser.RESPECT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}
		 	setState(4991)
		 	try match(plsqlParser.NULLS)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ArgumentContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_argument }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterArgument(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitArgument(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitArgument(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitArgument(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func argument() throws -> ArgumentContext {
		var _localctx: ArgumentContext = ArgumentContext(_ctx, getState())
		try enterRule(_localctx, 714, plsqlParser.RULE_argument)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4997)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,651,_ctx)) {
		 	case 1:
		 		setState(4993)
		 		try id()
		 		setState(4994)
		 		try match(plsqlParser.EQUALS_OP)
		 		setState(4995)
		 		try match(plsqlParser.GREATER_THAN_OP)

		 		break
		 	default: break
		 	}
		 	setState(4999)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_specContext:ParserRuleContext {
		open func datatype() -> DatatypeContext? {
			return getRuleContext(DatatypeContext.self,0)
		}
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func REF() -> TerminalNode? { return getToken(plsqlParser.REF, 0) }
		open func PERCENT_ROWTYPE() -> TerminalNode? { return getToken(plsqlParser.PERCENT_ROWTYPE, 0) }
		open func PERCENT_TYPE() -> TerminalNode? { return getToken(plsqlParser.PERCENT_TYPE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_spec() throws -> Type_specContext {
		var _localctx: Type_specContext = Type_specContext(_ctx, getState())
		try enterRule(_localctx, 716, plsqlParser.RULE_type_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5009)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,654, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5001)
		 		try datatype()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5003)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,652,_ctx)) {
		 		case 1:
		 			setState(5002)
		 			try match(plsqlParser.REF)

		 			break
		 		default: break
		 		}
		 		setState(5005)
		 		try type_name()
		 		setState(5007)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PERCENT_ROWTYPE || _la == plsqlParser.PERCENT_TYPE
		 		      return testSet
		 		 }()) {
		 			setState(5006)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.PERCENT_ROWTYPE || _la == plsqlParser.PERCENT_TYPE
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			} else {
		 				try consume()
		 			}

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DatatypeContext:ParserRuleContext {
		open func native_datatype_element() -> Native_datatype_elementContext? {
			return getRuleContext(Native_datatype_elementContext.self,0)
		}
		open func precision_part() -> Precision_partContext? {
			return getRuleContext(Precision_partContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.WITH, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.TIME, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.ZONE, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.LOCAL, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.INTERVAL, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.YEAR, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.DAY, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.MONTH, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.SECOND, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_datatype }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDatatype(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDatatype(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDatatype(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDatatype(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func datatype() throws -> DatatypeContext {
		var _localctx: DatatypeContext = DatatypeContext(_ctx, getState())
		try enterRule(_localctx, 718, plsqlParser.RULE_datatype)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5039)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.DATE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5011)
		 		try native_datatype_element()
		 		setState(5013)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,655,_ctx)) {
		 		case 1:
		 			setState(5012)
		 			try precision_part()

		 			break
		 		default: break
		 		}
		 		setState(5021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.WITH
		 		      return testSet
		 		 }()) {
		 			setState(5015)
		 			try match(plsqlParser.WITH)
		 			setState(5017)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.LOCAL
		 			      return testSet
		 			 }()) {
		 				setState(5016)
		 				try match(plsqlParser.LOCAL)

		 			}

		 			setState(5019)
		 			try match(plsqlParser.TIME)
		 			setState(5020)
		 			try match(plsqlParser.ZONE)

		 		}


		 		break

		 	case plsqlParser.INTERVAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5023)
		 		try match(plsqlParser.INTERVAL)
		 		setState(5024)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.DAY
		 		          testSet = testSet || _la == plsqlParser.YEAR
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(5029)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.LEFT_PAREN
		 		      return testSet
		 		 }()) {
		 			setState(5025)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(5026)
		 			try expression()
		 			setState(5027)
		 			try match(plsqlParser.RIGHT_PAREN)

		 		}

		 		setState(5031)
		 		try match(plsqlParser.TO)
		 		setState(5032)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.MONTH
		 		          testSet = testSet || _la == plsqlParser.SECOND
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(5037)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,659,_ctx)) {
		 		case 1:
		 			setState(5033)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(5034)
		 			try expression()
		 			setState(5035)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Precision_partContext:ParserRuleContext {
		open func numeric() -> Array<NumericContext> {
			return getRuleContexts(NumericContext.self)
		}
		open func numeric(_ i: Int) -> NumericContext? {
			return getRuleContext(NumericContext.self,i)
		}
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.CHAR, 0) }
		open func BYTE() -> TerminalNode? { return getToken(plsqlParser.BYTE, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_precision_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPrecision_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPrecision_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPrecision_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPrecision_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func precision_part() throws -> Precision_partContext {
		var _localctx: Precision_partContext = Precision_partContext(_ctx, getState())
		try enterRule(_localctx, 720, plsqlParser.RULE_precision_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5041)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(5042)
		 	try numeric()
		 	setState(5045)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.COMMA
		 	      return testSet
		 	 }()) {
		 		setState(5043)
		 		try match(plsqlParser.COMMA)
		 		setState(5044)
		 		try numeric()

		 	}

		 	setState(5048)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.BYTE || _la == plsqlParser.CHAR
		 	      return testSet
		 	 }()) {
		 		setState(5047)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.BYTE || _la == plsqlParser.CHAR
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}

		 	}

		 	setState(5050)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Native_datatype_elementContext:ParserRuleContext {
		open func BINARY_INTEGER() -> TerminalNode? { return getToken(plsqlParser.BINARY_INTEGER, 0) }
		open func PLS_INTEGER() -> TerminalNode? { return getToken(plsqlParser.PLS_INTEGER, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.NATURAL, 0) }
		open func BINARY_FLOAT() -> TerminalNode? { return getToken(plsqlParser.BINARY_FLOAT, 0) }
		open func BINARY_DOUBLE() -> TerminalNode? { return getToken(plsqlParser.BINARY_DOUBLE, 0) }
		open func NATURALN() -> TerminalNode? { return getToken(plsqlParser.NATURALN, 0) }
		open func POSITIVE() -> TerminalNode? { return getToken(plsqlParser.POSITIVE, 0) }
		open func POSITIVEN() -> TerminalNode? { return getToken(plsqlParser.POSITIVEN, 0) }
		open func SIGNTYPE() -> TerminalNode? { return getToken(plsqlParser.SIGNTYPE, 0) }
		open func SIMPLE_INTEGER() -> TerminalNode? { return getToken(plsqlParser.SIMPLE_INTEGER, 0) }
		open func NVARCHAR2() -> TerminalNode? { return getToken(plsqlParser.NVARCHAR2, 0) }
		open func DEC() -> TerminalNode? { return getToken(plsqlParser.DEC, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(plsqlParser.INTEGER, 0) }
		open func INT() -> TerminalNode? { return getToken(plsqlParser.INT, 0) }
		open func NUMERIC() -> TerminalNode? { return getToken(plsqlParser.NUMERIC, 0) }
		open func SMALLINT() -> TerminalNode? { return getToken(plsqlParser.SMALLINT, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(plsqlParser.NUMBER, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(plsqlParser.DECIMAL, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(plsqlParser.DOUBLE, 0) }
		open func PRECISION() -> TerminalNode? { return getToken(plsqlParser.PRECISION, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(plsqlParser.FLOAT, 0) }
		open func REAL() -> TerminalNode? { return getToken(plsqlParser.REAL, 0) }
		open func NCHAR() -> TerminalNode? { return getToken(plsqlParser.NCHAR, 0) }
		open func LONG() -> TerminalNode? { return getToken(plsqlParser.LONG, 0) }
		open func RAW() -> TerminalNode? { return getToken(plsqlParser.RAW, 0) }
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.CHAR, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(plsqlParser.CHARACTER, 0) }
		open func VARCHAR2() -> TerminalNode? { return getToken(plsqlParser.VARCHAR2, 0) }
		open func VARCHAR() -> TerminalNode? { return getToken(plsqlParser.VARCHAR, 0) }
		open func STRING() -> TerminalNode? { return getToken(plsqlParser.STRING, 0) }
		open func BOOLEAN() -> TerminalNode? { return getToken(plsqlParser.BOOLEAN, 0) }
		open func DATE() -> TerminalNode? { return getToken(plsqlParser.DATE, 0) }
		open func ROWID() -> TerminalNode? { return getToken(plsqlParser.ROWID, 0) }
		open func UROWID() -> TerminalNode? { return getToken(plsqlParser.UROWID, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.YEAR, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.MONTH, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.DAY, 0) }
		open func HOUR() -> TerminalNode? { return getToken(plsqlParser.HOUR, 0) }
		open func MINUTE() -> TerminalNode? { return getToken(plsqlParser.MINUTE, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.SECOND, 0) }
		open func TIMEZONE_HOUR() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_HOUR, 0) }
		open func TIMEZONE_MINUTE() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_MINUTE, 0) }
		open func TIMEZONE_REGION() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_REGION, 0) }
		open func TIMEZONE_ABBR() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_ABBR, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP, 0) }
		open func TIMESTAMP_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0) }
		open func TIMESTAMP_TZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0) }
		open func TIMESTAMP_LTZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0) }
		open func YMINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0) }
		open func DSINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0) }
		open func BFILE() -> TerminalNode? { return getToken(plsqlParser.BFILE, 0) }
		open func BLOB() -> TerminalNode? { return getToken(plsqlParser.BLOB, 0) }
		open func CLOB() -> TerminalNode? { return getToken(plsqlParser.CLOB, 0) }
		open func NCLOB() -> TerminalNode? { return getToken(plsqlParser.NCLOB, 0) }
		open func MLSLABEL() -> TerminalNode? { return getToken(plsqlParser.MLSLABEL, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_native_datatype_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNative_datatype_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNative_datatype_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNative_datatype_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNative_datatype_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func native_datatype_element() throws -> Native_datatype_elementContext {
		var _localctx: Native_datatype_elementContext = Native_datatype_elementContext(_ctx, getState())
		try enterRule(_localctx, 722, plsqlParser.RULE_native_datatype_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5112)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BINARY_INTEGER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5052)
		 		try match(plsqlParser.BINARY_INTEGER)

		 		break

		 	case plsqlParser.PLS_INTEGER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5053)
		 		try match(plsqlParser.PLS_INTEGER)

		 		break

		 	case plsqlParser.NATURAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5054)
		 		try match(plsqlParser.NATURAL)

		 		break

		 	case plsqlParser.BINARY_FLOAT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5055)
		 		try match(plsqlParser.BINARY_FLOAT)

		 		break

		 	case plsqlParser.BINARY_DOUBLE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5056)
		 		try match(plsqlParser.BINARY_DOUBLE)

		 		break

		 	case plsqlParser.NATURALN:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5057)
		 		try match(plsqlParser.NATURALN)

		 		break

		 	case plsqlParser.POSITIVE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5058)
		 		try match(plsqlParser.POSITIVE)

		 		break

		 	case plsqlParser.POSITIVEN:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5059)
		 		try match(plsqlParser.POSITIVEN)

		 		break

		 	case plsqlParser.SIGNTYPE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5060)
		 		try match(plsqlParser.SIGNTYPE)

		 		break

		 	case plsqlParser.SIMPLE_INTEGER:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5061)
		 		try match(plsqlParser.SIMPLE_INTEGER)

		 		break

		 	case plsqlParser.NVARCHAR2:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5062)
		 		try match(plsqlParser.NVARCHAR2)

		 		break

		 	case plsqlParser.DEC:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5063)
		 		try match(plsqlParser.DEC)

		 		break

		 	case plsqlParser.INTEGER:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5064)
		 		try match(plsqlParser.INTEGER)

		 		break

		 	case plsqlParser.INT:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(5065)
		 		try match(plsqlParser.INT)

		 		break

		 	case plsqlParser.NUMERIC:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(5066)
		 		try match(plsqlParser.NUMERIC)

		 		break

		 	case plsqlParser.SMALLINT:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(5067)
		 		try match(plsqlParser.SMALLINT)

		 		break

		 	case plsqlParser.NUMBER:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(5068)
		 		try match(plsqlParser.NUMBER)

		 		break

		 	case plsqlParser.DECIMAL:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(5069)
		 		try match(plsqlParser.DECIMAL)

		 		break

		 	case plsqlParser.DOUBLE:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(5070)
		 		try match(plsqlParser.DOUBLE)
		 		setState(5072)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.PRECISION
		 		      return testSet
		 		 }()) {
		 			setState(5071)
		 			try match(plsqlParser.PRECISION)

		 		}


		 		break

		 	case plsqlParser.FLOAT:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(5074)
		 		try match(plsqlParser.FLOAT)

		 		break

		 	case plsqlParser.REAL:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(5075)
		 		try match(plsqlParser.REAL)

		 		break

		 	case plsqlParser.NCHAR:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(5076)
		 		try match(plsqlParser.NCHAR)

		 		break

		 	case plsqlParser.LONG:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(5077)
		 		try match(plsqlParser.LONG)
		 		setState(5079)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.RAW
		 		      return testSet
		 		 }()) {
		 			setState(5078)
		 			try match(plsqlParser.RAW)

		 		}


		 		break

		 	case plsqlParser.CHAR:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(5081)
		 		try match(plsqlParser.CHAR)

		 		break

		 	case plsqlParser.CHARACTER:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(5082)
		 		try match(plsqlParser.CHARACTER)

		 		break

		 	case plsqlParser.VARCHAR2:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(5083)
		 		try match(plsqlParser.VARCHAR2)

		 		break

		 	case plsqlParser.VARCHAR:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(5084)
		 		try match(plsqlParser.VARCHAR)

		 		break

		 	case plsqlParser.STRING:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(5085)
		 		try match(plsqlParser.STRING)

		 		break

		 	case plsqlParser.RAW:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(5086)
		 		try match(plsqlParser.RAW)

		 		break

		 	case plsqlParser.BOOLEAN:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(5087)
		 		try match(plsqlParser.BOOLEAN)

		 		break

		 	case plsqlParser.DATE:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(5088)
		 		try match(plsqlParser.DATE)

		 		break

		 	case plsqlParser.ROWID:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(5089)
		 		try match(plsqlParser.ROWID)

		 		break

		 	case plsqlParser.UROWID:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(5090)
		 		try match(plsqlParser.UROWID)

		 		break

		 	case plsqlParser.YEAR:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(5091)
		 		try match(plsqlParser.YEAR)

		 		break

		 	case plsqlParser.MONTH:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(5092)
		 		try match(plsqlParser.MONTH)

		 		break

		 	case plsqlParser.DAY:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(5093)
		 		try match(plsqlParser.DAY)

		 		break

		 	case plsqlParser.HOUR:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(5094)
		 		try match(plsqlParser.HOUR)

		 		break

		 	case plsqlParser.MINUTE:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(5095)
		 		try match(plsqlParser.MINUTE)

		 		break

		 	case plsqlParser.SECOND:
		 		try enterOuterAlt(_localctx, 39)
		 		setState(5096)
		 		try match(plsqlParser.SECOND)

		 		break

		 	case plsqlParser.TIMEZONE_HOUR:
		 		try enterOuterAlt(_localctx, 40)
		 		setState(5097)
		 		try match(plsqlParser.TIMEZONE_HOUR)

		 		break

		 	case plsqlParser.TIMEZONE_MINUTE:
		 		try enterOuterAlt(_localctx, 41)
		 		setState(5098)
		 		try match(plsqlParser.TIMEZONE_MINUTE)

		 		break

		 	case plsqlParser.TIMEZONE_REGION:
		 		try enterOuterAlt(_localctx, 42)
		 		setState(5099)
		 		try match(plsqlParser.TIMEZONE_REGION)

		 		break

		 	case plsqlParser.TIMEZONE_ABBR:
		 		try enterOuterAlt(_localctx, 43)
		 		setState(5100)
		 		try match(plsqlParser.TIMEZONE_ABBR)

		 		break

		 	case plsqlParser.TIMESTAMP:
		 		try enterOuterAlt(_localctx, 44)
		 		setState(5101)
		 		try match(plsqlParser.TIMESTAMP)

		 		break

		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 45)
		 		setState(5102)
		 		try match(plsqlParser.TIMESTAMP_UNCONSTRAINED)

		 		break

		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 46)
		 		setState(5103)
		 		try match(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED)

		 		break

		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 47)
		 		setState(5104)
		 		try match(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED)

		 		break

		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 48)
		 		setState(5105)
		 		try match(plsqlParser.YMINTERVAL_UNCONSTRAINED)

		 		break

		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 49)
		 		setState(5106)
		 		try match(plsqlParser.DSINTERVAL_UNCONSTRAINED)

		 		break

		 	case plsqlParser.BFILE:
		 		try enterOuterAlt(_localctx, 50)
		 		setState(5107)
		 		try match(plsqlParser.BFILE)

		 		break

		 	case plsqlParser.BLOB:
		 		try enterOuterAlt(_localctx, 51)
		 		setState(5108)
		 		try match(plsqlParser.BLOB)

		 		break

		 	case plsqlParser.CLOB:
		 		try enterOuterAlt(_localctx, 52)
		 		setState(5109)
		 		try match(plsqlParser.CLOB)

		 		break

		 	case plsqlParser.NCLOB:
		 		try enterOuterAlt(_localctx, 53)
		 		setState(5110)
		 		try match(plsqlParser.NCLOB)

		 		break

		 	case plsqlParser.MLSLABEL:
		 		try enterOuterAlt(_localctx, 54)
		 		setState(5111)
		 		try match(plsqlParser.MLSLABEL)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Bind_variableContext:ParserRuleContext {
		open func BINDVAR() -> Array<TerminalNode> { return getTokens(plsqlParser.BINDVAR) }
		open func BINDVAR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.BINDVAR, i)
		}
		open func UNSIGNED_INTEGER() -> Array<TerminalNode> { return getTokens(plsqlParser.UNSIGNED_INTEGER) }
		open func UNSIGNED_INTEGER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.UNSIGNED_INTEGER, i)
		}
		open func general_element_part() -> Array<General_element_partContext> {
			return getRuleContexts(General_element_partContext.self)
		}
		open func general_element_part(_ i: Int) -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,i)
		}
		open func INDICATOR() -> TerminalNode? { return getToken(plsqlParser.INDICATOR, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_bind_variable }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBind_variable(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBind_variable(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBind_variable(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBind_variable(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func bind_variable() throws -> Bind_variableContext {
		var _localctx: Bind_variableContext = Bind_variableContext(_ctx, getState())
		try enterRule(_localctx, 724, plsqlParser.RULE_bind_variable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5117)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.BINDVAR:
		 		setState(5114)
		 		try match(plsqlParser.BINDVAR)

		 		break

		 	case plsqlParser.COLON:
		 		setState(5115)
		 		try match(plsqlParser.COLON)
		 		setState(5116)
		 		try match(plsqlParser.UNSIGNED_INTEGER)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5127)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,669,_ctx)) {
		 	case 1:
		 		setState(5120)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.INDICATOR
		 		      return testSet
		 		 }()) {
		 			setState(5119)
		 			try match(plsqlParser.INDICATOR)

		 		}

		 		setState(5125)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.BINDVAR:
		 			setState(5122)
		 			try match(plsqlParser.BINDVAR)

		 			break

		 		case plsqlParser.COLON:
		 			setState(5123)
		 			try match(plsqlParser.COLON)
		 			setState(5124)
		 			try match(plsqlParser.UNSIGNED_INTEGER)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		 	setState(5133)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,670,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5129)
		 			try match(plsqlParser.PERIOD)
		 			setState(5130)
		 			try general_element_part()

		 	 
		 		}
		 		setState(5135)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,670,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_elementContext:ParserRuleContext {
		open func general_element_part() -> Array<General_element_partContext> {
			return getRuleContexts(General_element_partContext.self)
		}
		open func general_element_part(_ i: Int) -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_element() throws -> General_elementContext {
		var _localctx: General_elementContext = General_elementContext(_ctx, getState())
		try enterRule(_localctx, 726, plsqlParser.RULE_general_element)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5136)
		 	try general_element_part()
		 	setState(5141)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,671,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5137)
		 			try match(plsqlParser.PERIOD)
		 			setState(5138)
		 			try general_element_part()

		 	 
		 		}
		 		setState(5143)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,671,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_element_partContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.INTRODUCER, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_element_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_element_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_element_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_element_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_element_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_element_part() throws -> General_element_partContext {
		var _localctx: General_element_partContext = General_element_partContext(_ctx, getState())
		try enterRule(_localctx, 728, plsqlParser.RULE_general_element_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5146)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTRODUCER
		 	      return testSet
		 	 }()) {
		 		setState(5144)
		 		try match(plsqlParser.INTRODUCER)
		 		setState(5145)
		 		try char_set_name()

		 	}

		 	setState(5148)
		 	try id_expression()
		 	setState(5153)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,673,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5149)
		 			try match(plsqlParser.PERIOD)
		 			setState(5150)
		 			try id_expression()

		 	 
		 		}
		 		setState(5155)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,673,_ctx)
		 	}
		 	setState(5157)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,674,_ctx)) {
		 	case 1:
		 		setState(5156)
		 		try function_argument()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_elementContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.INTRODUCER, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_element() throws -> Table_elementContext {
		var _localctx: Table_elementContext = Table_elementContext(_ctx, getState())
		try enterRule(_localctx, 730, plsqlParser.RULE_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5161)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTRODUCER
		 	      return testSet
		 	 }()) {
		 		setState(5159)
		 		try match(plsqlParser.INTRODUCER)
		 		setState(5160)
		 		try char_set_name()

		 	}

		 	setState(5163)
		 	try id_expression()
		 	setState(5168)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.PERIOD
		 	      return testSet
		 	 }()) {
		 		setState(5164)
		 		try match(plsqlParser.PERIOD)
		 		setState(5165)
		 		try id_expression()


		 		setState(5170)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConstantContext:ParserRuleContext {
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP, 0) }
		open func quoted_string() -> Array<Quoted_stringContext> {
			return getRuleContexts(Quoted_stringContext.self)
		}
		open func quoted_string(_ i: Int) -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,i)
		}
		open func bind_variable() -> Array<Bind_variableContext> {
			return getRuleContexts(Bind_variableContext.self)
		}
		open func bind_variable(_ i: Int) -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,i)
		}
		open func AT() -> TerminalNode? { return getToken(plsqlParser.AT, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.TIME, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.ZONE, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.INTERVAL, 0) }
		open func DAY() -> Array<TerminalNode> { return getTokens(plsqlParser.DAY) }
		open func DAY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.DAY, i)
		}
		open func HOUR() -> Array<TerminalNode> { return getTokens(plsqlParser.HOUR) }
		open func HOUR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.HOUR, i)
		}
		open func MINUTE() -> Array<TerminalNode> { return getTokens(plsqlParser.MINUTE) }
		open func MINUTE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.MINUTE, i)
		}
		open func SECOND() -> Array<TerminalNode> { return getTokens(plsqlParser.SECOND) }
		open func SECOND(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.SECOND, i)
		}
		open func general_element_part() -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(plsqlParser.TO, 0) }
		open func UNSIGNED_INTEGER() -> Array<TerminalNode> { return getTokens(plsqlParser.UNSIGNED_INTEGER) }
		open func UNSIGNED_INTEGER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.UNSIGNED_INTEGER, i)
		}
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open func DATE() -> TerminalNode? { return getToken(plsqlParser.DATE, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.NULL, 0) }
		open func TRUE() -> TerminalNode? { return getToken(plsqlParser.TRUE, 0) }
		open func FALSE() -> TerminalNode? { return getToken(plsqlParser.FALSE, 0) }
		open func DBTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.DBTIMEZONE, 0) }
		open func SESSIONTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.SESSIONTIMEZONE, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.MINVALUE, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.MAXVALUE, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.DEFAULT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constant }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstant(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstant(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstant(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstant(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constant() throws -> ConstantContext {
		var _localctx: ConstantContext = ConstantContext(_ctx, getState())
		try enterRule(_localctx, 732, plsqlParser.RULE_constant)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5233)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.TIMESTAMP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5171)
		 		try match(plsqlParser.TIMESTAMP)
		 		setState(5174)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case plsqlParser.CHAR_STRING:
		 			setState(5172)
		 			try quoted_string()

		 			break
		 		case plsqlParser.BINDVAR:fallthrough
		 		case plsqlParser.COLON:
		 			setState(5173)
		 			try bind_variable()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5180)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,678,_ctx)) {
		 		case 1:
		 			setState(5176)
		 			try match(plsqlParser.AT)
		 			setState(5177)
		 			try match(plsqlParser.TIME)
		 			setState(5178)
		 			try match(plsqlParser.ZONE)
		 			setState(5179)
		 			try quoted_string()

		 			break
		 		default: break
		 		}

		 		break

		 	case plsqlParser.INTERVAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5182)
		 		try match(plsqlParser.INTERVAL)
		 		setState(5186)
		 		try _errHandler.sync(self)
		 		switch (try _input.LA(1)) {
		 		case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case plsqlParser.CHAR_STRING:
		 			setState(5183)
		 			try quoted_string()

		 			break
		 		case plsqlParser.BINDVAR:fallthrough
		 		case plsqlParser.COLON:
		 			setState(5184)
		 			try bind_variable()

		 			break
		 		case plsqlParser.A_LETTER:fallthrough
		 		case plsqlParser.ADD:fallthrough
		 		case plsqlParser.AFTER:fallthrough
		 		case plsqlParser.AGENT:fallthrough
		 		case plsqlParser.AGGREGATE:fallthrough
		 		case plsqlParser.ANALYZE:fallthrough
		 		case plsqlParser.ARRAY:fallthrough
		 		case plsqlParser.ASSOCIATE:fallthrough
		 		case plsqlParser.AT:fallthrough
		 		case plsqlParser.ATTRIBUTE:fallthrough
		 		case plsqlParser.AUDIT:fallthrough
		 		case plsqlParser.AUTHID:fallthrough
		 		case plsqlParser.AUTO:fallthrough
		 		case plsqlParser.AUTOMATIC:fallthrough
		 		case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 		case plsqlParser.BATCH:fallthrough
		 		case plsqlParser.BEFORE:fallthrough
		 		case plsqlParser.BFILE:fallthrough
		 		case plsqlParser.BINARY_DOUBLE:fallthrough
		 		case plsqlParser.BINARY_FLOAT:fallthrough
		 		case plsqlParser.BINARY_INTEGER:fallthrough
		 		case plsqlParser.BLOB:fallthrough
		 		case plsqlParser.BLOCK:fallthrough
		 		case plsqlParser.BODY:fallthrough
		 		case plsqlParser.BOOLEAN:fallthrough
		 		case plsqlParser.BOTH:fallthrough
		 		case plsqlParser.BULK:fallthrough
		 		case plsqlParser.BYTE:fallthrough
		 		case plsqlParser.C_LETTER:fallthrough
		 		case plsqlParser.CALL:fallthrough
		 		case plsqlParser.CANONICAL:fallthrough
		 		case plsqlParser.CASCADE:fallthrough
		 		case plsqlParser.CAST:fallthrough
		 		case plsqlParser.CHAR:fallthrough
		 		case plsqlParser.CHAR_CS:fallthrough
		 		case plsqlParser.CHARACTER:fallthrough
		 		case plsqlParser.CHR:fallthrough
		 		case plsqlParser.CLOB:fallthrough
		 		case plsqlParser.CLOSE:fallthrough
		 		case plsqlParser.CLUSTER:fallthrough
		 		case plsqlParser.COLLECT:fallthrough
		 		case plsqlParser.COLUMNS:fallthrough
		 		case plsqlParser.COMMENT:fallthrough
		 		case plsqlParser.COMMIT:fallthrough
		 		case plsqlParser.COMMITTED:fallthrough
		 		case plsqlParser.COMPATIBILITY:fallthrough
		 		case plsqlParser.COMPILE:fallthrough
		 		case plsqlParser.COMPOUND:fallthrough
		 		case plsqlParser.CONSTANT:fallthrough
		 		case plsqlParser.CONSTRAINT:fallthrough
		 		case plsqlParser.CONSTRAINTS:fallthrough
		 		case plsqlParser.CONSTRUCTOR:fallthrough
		 		case plsqlParser.CONTENT:fallthrough
		 		case plsqlParser.CONTEXT:fallthrough
		 		case plsqlParser.CONTINUE:fallthrough
		 		case plsqlParser.CONVERT:fallthrough
		 		case plsqlParser.CORRUPT_XID:fallthrough
		 		case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 		case plsqlParser.COST:fallthrough
		 		case plsqlParser.COUNT:fallthrough
		 		case plsqlParser.CROSS:fallthrough
		 		case plsqlParser.CUBE:fallthrough
		 		case plsqlParser.CURRENT_USER:fallthrough
		 		case plsqlParser.CURSOR:fallthrough
		 		case plsqlParser.CUSTOMDATUM:fallthrough
		 		case plsqlParser.CYCLE:fallthrough
		 		case plsqlParser.DATA:fallthrough
		 		case plsqlParser.DATABASE:fallthrough
		 		case plsqlParser.DAY:fallthrough
		 		case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 		case plsqlParser.DBTIMEZONE:fallthrough
		 		case plsqlParser.DDL:fallthrough
		 		case plsqlParser.DEBUG:fallthrough
		 		case plsqlParser.DEC:fallthrough
		 		case plsqlParser.DECIMAL:fallthrough
		 		case plsqlParser.DECOMPOSE:fallthrough
		 		case plsqlParser.DECREMENT:fallthrough
		 		case plsqlParser.DEFAULTS:fallthrough
		 		case plsqlParser.DEFERRED:fallthrough
		 		case plsqlParser.DEFINER:fallthrough
		 		case plsqlParser.DETERMINISTIC:fallthrough
		 		case plsqlParser.DIMENSION:fallthrough
		 		case plsqlParser.DISABLE:fallthrough
		 		case plsqlParser.DISASSOCIATE:fallthrough
		 		case plsqlParser.DOCUMENT:fallthrough
		 		case plsqlParser.DOUBLE:fallthrough
		 		case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.EACH:fallthrough
		 		case plsqlParser.ELEMENT:fallthrough
		 		case plsqlParser.EMPTY:fallthrough
		 		case plsqlParser.ENABLE:fallthrough
		 		case plsqlParser.ENCODING:fallthrough
		 		case plsqlParser.ENTITYESCAPING:fallthrough
		 		case plsqlParser.ERR:fallthrough
		 		case plsqlParser.ERRORS:fallthrough
		 		case plsqlParser.ESCAPE:fallthrough
		 		case plsqlParser.EVALNAME:fallthrough
		 		case plsqlParser.EXCEPTION:fallthrough
		 		case plsqlParser.EXCEPTION_INIT:fallthrough
		 		case plsqlParser.EXCEPTIONS:fallthrough
		 		case plsqlParser.EXCLUDE:fallthrough
		 		case plsqlParser.EXECUTE:fallthrough
		 		case plsqlParser.EXIT:fallthrough
		 		case plsqlParser.EXPLAIN:fallthrough
		 		case plsqlParser.EXTERNAL:fallthrough
		 		case plsqlParser.EXTRACT:fallthrough
		 		case plsqlParser.FAILURE:fallthrough
		 		case plsqlParser.FINAL:fallthrough
		 		case plsqlParser.FIRST:fallthrough
		 		case plsqlParser.FIRST_VALUE:fallthrough
		 		case plsqlParser.FLOAT:fallthrough
		 		case plsqlParser.FOLLOWING:fallthrough
		 		case plsqlParser.FOLLOWS:fallthrough
		 		case plsqlParser.FORALL:fallthrough
		 		case plsqlParser.FORCE:fallthrough
		 		case plsqlParser.FULL:fallthrough
		 		case plsqlParser.FUNCTION:fallthrough
		 		case plsqlParser.GROUPING:fallthrough
		 		case plsqlParser.HASH:fallthrough
		 		case plsqlParser.HIDE:fallthrough
		 		case plsqlParser.HOUR:fallthrough
		 		case plsqlParser.IGNORE:fallthrough
		 		case plsqlParser.IMMEDIATE:fallthrough
		 		case plsqlParser.INCLUDE:fallthrough
		 		case plsqlParser.INCLUDING:fallthrough
		 		case plsqlParser.INCREMENT:fallthrough
		 		case plsqlParser.INDENT:fallthrough
		 		case plsqlParser.INDEXED:fallthrough
		 		case plsqlParser.INDICATOR:fallthrough
		 		case plsqlParser.INDICES:fallthrough
		 		case plsqlParser.INFINITE:fallthrough
		 		case plsqlParser.INLINE:fallthrough
		 		case plsqlParser.INNER:fallthrough
		 		case plsqlParser.INOUT:fallthrough
		 		case plsqlParser.INSTANTIABLE:fallthrough
		 		case plsqlParser.INSTEAD:fallthrough
		 		case plsqlParser.INT:fallthrough
		 		case plsqlParser.INTEGER:fallthrough
		 		case plsqlParser.INTERVAL:fallthrough
		 		case plsqlParser.INVALIDATE:fallthrough
		 		case plsqlParser.ISOLATION:fallthrough
		 		case plsqlParser.ITERATE:fallthrough
		 		case plsqlParser.JAVA:fallthrough
		 		case plsqlParser.JOIN:fallthrough
		 		case plsqlParser.KEEP:fallthrough
		 		case plsqlParser.LANGUAGE:fallthrough
		 		case plsqlParser.LAST:fallthrough
		 		case plsqlParser.LAST_VALUE:fallthrough
		 		case plsqlParser.LEADING:fallthrough
		 		case plsqlParser.LEFT:fallthrough
		 		case plsqlParser.LEVEL:fallthrough
		 		case plsqlParser.LIBRARY:fallthrough
		 		case plsqlParser.LIKE2:fallthrough
		 		case plsqlParser.LIKE4:fallthrough
		 		case plsqlParser.LIKEC:fallthrough
		 		case plsqlParser.LIMIT:fallthrough
		 		case plsqlParser.LOCAL:fallthrough
		 		case plsqlParser.LOCKED:fallthrough
		 		case plsqlParser.LOG:fallthrough
		 		case plsqlParser.LOGOFF:fallthrough
		 		case plsqlParser.LOGON:fallthrough
		 		case plsqlParser.LONG:fallthrough
		 		case plsqlParser.LOOP:fallthrough
		 		case plsqlParser.MAIN:fallthrough
		 		case plsqlParser.MAP:fallthrough
		 		case plsqlParser.MATCHED:fallthrough
		 		case plsqlParser.MAXVALUE:fallthrough
		 		case plsqlParser.MEASURES:fallthrough
		 		case plsqlParser.MEMBER:fallthrough
		 		case plsqlParser.MERGE:fallthrough
		 		case plsqlParser.MINUTE:fallthrough
		 		case plsqlParser.MINVALUE:fallthrough
		 		case plsqlParser.MLSLABEL:fallthrough
		 		case plsqlParser.MODEL:fallthrough
		 		case plsqlParser.MODIFY:fallthrough
		 		case plsqlParser.MONTH:fallthrough
		 		case plsqlParser.MULTISET:fallthrough
		 		case plsqlParser.NAME:fallthrough
		 		case plsqlParser.NAN:fallthrough
		 		case plsqlParser.NATURAL:fallthrough
		 		case plsqlParser.NATURALN:fallthrough
		 		case plsqlParser.NAV:fallthrough
		 		case plsqlParser.NCHAR:fallthrough
		 		case plsqlParser.NCHAR_CS:fallthrough
		 		case plsqlParser.NCLOB:fallthrough
		 		case plsqlParser.NESTED:fallthrough
		 		case plsqlParser.NEW:fallthrough
		 		case plsqlParser.NO:fallthrough
		 		case plsqlParser.NOAUDIT:fallthrough
		 		case plsqlParser.NOCOPY:fallthrough
		 		case plsqlParser.NOCYCLE:fallthrough
		 		case plsqlParser.NOENTITYESCAPING:fallthrough
		 		case plsqlParser.NONE:fallthrough
		 		case plsqlParser.NOSCHEMACHECK:fallthrough
		 		case plsqlParser.NULLS:fallthrough
		 		case plsqlParser.NUMBER:fallthrough
		 		case plsqlParser.NUMERIC:fallthrough
		 		case plsqlParser.NVARCHAR2:fallthrough
		 		case plsqlParser.OBJECT:fallthrough
		 		case plsqlParser.OFF:fallthrough
		 		case plsqlParser.OID:fallthrough
		 		case plsqlParser.OLD:fallthrough
		 		case plsqlParser.ONLY:fallthrough
		 		case plsqlParser.OPEN:fallthrough
		 		case plsqlParser.ORADATA:fallthrough
		 		case plsqlParser.ORDINALITY:fallthrough
		 		case plsqlParser.OSERROR:fallthrough
		 		case plsqlParser.OUT:fallthrough
		 		case plsqlParser.OUTER:fallthrough
		 		case plsqlParser.OVER:fallthrough
		 		case plsqlParser.OVERRIDING:fallthrough
		 		case plsqlParser.PACKAGE:fallthrough
		 		case plsqlParser.PARALLEL_ENABLE:fallthrough
		 		case plsqlParser.PARAMETERS:fallthrough
		 		case plsqlParser.PARENT:fallthrough
		 		case plsqlParser.PARTITION:fallthrough
		 		case plsqlParser.PASSING:fallthrough
		 		case plsqlParser.PATH:fallthrough
		 		case plsqlParser.PIPELINED:fallthrough
		 		case plsqlParser.PLAN:fallthrough
		 		case plsqlParser.PLS_INTEGER:fallthrough
		 		case plsqlParser.POSITIVE:fallthrough
		 		case plsqlParser.POSITIVEN:fallthrough
		 		case plsqlParser.PRAGMA:fallthrough
		 		case plsqlParser.PRECEDING:fallthrough
		 		case plsqlParser.PRECISION:fallthrough
		 		case plsqlParser.PRESENT:fallthrough
		 		case plsqlParser.RAISE:fallthrough
		 		case plsqlParser.RANGE:fallthrough
		 		case plsqlParser.RAW:fallthrough
		 		case plsqlParser.READ:fallthrough
		 		case plsqlParser.REAL:fallthrough
		 		case plsqlParser.RECORD:fallthrough
		 		case plsqlParser.REF:fallthrough
		 		case plsqlParser.REFERENCE:fallthrough
		 		case plsqlParser.REFERENCING:fallthrough
		 		case plsqlParser.REJECT:fallthrough
		 		case plsqlParser.RELIES_ON:fallthrough
		 		case plsqlParser.RENAME:fallthrough
		 		case plsqlParser.REPLACE:fallthrough
		 		case plsqlParser.RESPECT:fallthrough
		 		case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 		case plsqlParser.RESULT:fallthrough
		 		case plsqlParser.RESULT_CACHE:fallthrough
		 		case plsqlParser.RETURN:fallthrough
		 		case plsqlParser.RETURNING:fallthrough
		 		case plsqlParser.REUSE:fallthrough
		 		case plsqlParser.REVERSE:fallthrough
		 		case plsqlParser.RIGHT:fallthrough
		 		case plsqlParser.ROLLBACK:fallthrough
		 		case plsqlParser.ROLLUP:fallthrough
		 		case plsqlParser.ROW:fallthrough
		 		case plsqlParser.ROWID:fallthrough
		 		case plsqlParser.ROWS:fallthrough
		 		case plsqlParser.RULES:fallthrough
		 		case plsqlParser.SAMPLE:fallthrough
		 		case plsqlParser.SAVE:fallthrough
		 		case plsqlParser.SAVEPOINT:fallthrough
		 		case plsqlParser.SCHEMA:fallthrough
		 		case plsqlParser.SCHEMACHECK:fallthrough
		 		case plsqlParser.SCN:fallthrough
		 		case plsqlParser.SECOND:fallthrough
		 		case plsqlParser.SEED:fallthrough
		 		case plsqlParser.SEGMENT:fallthrough
		 		case plsqlParser.SELF:fallthrough
		 		case plsqlParser.SEQUENTIAL:fallthrough
		 		case plsqlParser.SERIALIZABLE:fallthrough
		 		case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 		case plsqlParser.SERVERERROR:fallthrough
		 		case plsqlParser.SESSIONTIMEZONE:fallthrough
		 		case plsqlParser.SET:fallthrough
		 		case plsqlParser.SETS:fallthrough
		 		case plsqlParser.SETTINGS:fallthrough
		 		case plsqlParser.SHOW:fallthrough
		 		case plsqlParser.SHUTDOWN:fallthrough
		 		case plsqlParser.SIBLINGS:fallthrough
		 		case plsqlParser.SIGNTYPE:fallthrough
		 		case plsqlParser.SIMPLE_INTEGER:fallthrough
		 		case plsqlParser.SINGLE:fallthrough
		 		case plsqlParser.SKIP_:fallthrough
		 		case plsqlParser.SMALLINT:fallthrough
		 		case plsqlParser.SNAPSHOT:fallthrough
		 		case plsqlParser.SOME:fallthrough
		 		case plsqlParser.SPECIFICATION:fallthrough
		 		case plsqlParser.SQLDATA:fallthrough
		 		case plsqlParser.SQLERROR:fallthrough
		 		case plsqlParser.STANDALONE:fallthrough
		 		case plsqlParser.STARTUP:fallthrough
		 		case plsqlParser.STATEMENT:fallthrough
		 		case plsqlParser.STATEMENT_ID:fallthrough
		 		case plsqlParser.STATIC:fallthrough
		 		case plsqlParser.STATISTICS:fallthrough
		 		case plsqlParser.STRING:fallthrough
		 		case plsqlParser.SUBMULTISET:fallthrough
		 		case plsqlParser.SUBPARTITION:fallthrough
		 		case plsqlParser.SUBSTITUTABLE:fallthrough
		 		case plsqlParser.SUBTYPE:fallthrough
		 		case plsqlParser.SUCCESS:fallthrough
		 		case plsqlParser.SUSPEND:fallthrough
		 		case plsqlParser.TIME:fallthrough
		 		case plsqlParser.TIMESTAMP:fallthrough
		 		case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case plsqlParser.TIMEZONE_ABBR:fallthrough
		 		case plsqlParser.TIMEZONE_HOUR:fallthrough
		 		case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 		case plsqlParser.TIMEZONE_REGION:fallthrough
		 		case plsqlParser.TRAILING:fallthrough
		 		case plsqlParser.TRANSACTION:fallthrough
		 		case plsqlParser.TRANSLATE:fallthrough
		 		case plsqlParser.TREAT:fallthrough
		 		case plsqlParser.TRIGGER:fallthrough
		 		case plsqlParser.TRIM:fallthrough
		 		case plsqlParser.TRUNCATE:fallthrough
		 		case plsqlParser.TYPE:fallthrough
		 		case plsqlParser.UNBOUNDED:fallthrough
		 		case plsqlParser.UNDER:fallthrough
		 		case plsqlParser.UNLIMITED:fallthrough
		 		case plsqlParser.UNTIL:fallthrough
		 		case plsqlParser.UPDATED:fallthrough
		 		case plsqlParser.UPSERT:fallthrough
		 		case plsqlParser.UROWID:fallthrough
		 		case plsqlParser.USE:fallthrough
		 		case plsqlParser.VALIDATE:fallthrough
		 		case plsqlParser.VALUE:fallthrough
		 		case plsqlParser.VARCHAR:fallthrough
		 		case plsqlParser.VARCHAR2:fallthrough
		 		case plsqlParser.VARIABLE:fallthrough
		 		case plsqlParser.VARRAY:fallthrough
		 		case plsqlParser.VARYING:fallthrough
		 		case plsqlParser.VERSION:fallthrough
		 		case plsqlParser.VERSIONS:fallthrough
		 		case plsqlParser.WAIT:fallthrough
		 		case plsqlParser.WARNING:fallthrough
		 		case plsqlParser.WELLFORMED:fallthrough
		 		case plsqlParser.WHENEVER:fallthrough
		 		case plsqlParser.WHILE:fallthrough
		 		case plsqlParser.WITHIN:fallthrough
		 		case plsqlParser.WORK:fallthrough
		 		case plsqlParser.WRITE:fallthrough
		 		case plsqlParser.XML:fallthrough
		 		case plsqlParser.XMLAGG:fallthrough
		 		case plsqlParser.XMLATTRIBUTES:fallthrough
		 		case plsqlParser.XMLCAST:fallthrough
		 		case plsqlParser.XMLCOLATTVAL:fallthrough
		 		case plsqlParser.XMLELEMENT:fallthrough
		 		case plsqlParser.XMLEXISTS:fallthrough
		 		case plsqlParser.XMLFOREST:fallthrough
		 		case plsqlParser.XMLNAMESPACES:fallthrough
		 		case plsqlParser.XMLPARSE:fallthrough
		 		case plsqlParser.XMLPI:fallthrough
		 		case plsqlParser.XMLQUERY:fallthrough
		 		case plsqlParser.XMLROOT:fallthrough
		 		case plsqlParser.XMLSERIALIZE:fallthrough
		 		case plsqlParser.XMLTABLE:fallthrough
		 		case plsqlParser.YEAR:fallthrough
		 		case plsqlParser.YES:fallthrough
		 		case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case plsqlParser.ZONE:fallthrough
		 		case plsqlParser.PREDICTION:fallthrough
		 		case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 		case plsqlParser.PREDICTION_COST:fallthrough
		 		case plsqlParser.PREDICTION_DETAILS:fallthrough
		 		case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 		case plsqlParser.PREDICTION_SET:fallthrough
		 		case plsqlParser.CUME_DIST:fallthrough
		 		case plsqlParser.DENSE_RANK:fallthrough
		 		case plsqlParser.LISTAGG:fallthrough
		 		case plsqlParser.PERCENT_RANK:fallthrough
		 		case plsqlParser.PERCENTILE_CONT:fallthrough
		 		case plsqlParser.PERCENTILE_DISC:fallthrough
		 		case plsqlParser.RANK:fallthrough
		 		case plsqlParser.AVG:fallthrough
		 		case plsqlParser.CORR:fallthrough
		 		case plsqlParser.LAG:fallthrough
		 		case plsqlParser.LEAD:fallthrough
		 		case plsqlParser.MAX:fallthrough
		 		case plsqlParser.MEDIAN:fallthrough
		 		case plsqlParser.MIN:fallthrough
		 		case plsqlParser.NTILE:fallthrough
		 		case plsqlParser.RATIO_TO_REPORT:fallthrough
		 		case plsqlParser.ROW_NUMBER:fallthrough
		 		case plsqlParser.SUM:fallthrough
		 		case plsqlParser.VARIANCE:fallthrough
		 		case plsqlParser.REGR_:fallthrough
		 		case plsqlParser.STDDEV:fallthrough
		 		case plsqlParser.VAR_:fallthrough
		 		case plsqlParser.COVAR_:fallthrough
		 		case plsqlParser.DELIMITED_ID:fallthrough
		 		case plsqlParser.INTRODUCER:fallthrough
		 		case plsqlParser.REGULAR_ID:
		 			setState(5185)
		 			try general_element_part()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5188)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.DAY
		 		          testSet = testSet || _la == plsqlParser.HOUR || _la == plsqlParser.MINUTE
		 		          testSet = testSet || _la == plsqlParser.SECOND
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		} else {
		 			try consume()
		 		}
		 		setState(5202)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,683,_ctx)) {
		 		case 1:
		 			setState(5189)
		 			try match(plsqlParser.LEFT_PAREN)
		 			setState(5192)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.UNSIGNED_INTEGER:
		 				setState(5190)
		 				try match(plsqlParser.UNSIGNED_INTEGER)

		 				break
		 			case plsqlParser.BINDVAR:fallthrough
		 			case plsqlParser.COLON:
		 				setState(5191)
		 				try bind_variable()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(5199)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.COMMA
		 			      return testSet
		 			 }()) {
		 				setState(5194)
		 				try match(plsqlParser.COMMA)
		 				setState(5197)
		 				try _errHandler.sync(self)
		 				switch (try _input.LA(1)) {
		 				case plsqlParser.UNSIGNED_INTEGER:
		 					setState(5195)
		 					try match(plsqlParser.UNSIGNED_INTEGER)

		 					break
		 				case plsqlParser.BINDVAR:fallthrough
		 				case plsqlParser.COLON:
		 					setState(5196)
		 					try bind_variable()

		 					break
		 				default:
		 					throw try ANTLRException.recognition(e: NoViableAltException(self))
		 				}

		 			}

		 			setState(5201)
		 			try match(plsqlParser.RIGHT_PAREN)

		 			break
		 		default: break
		 		}
		 		setState(5219)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,687,_ctx)) {
		 		case 1:
		 			setState(5204)
		 			try match(plsqlParser.TO)
		 			setState(5217)
		 			try _errHandler.sync(self)
		 			switch (try _input.LA(1)) {
		 			case plsqlParser.DAY:
		 				setState(5205)
		 				try match(plsqlParser.DAY)

		 				break

		 			case plsqlParser.HOUR:
		 				setState(5206)
		 				try match(plsqlParser.HOUR)

		 				break

		 			case plsqlParser.MINUTE:
		 				setState(5207)
		 				try match(plsqlParser.MINUTE)

		 				break

		 			case plsqlParser.SECOND:
		 				setState(5208)
		 				try match(plsqlParser.SECOND)
		 				setState(5215)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,685,_ctx)) {
		 				case 1:
		 					setState(5209)
		 					try match(plsqlParser.LEFT_PAREN)
		 					setState(5212)
		 					try _errHandler.sync(self)
		 					switch (try _input.LA(1)) {
		 					case plsqlParser.UNSIGNED_INTEGER:
		 						setState(5210)
		 						try match(plsqlParser.UNSIGNED_INTEGER)

		 						break
		 					case plsqlParser.BINDVAR:fallthrough
		 					case plsqlParser.COLON:
		 						setState(5211)
		 						try bind_variable()

		 						break
		 					default:
		 						throw try ANTLRException.recognition(e: NoViableAltException(self))
		 					}
		 					setState(5214)
		 					try match(plsqlParser.RIGHT_PAREN)

		 					break
		 				default: break
		 				}

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case plsqlParser.UNSIGNED_INTEGER:fallthrough
		 	case plsqlParser.APPROXIMATE_NUM_LIT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5221)
		 		try numeric()

		 		break

		 	case plsqlParser.DATE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5222)
		 		try match(plsqlParser.DATE)
		 		setState(5223)
		 		try quoted_string()

		 		break
		 	case plsqlParser.NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case plsqlParser.CHAR_STRING:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5224)
		 		try quoted_string()

		 		break

		 	case plsqlParser.NULL:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5225)
		 		try match(plsqlParser.NULL)

		 		break

		 	case plsqlParser.TRUE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5226)
		 		try match(plsqlParser.TRUE)

		 		break

		 	case plsqlParser.FALSE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5227)
		 		try match(plsqlParser.FALSE)

		 		break

		 	case plsqlParser.DBTIMEZONE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5228)
		 		try match(plsqlParser.DBTIMEZONE)

		 		break

		 	case plsqlParser.SESSIONTIMEZONE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5229)
		 		try match(plsqlParser.SESSIONTIMEZONE)

		 		break

		 	case plsqlParser.MINVALUE:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5230)
		 		try match(plsqlParser.MINVALUE)

		 		break

		 	case plsqlParser.MAXVALUE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5231)
		 		try match(plsqlParser.MAXVALUE)

		 		break

		 	case plsqlParser.DEFAULT:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5232)
		 		try match(plsqlParser.DEFAULT)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NumericContext:ParserRuleContext {
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.UNSIGNED_INTEGER, 0) }
		open func APPROXIMATE_NUM_LIT() -> TerminalNode? { return getToken(plsqlParser.APPROXIMATE_NUM_LIT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric() throws -> NumericContext {
		var _localctx: NumericContext = NumericContext(_ctx, getState())
		try enterRule(_localctx, 734, plsqlParser.RULE_numeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5235)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.UNSIGNED_INTEGER || _la == plsqlParser.APPROXIMATE_NUM_LIT
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Numeric_negativeContext:ParserRuleContext {
		open func MINUS_SIGN() -> TerminalNode? { return getToken(plsqlParser.MINUS_SIGN, 0) }
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric_negative }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric_negative(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric_negative(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric_negative(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric_negative(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric_negative() throws -> Numeric_negativeContext {
		var _localctx: Numeric_negativeContext = Numeric_negativeContext(_ctx, getState())
		try enterRule(_localctx, 736, plsqlParser.RULE_numeric_negative)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5237)
		 	try match(plsqlParser.MINUS_SIGN)
		 	setState(5238)
		 	try numeric()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Quoted_stringContext:ParserRuleContext {
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.CHAR_STRING, 0) }
		open func NATIONAL_CHAR_STRING_LIT() -> TerminalNode? { return getToken(plsqlParser.NATIONAL_CHAR_STRING_LIT, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_quoted_string }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuoted_string(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuoted_string(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuoted_string(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuoted_string(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func quoted_string() throws -> Quoted_stringContext {
		var _localctx: Quoted_stringContext = Quoted_stringContext(_ctx, getState())
		try enterRule(_localctx, 738, plsqlParser.RULE_quoted_string)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5240)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.NATIONAL_CHAR_STRING_LIT || _la == plsqlParser.CHAR_STRING
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdContext:ParserRuleContext {
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.INTRODUCER, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterId(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitId(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitId(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitId(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func id() throws -> IdContext {
		var _localctx: IdContext = IdContext(_ctx, getState())
		try enterRule(_localctx, 740, plsqlParser.RULE_id)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5244)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.INTRODUCER
		 	      return testSet
		 	 }()) {
		 		setState(5242)
		 		try match(plsqlParser.INTRODUCER)
		 		setState(5243)
		 		try char_set_name()

		 	}

		 	setState(5246)
		 	try id_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Id_expressionContext:ParserRuleContext {
		open func regular_id() -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,0)
		}
		open func DELIMITED_ID() -> TerminalNode? { return getToken(plsqlParser.DELIMITED_ID, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_id_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterId_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitId_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitId_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitId_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func id_expression() throws -> Id_expressionContext {
		var _localctx: Id_expressionContext = Id_expressionContext(_ctx, getState())
		try enterRule(_localctx, 742, plsqlParser.RULE_id_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5250)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.A_LETTER:fallthrough
		 	case plsqlParser.ADD:fallthrough
		 	case plsqlParser.AFTER:fallthrough
		 	case plsqlParser.AGENT:fallthrough
		 	case plsqlParser.AGGREGATE:fallthrough
		 	case plsqlParser.ANALYZE:fallthrough
		 	case plsqlParser.ARRAY:fallthrough
		 	case plsqlParser.ASSOCIATE:fallthrough
		 	case plsqlParser.AT:fallthrough
		 	case plsqlParser.ATTRIBUTE:fallthrough
		 	case plsqlParser.AUDIT:fallthrough
		 	case plsqlParser.AUTHID:fallthrough
		 	case plsqlParser.AUTO:fallthrough
		 	case plsqlParser.AUTOMATIC:fallthrough
		 	case plsqlParser.AUTONOMOUS_TRANSACTION:fallthrough
		 	case plsqlParser.BATCH:fallthrough
		 	case plsqlParser.BEFORE:fallthrough
		 	case plsqlParser.BFILE:fallthrough
		 	case plsqlParser.BINARY_DOUBLE:fallthrough
		 	case plsqlParser.BINARY_FLOAT:fallthrough
		 	case plsqlParser.BINARY_INTEGER:fallthrough
		 	case plsqlParser.BLOB:fallthrough
		 	case plsqlParser.BLOCK:fallthrough
		 	case plsqlParser.BODY:fallthrough
		 	case plsqlParser.BOOLEAN:fallthrough
		 	case plsqlParser.BOTH:fallthrough
		 	case plsqlParser.BULK:fallthrough
		 	case plsqlParser.BYTE:fallthrough
		 	case plsqlParser.C_LETTER:fallthrough
		 	case plsqlParser.CALL:fallthrough
		 	case plsqlParser.CANONICAL:fallthrough
		 	case plsqlParser.CASCADE:fallthrough
		 	case plsqlParser.CAST:fallthrough
		 	case plsqlParser.CHAR:fallthrough
		 	case plsqlParser.CHAR_CS:fallthrough
		 	case plsqlParser.CHARACTER:fallthrough
		 	case plsqlParser.CHR:fallthrough
		 	case plsqlParser.CLOB:fallthrough
		 	case plsqlParser.CLOSE:fallthrough
		 	case plsqlParser.CLUSTER:fallthrough
		 	case plsqlParser.COLLECT:fallthrough
		 	case plsqlParser.COLUMNS:fallthrough
		 	case plsqlParser.COMMENT:fallthrough
		 	case plsqlParser.COMMIT:fallthrough
		 	case plsqlParser.COMMITTED:fallthrough
		 	case plsqlParser.COMPATIBILITY:fallthrough
		 	case plsqlParser.COMPILE:fallthrough
		 	case plsqlParser.COMPOUND:fallthrough
		 	case plsqlParser.CONSTANT:fallthrough
		 	case plsqlParser.CONSTRAINT:fallthrough
		 	case plsqlParser.CONSTRAINTS:fallthrough
		 	case plsqlParser.CONSTRUCTOR:fallthrough
		 	case plsqlParser.CONTENT:fallthrough
		 	case plsqlParser.CONTEXT:fallthrough
		 	case plsqlParser.CONTINUE:fallthrough
		 	case plsqlParser.CONVERT:fallthrough
		 	case plsqlParser.CORRUPT_XID:fallthrough
		 	case plsqlParser.CORRUPT_XID_ALL:fallthrough
		 	case plsqlParser.COST:fallthrough
		 	case plsqlParser.COUNT:fallthrough
		 	case plsqlParser.CROSS:fallthrough
		 	case plsqlParser.CUBE:fallthrough
		 	case plsqlParser.CURRENT_USER:fallthrough
		 	case plsqlParser.CURSOR:fallthrough
		 	case plsqlParser.CUSTOMDATUM:fallthrough
		 	case plsqlParser.CYCLE:fallthrough
		 	case plsqlParser.DATA:fallthrough
		 	case plsqlParser.DATABASE:fallthrough
		 	case plsqlParser.DAY:fallthrough
		 	case plsqlParser.DB_ROLE_CHANGE:fallthrough
		 	case plsqlParser.DBTIMEZONE:fallthrough
		 	case plsqlParser.DDL:fallthrough
		 	case plsqlParser.DEBUG:fallthrough
		 	case plsqlParser.DEC:fallthrough
		 	case plsqlParser.DECIMAL:fallthrough
		 	case plsqlParser.DECOMPOSE:fallthrough
		 	case plsqlParser.DECREMENT:fallthrough
		 	case plsqlParser.DEFAULTS:fallthrough
		 	case plsqlParser.DEFERRED:fallthrough
		 	case plsqlParser.DEFINER:fallthrough
		 	case plsqlParser.DETERMINISTIC:fallthrough
		 	case plsqlParser.DIMENSION:fallthrough
		 	case plsqlParser.DISABLE:fallthrough
		 	case plsqlParser.DISASSOCIATE:fallthrough
		 	case plsqlParser.DOCUMENT:fallthrough
		 	case plsqlParser.DOUBLE:fallthrough
		 	case plsqlParser.DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.EACH:fallthrough
		 	case plsqlParser.ELEMENT:fallthrough
		 	case plsqlParser.EMPTY:fallthrough
		 	case plsqlParser.ENABLE:fallthrough
		 	case plsqlParser.ENCODING:fallthrough
		 	case plsqlParser.ENTITYESCAPING:fallthrough
		 	case plsqlParser.ERR:fallthrough
		 	case plsqlParser.ERRORS:fallthrough
		 	case plsqlParser.ESCAPE:fallthrough
		 	case plsqlParser.EVALNAME:fallthrough
		 	case plsqlParser.EXCEPTION:fallthrough
		 	case plsqlParser.EXCEPTION_INIT:fallthrough
		 	case plsqlParser.EXCEPTIONS:fallthrough
		 	case plsqlParser.EXCLUDE:fallthrough
		 	case plsqlParser.EXECUTE:fallthrough
		 	case plsqlParser.EXIT:fallthrough
		 	case plsqlParser.EXPLAIN:fallthrough
		 	case plsqlParser.EXTERNAL:fallthrough
		 	case plsqlParser.EXTRACT:fallthrough
		 	case plsqlParser.FAILURE:fallthrough
		 	case plsqlParser.FINAL:fallthrough
		 	case plsqlParser.FIRST:fallthrough
		 	case plsqlParser.FIRST_VALUE:fallthrough
		 	case plsqlParser.FLOAT:fallthrough
		 	case plsqlParser.FOLLOWING:fallthrough
		 	case plsqlParser.FOLLOWS:fallthrough
		 	case plsqlParser.FORALL:fallthrough
		 	case plsqlParser.FORCE:fallthrough
		 	case plsqlParser.FULL:fallthrough
		 	case plsqlParser.FUNCTION:fallthrough
		 	case plsqlParser.GROUPING:fallthrough
		 	case plsqlParser.HASH:fallthrough
		 	case plsqlParser.HIDE:fallthrough
		 	case plsqlParser.HOUR:fallthrough
		 	case plsqlParser.IGNORE:fallthrough
		 	case plsqlParser.IMMEDIATE:fallthrough
		 	case plsqlParser.INCLUDE:fallthrough
		 	case plsqlParser.INCLUDING:fallthrough
		 	case plsqlParser.INCREMENT:fallthrough
		 	case plsqlParser.INDENT:fallthrough
		 	case plsqlParser.INDEXED:fallthrough
		 	case plsqlParser.INDICATOR:fallthrough
		 	case plsqlParser.INDICES:fallthrough
		 	case plsqlParser.INFINITE:fallthrough
		 	case plsqlParser.INLINE:fallthrough
		 	case plsqlParser.INNER:fallthrough
		 	case plsqlParser.INOUT:fallthrough
		 	case plsqlParser.INSTANTIABLE:fallthrough
		 	case plsqlParser.INSTEAD:fallthrough
		 	case plsqlParser.INT:fallthrough
		 	case plsqlParser.INTEGER:fallthrough
		 	case plsqlParser.INTERVAL:fallthrough
		 	case plsqlParser.INVALIDATE:fallthrough
		 	case plsqlParser.ISOLATION:fallthrough
		 	case plsqlParser.ITERATE:fallthrough
		 	case plsqlParser.JAVA:fallthrough
		 	case plsqlParser.JOIN:fallthrough
		 	case plsqlParser.KEEP:fallthrough
		 	case plsqlParser.LANGUAGE:fallthrough
		 	case plsqlParser.LAST:fallthrough
		 	case plsqlParser.LAST_VALUE:fallthrough
		 	case plsqlParser.LEADING:fallthrough
		 	case plsqlParser.LEFT:fallthrough
		 	case plsqlParser.LEVEL:fallthrough
		 	case plsqlParser.LIBRARY:fallthrough
		 	case plsqlParser.LIKE2:fallthrough
		 	case plsqlParser.LIKE4:fallthrough
		 	case plsqlParser.LIKEC:fallthrough
		 	case plsqlParser.LIMIT:fallthrough
		 	case plsqlParser.LOCAL:fallthrough
		 	case plsqlParser.LOCKED:fallthrough
		 	case plsqlParser.LOG:fallthrough
		 	case plsqlParser.LOGOFF:fallthrough
		 	case plsqlParser.LOGON:fallthrough
		 	case plsqlParser.LONG:fallthrough
		 	case plsqlParser.LOOP:fallthrough
		 	case plsqlParser.MAIN:fallthrough
		 	case plsqlParser.MAP:fallthrough
		 	case plsqlParser.MATCHED:fallthrough
		 	case plsqlParser.MAXVALUE:fallthrough
		 	case plsqlParser.MEASURES:fallthrough
		 	case plsqlParser.MEMBER:fallthrough
		 	case plsqlParser.MERGE:fallthrough
		 	case plsqlParser.MINUTE:fallthrough
		 	case plsqlParser.MINVALUE:fallthrough
		 	case plsqlParser.MLSLABEL:fallthrough
		 	case plsqlParser.MODEL:fallthrough
		 	case plsqlParser.MODIFY:fallthrough
		 	case plsqlParser.MONTH:fallthrough
		 	case plsqlParser.MULTISET:fallthrough
		 	case plsqlParser.NAME:fallthrough
		 	case plsqlParser.NAN:fallthrough
		 	case plsqlParser.NATURAL:fallthrough
		 	case plsqlParser.NATURALN:fallthrough
		 	case plsqlParser.NAV:fallthrough
		 	case plsqlParser.NCHAR:fallthrough
		 	case plsqlParser.NCHAR_CS:fallthrough
		 	case plsqlParser.NCLOB:fallthrough
		 	case plsqlParser.NESTED:fallthrough
		 	case plsqlParser.NEW:fallthrough
		 	case plsqlParser.NO:fallthrough
		 	case plsqlParser.NOAUDIT:fallthrough
		 	case plsqlParser.NOCOPY:fallthrough
		 	case plsqlParser.NOCYCLE:fallthrough
		 	case plsqlParser.NOENTITYESCAPING:fallthrough
		 	case plsqlParser.NONE:fallthrough
		 	case plsqlParser.NOSCHEMACHECK:fallthrough
		 	case plsqlParser.NULLS:fallthrough
		 	case plsqlParser.NUMBER:fallthrough
		 	case plsqlParser.NUMERIC:fallthrough
		 	case plsqlParser.NVARCHAR2:fallthrough
		 	case plsqlParser.OBJECT:fallthrough
		 	case plsqlParser.OFF:fallthrough
		 	case plsqlParser.OID:fallthrough
		 	case plsqlParser.OLD:fallthrough
		 	case plsqlParser.ONLY:fallthrough
		 	case plsqlParser.OPEN:fallthrough
		 	case plsqlParser.ORADATA:fallthrough
		 	case plsqlParser.ORDINALITY:fallthrough
		 	case plsqlParser.OSERROR:fallthrough
		 	case plsqlParser.OUT:fallthrough
		 	case plsqlParser.OUTER:fallthrough
		 	case plsqlParser.OVER:fallthrough
		 	case plsqlParser.OVERRIDING:fallthrough
		 	case plsqlParser.PACKAGE:fallthrough
		 	case plsqlParser.PARALLEL_ENABLE:fallthrough
		 	case plsqlParser.PARAMETERS:fallthrough
		 	case plsqlParser.PARENT:fallthrough
		 	case plsqlParser.PARTITION:fallthrough
		 	case plsqlParser.PASSING:fallthrough
		 	case plsqlParser.PATH:fallthrough
		 	case plsqlParser.PIPELINED:fallthrough
		 	case plsqlParser.PLAN:fallthrough
		 	case plsqlParser.PLS_INTEGER:fallthrough
		 	case plsqlParser.POSITIVE:fallthrough
		 	case plsqlParser.POSITIVEN:fallthrough
		 	case plsqlParser.PRAGMA:fallthrough
		 	case plsqlParser.PRECEDING:fallthrough
		 	case plsqlParser.PRECISION:fallthrough
		 	case plsqlParser.PRESENT:fallthrough
		 	case plsqlParser.RAISE:fallthrough
		 	case plsqlParser.RANGE:fallthrough
		 	case plsqlParser.RAW:fallthrough
		 	case plsqlParser.READ:fallthrough
		 	case plsqlParser.REAL:fallthrough
		 	case plsqlParser.RECORD:fallthrough
		 	case plsqlParser.REF:fallthrough
		 	case plsqlParser.REFERENCE:fallthrough
		 	case plsqlParser.REFERENCING:fallthrough
		 	case plsqlParser.REJECT:fallthrough
		 	case plsqlParser.RELIES_ON:fallthrough
		 	case plsqlParser.RENAME:fallthrough
		 	case plsqlParser.REPLACE:fallthrough
		 	case plsqlParser.RESPECT:fallthrough
		 	case plsqlParser.RESTRICT_REFERENCES:fallthrough
		 	case plsqlParser.RESULT:fallthrough
		 	case plsqlParser.RESULT_CACHE:fallthrough
		 	case plsqlParser.RETURN:fallthrough
		 	case plsqlParser.RETURNING:fallthrough
		 	case plsqlParser.REUSE:fallthrough
		 	case plsqlParser.REVERSE:fallthrough
		 	case plsqlParser.RIGHT:fallthrough
		 	case plsqlParser.ROLLBACK:fallthrough
		 	case plsqlParser.ROLLUP:fallthrough
		 	case plsqlParser.ROW:fallthrough
		 	case plsqlParser.ROWID:fallthrough
		 	case plsqlParser.ROWS:fallthrough
		 	case plsqlParser.RULES:fallthrough
		 	case plsqlParser.SAMPLE:fallthrough
		 	case plsqlParser.SAVE:fallthrough
		 	case plsqlParser.SAVEPOINT:fallthrough
		 	case plsqlParser.SCHEMA:fallthrough
		 	case plsqlParser.SCHEMACHECK:fallthrough
		 	case plsqlParser.SCN:fallthrough
		 	case plsqlParser.SECOND:fallthrough
		 	case plsqlParser.SEED:fallthrough
		 	case plsqlParser.SEGMENT:fallthrough
		 	case plsqlParser.SELF:fallthrough
		 	case plsqlParser.SEQUENTIAL:fallthrough
		 	case plsqlParser.SERIALIZABLE:fallthrough
		 	case plsqlParser.SERIALLY_REUSABLE:fallthrough
		 	case plsqlParser.SERVERERROR:fallthrough
		 	case plsqlParser.SESSIONTIMEZONE:fallthrough
		 	case plsqlParser.SET:fallthrough
		 	case plsqlParser.SETS:fallthrough
		 	case plsqlParser.SETTINGS:fallthrough
		 	case plsqlParser.SHOW:fallthrough
		 	case plsqlParser.SHUTDOWN:fallthrough
		 	case plsqlParser.SIBLINGS:fallthrough
		 	case plsqlParser.SIGNTYPE:fallthrough
		 	case plsqlParser.SIMPLE_INTEGER:fallthrough
		 	case plsqlParser.SINGLE:fallthrough
		 	case plsqlParser.SKIP_:fallthrough
		 	case plsqlParser.SMALLINT:fallthrough
		 	case plsqlParser.SNAPSHOT:fallthrough
		 	case plsqlParser.SOME:fallthrough
		 	case plsqlParser.SPECIFICATION:fallthrough
		 	case plsqlParser.SQLDATA:fallthrough
		 	case plsqlParser.SQLERROR:fallthrough
		 	case plsqlParser.STANDALONE:fallthrough
		 	case plsqlParser.STARTUP:fallthrough
		 	case plsqlParser.STATEMENT:fallthrough
		 	case plsqlParser.STATEMENT_ID:fallthrough
		 	case plsqlParser.STATIC:fallthrough
		 	case plsqlParser.STATISTICS:fallthrough
		 	case plsqlParser.STRING:fallthrough
		 	case plsqlParser.SUBMULTISET:fallthrough
		 	case plsqlParser.SUBPARTITION:fallthrough
		 	case plsqlParser.SUBSTITUTABLE:fallthrough
		 	case plsqlParser.SUBTYPE:fallthrough
		 	case plsqlParser.SUCCESS:fallthrough
		 	case plsqlParser.SUSPEND:fallthrough
		 	case plsqlParser.TIME:fallthrough
		 	case plsqlParser.TIMESTAMP:fallthrough
		 	case plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case plsqlParser.TIMEZONE_ABBR:fallthrough
		 	case plsqlParser.TIMEZONE_HOUR:fallthrough
		 	case plsqlParser.TIMEZONE_MINUTE:fallthrough
		 	case plsqlParser.TIMEZONE_REGION:fallthrough
		 	case plsqlParser.TRAILING:fallthrough
		 	case plsqlParser.TRANSACTION:fallthrough
		 	case plsqlParser.TRANSLATE:fallthrough
		 	case plsqlParser.TREAT:fallthrough
		 	case plsqlParser.TRIGGER:fallthrough
		 	case plsqlParser.TRIM:fallthrough
		 	case plsqlParser.TRUNCATE:fallthrough
		 	case plsqlParser.TYPE:fallthrough
		 	case plsqlParser.UNBOUNDED:fallthrough
		 	case plsqlParser.UNDER:fallthrough
		 	case plsqlParser.UNLIMITED:fallthrough
		 	case plsqlParser.UNTIL:fallthrough
		 	case plsqlParser.UPDATED:fallthrough
		 	case plsqlParser.UPSERT:fallthrough
		 	case plsqlParser.UROWID:fallthrough
		 	case plsqlParser.USE:fallthrough
		 	case plsqlParser.VALIDATE:fallthrough
		 	case plsqlParser.VALUE:fallthrough
		 	case plsqlParser.VARCHAR:fallthrough
		 	case plsqlParser.VARCHAR2:fallthrough
		 	case plsqlParser.VARIABLE:fallthrough
		 	case plsqlParser.VARRAY:fallthrough
		 	case plsqlParser.VARYING:fallthrough
		 	case plsqlParser.VERSION:fallthrough
		 	case plsqlParser.VERSIONS:fallthrough
		 	case plsqlParser.WAIT:fallthrough
		 	case plsqlParser.WARNING:fallthrough
		 	case plsqlParser.WELLFORMED:fallthrough
		 	case plsqlParser.WHENEVER:fallthrough
		 	case plsqlParser.WHILE:fallthrough
		 	case plsqlParser.WITHIN:fallthrough
		 	case plsqlParser.WORK:fallthrough
		 	case plsqlParser.WRITE:fallthrough
		 	case plsqlParser.XML:fallthrough
		 	case plsqlParser.XMLAGG:fallthrough
		 	case plsqlParser.XMLATTRIBUTES:fallthrough
		 	case plsqlParser.XMLCAST:fallthrough
		 	case plsqlParser.XMLCOLATTVAL:fallthrough
		 	case plsqlParser.XMLELEMENT:fallthrough
		 	case plsqlParser.XMLEXISTS:fallthrough
		 	case plsqlParser.XMLFOREST:fallthrough
		 	case plsqlParser.XMLNAMESPACES:fallthrough
		 	case plsqlParser.XMLPARSE:fallthrough
		 	case plsqlParser.XMLPI:fallthrough
		 	case plsqlParser.XMLQUERY:fallthrough
		 	case plsqlParser.XMLROOT:fallthrough
		 	case plsqlParser.XMLSERIALIZE:fallthrough
		 	case plsqlParser.XMLTABLE:fallthrough
		 	case plsqlParser.YEAR:fallthrough
		 	case plsqlParser.YES:fallthrough
		 	case plsqlParser.YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case plsqlParser.ZONE:fallthrough
		 	case plsqlParser.PREDICTION:fallthrough
		 	case plsqlParser.PREDICTION_BOUNDS:fallthrough
		 	case plsqlParser.PREDICTION_COST:fallthrough
		 	case plsqlParser.PREDICTION_DETAILS:fallthrough
		 	case plsqlParser.PREDICTION_PROBABILITY:fallthrough
		 	case plsqlParser.PREDICTION_SET:fallthrough
		 	case plsqlParser.CUME_DIST:fallthrough
		 	case plsqlParser.DENSE_RANK:fallthrough
		 	case plsqlParser.LISTAGG:fallthrough
		 	case plsqlParser.PERCENT_RANK:fallthrough
		 	case plsqlParser.PERCENTILE_CONT:fallthrough
		 	case plsqlParser.PERCENTILE_DISC:fallthrough
		 	case plsqlParser.RANK:fallthrough
		 	case plsqlParser.AVG:fallthrough
		 	case plsqlParser.CORR:fallthrough
		 	case plsqlParser.LAG:fallthrough
		 	case plsqlParser.LEAD:fallthrough
		 	case plsqlParser.MAX:fallthrough
		 	case plsqlParser.MEDIAN:fallthrough
		 	case plsqlParser.MIN:fallthrough
		 	case plsqlParser.NTILE:fallthrough
		 	case plsqlParser.RATIO_TO_REPORT:fallthrough
		 	case plsqlParser.ROW_NUMBER:fallthrough
		 	case plsqlParser.SUM:fallthrough
		 	case plsqlParser.VARIANCE:fallthrough
		 	case plsqlParser.REGR_:fallthrough
		 	case plsqlParser.STDDEV:fallthrough
		 	case plsqlParser.VAR_:fallthrough
		 	case plsqlParser.COVAR_:fallthrough
		 	case plsqlParser.REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5248)
		 		try regular_id()

		 		break

		 	case plsqlParser.DELIMITED_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5249)
		 		try match(plsqlParser.DELIMITED_ID)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Not_equal_opContext:ParserRuleContext {
		open func NOT_EQUAL_OP() -> TerminalNode? { return getToken(plsqlParser.NOT_EQUAL_OP, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_not_equal_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNot_equal_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNot_equal_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNot_equal_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNot_equal_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func not_equal_op() throws -> Not_equal_opContext {
		var _localctx: Not_equal_opContext = Not_equal_opContext(_ctx, getState())
		try enterRule(_localctx, 744, plsqlParser.RULE_not_equal_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5259)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.NOT_EQUAL_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5252)
		 		try match(plsqlParser.NOT_EQUAL_OP)

		 		break

		 	case plsqlParser.LESS_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5253)
		 		try match(plsqlParser.LESS_THAN_OP)
		 		setState(5254)
		 		try match(plsqlParser.GREATER_THAN_OP)

		 		break

		 	case plsqlParser.EXCLAMATION_OPERATOR_PART:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5255)
		 		try match(plsqlParser.EXCLAMATION_OPERATOR_PART)
		 		setState(5256)
		 		try match(plsqlParser.EQUALS_OP)

		 		break

		 	case plsqlParser.CARRET_OPERATOR_PART:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5257)
		 		try match(plsqlParser.CARRET_OPERATOR_PART)
		 		setState(5258)
		 		try match(plsqlParser.EQUALS_OP)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Greater_than_or_equals_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_greater_than_or_equals_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGreater_than_or_equals_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGreater_than_or_equals_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGreater_than_or_equals_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGreater_than_or_equals_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func greater_than_or_equals_op() throws -> Greater_than_or_equals_opContext {
		var _localctx: Greater_than_or_equals_opContext = Greater_than_or_equals_opContext(_ctx, getState())
		try enterRule(_localctx, 746, plsqlParser.RULE_greater_than_or_equals_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5264)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.GREATER_THAN_OR_EQUALS_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5261)
		 		try match(plsqlParser.GREATER_THAN_OR_EQUALS_OP)

		 		break

		 	case plsqlParser.GREATER_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5262)
		 		try match(plsqlParser.GREATER_THAN_OP)
		 		setState(5263)
		 		try match(plsqlParser.EQUALS_OP)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Less_than_or_equals_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_less_than_or_equals_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLess_than_or_equals_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLess_than_or_equals_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLess_than_or_equals_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLess_than_or_equals_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func less_than_or_equals_op() throws -> Less_than_or_equals_opContext {
		var _localctx: Less_than_or_equals_opContext = Less_than_or_equals_opContext(_ctx, getState())
		try enterRule(_localctx, 748, plsqlParser.RULE_less_than_or_equals_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5269)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.LESS_THAN_OR_EQUALS_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5266)
		 		try match(plsqlParser.LESS_THAN_OR_EQUALS_OP)

		 		break

		 	case plsqlParser.LESS_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5267)
		 		try match(plsqlParser.LESS_THAN_OP)
		 		setState(5268)
		 		try match(plsqlParser.EQUALS_OP)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Concatenation_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_concatenation_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConcatenation_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConcatenation_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConcatenation_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConcatenation_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func concatenation_op() throws -> Concatenation_opContext {
		var _localctx: Concatenation_opContext = Concatenation_opContext(_ctx, getState())
		try enterRule(_localctx, 750, plsqlParser.RULE_concatenation_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5274)
		 	try _errHandler.sync(self)
		 	switch (try _input.LA(1)) {
		 	case plsqlParser.CONCATENATION_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5271)
		 		try match(plsqlParser.CONCATENATION_OP)

		 		break

		 	case plsqlParser.VERTICAL_BAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5272)
		 		try match(plsqlParser.VERTICAL_BAR)
		 		setState(5273)
		 		try match(plsqlParser.VERTICAL_BAR)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Outer_join_signContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_outer_join_sign }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOuter_join_sign(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOuter_join_sign(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOuter_join_sign(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOuter_join_sign(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func outer_join_sign() throws -> Outer_join_signContext {
		var _localctx: Outer_join_signContext = Outer_join_signContext(_ctx, getState())
		try enterRule(_localctx, 752, plsqlParser.RULE_outer_join_sign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5276)
		 	try match(plsqlParser.LEFT_PAREN)
		 	setState(5277)
		 	try match(plsqlParser.PLUS_SIGN)
		 	setState(5278)
		 	try match(plsqlParser.RIGHT_PAREN)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Regular_idContext:ParserRuleContext {
		open func REGULAR_ID() -> TerminalNode? { return getToken(plsqlParser.REGULAR_ID, 0) }
		open func A_LETTER() -> TerminalNode? { return getToken(plsqlParser.A_LETTER, 0) }
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.ADD, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.AFTER, 0) }
		open func AGENT() -> TerminalNode? { return getToken(plsqlParser.AGENT, 0) }
		open func AGGREGATE() -> TerminalNode? { return getToken(plsqlParser.AGGREGATE, 0) }
		open func ANALYZE() -> TerminalNode? { return getToken(plsqlParser.ANALYZE, 0) }
		open func ARRAY() -> TerminalNode? { return getToken(plsqlParser.ARRAY, 0) }
		open func ASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.ASSOCIATE, 0) }
		open func AT() -> TerminalNode? { return getToken(plsqlParser.AT, 0) }
		open func ATTRIBUTE() -> TerminalNode? { return getToken(plsqlParser.ATTRIBUTE, 0) }
		open func AUDIT() -> TerminalNode? { return getToken(plsqlParser.AUDIT, 0) }
		open func AUTHID() -> TerminalNode? { return getToken(plsqlParser.AUTHID, 0) }
		open func AUTO() -> TerminalNode? { return getToken(plsqlParser.AUTO, 0) }
		open func AUTOMATIC() -> TerminalNode? { return getToken(plsqlParser.AUTOMATIC, 0) }
		open func AUTONOMOUS_TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0) }
		open func BATCH() -> TerminalNode? { return getToken(plsqlParser.BATCH, 0) }
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.BEFORE, 0) }
		open func BFILE() -> TerminalNode? { return getToken(plsqlParser.BFILE, 0) }
		open func BINARY_DOUBLE() -> TerminalNode? { return getToken(plsqlParser.BINARY_DOUBLE, 0) }
		open func BINARY_FLOAT() -> TerminalNode? { return getToken(plsqlParser.BINARY_FLOAT, 0) }
		open func BINARY_INTEGER() -> TerminalNode? { return getToken(plsqlParser.BINARY_INTEGER, 0) }
		open func BLOB() -> TerminalNode? { return getToken(plsqlParser.BLOB, 0) }
		open func BLOCK() -> TerminalNode? { return getToken(plsqlParser.BLOCK, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.BODY, 0) }
		open func BOOLEAN() -> TerminalNode? { return getToken(plsqlParser.BOOLEAN, 0) }
		open func BOTH() -> TerminalNode? { return getToken(plsqlParser.BOTH, 0) }
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.BULK, 0) }
		open func BYTE() -> TerminalNode? { return getToken(plsqlParser.BYTE, 0) }
		open func C_LETTER() -> TerminalNode? { return getToken(plsqlParser.C_LETTER, 0) }
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.CALL, 0) }
		open func CANONICAL() -> TerminalNode? { return getToken(plsqlParser.CANONICAL, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(plsqlParser.CASCADE, 0) }
		open func CAST() -> TerminalNode? { return getToken(plsqlParser.CAST, 0) }
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.CHAR, 0) }
		open func CHAR_CS() -> TerminalNode? { return getToken(plsqlParser.CHAR_CS, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(plsqlParser.CHARACTER, 0) }
		open func CHR() -> TerminalNode? { return getToken(plsqlParser.CHR, 0) }
		open func CLOB() -> TerminalNode? { return getToken(plsqlParser.CLOB, 0) }
		open func CLOSE() -> TerminalNode? { return getToken(plsqlParser.CLOSE, 0) }
		open func CLUSTER() -> TerminalNode? { return getToken(plsqlParser.CLUSTER, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.COLLECT, 0) }
		open func COLUMNS() -> TerminalNode? { return getToken(plsqlParser.COLUMNS, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.COMMENT, 0) }
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.COMMIT, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(plsqlParser.COMMITTED, 0) }
		open func COMPATIBILITY() -> TerminalNode? { return getToken(plsqlParser.COMPATIBILITY, 0) }
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.COMPILE, 0) }
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.COMPOUND, 0) }
		open func CONSTANT() -> TerminalNode? { return getToken(plsqlParser.CONSTANT, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.CONSTRAINT, 0) }
		open func CONSTRAINTS() -> TerminalNode? { return getToken(plsqlParser.CONSTRAINTS, 0) }
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.CONSTRUCTOR, 0) }
		open func CONTENT() -> TerminalNode? { return getToken(plsqlParser.CONTENT, 0) }
		open func CONTEXT() -> TerminalNode? { return getToken(plsqlParser.CONTEXT, 0) }
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.CONTINUE, 0) }
		open func CONVERT() -> TerminalNode? { return getToken(plsqlParser.CONVERT, 0) }
		open func CORRUPT_XID() -> TerminalNode? { return getToken(plsqlParser.CORRUPT_XID, 0) }
		open func CORRUPT_XID_ALL() -> TerminalNode? { return getToken(plsqlParser.CORRUPT_XID_ALL, 0) }
		open func COST() -> TerminalNode? { return getToken(plsqlParser.COST, 0) }
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.COUNT, 0) }
		open func CROSS() -> TerminalNode? { return getToken(plsqlParser.CROSS, 0) }
		open func CUBE() -> TerminalNode? { return getToken(plsqlParser.CUBE, 0) }
		open func CURRENT_USER() -> TerminalNode? { return getToken(plsqlParser.CURRENT_USER, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.CURSOR, 0) }
		open func CUSTOMDATUM() -> TerminalNode? { return getToken(plsqlParser.CUSTOMDATUM, 0) }
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.CYCLE, 0) }
		open func DATA() -> TerminalNode? { return getToken(plsqlParser.DATA, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.DATABASE, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.DAY, 0) }
		open func DB_ROLE_CHANGE() -> TerminalNode? { return getToken(plsqlParser.DB_ROLE_CHANGE, 0) }
		open func DBTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.DBTIMEZONE, 0) }
		open func DDL() -> TerminalNode? { return getToken(plsqlParser.DDL, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.DEBUG, 0) }
		open func DEC() -> TerminalNode? { return getToken(plsqlParser.DEC, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(plsqlParser.DECIMAL, 0) }
		open func DECOMPOSE() -> TerminalNode? { return getToken(plsqlParser.DECOMPOSE, 0) }
		open func DECREMENT() -> TerminalNode? { return getToken(plsqlParser.DECREMENT, 0) }
		open func DEFAULTS() -> TerminalNode? { return getToken(plsqlParser.DEFAULTS, 0) }
		open func DEFERRED() -> TerminalNode? { return getToken(plsqlParser.DEFERRED, 0) }
		open func DEFINER() -> TerminalNode? { return getToken(plsqlParser.DEFINER, 0) }
		open func DETERMINISTIC() -> TerminalNode? { return getToken(plsqlParser.DETERMINISTIC, 0) }
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.DIMENSION, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.DISABLE, 0) }
		open func DISASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.DISASSOCIATE, 0) }
		open func DOCUMENT() -> TerminalNode? { return getToken(plsqlParser.DOCUMENT, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(plsqlParser.DOUBLE, 0) }
		open func DSINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0) }
		open func EACH() -> TerminalNode? { return getToken(plsqlParser.EACH, 0) }
		open func ELEMENT() -> TerminalNode? { return getToken(plsqlParser.ELEMENT, 0) }
		open func EMPTY() -> TerminalNode? { return getToken(plsqlParser.EMPTY, 0) }
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.ENABLE, 0) }
		open func ENCODING() -> TerminalNode? { return getToken(plsqlParser.ENCODING, 0) }
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.ENTITYESCAPING, 0) }
		open func ERR() -> TerminalNode? { return getToken(plsqlParser.ERR, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.ERRORS, 0) }
		open func ESCAPE() -> TerminalNode? { return getToken(plsqlParser.ESCAPE, 0) }
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.EVALNAME, 0) }
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.EXCEPTION, 0) }
		open func EXCEPTION_INIT() -> TerminalNode? { return getToken(plsqlParser.EXCEPTION_INIT, 0) }
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.EXCEPTIONS, 0) }
		open func EXCLUDE() -> TerminalNode? { return getToken(plsqlParser.EXCLUDE, 0) }
		open func EXECUTE() -> TerminalNode? { return getToken(plsqlParser.EXECUTE, 0) }
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.EXIT, 0) }
		open func EXPLAIN() -> TerminalNode? { return getToken(plsqlParser.EXPLAIN, 0) }
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.EXTERNAL, 0) }
		open func EXTRACT() -> TerminalNode? { return getToken(plsqlParser.EXTRACT, 0) }
		open func FAILURE() -> TerminalNode? { return getToken(plsqlParser.FAILURE, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.FINAL, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.FIRST, 0) }
		open func FIRST_VALUE() -> TerminalNode? { return getToken(plsqlParser.FIRST_VALUE, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(plsqlParser.FLOAT, 0) }
		open func FOLLOWING() -> TerminalNode? { return getToken(plsqlParser.FOLLOWING, 0) }
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.FOLLOWS, 0) }
		open func FORALL() -> TerminalNode? { return getToken(plsqlParser.FORALL, 0) }
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.FORCE, 0) }
		open func FULL() -> TerminalNode? { return getToken(plsqlParser.FULL, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.FUNCTION, 0) }
		open func GROUPING() -> TerminalNode? { return getToken(plsqlParser.GROUPING, 0) }
		open func HASH() -> TerminalNode? { return getToken(plsqlParser.HASH, 0) }
		open func HIDE() -> TerminalNode? { return getToken(plsqlParser.HIDE, 0) }
		open func HOUR() -> TerminalNode? { return getToken(plsqlParser.HOUR, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.IGNORE, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.IMMEDIATE, 0) }
		open func INCLUDE() -> TerminalNode? { return getToken(plsqlParser.INCLUDE, 0) }
		open func INCLUDING() -> TerminalNode? { return getToken(plsqlParser.INCLUDING, 0) }
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.INCREMENT, 0) }
		open func INDENT() -> TerminalNode? { return getToken(plsqlParser.INDENT, 0) }
		open func INDEXED() -> TerminalNode? { return getToken(plsqlParser.INDEXED, 0) }
		open func INDICATOR() -> TerminalNode? { return getToken(plsqlParser.INDICATOR, 0) }
		open func INDICES() -> TerminalNode? { return getToken(plsqlParser.INDICES, 0) }
		open func INFINITE() -> TerminalNode? { return getToken(plsqlParser.INFINITE, 0) }
		open func INLINE() -> TerminalNode? { return getToken(plsqlParser.INLINE, 0) }
		open func INNER() -> TerminalNode? { return getToken(plsqlParser.INNER, 0) }
		open func INOUT() -> TerminalNode? { return getToken(plsqlParser.INOUT, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.INSTANTIABLE, 0) }
		open func INSTEAD() -> TerminalNode? { return getToken(plsqlParser.INSTEAD, 0) }
		open func INT() -> TerminalNode? { return getToken(plsqlParser.INT, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(plsqlParser.INTEGER, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.INTERVAL, 0) }
		open func INVALIDATE() -> TerminalNode? { return getToken(plsqlParser.INVALIDATE, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(plsqlParser.ISOLATION, 0) }
		open func ITERATE() -> TerminalNode? { return getToken(plsqlParser.ITERATE, 0) }
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.JAVA, 0) }
		open func JOIN() -> TerminalNode? { return getToken(plsqlParser.JOIN, 0) }
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.KEEP, 0) }
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.LANGUAGE, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.LAST, 0) }
		open func LAST_VALUE() -> TerminalNode? { return getToken(plsqlParser.LAST_VALUE, 0) }
		open func LEADING() -> TerminalNode? { return getToken(plsqlParser.LEADING, 0) }
		open func LEFT() -> TerminalNode? { return getToken(plsqlParser.LEFT, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(plsqlParser.LEVEL, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(plsqlParser.LIBRARY, 0) }
		open func LIKE2() -> TerminalNode? { return getToken(plsqlParser.LIKE2, 0) }
		open func LIKE4() -> TerminalNode? { return getToken(plsqlParser.LIKE4, 0) }
		open func LIKEC() -> TerminalNode? { return getToken(plsqlParser.LIKEC, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.LIMIT, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.LOCAL, 0) }
		open func LOCKED() -> TerminalNode? { return getToken(plsqlParser.LOCKED, 0) }
		open func LOG() -> TerminalNode? { return getToken(plsqlParser.LOG, 0) }
		open func LOGOFF() -> TerminalNode? { return getToken(plsqlParser.LOGOFF, 0) }
		open func LOGON() -> TerminalNode? { return getToken(plsqlParser.LOGON, 0) }
		open func LONG() -> TerminalNode? { return getToken(plsqlParser.LONG, 0) }
		open func LOOP() -> TerminalNode? { return getToken(plsqlParser.LOOP, 0) }
		open func MAIN() -> TerminalNode? { return getToken(plsqlParser.MAIN, 0) }
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.MAP, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.MATCHED, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.MAXVALUE, 0) }
		open func MEASURES() -> TerminalNode? { return getToken(plsqlParser.MEASURES, 0) }
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.MEMBER, 0) }
		open func MERGE() -> TerminalNode? { return getToken(plsqlParser.MERGE, 0) }
		open func MINUTE() -> TerminalNode? { return getToken(plsqlParser.MINUTE, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.MINVALUE, 0) }
		open func MLSLABEL() -> TerminalNode? { return getToken(plsqlParser.MLSLABEL, 0) }
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.MODEL, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.MODIFY, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.MONTH, 0) }
		open func MULTISET() -> TerminalNode? { return getToken(plsqlParser.MULTISET, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.NAME, 0) }
		open func NAN() -> TerminalNode? { return getToken(plsqlParser.NAN, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.NATURAL, 0) }
		open func NATURALN() -> TerminalNode? { return getToken(plsqlParser.NATURALN, 0) }
		open func NAV() -> TerminalNode? { return getToken(plsqlParser.NAV, 0) }
		open func NCHAR() -> TerminalNode? { return getToken(plsqlParser.NCHAR, 0) }
		open func NCHAR_CS() -> TerminalNode? { return getToken(plsqlParser.NCHAR_CS, 0) }
		open func NCLOB() -> TerminalNode? { return getToken(plsqlParser.NCLOB, 0) }
		open func NESTED() -> TerminalNode? { return getToken(plsqlParser.NESTED, 0) }
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.NEW, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.NO, 0) }
		open func NOAUDIT() -> TerminalNode? { return getToken(plsqlParser.NOAUDIT, 0) }
		open func NOCOPY() -> TerminalNode? { return getToken(plsqlParser.NOCOPY, 0) }
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.NOCYCLE, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.NOENTITYESCAPING, 0) }
		open func NONE() -> TerminalNode? { return getToken(plsqlParser.NONE, 0) }
		open func NOSCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.NOSCHEMACHECK, 0) }
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.NULLS, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(plsqlParser.NUMBER, 0) }
		open func NUMERIC() -> TerminalNode? { return getToken(plsqlParser.NUMERIC, 0) }
		open func NVARCHAR2() -> TerminalNode? { return getToken(plsqlParser.NVARCHAR2, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.OBJECT, 0) }
		open func OFF() -> TerminalNode? { return getToken(plsqlParser.OFF, 0) }
		open func OID() -> TerminalNode? { return getToken(plsqlParser.OID, 0) }
		open func OLD() -> TerminalNode? { return getToken(plsqlParser.OLD, 0) }
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.ONLY, 0) }
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.OPEN, 0) }
		open func ORADATA() -> TerminalNode? { return getToken(plsqlParser.ORADATA, 0) }
		open func ORDINALITY() -> TerminalNode? { return getToken(plsqlParser.ORDINALITY, 0) }
		open func OSERROR() -> TerminalNode? { return getToken(plsqlParser.OSERROR, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.OUT, 0) }
		open func OUTER() -> TerminalNode? { return getToken(plsqlParser.OUTER, 0) }
		open func OVER() -> TerminalNode? { return getToken(plsqlParser.OVER, 0) }
		open func OVERRIDING() -> TerminalNode? { return getToken(plsqlParser.OVERRIDING, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.PACKAGE, 0) }
		open func PARALLEL_ENABLE() -> TerminalNode? { return getToken(plsqlParser.PARALLEL_ENABLE, 0) }
		open func PARAMETERS() -> TerminalNode? { return getToken(plsqlParser.PARAMETERS, 0) }
		open func PARENT() -> TerminalNode? { return getToken(plsqlParser.PARENT, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.PARTITION, 0) }
		open func PASSING() -> TerminalNode? { return getToken(plsqlParser.PASSING, 0) }
		open func PATH() -> TerminalNode? { return getToken(plsqlParser.PATH, 0) }
		open func PIPELINED() -> TerminalNode? { return getToken(plsqlParser.PIPELINED, 0) }
		open func PLAN() -> TerminalNode? { return getToken(plsqlParser.PLAN, 0) }
		open func PLS_INTEGER() -> TerminalNode? { return getToken(plsqlParser.PLS_INTEGER, 0) }
		open func POSITIVE() -> TerminalNode? { return getToken(plsqlParser.POSITIVE, 0) }
		open func POSITIVEN() -> TerminalNode? { return getToken(plsqlParser.POSITIVEN, 0) }
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.PRAGMA, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(plsqlParser.PRECEDING, 0) }
		open func PRECISION() -> TerminalNode? { return getToken(plsqlParser.PRECISION, 0) }
		open func PRESENT() -> TerminalNode? { return getToken(plsqlParser.PRESENT, 0) }
		open func RAISE() -> TerminalNode? { return getToken(plsqlParser.RAISE, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.RANGE, 0) }
		open func RAW() -> TerminalNode? { return getToken(plsqlParser.RAW, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.READ, 0) }
		open func REAL() -> TerminalNode? { return getToken(plsqlParser.REAL, 0) }
		open func RECORD() -> TerminalNode? { return getToken(plsqlParser.RECORD, 0) }
		open func REF() -> TerminalNode? { return getToken(plsqlParser.REF, 0) }
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.REFERENCE, 0) }
		open func REFERENCING() -> TerminalNode? { return getToken(plsqlParser.REFERENCING, 0) }
		open func REJECT() -> TerminalNode? { return getToken(plsqlParser.REJECT, 0) }
		open func RELIES_ON() -> TerminalNode? { return getToken(plsqlParser.RELIES_ON, 0) }
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.RENAME, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.REPLACE, 0) }
		open func RESPECT() -> TerminalNode? { return getToken(plsqlParser.RESPECT, 0) }
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.RESTRICT_REFERENCES, 0) }
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.RESULT, 0) }
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.RESULT_CACHE, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.RETURN, 0) }
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.RETURNING, 0) }
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.REUSE, 0) }
		open func REVERSE() -> TerminalNode? { return getToken(plsqlParser.REVERSE, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(plsqlParser.RIGHT, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.ROLLBACK, 0) }
		open func ROLLUP() -> TerminalNode? { return getToken(plsqlParser.ROLLUP, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.ROW, 0) }
		open func ROWID() -> TerminalNode? { return getToken(plsqlParser.ROWID, 0) }
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.ROWS, 0) }
		open func RULES() -> TerminalNode? { return getToken(plsqlParser.RULES, 0) }
		open func SAMPLE() -> TerminalNode? { return getToken(plsqlParser.SAMPLE, 0) }
		open func SAVE() -> TerminalNode? { return getToken(plsqlParser.SAVE, 0) }
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.SAVEPOINT, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.SCHEMA, 0) }
		open func SCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.SCHEMACHECK, 0) }
		open func SCN() -> TerminalNode? { return getToken(plsqlParser.SCN, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.SECOND, 0) }
		open func SEED() -> TerminalNode? { return getToken(plsqlParser.SEED, 0) }
		open func SEGMENT() -> TerminalNode? { return getToken(plsqlParser.SEGMENT, 0) }
		open func SELF() -> TerminalNode? { return getToken(plsqlParser.SELF, 0) }
		open func SEQUENTIAL() -> TerminalNode? { return getToken(plsqlParser.SEQUENTIAL, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(plsqlParser.SERIALIZABLE, 0) }
		open func SERIALLY_REUSABLE() -> TerminalNode? { return getToken(plsqlParser.SERIALLY_REUSABLE, 0) }
		open func SERVERERROR() -> TerminalNode? { return getToken(plsqlParser.SERVERERROR, 0) }
		open func SESSIONTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.SESSIONTIMEZONE, 0) }
		open func SET() -> TerminalNode? { return getToken(plsqlParser.SET, 0) }
		open func SETS() -> TerminalNode? { return getToken(plsqlParser.SETS, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.SETTINGS, 0) }
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.SHOW, 0) }
		open func SHUTDOWN() -> TerminalNode? { return getToken(plsqlParser.SHUTDOWN, 0) }
		open func SIBLINGS() -> TerminalNode? { return getToken(plsqlParser.SIBLINGS, 0) }
		open func SIGNTYPE() -> TerminalNode? { return getToken(plsqlParser.SIGNTYPE, 0) }
		open func SIMPLE_INTEGER() -> TerminalNode? { return getToken(plsqlParser.SIMPLE_INTEGER, 0) }
		open func SINGLE() -> TerminalNode? { return getToken(plsqlParser.SINGLE, 0) }
		open func SKIP_() -> TerminalNode? { return getToken(plsqlParser.SKIP_, 0) }
		open func SMALLINT() -> TerminalNode? { return getToken(plsqlParser.SMALLINT, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(plsqlParser.SNAPSHOT, 0) }
		open func SOME() -> TerminalNode? { return getToken(plsqlParser.SOME, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.SPECIFICATION, 0) }
		open func SQLDATA() -> TerminalNode? { return getToken(plsqlParser.SQLDATA, 0) }
		open func SQLERROR() -> TerminalNode? { return getToken(plsqlParser.SQLERROR, 0) }
		open func STANDALONE() -> TerminalNode? { return getToken(plsqlParser.STANDALONE, 0) }
		open func STARTUP() -> TerminalNode? { return getToken(plsqlParser.STARTUP, 0) }
		open func STATEMENT() -> TerminalNode? { return getToken(plsqlParser.STATEMENT, 0) }
		open func STATEMENT_ID() -> TerminalNode? { return getToken(plsqlParser.STATEMENT_ID, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.STATIC, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(plsqlParser.STATISTICS, 0) }
		open func STRING() -> TerminalNode? { return getToken(plsqlParser.STRING, 0) }
		open func SUBMULTISET() -> TerminalNode? { return getToken(plsqlParser.SUBMULTISET, 0) }
		open func SUBPARTITION() -> TerminalNode? { return getToken(plsqlParser.SUBPARTITION, 0) }
		open func SUBSTITUTABLE() -> TerminalNode? { return getToken(plsqlParser.SUBSTITUTABLE, 0) }
		open func SUBTYPE() -> TerminalNode? { return getToken(plsqlParser.SUBTYPE, 0) }
		open func SUCCESS() -> TerminalNode? { return getToken(plsqlParser.SUCCESS, 0) }
		open func SUSPEND() -> TerminalNode? { return getToken(plsqlParser.SUSPEND, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.TIME, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP, 0) }
		open func TIMESTAMP_LTZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0) }
		open func TIMESTAMP_TZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0) }
		open func TIMESTAMP_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0) }
		open func TIMEZONE_ABBR() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_ABBR, 0) }
		open func TIMEZONE_HOUR() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_HOUR, 0) }
		open func TIMEZONE_MINUTE() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_MINUTE, 0) }
		open func TIMEZONE_REGION() -> TerminalNode? { return getToken(plsqlParser.TIMEZONE_REGION, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(plsqlParser.TRAILING, 0) }
		open func TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.TRANSACTION, 0) }
		open func TRANSLATE() -> TerminalNode? { return getToken(plsqlParser.TRANSLATE, 0) }
		open func TREAT() -> TerminalNode? { return getToken(plsqlParser.TREAT, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.TRIGGER, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.TRIM, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.TRUNCATE, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.TYPE, 0) }
		open func UNBOUNDED() -> TerminalNode? { return getToken(plsqlParser.UNBOUNDED, 0) }
		open func UNDER() -> TerminalNode? { return getToken(plsqlParser.UNDER, 0) }
		open func UNLIMITED() -> TerminalNode? { return getToken(plsqlParser.UNLIMITED, 0) }
		open func UNTIL() -> TerminalNode? { return getToken(plsqlParser.UNTIL, 0) }
		open func UPDATED() -> TerminalNode? { return getToken(plsqlParser.UPDATED, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.UPSERT, 0) }
		open func UROWID() -> TerminalNode? { return getToken(plsqlParser.UROWID, 0) }
		open func USE() -> TerminalNode? { return getToken(plsqlParser.USE, 0) }
		open func VALIDATE() -> TerminalNode? { return getToken(plsqlParser.VALIDATE, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.VALUE, 0) }
		open func VARCHAR() -> TerminalNode? { return getToken(plsqlParser.VARCHAR, 0) }
		open func VARCHAR2() -> TerminalNode? { return getToken(plsqlParser.VARCHAR2, 0) }
		open func VARIABLE() -> TerminalNode? { return getToken(plsqlParser.VARIABLE, 0) }
		open func VARRAY() -> TerminalNode? { return getToken(plsqlParser.VARRAY, 0) }
		open func VARYING() -> TerminalNode? { return getToken(plsqlParser.VARYING, 0) }
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.VERSION, 0) }
		open func VERSIONS() -> TerminalNode? { return getToken(plsqlParser.VERSIONS, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.WAIT, 0) }
		open func WARNING() -> TerminalNode? { return getToken(plsqlParser.WARNING, 0) }
		open func WELLFORMED() -> TerminalNode? { return getToken(plsqlParser.WELLFORMED, 0) }
		open func WHENEVER() -> TerminalNode? { return getToken(plsqlParser.WHENEVER, 0) }
		open func WHILE() -> TerminalNode? { return getToken(plsqlParser.WHILE, 0) }
		open func WITHIN() -> TerminalNode? { return getToken(plsqlParser.WITHIN, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.WORK, 0) }
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.WRITE, 0) }
		open func XML() -> TerminalNode? { return getToken(plsqlParser.XML, 0) }
		open func XMLAGG() -> TerminalNode? { return getToken(plsqlParser.XMLAGG, 0) }
		open func XMLATTRIBUTES() -> TerminalNode? { return getToken(plsqlParser.XMLATTRIBUTES, 0) }
		open func XMLCAST() -> TerminalNode? { return getToken(plsqlParser.XMLCAST, 0) }
		open func XMLCOLATTVAL() -> TerminalNode? { return getToken(plsqlParser.XMLCOLATTVAL, 0) }
		open func XMLELEMENT() -> TerminalNode? { return getToken(plsqlParser.XMLELEMENT, 0) }
		open func XMLEXISTS() -> TerminalNode? { return getToken(plsqlParser.XMLEXISTS, 0) }
		open func XMLFOREST() -> TerminalNode? { return getToken(plsqlParser.XMLFOREST, 0) }
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(plsqlParser.XMLNAMESPACES, 0) }
		open func XMLPARSE() -> TerminalNode? { return getToken(plsqlParser.XMLPARSE, 0) }
		open func XMLPI() -> TerminalNode? { return getToken(plsqlParser.XMLPI, 0) }
		open func XMLQUERY() -> TerminalNode? { return getToken(plsqlParser.XMLQUERY, 0) }
		open func XMLROOT() -> TerminalNode? { return getToken(plsqlParser.XMLROOT, 0) }
		open func XMLSERIALIZE() -> TerminalNode? { return getToken(plsqlParser.XMLSERIALIZE, 0) }
		open func XMLTABLE() -> TerminalNode? { return getToken(plsqlParser.XMLTABLE, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.YEAR, 0) }
		open func YES() -> TerminalNode? { return getToken(plsqlParser.YES, 0) }
		open func YMINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.ZONE, 0) }
		open func PREDICTION() -> TerminalNode? { return getToken(plsqlParser.PREDICTION, 0) }
		open func PREDICTION_BOUNDS() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_BOUNDS, 0) }
		open func PREDICTION_COST() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_COST, 0) }
		open func PREDICTION_DETAILS() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_DETAILS, 0) }
		open func PREDICTION_PROBABILITY() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_PROBABILITY, 0) }
		open func PREDICTION_SET() -> TerminalNode? { return getToken(plsqlParser.PREDICTION_SET, 0) }
		open func CUME_DIST() -> TerminalNode? { return getToken(plsqlParser.CUME_DIST, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.DENSE_RANK, 0) }
		open func LISTAGG() -> TerminalNode? { return getToken(plsqlParser.LISTAGG, 0) }
		open func PERCENT_RANK() -> TerminalNode? { return getToken(plsqlParser.PERCENT_RANK, 0) }
		open func PERCENTILE_CONT() -> TerminalNode? { return getToken(plsqlParser.PERCENTILE_CONT, 0) }
		open func PERCENTILE_DISC() -> TerminalNode? { return getToken(plsqlParser.PERCENTILE_DISC, 0) }
		open func RANK() -> TerminalNode? { return getToken(plsqlParser.RANK, 0) }
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.AVG, 0) }
		open func CORR() -> TerminalNode? { return getToken(plsqlParser.CORR, 0) }
		open func LAG() -> TerminalNode? { return getToken(plsqlParser.LAG, 0) }
		open func LEAD() -> TerminalNode? { return getToken(plsqlParser.LEAD, 0) }
		open func MAX() -> TerminalNode? { return getToken(plsqlParser.MAX, 0) }
		open func MEDIAN() -> TerminalNode? { return getToken(plsqlParser.MEDIAN, 0) }
		open func MIN() -> TerminalNode? { return getToken(plsqlParser.MIN, 0) }
		open func NTILE() -> TerminalNode? { return getToken(plsqlParser.NTILE, 0) }
		open func RATIO_TO_REPORT() -> TerminalNode? { return getToken(plsqlParser.RATIO_TO_REPORT, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(plsqlParser.ROW_NUMBER, 0) }
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.SUM, 0) }
		open func VARIANCE() -> TerminalNode? { return getToken(plsqlParser.VARIANCE, 0) }
		open func REGR_() -> TerminalNode? { return getToken(plsqlParser.REGR_, 0) }
		open func STDDEV() -> TerminalNode? { return getToken(plsqlParser.STDDEV, 0) }
		open func VAR_() -> TerminalNode? { return getToken(plsqlParser.VAR_, 0) }
		open func COVAR_() -> TerminalNode? { return getToken(plsqlParser.COVAR_, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_regular_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRegular_id(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRegular_id(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRegular_id(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRegular_id(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func regular_id() throws -> Regular_idContext {
		var _localctx: Regular_idContext = Regular_idContext(_ctx, getState())
		try enterRule(_localctx, 754, plsqlParser.RULE_regular_id)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5280)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.A_LETTER,plsqlParser.ADD,plsqlParser.AFTER,plsqlParser.AGENT,plsqlParser.AGGREGATE,plsqlParser.ANALYZE,plsqlParser.ARRAY,plsqlParser.ASSOCIATE,plsqlParser.AT,plsqlParser.ATTRIBUTE,plsqlParser.AUDIT,plsqlParser.AUTHID,plsqlParser.AUTO,plsqlParser.AUTOMATIC,plsqlParser.AUTONOMOUS_TRANSACTION,plsqlParser.BATCH,plsqlParser.BEFORE,plsqlParser.BFILE,plsqlParser.BINARY_DOUBLE,plsqlParser.BINARY_FLOAT,plsqlParser.BINARY_INTEGER,plsqlParser.BLOB,plsqlParser.BLOCK,plsqlParser.BODY,plsqlParser.BOOLEAN,plsqlParser.BOTH,plsqlParser.BULK,plsqlParser.BYTE,plsqlParser.C_LETTER,plsqlParser.CALL,plsqlParser.CANONICAL,plsqlParser.CASCADE,plsqlParser.CAST,plsqlParser.CHAR,plsqlParser.CHAR_CS,plsqlParser.CHARACTER,plsqlParser.CHR,plsqlParser.CLOB,plsqlParser.CLOSE,plsqlParser.CLUSTER,plsqlParser.COLLECT,plsqlParser.COLUMNS,plsqlParser.COMMENT,plsqlParser.COMMIT,plsqlParser.COMMITTED,plsqlParser.COMPATIBILITY,plsqlParser.COMPILE,plsqlParser.COMPOUND]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.CONSTANT,plsqlParser.CONSTRAINT,plsqlParser.CONSTRAINTS,plsqlParser.CONSTRUCTOR,plsqlParser.CONTENT,plsqlParser.CONTEXT,plsqlParser.CONTINUE,plsqlParser.CONVERT,plsqlParser.CORRUPT_XID,plsqlParser.CORRUPT_XID_ALL,plsqlParser.COST,plsqlParser.COUNT,plsqlParser.CROSS,plsqlParser.CUBE,plsqlParser.CURRENT_USER,plsqlParser.CURSOR,plsqlParser.CUSTOMDATUM,plsqlParser.CYCLE,plsqlParser.DATA,plsqlParser.DATABASE,plsqlParser.DAY,plsqlParser.DB_ROLE_CHANGE,plsqlParser.DBTIMEZONE,plsqlParser.DDL,plsqlParser.DEBUG,plsqlParser.DEC,plsqlParser.DECIMAL,plsqlParser.DECOMPOSE,plsqlParser.DECREMENT,plsqlParser.DEFAULTS,plsqlParser.DEFERRED,plsqlParser.DEFINER,plsqlParser.DETERMINISTIC,plsqlParser.DIMENSION,plsqlParser.DISABLE,plsqlParser.DISASSOCIATE,plsqlParser.DOCUMENT,plsqlParser.DOUBLE,plsqlParser.DSINTERVAL_UNCONSTRAINED,plsqlParser.EACH,plsqlParser.ELEMENT,plsqlParser.EMPTY,plsqlParser.ENABLE,plsqlParser.ENCODING,plsqlParser.ENTITYESCAPING,plsqlParser.ERR,plsqlParser.ERRORS,plsqlParser.ESCAPE,plsqlParser.EVALNAME,plsqlParser.EXCEPTION,plsqlParser.EXCEPTION_INIT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.EXCEPTIONS,plsqlParser.EXCLUDE,plsqlParser.EXECUTE,plsqlParser.EXIT,plsqlParser.EXPLAIN,plsqlParser.EXTERNAL,plsqlParser.EXTRACT,plsqlParser.FAILURE,plsqlParser.FINAL,plsqlParser.FIRST,plsqlParser.FIRST_VALUE,plsqlParser.FLOAT,plsqlParser.FOLLOWING,plsqlParser.FOLLOWS,plsqlParser.FORALL,plsqlParser.FORCE,plsqlParser.FULL,plsqlParser.FUNCTION,plsqlParser.GROUPING,plsqlParser.HASH,plsqlParser.HIDE,plsqlParser.HOUR,plsqlParser.IGNORE,plsqlParser.IMMEDIATE,plsqlParser.INCLUDE,plsqlParser.INCLUDING,plsqlParser.INCREMENT,plsqlParser.INDENT,plsqlParser.INDEXED,plsqlParser.INDICATOR,plsqlParser.INDICES,plsqlParser.INFINITE,plsqlParser.INLINE,plsqlParser.INNER,plsqlParser.INOUT,plsqlParser.INSTANTIABLE,plsqlParser.INSTEAD,plsqlParser.INT,plsqlParser.INTEGER,plsqlParser.INTERVAL,plsqlParser.INVALIDATE,plsqlParser.ISOLATION,plsqlParser.ITERATE,plsqlParser.JAVA,plsqlParser.JOIN,plsqlParser.KEEP,plsqlParser.LANGUAGE]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.LAST,plsqlParser.LAST_VALUE,plsqlParser.LEADING,plsqlParser.LEFT,plsqlParser.LEVEL,plsqlParser.LIBRARY,plsqlParser.LIKE2,plsqlParser.LIKE4,plsqlParser.LIKEC,plsqlParser.LIMIT,plsqlParser.LOCAL,plsqlParser.LOCKED,plsqlParser.LOG,plsqlParser.LOGOFF,plsqlParser.LOGON,plsqlParser.LONG,plsqlParser.LOOP,plsqlParser.MAIN,plsqlParser.MAP,plsqlParser.MATCHED,plsqlParser.MAXVALUE,plsqlParser.MEASURES,plsqlParser.MEMBER,plsqlParser.MERGE,plsqlParser.MINUTE,plsqlParser.MINVALUE,plsqlParser.MLSLABEL,plsqlParser.MODEL,plsqlParser.MODIFY,plsqlParser.MONTH,plsqlParser.MULTISET,plsqlParser.NAME,plsqlParser.NAN,plsqlParser.NATURAL,plsqlParser.NATURALN,plsqlParser.NAV,plsqlParser.NCHAR,plsqlParser.NCHAR_CS,plsqlParser.NCLOB,plsqlParser.NESTED,plsqlParser.NEW,plsqlParser.NO,plsqlParser.NOAUDIT,plsqlParser.NOCOPY,plsqlParser.NOCYCLE,plsqlParser.NOENTITYESCAPING,plsqlParser.NONE,plsqlParser.NOSCHEMACHECK,plsqlParser.NULLS,plsqlParser.NUMBER,plsqlParser.NUMERIC,plsqlParser.NVARCHAR2,plsqlParser.OBJECT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.OFF,plsqlParser.OID,plsqlParser.OLD,plsqlParser.ONLY,plsqlParser.OPEN,plsqlParser.ORADATA,plsqlParser.ORDINALITY,plsqlParser.OSERROR,plsqlParser.OUT,plsqlParser.OUTER,plsqlParser.OVER,plsqlParser.OVERRIDING,plsqlParser.PACKAGE,plsqlParser.PARALLEL_ENABLE,plsqlParser.PARAMETERS,plsqlParser.PARENT,plsqlParser.PARTITION,plsqlParser.PASSING,plsqlParser.PATH,plsqlParser.PIPELINED,plsqlParser.PLAN,plsqlParser.PLS_INTEGER,plsqlParser.POSITIVE,plsqlParser.POSITIVEN,plsqlParser.PRAGMA,plsqlParser.PRECEDING,plsqlParser.PRECISION,plsqlParser.PRESENT,plsqlParser.RAISE,plsqlParser.RANGE,plsqlParser.RAW,plsqlParser.READ,plsqlParser.REAL,plsqlParser.RECORD,plsqlParser.REF,plsqlParser.REFERENCE,plsqlParser.REFERENCING,plsqlParser.REJECT,plsqlParser.RELIES_ON,plsqlParser.RENAME,plsqlParser.REPLACE,plsqlParser.RESPECT,plsqlParser.RESTRICT_REFERENCES,plsqlParser.RESULT,plsqlParser.RESULT_CACHE,plsqlParser.RETURN,plsqlParser.RETURNING,plsqlParser.REUSE,plsqlParser.REVERSE,plsqlParser.RIGHT]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.ROLLBACK,plsqlParser.ROLLUP,plsqlParser.ROW,plsqlParser.ROWID,plsqlParser.ROWS,plsqlParser.RULES,plsqlParser.SAMPLE,plsqlParser.SAVE,plsqlParser.SAVEPOINT,plsqlParser.SCHEMA,plsqlParser.SCHEMACHECK,plsqlParser.SCN,plsqlParser.SECOND,plsqlParser.SEED,plsqlParser.SEGMENT,plsqlParser.SELF,plsqlParser.SEQUENTIAL,plsqlParser.SERIALIZABLE,plsqlParser.SERIALLY_REUSABLE,plsqlParser.SERVERERROR,plsqlParser.SESSIONTIMEZONE,plsqlParser.SET,plsqlParser.SETS,plsqlParser.SETTINGS,plsqlParser.SHOW,plsqlParser.SHUTDOWN,plsqlParser.SIBLINGS,plsqlParser.SIGNTYPE,plsqlParser.SIMPLE_INTEGER,plsqlParser.SINGLE,plsqlParser.SKIP_,plsqlParser.SMALLINT,plsqlParser.SNAPSHOT,plsqlParser.SOME,plsqlParser.SPECIFICATION,plsqlParser.SQLDATA,plsqlParser.SQLERROR,plsqlParser.STANDALONE,plsqlParser.STARTUP,plsqlParser.STATEMENT,plsqlParser.STATEMENT_ID,plsqlParser.STATIC,plsqlParser.STATISTICS,plsqlParser.STRING,plsqlParser.SUBMULTISET,plsqlParser.SUBPARTITION,plsqlParser.SUBSTITUTABLE,plsqlParser.SUBTYPE,plsqlParser.SUCCESS,plsqlParser.SUSPEND,plsqlParser.TIME,plsqlParser.TIMESTAMP,plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED,plsqlParser.TIMESTAMP_UNCONSTRAINED]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.TIMEZONE_ABBR,plsqlParser.TIMEZONE_HOUR,plsqlParser.TIMEZONE_MINUTE,plsqlParser.TIMEZONE_REGION,plsqlParser.TRAILING,plsqlParser.TRANSACTION,plsqlParser.TRANSLATE,plsqlParser.TREAT,plsqlParser.TRIGGER,plsqlParser.TRIM,plsqlParser.TRUNCATE,plsqlParser.TYPE,plsqlParser.UNBOUNDED,plsqlParser.UNDER,plsqlParser.UNLIMITED,plsqlParser.UNTIL,plsqlParser.UPDATED,plsqlParser.UPSERT,plsqlParser.UROWID,plsqlParser.USE,plsqlParser.VALIDATE,plsqlParser.VALUE,plsqlParser.VARCHAR,plsqlParser.VARCHAR2,plsqlParser.VARIABLE,plsqlParser.VARRAY,plsqlParser.VARYING,plsqlParser.VERSION,plsqlParser.VERSIONS,plsqlParser.WAIT,plsqlParser.WARNING,plsqlParser.WELLFORMED,plsqlParser.WHENEVER,plsqlParser.WHILE,plsqlParser.WITHIN,plsqlParser.WORK,plsqlParser.WRITE,plsqlParser.XML,plsqlParser.XMLAGG,plsqlParser.XMLATTRIBUTES,plsqlParser.XMLCAST,plsqlParser.XMLCOLATTVAL,plsqlParser.XMLELEMENT,plsqlParser.XMLEXISTS,plsqlParser.XMLFOREST,plsqlParser.XMLNAMESPACES,plsqlParser.XMLPARSE,plsqlParser.XMLPI,plsqlParser.XMLQUERY,plsqlParser.XMLROOT,plsqlParser.XMLSERIALIZE,plsqlParser.XMLTABLE,plsqlParser.YEAR]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.YES,plsqlParser.YMINTERVAL_UNCONSTRAINED,plsqlParser.ZONE,plsqlParser.PREDICTION,plsqlParser.PREDICTION_BOUNDS,plsqlParser.PREDICTION_COST,plsqlParser.PREDICTION_DETAILS,plsqlParser.PREDICTION_PROBABILITY,plsqlParser.PREDICTION_SET,plsqlParser.CUME_DIST,plsqlParser.DENSE_RANK,plsqlParser.LISTAGG,plsqlParser.PERCENT_RANK,plsqlParser.PERCENTILE_CONT,plsqlParser.PERCENTILE_DISC,plsqlParser.RANK,plsqlParser.AVG,plsqlParser.CORR,plsqlParser.LAG,plsqlParser.LEAD,plsqlParser.MAX,plsqlParser.MEDIAN,plsqlParser.MIN,plsqlParser.NTILE,plsqlParser.RATIO_TO_REPORT,plsqlParser.ROW_NUMBER,plsqlParser.SUM,plsqlParser.VARIANCE,plsqlParser.REGR_,plsqlParser.STDDEV,plsqlParser.VAR_,plsqlParser.COVAR_]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.REGULAR_ID
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	} else {
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

    override
	open func sempred(_ _localctx: RuleContext?, _ ruleIndex: Int,  _ predIndex: Int)throws -> Bool {
		switch (ruleIndex) {
		case  248:
			return try logical_or_expression_sempred(_localctx?.castdown(Logical_or_expressionContext.self), predIndex)
		case  249:
			return try logical_and_expression_sempred(_localctx?.castdown(Logical_and_expressionContext.self), predIndex)
		case  254:
			return try relational_expression_sempred(_localctx?.castdown(Relational_expressionContext.self), predIndex)
	    default: return true
		}
	}
	private func logical_or_expression_sempred(_ _localctx: Logical_or_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 0:return precpred(_ctx, 1)
		    default: return true
		}
	}
	private func logical_and_expression_sempred(_ _localctx: Logical_and_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 1:return precpred(_ctx, 1)
		    default: return true
		}
	}
	private func relational_expression_sempred(_ _localctx: Relational_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 2:return precpred(_ctx, 2)
		    default: return true
		}
	}

   public static let _serializedATN : String = plsqlParserATN().jsonString
   public static let _ATN: ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}